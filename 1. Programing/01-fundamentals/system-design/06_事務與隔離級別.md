# 06 - äº‹å‹™èˆ‡éš”é›¢ç´šåˆ¥ (Transactions and Isolation Levels)

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å¾Œ,ä½ å°‡èƒ½å¤ :
- ç†è§£äº‹å‹™çš„ ACID ç‰¹æ€§åŠå…¶é‡è¦æ€§
- æŒæ¡ä¸åŒéš”é›¢ç´šåˆ¥çš„èªç¾©èˆ‡æ‡‰ç”¨å ´æ™¯
- è­˜åˆ¥ä¸¦ç™¼å•é¡Œ (é«’è®€ã€ä¸å¯é‡è¤‡è®€ã€å¹»è®€)
- ç†è§£é–æ©Ÿåˆ¶èˆ‡ MVCC çš„å¯¦ä½œåŸç†

---

## ğŸ’¡ æ ¸å¿ƒæ¦‚å¿µ

### ä»€éº¼æ˜¯äº‹å‹™?

**äº‹å‹™ (Transaction)** æ˜¯ä¸€çµ„è³‡æ–™åº«æ“ä½œçš„é‚è¼¯å–®å…ƒ,è¦éº¼å…¨éƒ¨æˆåŠŸ,è¦éº¼å…¨éƒ¨å¤±æ•—ã€‚

```mermaid
graph LR
    A["é–‹å§‹äº‹å‹™"] --> B["æ“ä½œ 1: æ‰£æ¬¾ $100"]
    B --> C["æ“ä½œ 2: åŠ æ¬¾ $100"]
    C --> D{"å…¨éƒ¨æˆåŠŸ?"}
    D -->|æ˜¯| E["æäº¤ (Commit)"]
    D -->|å¦| F["å›æ»¾ (Rollback)"]
    
    style E fill:#90EE90
    style F fill:#FFB6C1
```

**ç¶“å…¸æ¡ˆä¾‹: éŠ€è¡Œè½‰å¸³**

```python
def transfer(from_account, to_account, amount):
    # é–‹å§‹äº‹å‹™
    with db.transaction():
        # æ“ä½œ 1: æ‰£æ¬¾
        db.execute(
            "UPDATE accounts SET balance = balance - ? WHERE id = ?",
            (amount, from_account)
        )
        
        # æ“ä½œ 2: åŠ æ¬¾
        db.execute(
            "UPDATE accounts SET balance = balance + ? WHERE id = ?",
            (amount, to_account)
        )
        
        # æäº¤äº‹å‹™
        db.commit()
```

**ç‚ºä»€éº¼éœ€è¦äº‹å‹™?**

æ²’æœ‰äº‹å‹™çš„å ´æ™¯:
```python
# âŒ ä¸å®‰å…¨çš„è½‰å¸³
balance_a = get_balance('Alice')  # $100
balance_b = get_balance('Bob')    # $50

set_balance('Alice', balance_a - 50)  # $50
# ğŸ’¥ é€™è£¡ç³»çµ±å´©æ½°!
set_balance('Bob', balance_b + 50)    # æ°¸é ä¸æœƒåŸ·è¡Œ

# çµæœ: Alice æå¤± $50,Bob æ²’æ”¶åˆ°,æ†‘ç©ºæ¶ˆå¤±!
```

æœ‰äº‹å‹™çš„å ´æ™¯:
```python
# âœ… å®‰å…¨çš„è½‰å¸³
with transaction:
    set_balance('Alice', get_balance('Alice') - 50)
    # ğŸ’¥ é€™è£¡ç³»çµ±å´©æ½°!
    set_balance('Bob', get_balance('Bob') + 50)

# çµæœ: äº‹å‹™è‡ªå‹•å›æ»¾,å…©äººé¤˜é¡ä¸è®Š
```

---

## ğŸ“Š ACID ç‰¹æ€§

### A - åŸå­æ€§ (Atomicity)

**å®šç¾©**: äº‹å‹™ä¸­çš„æ‰€æœ‰æ“ä½œè¦éº¼å…¨éƒ¨å®Œæˆ,è¦éº¼å…¨éƒ¨ä¸åšã€‚

```mermaid
graph TD
    A["äº‹å‹™: è½‰å¸³ $100"] --> B["æ‰£ Alice $100"]
    B --> C["åŠ  Bob $100"]
    C --> D{"å…©å€‹æ“ä½œéƒ½æˆåŠŸ?"}
    D -->|æ˜¯| E["âœ… æäº¤"]
    D -->|å¦| F["âŒ å›æ»¾ (å…©å€‹æ“ä½œéƒ½æ’¤éŠ·)"]
```

**å¯¦ä½œæ©Ÿåˆ¶: é å¯«æ—¥èªŒ (Write-Ahead Log, WAL)**

```python
class TransactionLog:
    def __init__(self):
        self.log_file = open('transaction.log', 'a')
        self.operations = []
    
    def begin(self, txn_id):
        self.log_file.write(f"BEGIN {txn_id}\n")
        self.operations = []
    
    def log_operation(self, operation):
        # å…ˆå¯«æ—¥èªŒ,å†åŸ·è¡Œæ“ä½œ
        self.log_file.write(f"OP: {operation}\n")
        self.log_file.flush()  # ç¢ºä¿å¯«å…¥ç£ç¢Ÿ
        self.operations.append(operation)
    
    def commit(self, txn_id):
        self.log_file.write(f"COMMIT {txn_id}\n")
        self.log_file.flush()
    
    def rollback(self, txn_id):
        # åŸ·è¡Œæ‰€æœ‰æ“ä½œçš„é€†æ“ä½œ
        for operation in reversed(self.operations):
            operation.undo()
        self.log_file.write(f"ROLLBACK {txn_id}\n")

# å´©æ½°æ¢å¾©
def recover():
    for line in open('transaction.log'):
        if 'BEGIN' in line:
            # é–‹å§‹æ–°äº‹å‹™
            pass
        elif 'COMMIT' in line:
            # äº‹å‹™å·²å®Œæˆ,ç„¡éœ€æ“ä½œ
            pass
        else:
            # æœªå®Œæˆçš„äº‹å‹™,é‡æ–°åŸ·è¡Œæˆ–å›æ»¾
            pass
```

---

### C - ä¸€è‡´æ€§ (Consistency)

**å®šç¾©**: äº‹å‹™å°‡è³‡æ–™åº«å¾ä¸€å€‹ä¸€è‡´ç‹€æ…‹è½‰æ›åˆ°å¦ä¸€å€‹ä¸€è‡´ç‹€æ…‹ã€‚

**ä¸€è‡´æ€§ç´„æŸç¯„ä¾‹**:

```sql
-- ç´„æŸ 1: ç¸½é‡‘é¡å®ˆæ†
CREATE TRIGGER check_total_balance
AFTER UPDATE ON accounts
FOR EACH STATEMENT
BEGIN
    IF (SELECT SUM(balance) FROM accounts) != @initial_total THEN
        SIGNAL SQLSTATE '45000'
        SET MESSAGE_TEXT = 'ç¸½é‡‘é¡ä¸å®ˆæ†';
    END IF;
END;

-- ç´„æŸ 2: é¤˜é¡ä¸èƒ½ç‚ºè² 
ALTER TABLE accounts ADD CONSTRAINT balance_non_negative
CHECK (balance >= 0);
```

**æ‡‰ç”¨å±¤ä¸€è‡´æ€§**:

```python
class BankAccount:
    def transfer(self, to_account, amount):
        with db.transaction():
            # æ¥­å‹™è¦å‰‡: è½‰å¸³é‡‘é¡å¿…é ˆç‚ºæ­£
            if amount <= 0:
                raise ValueError("é‡‘é¡å¿…é ˆç‚ºæ­£")
            
            # æ¥­å‹™è¦å‰‡: é¤˜é¡ä¸è¶³
            if self.balance < amount:
                raise ValueError("é¤˜é¡ä¸è¶³")
            
            self.balance -= amount
            to_account.balance += amount
            
            # æ¥­å‹™è¦å‰‡: è½‰å¸³å¾Œç¸½é‡‘é¡ä¸è®Š
            assert self.balance + to_account.balance == initial_total
```

---

### I - éš”é›¢æ€§ (Isolation)

**å®šç¾©**: å¤šå€‹äº‹å‹™ä¸¦ç™¼åŸ·è¡Œæ™‚,å½¼æ­¤ä¸æ‡‰ç›¸äº’å¹²æ“¾ã€‚

**ç†æƒ³æƒ…æ³**: äº‹å‹™çœ‹èµ·ä¾†åƒæ˜¯ä¸²è¡ŒåŸ·è¡Œ

```mermaid
sequenceDiagram
    participant T1 as äº‹å‹™ 1
    participant T2 as äº‹å‹™ 2
    participant DB as è³‡æ–™åº«
    
    Note over T1,T2: ç†æƒ³: ä¸²è¡ŒåŸ·è¡Œ
    T1->>DB: è®€å– X = 100
    T1->>DB: å¯«å…¥ X = 150
    Note over T1: äº‹å‹™ 1 å®Œæˆ
    
    T2->>DB: è®€å– X = 150
    T2->>DB: å¯«å…¥ X = 200
    Note over T2: äº‹å‹™ 2 å®Œæˆ
```

**ç¾å¯¦æƒ…æ³**: ç‚ºäº†æ€§èƒ½,å…è¨±ä¸€å®šç¨‹åº¦çš„ç›¸äº’å½±éŸ¿ â†’ **éš”é›¢ç´šåˆ¥**

---

### D - æŒä¹…æ€§ (Durability)

**å®šç¾©**: ä¸€æ—¦äº‹å‹™æäº¤,å…¶çµæœæ°¸ä¹…ä¿å­˜,å³ä½¿ç³»çµ±å´©æ½°ä¹Ÿä¸æœƒä¸Ÿå¤±ã€‚

**å¯¦ä½œæ©Ÿåˆ¶**:

```mermaid
graph LR
    A["äº‹å‹™æäº¤"] --> B["å¯«å…¥ WAL"]
    B --> C["fsync åˆ·åˆ°ç£ç¢Ÿ"]
    C --> D["è¿”å›æˆåŠŸ"]
    
    D --> E["å¾Œå°ç•°æ­¥å¯«å…¥è³‡æ–™æª”æ¡ˆ"]
```

**ğŸ’» å¯¦ä½œç¯„ä¾‹**:

```python
import os

class DurableStorage:
    def __init__(self, filename):
        self.file = open(filename, 'a')
    
    def write(self, data):
        # å¯«å…¥ç·©è¡å€
        self.file.write(data)
        
        # åˆ·æ–°åˆ° OS ç·©è¡å€
        self.file.flush()
        
        # å¼·åˆ¶å¯«å…¥ç£ç¢Ÿ (é—œéµ!)
        os.fsync(self.file.fileno())
        
        # ç¾åœ¨å¯ä»¥ä¿è­‰æ•¸æ“šå·²æŒä¹…åŒ–

# å³ä½¿é€™è£¡ç³»çµ±å´©æ½°,è³‡æ–™ä¹Ÿå·²å®‰å…¨å­˜å„²
```

**âš–ï¸ æ€§èƒ½èˆ‡æŒä¹…æ€§çš„æ¬Šè¡¡**:

| æ–¹æ³• | æŒä¹…æ€§ | æ€§èƒ½ |
|------|--------|------|
| æ¯æ¬¡ fsync | âœ… å¼· | âŒ æ…¢ (10-100ms/æ¬¡) |
| æ‰¹æ¬¡ fsync | âš ï¸ ä¸­ | âœ… å¿« (æ”¤éŠ·æˆæœ¬) |
| ç•°æ­¥è¤‡è£½ | âš ï¸ ä¸­ | âœ… å¿« |
| åªå¯«å…§å­˜ | âŒ å¼± | âœ… æ¥µå¿« |

**ğŸ¢ çœŸå¯¦æ¡ˆä¾‹: Redis æŒä¹…æ€§é¸é …**

```conf
# é¸é … 1: æ¯æ¬¡å¯«å…¥éƒ½ fsync (æœ€æ…¢,æœ€å®‰å…¨)
appendfsync always

# é¸é … 2: æ¯ç§’ fsync ä¸€æ¬¡ (å¹³è¡¡)
appendfsync everysec

# é¸é … 3: ç”± OS æ±ºå®š (æœ€å¿«,å¯èƒ½ä¸Ÿå¤±æ•¸æ“š)
appendfsync no
```

---

## ğŸ”’ éš”é›¢ç´šåˆ¥ (Isolation Levels)

### ä¸¦ç™¼å•é¡Œæ¦‚è¦½

```mermaid
graph TD
    A["ä¸¦ç™¼å•é¡Œ"] --> B["é«’è®€<br/>Dirty Read"]
    A --> C["ä¸å¯é‡è¤‡è®€<br/>Non-Repeatable Read"]
    A --> D["å¹»è®€<br/>Phantom Read"]
    A --> E["ä¸Ÿå¤±æ›´æ–°<br/>Lost Update"]
    A --> F["å¯«åæ–œ<br/>Write Skew"]
```

### å•é¡Œ 1: é«’è®€ (Dirty Read)

**å®šç¾©**: è®€å–åˆ°å…¶ä»–äº‹å‹™æœªæäº¤çš„è³‡æ–™ã€‚

```mermaid
sequenceDiagram
    participant T1 as äº‹å‹™ 1
    participant T2 as äº‹å‹™ 2
    participant DB as è³‡æ–™åº« (X=100)
    
    T1->>DB: å¯«å…¥ X = 200
    Note over T1: æœªæäº¤
    
    T2->>DB: è®€å– X
    DB-->>T2: è¿”å› 200 (é«’è®€!)
    
    T1->>DB: å›æ»¾
    Note over DB: X æ¢å¾©ç‚º 100
    
    Note over T2: T2 è®€åˆ°çš„ 200 æ˜¯ç„¡æ•ˆè³‡æ–™
```

**ğŸ’» å¯¦éš›ç¯„ä¾‹**:

```python
# äº‹å‹™ 1: è½‰å¸³
with db.transaction():
    set_balance('Alice', 0)  # é¤˜é¡æš«æ™‚ç‚º 0
    time.sleep(5)  # æ¨¡æ“¬è€—æ™‚æ“ä½œ
    set_balance('Alice', 1000)  # æœ€çµ‚é¤˜é¡ 1000
    commit()

# äº‹å‹™ 2: æŸ¥è©¢é¤˜é¡
balance = get_balance('Alice')
print(f"Alice é¤˜é¡: {balance}")

# å¦‚æœ T2 åœ¨ T1 sleep æœŸé–“åŸ·è¡Œ:
# è¼¸å‡º: Alice é¤˜é¡: 0 (é«’è®€! å¯¦éš›æ‡‰è©²æ˜¯ 100 æˆ– 1000)
```

---

### å•é¡Œ 2: ä¸å¯é‡è¤‡è®€ (Non-Repeatable Read)

**å®šç¾©**: åŒä¸€äº‹å‹™å…§å¤šæ¬¡è®€å–åŒä¸€è³‡æ–™,çµæœä¸ä¸€è‡´ã€‚

```mermaid
sequenceDiagram
    participant T1 as äº‹å‹™ 1
    participant T2 as äº‹å‹™ 2
    participant DB as è³‡æ–™åº« (X=100)
    
    T1->>DB: è®€å– X
    DB-->>T1: è¿”å› 100
    
    T2->>DB: å¯«å…¥ X = 200
    T2->>DB: æäº¤
    
    T1->>DB: å†æ¬¡è®€å– X
    DB-->>T1: è¿”å› 200 (ä¸ä¸€è‡´!)
    
    Note over T1: åŒä¸€äº‹å‹™å…§,<br/>å…©æ¬¡è®€å–çµæœä¸åŒ
```

**ğŸ’» å¯¦éš›ç¯„ä¾‹**:

```python
# è½‰å¸³é‚è¼¯
with db.transaction():
    # ç¬¬ 1 æ¬¡è®€å–
    balance = get_balance('Alice')  # 100
    
    # æª¢æŸ¥é¤˜é¡æ˜¯å¦è¶³å¤ 
    if balance >= 50:
        # å…¶ä»–äº‹å‹™åœ¨é€™è£¡ä¿®æ”¹äº†é¤˜é¡
        # Alice çš„é¤˜é¡è¢«åˆ¥äººæ‰£æˆ 10
        
        # ç¬¬ 2 æ¬¡è®€å–
        new_balance = get_balance('Alice')  # 10 (ä¸å¯é‡è¤‡è®€!)
        
        # åŸºæ–¼ç¬¬ä¸€æ¬¡è®€å–çš„æ±ºç­–å·²ç¶“ç„¡æ•ˆ
        deduct(50)  # éŒ¯èª¤: é¤˜é¡ä¸è¶³ä½†ä»æ‰£æ¬¾
```

---

### å•é¡Œ 3: å¹»è®€ (Phantom Read)

**å®šç¾©**: åŒä¸€æŸ¥è©¢æ¢ä»¶,å¤šæ¬¡è®€å–è¿”å›çš„**è³‡æ–™é›†åˆ**ä¸åŒã€‚

```mermaid
sequenceDiagram
    participant T1 as äº‹å‹™ 1
    participant T2 as äº‹å‹™ 2
    participant DB as è³‡æ–™åº«
    
    T1->>DB: SELECT COUNT(*) WHERE age < 18
    DB-->>T1: è¿”å› 5
    
    T2->>DB: INSERT ä¸€å€‹ age=15 çš„è¨˜éŒ„
    T2->>DB: æäº¤
    
    T1->>DB: SELECT COUNT(*) WHERE age < 18
    DB-->>T1: è¿”å› 6 (å¹»è®€!)
    
    Note over T1: å‡ºç¾äº†"å¹»å½±"è¨˜éŒ„
```

**ğŸ’» å¯¦éš›ç¯„ä¾‹**:

```python
# çµ±è¨ˆèˆ‡æ›´æ–°é‚è¼¯
with db.transaction():
    # ç¬¬ 1 æ¬¡æŸ¥è©¢
    count = db.execute("SELECT COUNT(*) FROM students WHERE age < 18").fetchone()[0]
    print(f"æœªæˆå¹´å­¸ç”Ÿ: {count} äºº")  # 5 äºº
    
    # å…¶ä»–äº‹å‹™æ’å…¥äº†ä¸€å€‹ age=15 çš„å­¸ç”Ÿ
    
    # æ›´æ–°æ‰€æœ‰æœªæˆå¹´å­¸ç”Ÿçš„è³‡æ–™
    db.execute("UPDATE students SET discount = 0.5 WHERE age < 18")
    
    # ç¬¬ 2 æ¬¡æŸ¥è©¢
    count = db.execute("SELECT COUNT(*) FROM students WHERE age < 18").fetchone()[0]
    print(f"æ›´æ–°äº† {count} äºº")  # 6 äºº (å¹»è®€!)
    
    # çµæœ: çµ±è¨ˆèˆ‡å¯¦éš›æ›´æ–°çš„æ•¸é‡ä¸ä¸€è‡´
```

---

### å•é¡Œ 4: ä¸Ÿå¤±æ›´æ–° (Lost Update)

**å®šç¾©**: å…©å€‹äº‹å‹™åŒæ™‚è®€å–ä¸¦ä¿®æ”¹åŒä¸€è³‡æ–™,å¾Œæäº¤çš„è¦†è“‹å‰ä¸€å€‹ã€‚

```mermaid
sequenceDiagram
    participant T1 as äº‹å‹™ 1
    participant T2 as äº‹å‹™ 2
    participant DB as è³‡æ–™åº« (X=100)
    
    T1->>DB: è®€å– X
    DB-->>T1: 100
    
    T2->>DB: è®€å– X
    DB-->>T2: 100
    
    T1->>DB: å¯«å…¥ X = 100 + 10 = 110
    T1->>DB: æäº¤
    
    T2->>DB: å¯«å…¥ X = 100 + 20 = 120
    T2->>DB: æäº¤
    
    Note over DB: X = 120<br/>T1 çš„ +10 ä¸Ÿå¤±äº†!
```

**ğŸ’» å¯¦éš›ç¯„ä¾‹**:

```python
# å¢åŠ ç€è¦½è¨ˆæ•¸
def increment_view_count(article_id):
    with db.transaction():
        # è®€å–ç•¶å‰è¨ˆæ•¸
        count = db.execute(
            "SELECT view_count FROM articles WHERE id = ?",
            (article_id,)
        ).fetchone()[0]
        
        # å¢åŠ  1
        new_count = count + 1
        
        # å¯«å›è³‡æ–™åº«
        db.execute(
            "UPDATE articles SET view_count = ? WHERE id = ?",
            (new_count, article_id)
        )

# ä¸¦ç™¼å ´æ™¯
# T1 å’Œ T2 åŒæ™‚åŸ·è¡Œ increment_view_count(1)
# T1: è®€å– 100 â†’ å¯«å…¥ 101
# T2: è®€å– 100 â†’ å¯«å…¥ 101 (è¦†è“‹ T1)
# çµæœ: å…©æ¬¡å¢åŠ ,ä½†è¨ˆæ•¸åªå¢åŠ äº† 1 (ä¸Ÿå¤±æ›´æ–°!)
```

---

### å•é¡Œ 5: å¯«åæ–œ (Write Skew)

**å®šç¾©**: å¤šå€‹äº‹å‹™è®€å–ç›¸åŒè³‡æ–™,åŸºæ–¼è®€å–çµæœåšæ±ºç­–,å„è‡ªå¯«å…¥ä¸åŒçš„è³‡æ–™,å°è‡´ç´„æŸè¢«é•åã€‚

**ç¶“å…¸æ¡ˆä¾‹: å€¼ç­é†«ç”Ÿå•é¡Œ**

```mermaid
sequenceDiagram
    participant T1 as äº‹å‹™ 1 (Alice)
    participant T2 as äº‹å‹™ 2 (Bob)
    participant DB as è³‡æ–™åº«
    
    Note over DB: ç´„æŸ: è‡³å°‘ 1 å€‹é†«ç”Ÿå€¼ç­
    Note over DB: ç•¶å‰: Alice å€¼ç­, Bob å€¼ç­
    
    T1->>DB: SELECT COUNT(*) WHERE on_call=true
    DB-->>T1: 2 äººå€¼ç­
    Note over T1: 2 > 1, å¯ä»¥è«‹å‡
    
    T2->>DB: SELECT COUNT(*) WHERE on_call=true
    DB-->>T2: 2 äººå€¼ç­
    Note over T2: 2 > 1, å¯ä»¥è«‹å‡
    
    T1->>DB: UPDATE Alice SET on_call=false
    T1->>DB: æäº¤
    
    T2->>DB: UPDATE Bob SET on_call=false
    T2->>DB: æäº¤
    
    Note over DB: âŒ çµæœ: 0 äººå€¼ç­<br/>é•åç´„æŸ!
```

**ğŸ’» å¯¦éš›ç¯„ä¾‹**:

```python
# Alice çš„è«‹å‡é‚è¼¯
with db.transaction():
    on_call_count = db.execute(
        "SELECT COUNT(*) FROM doctors WHERE on_call = true"
    ).fetchone()[0]
    
    if on_call_count > 1:
        # é‚„æœ‰å…¶ä»–é†«ç”Ÿå€¼ç­,å¯ä»¥è«‹å‡
        db.execute(
            "UPDATE doctors SET on_call = false WHERE name = 'Alice'"
        )

# Bob çš„è«‹å‡é‚è¼¯ (åŒæ™‚åŸ·è¡Œ)
with db.transaction():
    on_call_count = db.execute(
        "SELECT COUNT(*) FROM doctors WHERE on_call = true"
    ).fetchone()[0]
    
    if on_call_count > 1:
        # é‚„æœ‰å…¶ä»–é†«ç”Ÿå€¼ç­,å¯ä»¥è«‹å‡
        db.execute(
            "UPDATE doctors SET on_call = false WHERE name = 'Bob'"
        )

# çµæœ: å…©äººéƒ½è«‹å‡æˆåŠŸ,ç„¡äººå€¼ç­!
```

---

## ğŸ“Š éš”é›¢ç´šåˆ¥è©³è§£

### æ¨™æº– SQL éš”é›¢ç´šåˆ¥

```mermaid
graph LR
    A["Read Uncommitted<br/>è®€æœªæäº¤"] --> B["Read Committed<br/>è®€å·²æäº¤"]
    B --> C["Repeatable Read<br/>å¯é‡è¤‡è®€"]
    C --> D["Serializable<br/>å¯åºåˆ—åŒ–"]
    
    A -->|æ›´å¼·çš„éš”é›¢| D
    D -->|æ›´å¥½çš„æ€§èƒ½| A
```

### ç´šåˆ¥å°æ¯”è¡¨

| éš”é›¢ç´šåˆ¥ | é«’è®€ | ä¸å¯é‡è¤‡è®€ | å¹»è®€ | ä¸Ÿå¤±æ›´æ–° | å¯«åæ–œ |
|----------|------|-----------|------|---------|--------|
| Read Uncommitted | âŒ å¯èƒ½ | âŒ å¯èƒ½ | âŒ å¯èƒ½ | âŒ å¯èƒ½ | âŒ å¯èƒ½ |
| Read Committed | âœ… ä¸æœƒ | âŒ å¯èƒ½ | âŒ å¯èƒ½ | âŒ å¯èƒ½ | âŒ å¯èƒ½ |
| Repeatable Read | âœ… ä¸æœƒ | âœ… ä¸æœƒ | âš ï¸ å¯èƒ½* | âš ï¸ å¯èƒ½* | âš ï¸ å¯èƒ½* |
| Serializable | âœ… ä¸æœƒ | âœ… ä¸æœƒ | âœ… ä¸æœƒ | âœ… ä¸æœƒ | âœ… ä¸æœƒ |

*æ³¨: ä¸åŒè³‡æ–™åº«å¯¦ä½œçš„ Repeatable Read è¡Œç‚ºå¯èƒ½ä¸åŒ

---

### ç´šåˆ¥ 1: Read Uncommitted (è®€æœªæäº¤)

**ç‰¹æ€§**: å…è¨±è®€å–æœªæäº¤çš„è³‡æ–™ã€‚

```sql
SET TRANSACTION ISOLATION LEVEL READ UNCOMMITTED;
```

**âš ï¸ å¹¾ä¹å¾ä¸ä½¿ç”¨**: å…è¨±é«’è®€,è³‡æ–™ä¸€è‡´æ€§ç„¡ä¿éšœã€‚

---

### ç´šåˆ¥ 2: Read Committed (è®€å·²æäº¤)

**ç‰¹æ€§**: åªèƒ½è®€å–å·²æäº¤çš„è³‡æ–™ã€‚

**å¯¦ä½œæ©Ÿåˆ¶ 1: è®€é–**

```mermaid
sequenceDiagram
    participant T1 as äº‹å‹™ 1 (å¯«å…¥)
    participant T2 as äº‹å‹™ 2 (è®€å–)
    participant Lock as é–ç®¡ç†å™¨
    participant DB as è³‡æ–™åº«
    
    T1->>Lock: ç²å– X çš„å¯«é–
    Lock-->>T1: æˆåŠŸ
    T1->>DB: å¯«å…¥ X = 200 (æœªæäº¤)
    
    T2->>Lock: è«‹æ±‚ X çš„è®€é–
    Lock-->>T2: ç­‰å¾…... (å¯«é–æœªé‡‹æ”¾)
    
    T1->>DB: æäº¤
    T1->>Lock: é‡‹æ”¾å¯«é–
    
    Lock-->>T2: æˆåŠŸç²å–è®€é–
    T2->>DB: è®€å– X
    DB-->>T2: 200 (å·²æäº¤çš„å€¼)
```

**å¯¦ä½œæ©Ÿåˆ¶ 2: MVCC (æ›´å¸¸è¦‹)**

```python
class MVCCDatabase:
    def __init__(self):
        self.data = {}  # {key: [(value, txn_id, committed), ...]}
        self.next_txn_id = 1
    
    def begin_transaction(self):
        txn_id = self.next_txn_id
        self.next_txn_id += 1
        return txn_id
    
    def read(self, key, txn_id):
        """è®€å–å·²æäº¤çš„æœ€æ–°ç‰ˆæœ¬"""
        versions = self.data.get(key, [])
        
        # æ‰¾åˆ°æœ€æ–°çš„å·²æäº¤ç‰ˆæœ¬
        for value, version_txn_id, committed in reversed(versions):
            if committed:
                return value
        
        return None  # ç„¡å·²æäº¤ç‰ˆæœ¬
    
    def write(self, key, value, txn_id):
        """å¯«å…¥æ–°ç‰ˆæœ¬ (æœªæäº¤)"""
        if key not in self.data:
            self.data[key] = []
        
        self.data[key].append((value, txn_id, False))
    
    def commit(self, txn_id):
        """æäº¤äº‹å‹™,æ¨™è¨˜æ‰€æœ‰ç‰ˆæœ¬ç‚ºå·²æäº¤"""
        for versions in self.data.values():
            for i, (value, version_txn_id, committed) in enumerate(versions):
                if version_txn_id == txn_id:
                    versions[i] = (value, version_txn_id, True)

# ä½¿ç”¨ç¯„ä¾‹
db = MVCCDatabase()

# äº‹å‹™ 1: å¯«å…¥
t1 = db.begin_transaction()
db.write('X', 200, t1)

# äº‹å‹™ 2: è®€å– (T1 æœªæäº¤)
t2 = db.begin_transaction()
print(db.read('X', t2))  # None æˆ–èˆŠå€¼ (ä¸æœƒè®€åˆ° 200)

# äº‹å‹™ 1 æäº¤
db.commit(t1)

# äº‹å‹™ 2: å†æ¬¡è®€å–
print(db.read('X', t2))  # 200 (å·²æäº¤)
```

**ğŸ¢ çœŸå¯¦æ¡ˆä¾‹**:
- PostgreSQL, Oracle é»˜èªéš”é›¢ç´šåˆ¥
- é©åˆå¤§å¤šæ•¸æ‡‰ç”¨

**âœ… å„ªé»**: é˜²æ­¢é«’è®€,æ€§èƒ½è¼ƒå¥½

**âŒ ç¼ºé»**: ä¸é˜²æ­¢ä¸å¯é‡è¤‡è®€

---

### ç´šåˆ¥ 3: Repeatable Read (å¯é‡è¤‡è®€)

**ç‰¹æ€§**: åŒä¸€äº‹å‹™å…§å¤šæ¬¡è®€å–çµæœä¸€è‡´ã€‚

**å¯¦ä½œæ©Ÿåˆ¶: MVCC + å¿«ç…§éš”é›¢ (Snapshot Isolation)**

```python
class SnapshotIsolationDB:
    def __init__(self):
        self.data = {}  # {key: [(value, txn_id), ...]}
        self.next_txn_id = 1
    
    def begin_transaction(self):
        """äº‹å‹™é–‹å§‹æ™‚,è¨˜éŒ„ç•¶å‰å¿«ç…§ç‰ˆæœ¬"""
        txn_id = self.next_txn_id
        self.next_txn_id += 1
        snapshot_version = txn_id - 1
        return txn_id, snapshot_version
    
    def read(self, key, snapshot_version):
        """è®€å–å¿«ç…§ç‰ˆæœ¬çš„è³‡æ–™"""
        versions = self.data.get(key, [])
        
        # æ‰¾åˆ° <= snapshot_version çš„æœ€æ–°ç‰ˆæœ¬
        for value, version_txn_id in reversed(versions):
            if version_txn_id <= snapshot_version:
                return value
        
        return None
    
    def write(self, key, value, txn_id):
        if key not in self.data:
            self.data[key] = []
        self.data[key].append((value, txn_id))

# ä½¿ç”¨ç¯„ä¾‹
db = SnapshotIsolationDB()

# åˆå§‹åŒ–è³‡æ–™
db.data['X'] = [(100, 0)]

# äº‹å‹™ 1: é•·æ™‚é–“é‹è¡Œ
t1, snapshot1 = db.begin_transaction()
print(db.read('X', snapshot1))  # 100

# äº‹å‹™ 2: æ›´æ–°è³‡æ–™
t2, snapshot2 = db.begin_transaction()
db.write('X', 200, t2)

# äº‹å‹™ 1: å†æ¬¡è®€å– (ä»ç„¶æ˜¯å¿«ç…§ç‰ˆæœ¬)
print(db.read('X', snapshot1))  # 100 (å¯é‡è¤‡è®€!)

# æ–°äº‹å‹™ 3: è®€å–
t3, snapshot3 = db.begin_transaction()
print(db.read('X', snapshot3))  # 200 (çœ‹åˆ° T2 çš„å¯«å…¥)
```

**å¯è¦–åŒ–ç¤ºæ„**:

```mermaid
graph LR
    subgraph Snapshot["äº‹å‹™ 1 çš„å¿«ç…§ (t=10)"]
        S1["X=100"]
        S2["Y=50"]
    end
    
    subgraph Current["ç•¶å‰è³‡æ–™ (t=20)"]
        C1["X=200 (è¢« T2 ä¿®æ”¹)"]
        C2["Y=50"]
    end
    
    T1["äº‹å‹™ 1<br/>ä»è®€åˆ° X=100"] -.->|è®€å–å¿«ç…§| Snapshot
    T2["äº‹å‹™ 2<br/>è®€åˆ° X=200"] -.->|è®€å–æœ€æ–°| Current
```

**ğŸ¢ çœŸå¯¦æ¡ˆä¾‹: MySQL InnoDB**

MySQL çš„ Repeatable Read é‚„é˜²æ­¢äº†å¹»è®€ (é€šéé–“éš™é–):

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;

BEGIN;

-- ç¬¬ä¸€æ¬¡æŸ¥è©¢
SELECT * FROM students WHERE age < 18;  -- 5 æ¢è¨˜éŒ„

-- å…¶ä»–äº‹å‹™å˜—è©¦æ’å…¥ age=15 çš„å­¸ç”Ÿ
-- æœƒè¢«é˜»å¡ (é–“éš™é–)

-- ç¬¬äºŒæ¬¡æŸ¥è©¢
SELECT * FROM students WHERE age < 18;  -- ä»ç„¶ 5 æ¢è¨˜éŒ„ (ç„¡å¹»è®€)

COMMIT;
```

**âœ… å„ªé»**: ç¬¦åˆå¤§å¤šæ•¸ç›´è¦º,é˜²æ­¢å¸¸è¦‹ç•°å¸¸

**âŒ ç¼ºé»**: ä»å¯èƒ½å‡ºç¾å¯«åæ–œ

---

### ç´šåˆ¥ 4: Serializable (å¯åºåˆ—åŒ–)

**ç‰¹æ€§**: æœ€å¼·çš„éš”é›¢ç´šåˆ¥,å®Œå…¨ä¸²è¡ŒåŒ–åŸ·è¡Œçš„æ•ˆæœã€‚

**å¯¦ä½œæ©Ÿåˆ¶ 1: å…©éšæ®µé– (2PL, Two-Phase Locking)**

```mermaid
graph LR
    A["äº‹å‹™é–‹å§‹"] --> B["éšæ®µ 1: åŠ é–éšæ®µ<br/>åªåŠ é–,ä¸é‡‹æ”¾"]
    B --> C["éšæ®µ 2: é‡‹æ”¾éšæ®µ<br/>åªé‡‹æ”¾,ä¸åŠ é–"]
    C --> D["äº‹å‹™çµæŸ"]
```

**é–çš„é¡å‹**:

| æ“ä½œ | é–é¡å‹ | ç›¸å®¹æ€§ |
|------|--------|--------|
| è®€å– | å…±äº«é– (S-Lock) | å¤šå€‹äº‹å‹™å¯åŒæ™‚æŒæœ‰ |
| å¯«å…¥ | æ’ä»–é– (X-Lock) | ç¨å ,å…¶ä»–äº‹å‹™å¿…é ˆç­‰å¾… |

**ğŸ’» å¯¦ä½œç¯„ä¾‹**:

```python
from threading import Lock
from collections import defaultdict

class TwoPhaseLocking:
    def __init__(self):
        self.locks = defaultdict(lambda: {'S': [], 'X': None})
        self.lock_mutex = Lock()
    
    def acquire_shared_lock(self, key, txn_id):
        """ç²å–å…±äº«é– (è®€é–)"""
        with self.lock_mutex:
            # å¦‚æœæœ‰æ’ä»–é–,ç­‰å¾…
            while self.locks[key]['X'] is not None:
                pass  # å¯¦éš›æ‡‰ä½¿ç”¨æ¢ä»¶è®Šé‡
            
            # æ·»åŠ å…±äº«é–
            self.locks[key]['S'].append(txn_id)
    
    def acquire_exclusive_lock(self, key, txn_id):
        """ç²å–æ’ä»–é– (å¯«é–)"""
        with self.lock_mutex:
            # å¦‚æœæœ‰å…¶ä»–é–,ç­‰å¾…
            while (self.locks[key]['X'] is not None or 
                   len(self.locks[key]['S']) > 0):
                pass  # å¯¦éš›æ‡‰ä½¿ç”¨æ¢ä»¶è®Šé‡
            
            # æ·»åŠ æ’ä»–é–
            self.locks[key]['X'] = txn_id
    
    def release_all_locks(self, txn_id):
        """äº‹å‹™çµæŸæ™‚é‡‹æ”¾æ‰€æœ‰é–"""
        with self.lock_mutex:
            for key in list(self.locks.keys()):
                # é‡‹æ”¾å…±äº«é–
                if txn_id in self.locks[key]['S']:
                    self.locks[key]['S'].remove(txn_id)
                
                # é‡‹æ”¾æ’ä»–é–
                if self.locks[key]['X'] == txn_id:
                    self.locks[key]['X'] = None

# ä½¿ç”¨ç¯„ä¾‹
db = TwoPhaseLocking()

# äº‹å‹™ 1
db.acquire_shared_lock('X', txn_id=1)  # è®€å– X
db.acquire_exclusive_lock('Y', txn_id=1)  # å¯«å…¥ Y
# ... åŸ·è¡Œæ“ä½œ ...
db.release_all_locks(txn_id=1)  # æäº¤æ™‚é‡‹æ”¾

# äº‹å‹™ 2 (å¦‚æœåœ¨ T1 æœŸé–“å˜—è©¦ç²å– X çš„å¯«é–,æœƒè¢«é˜»å¡)
```

**âš ï¸ å•é¡Œ: æ­»é– (Deadlock)**

```mermaid
sequenceDiagram
    participant T1 as äº‹å‹™ 1
    participant T2 as äº‹å‹™ 2
    participant Lock as é–ç®¡ç†å™¨
    
    T1->>Lock: ç²å– X çš„å¯«é–
    Lock-->>T1: æˆåŠŸ
    
    T2->>Lock: ç²å– Y çš„å¯«é–
    Lock-->>T2: æˆåŠŸ
    
    T1->>Lock: ç²å– Y çš„å¯«é–
    Note over T1: ç­‰å¾… T2 é‡‹æ”¾...
    
    T2->>Lock: ç²å– X çš„å¯«é–
    Note over T2: ç­‰å¾… T1 é‡‹æ”¾...
    
    Note over T1,T2: âŒ æ­»é–!<br/>é›™æ–¹äº’ç›¸ç­‰å¾…
```

**æ­»é–æª¢æ¸¬èˆ‡è§£æ±º**:

```python
class DeadlockDetector:
    def __init__(self):
        self.wait_graph = defaultdict(list)  # {txn: [waiting_for_txn, ...]}
    
    def add_wait_edge(self, txn_id, waiting_for):
        """äº‹å‹™ txn_id æ­£åœ¨ç­‰å¾… waiting_for"""
        self.wait_graph[txn_id].append(waiting_for)
    
    def detect_cycle(self):
        """æª¢æ¸¬ç­‰å¾…åœ–ä¸­çš„ç’° (æ­»é–)"""
        visited = set()
        rec_stack = set()
        
        def dfs(node):
            visited.add(node)
            rec_stack.add(node)
            
            for neighbor in self.wait_graph[node]:
                if neighbor not in visited:
                    if dfs(neighbor):
                        return True
                elif neighbor in rec_stack:
                    return True  # æ‰¾åˆ°ç’°
            
            rec_stack.remove(node)
            return False
        
        for node in self.wait_graph:
            if node not in visited:
                if dfs(node):
                    return True  # å­˜åœ¨æ­»é–
        
        return False
    
    def resolve_deadlock(self):
        """è§£æ±ºæ­»é–: ä¸­æ­¢ä»£åƒ¹æœ€å°çš„äº‹å‹™"""
        # é¸æ“‡ä¸€å€‹äº‹å‹™å›æ»¾
        victim = self.choose_victim()
        self.abort_transaction(victim)

# PostgreSQL æ­»é–ç¤ºä¾‹
# äº‹å‹™ 1
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;  -- é–ä½ id=1
UPDATE accounts SET balance = balance + 100 WHERE id = 2;  -- ç­‰å¾… id=2

# äº‹å‹™ 2 (åŒæ™‚åŸ·è¡Œ)
BEGIN;
UPDATE accounts SET balance = balance - 50 WHERE id = 2;  -- é–ä½ id=2
UPDATE accounts SET balance = balance + 50 WHERE id = 1;  -- ç­‰å¾… id=1 (æ­»é–!)

-- PostgreSQL æœƒè‡ªå‹•æª¢æ¸¬ä¸¦ä¸­æ­¢å…¶ä¸­ä¸€å€‹äº‹å‹™:
-- ERROR: deadlock detected
```

---

**å¯¦ä½œæ©Ÿåˆ¶ 2: ä¸²è¡ŒåŸ·è¡Œ (Single-threaded Execution)**

**è¨­è¨ˆ**: æ‰€æœ‰äº‹å‹™åœ¨å–®ç·šç¨‹ä¸­ä¸²è¡ŒåŸ·è¡Œã€‚

**é©ç”¨å ´æ™¯**: äº‹å‹™**æ¥µå¿«** (å…¨å…§å­˜æ“ä½œ),å¦‚ Redisã€‚

```python
import queue

class SerialExecutor:
    def __init__(self):
        self.task_queue = queue.Queue()
        self.data = {}
    
    def submit_transaction(self, transaction):
        """æäº¤äº‹å‹™åˆ°éšŠåˆ—"""
        self.task_queue.put(transaction)
    
    def run(self):
        """å–®ç·šç¨‹åŸ·è¡Œæ‰€æœ‰äº‹å‹™"""
        while True:
            transaction = self.task_queue.get()
            
            # ä¸²è¡ŒåŸ·è¡Œ,ç„¡éœ€é–
            transaction.execute(self.data)

# ä½¿ç”¨ç¯„ä¾‹
executor = SerialExecutor()

def transfer(data):
    data['Alice'] -= 100
    data['Bob'] += 100

executor.submit_transaction(transfer)
executor.run()
```

**ğŸ¢ çœŸå¯¦æ¡ˆä¾‹: Redis**

```python
# Redis äº‹å‹™ (ä¸²è¡ŒåŸ·è¡Œ)
import redis

r = redis.Redis()

# ä½¿ç”¨ MULTI/EXEC ä¸²è¡ŒåŸ·è¡Œå‘½ä»¤
pipe = r.pipeline()
pipe.multi()
pipe.decrby('Alice:balance', 100)
pipe.incrby('Bob:balance', 100)
pipe.execute()  # åŸå­æ€§ä¸²è¡ŒåŸ·è¡Œ
```

**âœ… å„ªé»**: ç„¡é–,ç„¡æ­»é–,å¯¦ä½œç°¡å–®

**âŒ ç¼ºé»**: ååé‡å—é™æ–¼å–®ç·šç¨‹æ€§èƒ½

---

**å¯¦ä½œæ©Ÿåˆ¶ 3: åºåˆ—åŒ–å¿«ç…§éš”é›¢ (SSI, Serializable Snapshot Isolation)**

**è¨­è¨ˆ**: åœ¨å¿«ç…§éš”é›¢åŸºç¤ä¸Š,æª¢æ¸¬å¯èƒ½ç ´å£åºåˆ—åŒ–çš„è¡çªã€‚

```mermaid
graph TD
    A["äº‹å‹™åŸ·è¡Œ<br/>(å¿«ç…§éš”é›¢)"] --> B{"æª¢æ¸¬è¡çª"}
    B -->|ç„¡è¡çª| C["æäº¤æˆåŠŸ"]
    B -->|æœ‰è¡çª| D["ä¸­æ­¢äº‹å‹™<br/>è¿”å›éŒ¯èª¤"]
    
    D --> E["å®¢æˆ¶ç«¯é‡è©¦"]
```

**æª¢æ¸¬çš„è¡çªé¡å‹**:

1. **è®€å¯«è¡çª**: T1 è®€å– X,T2 ä¿®æ”¹ X,T1 åŸºæ–¼è®€å–çµæœå¯«å…¥
2. **å¯«å¯«è¡çª**: T1 å’Œ T2 åŒæ™‚å¯«å…¥åŒä¸€è³‡æ–™

**ğŸ’» PostgreSQL SSI ç¯„ä¾‹**:

```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;

BEGIN;

-- T1: æª¢æŸ¥å€¼ç­é†«ç”Ÿæ•¸é‡
SELECT COUNT(*) FROM doctors WHERE on_call = true;  -- 2 äºº

-- T2 åŒæ™‚åŸ·è¡Œç›¸åŒé‚è¼¯ä¸¦ä¿®æ”¹è³‡æ–™

-- T1: åŸºæ–¼è®€å–çµæœæ›´æ–°
UPDATE doctors SET on_call = false WHERE name = 'Alice';

COMMIT;
-- ERROR: could not serialize access due to read/write dependencies among transactions
```

**ğŸ¢ çœŸå¯¦æ¡ˆä¾‹: PostgreSQL 9.1+, CockroachDB**

**âœ… å„ªé»**: æ€§èƒ½é å„ªæ–¼ 2PL,ç„¡æ­»é–

**âŒ ç¼ºé»**: äº‹å‹™å¯èƒ½è¢«ä¸­æ­¢,éœ€è¦æ‡‰ç”¨å±¤é‡è©¦

---

## ğŸ¤” æ·±å…¥æ€è€ƒ

### ç·´ç¿’ 1: é¸æ“‡éš”é›¢ç´šåˆ¥

çµ¦å®šä»¥ä¸‹å ´æ™¯,é¸æ“‡æœ€åˆé©çš„éš”é›¢ç´šåˆ¥:

**å ´æ™¯ A: éŠ€è¡Œè½‰å¸³ç³»çµ±**
- è¦æ±‚: çµ•å°ä¸èƒ½ä¸Ÿå¤±é‡‘é¡,ä¸èƒ½å‡ºç¾è² é¤˜é¡
- ä¸¦ç™¼: ä¸­ç­‰

**å ´æ™¯ B: ç¤¾äº¤åª’é«”ç€è¦½è¨ˆæ•¸**
- è¦æ±‚: å¤§è‡´æº–ç¢ºå³å¯,å…è¨±å¶çˆ¾å°‘è¨ˆæ•¸å¹¾æ¬¡
- ä¸¦ç™¼: æ¥µé«˜

**å ´æ™¯ C: åº«å­˜æ‰£æ¸›**
- è¦æ±‚: ä¸èƒ½è¶…è³£,ä½†å…è¨±çŸ­æš«çš„ä¸ä¸€è‡´
- ä¸¦ç™¼: é«˜

<details>
<summary>ğŸ’¡ åƒè€ƒç­”æ¡ˆ</summary>

**å ´æ™¯ A: Serializable**
```sql
SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
BEGIN;
-- è½‰å¸³é‚è¼¯
COMMIT;
```
ç†ç”±: é‡‘é¡æº–ç¢ºæ€§è‡³é—œé‡è¦,å¿…é ˆä½¿ç”¨æœ€å¼·éš”é›¢ç´šåˆ¥ã€‚

**å ´æ™¯ B: Read Committed æˆ–æ›´ä½**
```sql
-- ä½¿ç”¨ Redis åŸå­æ“ä½œ
INCR article:123:views
```
ç†ç”±: è¨ˆæ•¸ä¸éœ€è¦çµ•å°æº–ç¢º,æ€§èƒ½å„ªå…ˆã€‚

**å ´æ™¯ C: Repeatable Read + æ¨‚è§€é–**
```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;

SELECT stock, version FROM products WHERE id = 123 FOR UPDATE;

UPDATE products 
SET stock = stock - 1, version = version + 1
WHERE id = 123 AND version = @old_version;

IF @@ROWCOUNT = 0 THEN
    ROLLBACK;  -- ç‰ˆæœ¬è¡çª,é‡è©¦
ELSE
    COMMIT;
END IF;
```
ç†ç”±: å¹³è¡¡ä¸€è‡´æ€§èˆ‡æ€§èƒ½ã€‚

</details>

---

### ç·´ç¿’ 2: åˆ†æä¸¦ç™¼ç•°å¸¸

ä»¥ä¸‹ç¨‹å¼ç¢¼åœ¨ Read Committed éš”é›¢ç´šåˆ¥ä¸‹é‹è¡Œ,æŒ‡å‡ºå¯èƒ½çš„å•é¡Œ:

```python
def book_seat(user_id, seat_id):
    with db.transaction(isolation='READ COMMITTED'):
        # æª¢æŸ¥åº§ä½æ˜¯å¦å¯ç”¨
        seat = db.execute(
            "SELECT * FROM seats WHERE id = ? AND booked = false",
            (seat_id,)
        ).fetchone()
        
        if seat:
            # é è¨‚åº§ä½
            db.execute(
                "UPDATE seats SET booked = true, user_id = ? WHERE id = ?",
                (user_id, seat_id)
            )
            return "é è¨‚æˆåŠŸ"
        else:
            return "åº§ä½å·²è¢«é è¨‚"

# å…©å€‹ç”¨æˆ¶åŒæ™‚é è¨‚åŒä¸€åº§ä½
book_seat(user_1, seat_101)  # T1
book_seat(user_2, seat_101)  # T2
```

<details>
<summary>ğŸ’¡ åƒè€ƒç­”æ¡ˆ</summary>

**å•é¡Œ: ä¸å¯é‡è¤‡è®€å°è‡´é›™é‡é è¨‚**

```mermaid
sequenceDiagram
    participant T1 as ç”¨æˆ¶ 1
    participant T2 as ç”¨æˆ¶ 2
    participant DB as è³‡æ–™åº«
    
    T1->>DB: SELECT (seat_101 å¯ç”¨)
    T2->>DB: SELECT (seat_101 å¯ç”¨)
    
    T1->>DB: UPDATE (é è¨‚åº§ä½)
    T2->>DB: UPDATE (ä¹Ÿé è¨‚äº†åº§ä½!)
    
    Note over DB: âŒ é›™é‡é è¨‚
```

**è§£æ±ºæ–¹æ¡ˆ 1: ä½¿ç”¨ FOR UPDATE (æ‚²è§€é–)**

```python
def book_seat(user_id, seat_id):
    with db.transaction():
        # é–ä½è©²è¡Œ
        seat = db.execute(
            "SELECT * FROM seats WHERE id = ? AND booked = false FOR UPDATE",
            (seat_id,)
        ).fetchone()
        
        if seat:
            db.execute(
                "UPDATE seats SET booked = true, user_id = ? WHERE id = ?",
                (user_id, seat_id)
            )
            return "é è¨‚æˆåŠŸ"
        else:
            return "åº§ä½å·²è¢«é è¨‚"
```

**è§£æ±ºæ–¹æ¡ˆ 2: ä½¿ç”¨æ¨‚è§€é– (ç‰ˆæœ¬è™Ÿ)**

```python
def book_seat(user_id, seat_id):
    with db.transaction():
        seat = db.execute(
            "SELECT version FROM seats WHERE id = ? AND booked = false",
            (seat_id,)
        ).fetchone()
        
        if seat:
            version = seat['version']
            
            # æ›´æ–°æ™‚æª¢æŸ¥ç‰ˆæœ¬
            rows = db.execute(
                """UPDATE seats 
                   SET booked = true, user_id = ?, version = version + 1
                   WHERE id = ? AND version = ?""",
                (user_id, seat_id, version)
            ).rowcount
            
            if rows == 1:
                return "é è¨‚æˆåŠŸ"
            else:
                return "é è¨‚å¤±æ•—,è«‹é‡è©¦"  # ç‰ˆæœ¬è¡çª
```

**è§£æ±ºæ–¹æ¡ˆ 3: ä½¿ç”¨ Serializable éš”é›¢ç´šåˆ¥**

```python
def book_seat(user_id, seat_id):
    with db.transaction(isolation='SERIALIZABLE'):
        # è‡ªå‹•æª¢æ¸¬è¡çª
        seat = db.execute(
            "SELECT * FROM seats WHERE id = ? AND booked = false",
            (seat_id,)
        ).fetchone()
        
        if seat:
            db.execute(
                "UPDATE seats SET booked = true, user_id = ? WHERE id = ?",
                (user_id, seat_id)
            )
            return "é è¨‚æˆåŠŸ"
```

</details>

---

## ğŸ“š ç¸½çµ

### æ ¸å¿ƒè¦é»

```mermaid
graph TD
    A["äº‹å‹™"] --> B["ACID ç‰¹æ€§"]
    A --> C["éš”é›¢ç´šåˆ¥"]
    A --> D["å¯¦ä½œæ©Ÿåˆ¶"]
    
    B --> B1["åŸå­æ€§: å…¨æœ‰æˆ–å…¨ç„¡"]
    B --> B2["ä¸€è‡´æ€§: ä¿æŒç´„æŸ"]
    B --> B3["éš”é›¢æ€§: ä¸¦ç™¼æ§åˆ¶"]
    B --> B4["æŒä¹…æ€§: æäº¤å¾Œæ°¸ä¹…ä¿å­˜"]
    
    C --> C1["Read Committed (å¸¸ç”¨)"]
    C --> C2["Repeatable Read (MySQL é»˜èª)"]
    C --> C3["Serializable (æœ€å¼·)"]
    
    D --> D1["é– (2PL)"]
    D --> D2["MVCC (å¿«ç…§)"]
    D --> D3["SSI (æ¨‚è§€)"]
```

### æ±ºç­–æŒ‡å—

**é¸æ“‡éš”é›¢ç´šåˆ¥**:

| å ´æ™¯ | æ¨è–¦éš”é›¢ç´šåˆ¥ | ç†ç”± |
|------|-------------|------|
| é‡‘èäº¤æ˜“ | Serializable | ä¸å®¹è¨±ä»»ä½•ç•°å¸¸ |
| è¨‚å–®ç³»çµ± | Repeatable Read + æ¨‚è§€é– | å¹³è¡¡æ€§èƒ½èˆ‡ä¸€è‡´æ€§ |
| ç¤¾äº¤åª’é«” | Read Committed | æ€§èƒ½å„ªå…ˆ,å®¹å¿çŸ­æš«ä¸ä¸€è‡´ |
| æ•¸æ“šåˆ†æ (åªè®€) | Read Committed æˆ–æ›´ä½ | ç„¡å¯«å…¥è¡çª |

**é¿å…å¸¸è¦‹é™·é˜±**:

1. **ä¸è¦å‡è¨­é»˜èªéš”é›¢ç´šåˆ¥è¶³å¤ **: æ˜ç¢ºè¨­ç½®éš”é›¢ç´šåˆ¥
2. **æ³¨æ„é•·äº‹å‹™**: æŒæœ‰é–æ™‚é–“éé•·,å½±éŸ¿ä¸¦ç™¼
3. **è™•ç†æ­»é–**: å¯¦ä½œé‡è©¦é‚è¼¯
4. **æ¸¬è©¦ä¸¦ç™¼å ´æ™¯**: å–®ç·šç¨‹æ¸¬è©¦ç„¡æ³•ç™¼ç¾ä¸¦ç™¼å•é¡Œ

---

## ğŸ”— åƒè€ƒè³‡æ–™

1. **æ›¸ç±**:
   - Martin Kleppmann, *Designing Data-Intensive Applications*, Chapter 7
   - Jim Gray, *Transaction Processing: Concepts and Techniques*

2. **è«–æ–‡**:
   - [A Critique of ANSI SQL Isolation Levels](https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/tr-95-51.pdf)
   - [Serializable Snapshot Isolation in PostgreSQL](https://drkp.net/papers/ssi-vldb12.pdf)

3. **æŠ€è¡“æ–‡ä»¶**:
   - [PostgreSQL Transaction Isolation](https://www.postgresql.org/docs/current/transaction-iso.html)
   - [MySQL InnoDB Locking](https://dev.mysql.com/doc/refman/8.0/en/innodb-locking.html)

4. **éƒ¨è½æ ¼**:
   - [Jepsen: Consistency Models](https://jepsen.io/consistency)
   - [Understanding Isolation Levels](https://www.cockroachlabs.com/blog/sql-isolation-levels-explained/)

# 08 - ä¸€è‡´æ€§èˆ‡å…±è­˜ (Consistency and Consensus)

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å¾Œ,ä½ å°‡èƒ½å¤ :
- ç†è§£åˆ†æ•£å¼ç³»çµ±ä¸­çš„ä¸€è‡´æ€§æ¨¡å‹
- æŒæ¡å…±è­˜ç®—æ³•çš„åŸç† (Paxos, Raft)
- ç†è§£ CAP å®šç†èˆ‡å¯¦éš›æ‡‰ç”¨
- è¨­è¨ˆéœ€è¦å…±è­˜çš„åˆ†æ•£å¼ç³»çµ±

---

## ğŸ’¡ æ ¸å¿ƒæ¦‚å¿µ

### ä»€éº¼æ˜¯å…±è­˜?

**å…±è­˜ (Consensus)**: è®“å¤šå€‹ç¯€é»å°æŸå€‹å€¼é”æˆä¸€è‡´æ„è¦‹ã€‚

**ç‚ºä»€éº¼å›°é›£?**

```mermaid
graph TD
    A["å…±è­˜çš„æŒ‘æˆ°"] --> B["ç¶²è·¯ä¸å¯é <br/>è¨Šæ¯å¯èƒ½ä¸Ÿå¤±æˆ–å»¶é²"]
    A --> C["ç¯€é»å¯èƒ½æ•…éšœ<br/>å´©æ½°æˆ–æš«åœ"]
    A --> D["ç„¡å…¨å±€æ™‚é˜<br/>ç„¡æ³•åˆ¤æ–·äº‹ä»¶é †åº"]
```

**å…±è­˜çš„æ‡‰ç”¨å ´æ™¯**:

| æ‡‰ç”¨ | éœ€è¦å…±è­˜çš„å…§å®¹ |
|------|--------------|
| **Leader é¸èˆ‰** | èª°æ˜¯æ–°çš„ Leader |
| **åŸå­æäº¤** | äº‹å‹™æ˜¯å¦æäº¤ |
| **è¤‡è£½æ—¥èªŒ** | æ—¥èªŒæ¢ç›®çš„é †åº |
| **é–æœå‹™** | èª°ç²å¾—é– |
| **é…ç½®ç®¡ç†** | é›†ç¾¤é…ç½®çš„ç‰ˆæœ¬ |

---

## ğŸ“Š ä¸€è‡´æ€§æ¨¡å‹

### ä¸€è‡´æ€§å…‰è­œ

```mermaid
graph LR
    A["å¼·ä¸€è‡´æ€§<br/>(Linearizability)"] -->|å¼±åŒ–| B["é †åºä¸€è‡´æ€§<br/>(Sequential)"]
    B -->|å¼±åŒ–| C["å› æœä¸€è‡´æ€§<br/>(Causal)"]
    C -->|å¼±åŒ–| D["æœ€çµ‚ä¸€è‡´æ€§<br/>(Eventual)"]
    
    A --> A1["ä¿è­‰: å¯¦æ™‚<br/>ä»£åƒ¹: é«˜å»¶é²"]
    D --> D1["ä¿è­‰: æœ€çµ‚<br/>ä»£åƒ¹: ä½å»¶é²"]
```

---

### ç·šæ€§ä¸€è‡´æ€§ (Linearizability)

**å®šç¾©**: æœ€å¼·çš„ä¸€è‡´æ€§ä¿è­‰,ç³»çµ±è¡¨ç¾å¾—åƒåªæœ‰ä¸€å€‹å‰¯æœ¬,æ“ä½œç¬é–“å®Œæˆä¸”é †åºæ˜ç¢ºã€‚

**ç‰¹æ€§**:
1. **å¯¦æ™‚æ€§ (Real-time)**: å¦‚æœæ“ä½œ A åœ¨æ“ä½œ B é–‹å§‹å‰å®Œæˆ,å‰‡ A å¿…é ˆåœ¨ B ä¹‹å‰ç”Ÿæ•ˆ
2. **å…¨å±€é †åº**: æ‰€æœ‰æ“ä½œæœ‰å”¯ä¸€çš„å…¨å±€é †åº
3. **è®€å–æœ€æ–°å€¼**: è®€æ“ä½œå¿…é ˆè¿”å›æœ€æ–°å¯«å…¥çš„å€¼

**å¯è¦–åŒ–ç¤ºæ„**:

```mermaid
sequenceDiagram
    participant C1 as å®¢æˆ¶ç«¯ 1
    participant S as ç³»çµ±
    participant C2 as å®¢æˆ¶ç«¯ 2
    
    Note over S: X = 0
    
    C1->>S: write(X, 1)
    Note over S: X = 1
    S-->>C1: OK
    
    Note over C1,C2: æ™‚é–“æµé€
    
    C2->>S: read(X)
    S-->>C2: 1 (å¿…é ˆæ˜¯æœ€æ–°å€¼)
    
    Note over S: âœ… ç·šæ€§ä¸€è‡´æ€§
```

**éç·šæ€§ä¸€è‡´æ€§ç¯„ä¾‹**:

```mermaid
sequenceDiagram
    participant C1 as å®¢æˆ¶ç«¯ 1
    participant S as ç³»çµ±
    participant C2 as å®¢æˆ¶ç«¯ 2
    
    Note over S: X = 0
    
    C1->>S: write(X, 1)
    Note over S: X = 1 (ä½†å°šæœªåŒæ­¥åˆ°æ‰€æœ‰å‰¯æœ¬)
    S-->>C1: OK
    
    C2->>S: read(X)
    S-->>C2: 0 (è®€åˆ°èˆŠå€¼)
    
    Note over S: âŒ é•åç·šæ€§ä¸€è‡´æ€§
```

---

### ğŸ’» å¯¦ä½œç¯„ä¾‹: æª¢æ¸¬ç·šæ€§ä¸€è‡´æ€§

```python
class LinearizabilityChecker:
    """æª¢æ¸¬æ“ä½œæ­·å²æ˜¯å¦æ»¿è¶³ç·šæ€§ä¸€è‡´æ€§"""
    
    def __init__(self):
        self.history = []  # [(operation, start_time, end_time), ...]
    
    def add_operation(self, op_type, key, value, start_time, end_time):
        """è¨˜éŒ„æ“ä½œ"""
        self.history.append({
            'type': op_type,  # 'read' or 'write'
            'key': key,
            'value': value,
            'start': start_time,
            'end': end_time
        })
    
    def check(self):
        """æª¢æŸ¥æ˜¯å¦ç·šæ€§ä¸€è‡´"""
        # å˜—è©¦æ‰¾åˆ°ä¸€å€‹åˆæ³•çš„ç·šæ€§é †åº
        return self._find_linearization(self.history)
    
    def _find_linearization(self, history):
        """å˜—è©¦æ§‹é€ ç·šæ€§é †åº"""
        # ç°¡åŒ–å¯¦ä½œ: æª¢æŸ¥è®€æ“ä½œæ˜¯å¦è¿”å›æœ€è¿‘çš„å¯«å…¥å€¼
        state = {}  # {key: value}
        
        # æŒ‰æ“ä½œçµæŸæ™‚é–“æ’åº
        sorted_history = sorted(history, key=lambda x: x['end'])
        
        for op in sorted_history:
            if op['type'] == 'write':
                state[op['key']] = op['value']
            elif op['type'] == 'read':
                # æª¢æŸ¥è®€å–çš„å€¼æ˜¯å¦æ˜¯æœ€æ–°å¯«å…¥çš„å€¼
                expected = state.get(op['key'])
                if op['value'] != expected:
                    return False
        
        return True

# ä½¿ç”¨ç¯„ä¾‹
checker = LinearizabilityChecker()

# å ´æ™¯ 1: ç·šæ€§ä¸€è‡´
checker.add_operation('write', 'X', 1, start_time=0, end_time=1)
checker.add_operation('read', 'X', 1, start_time=2, end_time=3)
print(checker.check())  # True

# å ´æ™¯ 2: éç·šæ€§ä¸€è‡´
checker2 = LinearizabilityChecker()
checker2.add_operation('write', 'X', 1, start_time=0, end_time=1)
checker2.add_operation('read', 'X', 0, start_time=2, end_time=3)  # è®€åˆ°èˆŠå€¼
print(checker2.check())  # False
```

---

### ç·šæ€§ä¸€è‡´æ€§çš„ä»£åƒ¹

**å•é¡Œ**: ç¶²è·¯åˆ†å€æ™‚ç„¡æ³•ä¿è­‰ç·šæ€§ä¸€è‡´æ€§ã€‚

```mermaid
graph TD
    A["CAP å®šç†"] --> B["ä¸€è‡´æ€§<br/>(Consistency)"]
    A --> C["å¯ç”¨æ€§<br/>(Availability)"]
    A --> D["åˆ†å€å®¹éŒ¯<br/>(Partition Tolerance)"]
    
    B --> E["é¸æ“‡ CP<br/>çŠ§ç‰²å¯ç”¨æ€§"]
    C --> F["é¸æ“‡ AP<br/>çŠ§ç‰²ä¸€è‡´æ€§"]
    D --> G["å¿…é ˆä¿è­‰<br/>(ç¶²è·¯ç¸½æœƒåˆ†å€)"]
```

**ç¯„ä¾‹: etcd çš„ CP é¸æ“‡**

```python
# etcd åœ¨ç¶²è·¯åˆ†å€æ™‚çš„è¡Œç‚º
import etcd3

client = etcd3.client(host='etcd-node1')

try:
    # å¦‚æœç•¶å‰ç¯€é»èˆ‡ Leader å¤±è¯
    client.put('key', 'value')
except Exception as e:
    print("å¯«å…¥å¤±æ•—: ç¯€é»ä¸åœ¨å¤šæ•¸æ´¾") # âŒ çŠ§ç‰²å¯ç”¨æ€§ä¿è­‰ä¸€è‡´æ€§
```

**ç¯„ä¾‹: Cassandra çš„ AP é¸æ“‡**

```python
# Cassandra åœ¨ç¶²è·¯åˆ†å€æ™‚çš„è¡Œç‚º
from cassandra.cluster import Cluster

cluster = Cluster(['node1', 'node2'])
session = cluster.connect('keyspace')

# å³ä½¿ç¶²è·¯åˆ†å€,ä»ç„¶å¯ä»¥å¯«å…¥
session.execute(
    "INSERT INTO users (id, name) VALUES (1, 'Alice')"
)  # âœ… ä¿è­‰å¯ç”¨æ€§,ä½†å¯èƒ½ä¸ä¸€è‡´
```

---

### å› æœä¸€è‡´æ€§ (Causal Consistency)

**å®šç¾©**: ä¿è­‰æœ‰å› æœé—œä¿‚çš„æ“ä½œé †åº,ä½†ä¸ä¿è­‰ç„¡é—œæ“ä½œçš„é †åºã€‚

**å› æœé—œä¿‚ç¯„ä¾‹**:

```mermaid
sequenceDiagram
    participant Alice
    participant Bob
    participant Charlie
    
    Alice->>Bob: "è–æ¯å³°å¤šé«˜?" (äº‹ä»¶ A)
    Bob->>Charlie: "8849 å…¬å°º" (äº‹ä»¶ B)
    
    Note over Alice,Charlie: å› æœé—œä¿‚: B ä¾è³´æ–¼ A<br/>æ‰€æœ‰äººå¿…é ˆå…ˆçœ‹åˆ° A å†çœ‹åˆ° B
    
    Alice->>Bob: "ä»Šå¤©å¤©æ°£çœŸå¥½" (äº‹ä»¶ C)
    
    Note over Alice,Charlie: ç„¡å› æœé—œä¿‚: A å’Œ C ç¨ç«‹<br/>å¯ä»¥ä»¥ä»»æ„é †åºçœ‹åˆ°
```

**å‘é‡æ™‚é˜ (Vector Clock)** è¿½è¹¤å› æœé—œä¿‚:

```python
class VectorClock:
    def __init__(self, node_id, num_nodes):
        self.node_id = node_id
        self.clock = [0] * num_nodes
    
    def increment(self):
        """æœ¬åœ°äº‹ä»¶,æ™‚é˜éå¢"""
        self.clock[self.node_id] += 1
    
    def update(self, other_clock):
        """æ¥æ”¶è¨Šæ¯,æ›´æ–°æ™‚é˜"""
        for i in range(len(self.clock)):
            self.clock[i] = max(self.clock[i], other_clock[i])
        self.increment()  # æ¥æ”¶ä¹Ÿæ˜¯ä¸€å€‹äº‹ä»¶
    
    def happens_before(self, other_clock):
        """åˆ¤æ–·æ˜¯å¦æœ‰å› æœé—œä¿‚: self -> other"""
        less_or_equal = all(self.clock[i] <= other_clock[i] for i in range(len(self.clock)))
        strictly_less = any(self.clock[i] < other_clock[i] for i in range(len(self.clock)))
        return less_or_equal and strictly_less
    
    def concurrent(self, other_clock):
        """åˆ¤æ–·æ˜¯å¦ä¸¦ç™¼ (ç„¡å› æœé—œä¿‚)"""
        return not self.happens_before(other_clock) and not VectorClock.happens_before_static(other_clock, self.clock)
    
    @staticmethod
    def happens_before_static(clock1, clock2):
        less_or_equal = all(clock1[i] <= clock2[i] for i in range(len(clock1)))
        strictly_less = any(clock1[i] < clock2[i] for i in range(len(clock1)))
        return less_or_equal and strictly_less

# ä½¿ç”¨ç¯„ä¾‹ (3 å€‹ç¯€é»)
alice = VectorClock(node_id=0, num_nodes=3)
bob = VectorClock(node_id=1, num_nodes=3)
charlie = VectorClock(node_id=2, num_nodes=3)

# Alice ç™¼é€è¨Šæ¯
alice.increment()  # [1, 0, 0]

# Bob æ¥æ”¶è¨Šæ¯
bob.update(alice.clock)  # [1, 1, 0]

# Bob ç™¼é€å›è¦†
bob.increment()  # [1, 2, 0]

# Charlie æ¥æ”¶ Bob çš„è¨Šæ¯
charlie.update(bob.clock)  # [1, 2, 1]

# æª¢æŸ¥å› æœé—œä¿‚
print(alice.happens_before(charlie.clock))  # True (Alice -> Charlie)
```

---

## ğŸ—³ï¸ å…±è­˜ç®—æ³•

### å…±è­˜å•é¡Œçš„å½¢å¼åŒ–å®šç¾©

**è¦æ±‚**:
1. **ä¸€è‡´æ€§ (Agreement)**: æ‰€æœ‰ç¯€é»æ±ºå®šç›¸åŒçš„å€¼
2. **åˆæ³•æ€§ (Validity)**: æ±ºå®šçš„å€¼å¿…é ˆæ˜¯æŸå€‹ç¯€é»æè­°çš„å€¼
3. **çµ‚æ­¢æ€§ (Termination)**: æ‰€æœ‰æ­£å¸¸ç¯€é»æœ€çµ‚æœƒåšå‡ºæ±ºå®š

**ä¸å¯èƒ½çµæœ (FLP Impossibility)**:
- åœ¨ç•°æ­¥ç¶²è·¯ä¸­,å³ä½¿åªæœ‰ä¸€å€‹ç¯€é»å¯èƒ½æ•…éšœ,ä¹Ÿ**ä¸å­˜åœ¨**ç¢ºå®šæ€§å…±è­˜ç®—æ³•
- å¯¦å‹™è§£æ±ºæ–¹æ¡ˆ: ä½¿ç”¨è¶…æ™‚ç­‰å•Ÿç™¼å¼æ–¹æ³•,çŠ§ç‰²ç¢ºå®šæ€§

---

### Raft å…±è­˜ç®—æ³•

**è¨­è¨ˆç›®æ¨™**: æ˜“æ–¼ç†è§£çš„å…±è­˜ç®—æ³•ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:

```mermaid
graph LR
    A["Raft çš„ä¸‰å€‹å­å•é¡Œ"] --> B["Leader é¸èˆ‰"]
    A --> C["æ—¥èªŒè¤‡è£½"]
    A --> D["å®‰å…¨æ€§ä¿è­‰"]
```

---

#### 1. Leader é¸èˆ‰

**è§’è‰²**:

```mermaid
stateDiagram-v2
    [*] --> Follower: å•Ÿå‹•
    Follower --> Candidate: é¸èˆ‰è¶…æ™‚
    Candidate --> Leader: ç²å¾—å¤šæ•¸ç¥¨
    Candidate --> Follower: ç™¼ç¾æ›´é«˜ä»»æœŸçš„ Leader
    Leader --> Follower: ç™¼ç¾æ›´é«˜ä»»æœŸ
    Candidate --> Candidate: åˆ†ç¥¨,é‡æ–°é¸èˆ‰
```

**é¸èˆ‰æµç¨‹**:

```mermaid
sequenceDiagram
    participant F1 as Follower 1
    participant C as Candidate (F2)
    participant F3 as Follower 3
    participant F4 as Follower 4
    
    Note over F1,F4: Leader æ•…éšœ,å¿ƒè·³è¶…æ™‚
    
    C->>C: é¸èˆ‰è¶…æ™‚<br/>è½‰æ›ç‚º Candidate<br/>Term éå¢ (Term=2)
    
    C->>F1: RequestVote (Term=2)
    C->>F3: RequestVote (Term=2)
    C->>F4: RequestVote (Term=2)
    
    F1-->>C: æŠ•ç¥¨çµ¦ä½ 
    F3-->>C: æŠ•ç¥¨çµ¦ä½ 
    F4-->>C: æŠ•ç¥¨çµ¦ä½ 
    
    Note over C: ç²å¾—å¤šæ•¸ç¥¨ (3/4)<br/>æˆç‚º Leader
    
    C->>F1: Heartbeat (Term=2)
    C->>F3: Heartbeat (Term=2)
    C->>F4: Heartbeat (Term=2)
```

**ğŸ’» å¯¦ä½œç¯„ä¾‹**:

```python
import time
import random
from enum import Enum

class Role(Enum):
    FOLLOWER = 1
    CANDIDATE = 2
    LEADER = 3

class RaftNode:
    def __init__(self, node_id, peers):
        self.node_id = node_id
        self.peers = peers  # å…¶ä»–ç¯€é»åˆ—è¡¨
        
        # æŒä¹…ç‹€æ…‹
        self.current_term = 0
        self.voted_for = None
        self.log = []
        
        # æ˜“å¤±ç‹€æ…‹
        self.role = Role.FOLLOWER
        self.leader_id = None
        
        # é¸èˆ‰è¶…æ™‚ (éš¨æ©Ÿ 150-300ms)
        self.election_timeout = random.uniform(0.15, 0.3)
        self.last_heartbeat = time.time()
    
    def start_election(self):
        """ç™¼èµ·é¸èˆ‰"""
        self.role = Role.CANDIDATE
        self.current_term += 1
        self.voted_for = self.node_id
        
        votes = 1  # çµ¦è‡ªå·±æŠ•ç¥¨
        
        # å‘æ‰€æœ‰ç¯€é»è«‹æ±‚æŠ•ç¥¨
        for peer in self.peers:
            response = peer.request_vote(
                term=self.current_term,
                candidate_id=self.node_id,
                last_log_index=len(self.log) - 1,
                last_log_term=self.log[-1]['term'] if self.log else 0
            )
            
            if response['vote_granted']:
                votes += 1
        
        # æª¢æŸ¥æ˜¯å¦ç²å¾—å¤šæ•¸ç¥¨
        if votes > len(self.peers) / 2:
            self.become_leader()
    
    def request_vote(self, term, candidate_id, last_log_index, last_log_term):
        """è™•ç†æŠ•ç¥¨è«‹æ±‚"""
        # å¦‚æœå°æ–¹ä»»æœŸæ›´é«˜,æ›´æ–°è‡ªå·±çš„ä»»æœŸ
        if term > self.current_term:
            self.current_term = term
            self.voted_for = None
            self.role = Role.FOLLOWER
        
        # æŠ•ç¥¨æ¢ä»¶:
        # 1. ç•¶å‰ä»»æœŸå…§å°šæœªæŠ•ç¥¨,æˆ–å·²æŠ•ç¥¨çµ¦è©²å€™é¸äºº
        # 2. å€™é¸äººçš„æ—¥èªŒè‡³å°‘èˆ‡è‡ªå·±ä¸€æ¨£æ–°
        vote_granted = False
        
        if term >= self.current_term and (self.voted_for is None or self.voted_for == candidate_id):
            # æª¢æŸ¥æ—¥èªŒæ–°èˆŠ (ç°¡åŒ–ç‰ˆ)
            if last_log_index >= len(self.log) - 1:
                self.voted_for = candidate_id
                vote_granted = True
                self.last_heartbeat = time.time()  # é‡ç½®å¿ƒè·³
        
        return {'term': self.current_term, 'vote_granted': vote_granted}
    
    def become_leader(self):
        """æˆç‚º Leader"""
        self.role = Role.LEADER
        self.leader_id = self.node_id
        print(f"ç¯€é» {self.node_id} æˆç‚º Leader (Term {self.current_term})")
        
        # é–‹å§‹ç™¼é€å¿ƒè·³
        self.send_heartbeats()
    
    def send_heartbeats(self):
        """ç™¼é€å¿ƒè·³ (ç©ºçš„æ—¥èªŒè¤‡è£½è«‹æ±‚)"""
        for peer in self.peers:
            peer.append_entries(
                term=self.current_term,
                leader_id=self.node_id,
                entries=[]
            )
    
    def append_entries(self, term, leader_id, entries):
        """è™•ç†æ—¥èªŒè¤‡è£½è«‹æ±‚ (å¿ƒè·³)"""
        if term >= self.current_term:
            self.current_term = term
            self.role = Role.FOLLOWER
            self.leader_id = leader_id
            self.last_heartbeat = time.time()
        
        return {'term': self.current_term, 'success': True}
    
    def run(self):
        """ä¸»å¾ªç’°"""
        while True:
            if self.role == Role.FOLLOWER or self.role == Role.CANDIDATE:
                # æª¢æŸ¥é¸èˆ‰è¶…æ™‚
                if time.time() - self.last_heartbeat > self.election_timeout:
                    self.start_election()
            
            elif self.role == Role.LEADER:
                # å®šæœŸç™¼é€å¿ƒè·³
                time.sleep(0.05)  # 50ms å¿ƒè·³é–“éš”
                self.send_heartbeats()
```

---

#### 2. æ—¥èªŒè¤‡è£½

**æµç¨‹**:

```mermaid
sequenceDiagram
    participant C as å®¢æˆ¶ç«¯
    participant L as Leader
    participant F1 as Follower 1
    participant F2 as Follower 2
    
    C->>L: å¯«å…¥è«‹æ±‚ (SET X=5)
    
    Note over L: æ·»åŠ æ—¥èªŒæ¢ç›®<br/>[1] SET X=5 (æœªæäº¤)
    
    L->>F1: AppendEntries ([1] SET X=5)
    L->>F2: AppendEntries ([1] SET X=5)
    
    F1->>L: ç¢ºèª
    F2->>L: ç¢ºèª
    
    Note over L: å¤šæ•¸æ´¾ç¢ºèª<br/>æäº¤æ—¥èªŒæ¢ç›®
    
    L->>C: è¿”å›æˆåŠŸ
    
    L->>F1: Heartbeat (commitIndex=1)
    L->>F2: Heartbeat (commitIndex=1)
    
    Note over F1,F2: æ‡‰ç”¨æ—¥èªŒæ¢ç›®
```

**æ—¥èªŒçµæ§‹**:

```python
class LogEntry:
    def __init__(self, term, command):
        self.term = term        # æ—¥èªŒæ¢ç›®çš„ä»»æœŸ
        self.command = command  # ç‹€æ…‹æ©Ÿå‘½ä»¤

class RaftLog:
    def __init__(self):
        self.entries = []       # æ—¥èªŒæ¢ç›®åˆ—è¡¨
        self.commit_index = -1  # å·²æäº¤çš„æœ€é«˜ç´¢å¼•
        self.last_applied = -1  # å·²æ‡‰ç”¨åˆ°ç‹€æ…‹æ©Ÿçš„æœ€é«˜ç´¢å¼•
    
    def append(self, term, command):
        """æ·»åŠ æ—¥èªŒæ¢ç›®"""
        entry = LogEntry(term, command)
        self.entries.append(entry)
        return len(self.entries) - 1
    
    def commit(self, index):
        """æäº¤æ—¥èªŒæ¢ç›®"""
        self.commit_index = index
    
    def apply_to_state_machine(self, state_machine):
        """æ‡‰ç”¨å·²æäº¤ä½†æœªæ‡‰ç”¨çš„æ—¥èªŒ"""
        while self.last_applied < self.commit_index:
            self.last_applied += 1
            entry = self.entries[self.last_applied]
            state_machine.apply(entry.command)

# Leader çš„æ—¥èªŒè¤‡è£½é‚è¼¯
class RaftLeader:
    def replicate_log(self, command):
        """è¤‡è£½æ—¥èªŒåˆ°æ‰€æœ‰ Follower"""
        # 1. æ·»åŠ åˆ°æœ¬åœ°æ—¥èªŒ
        index = self.log.append(self.current_term, command)
        
        # 2. ä¸¦è¡Œç™¼é€åˆ°æ‰€æœ‰ Follower
        ack_count = 1  # è‡ªå·±çš„ç¢ºèª
        
        for peer in self.peers:
            response = peer.append_entries(
                term=self.current_term,
                leader_id=self.node_id,
                prev_log_index=index - 1,
                prev_log_term=self.log.entries[index - 1].term if index > 0 else 0,
                entries=[self.log.entries[index]],
                leader_commit=self.log.commit_index
            )
            
            if response['success']:
                ack_count += 1
        
        # 3. å¦‚æœç²å¾—å¤šæ•¸æ´¾ç¢ºèª,æäº¤æ—¥èªŒ
        if ack_count > len(self.peers) / 2:
            self.log.commit(index)
            return True
        
        return False
```

---

#### 3. å®‰å…¨æ€§ä¿è­‰

**Leader å®Œæ•´æ€§ (Leader Completeness)**:
- å¦‚æœæ—¥èªŒæ¢ç›®åœ¨æŸå€‹ä»»æœŸè¢«æäº¤,å‰‡å®ƒæœƒå‡ºç¾åœ¨æ‰€æœ‰æ›´é«˜ä»»æœŸçš„ Leader æ—¥èªŒä¸­

**å¯¦ç¾æ–¹å¼**: é¸èˆ‰é™åˆ¶

```python
def request_vote(self, term, candidate_id, last_log_index, last_log_term):
    """è™•ç†æŠ•ç¥¨è«‹æ±‚"""
    # æª¢æŸ¥å€™é¸äººçš„æ—¥èªŒæ˜¯å¦è‡³å°‘èˆ‡è‡ªå·±ä¸€æ¨£æ–°
    my_last_index = len(self.log) - 1
    my_last_term = self.log[my_last_index].term if self.log else 0
    
    # æ—¥èªŒ"æ›´æ–°"çš„å®šç¾©:
    # 1. æœ€å¾Œä¸€æ¢æ—¥èªŒçš„ä»»æœŸæ›´å¤§,æˆ–
    # 2. ä»»æœŸç›¸åŒä½†ç´¢å¼•æ›´å¤§
    log_is_up_to_date = (
        last_log_term > my_last_term or
        (last_log_term == my_last_term and last_log_index >= my_last_index)
    )
    
    if not log_is_up_to_date:
        return {'vote_granted': False}
    
    # ... å…¶ä»–æŠ•ç¥¨é‚è¼¯
```

---

### Paxos ç®—æ³•

**æ ¸å¿ƒæ€æƒ³**: åˆ†å…©éšæ®µé”æˆå…±è­˜ã€‚

**è§’è‰²**:
- **Proposer**: æè­°è€…
- **Acceptor**: æ¥å—è€…
- **Learner**: å­¸ç¿’è€…

**å…©éšæ®µæµç¨‹**:

```mermaid
sequenceDiagram
    participant P as Proposer
    participant A1 as Acceptor 1
    participant A2 as Acceptor 2
    participant A3 as Acceptor 3
    
    Note over P,A3: éšæ®µ 1: Prepare
    P->>A1: Prepare(n=10)
    P->>A2: Prepare(n=10)
    P->>A3: Prepare(n=10)
    
    A1-->>P: Promise (ç„¡å…ˆå‰æ¥å—)
    A2-->>P: Promise (ç„¡å…ˆå‰æ¥å—)
    A3-->>P: Promise (ç„¡å…ˆå‰æ¥å—)
    
    Note over P,A3: éšæ®µ 2: Accept
    P->>A1: Accept(n=10, value="X")
    P->>A2: Accept(n=10, value="X")
    P->>A3: Accept(n=10, value="X")
    
    A1-->>P: Accepted
    A2-->>P: Accepted
    A3-->>P: Accepted
    
    Note over P,A3: å€¼ "X" è¢«é¸å®š
```

**Paxos vs Raft**:

| ç‰¹æ€§ | Paxos | Raft |
|------|-------|------|
| **æ˜“ç†è§£æ€§** | âŒ è¤‡é›œ | âœ… ç°¡å–® |
| **å¯¦ä½œè¤‡é›œåº¦** | âŒ é«˜ | âœ… ä¸­ç­‰ |
| **æ•ˆèƒ½** | âš ï¸ éœ€å„ªåŒ– (Multi-Paxos) | âœ… é«˜æ•ˆ |
| **å·¥æ¥­æ‡‰ç”¨** | Google Chubby, ZooKeeper (ZAB) | etcd, Consul, CockroachDB |

---

## ğŸ” åŸå­æäº¤ (Atomic Commit)

### å…©éšæ®µæäº¤ (2PC, Two-Phase Commit)

**ä½¿ç”¨å ´æ™¯**: åˆ†æ•£å¼äº‹å‹™,ç¢ºä¿æ‰€æœ‰åƒèˆ‡è€…ä¸€è‡´æäº¤æˆ–å›æ»¾ã€‚

**æµç¨‹**:

```mermaid
sequenceDiagram
    participant C as å”èª¿è€…
    participant P1 as åƒèˆ‡è€… 1
    participant P2 as åƒèˆ‡è€… 2
    participant P3 as åƒèˆ‡è€… 3
    
    Note over C,P3: éšæ®µ 1: Prepare
    C->>P1: Prepare
    C->>P2: Prepare
    C->>P3: Prepare
    
    P1-->>C: Yes (æº–å‚™å¥½)
    P2-->>C: Yes (æº–å‚™å¥½)
    P3-->>C: Yes (æº–å‚™å¥½)
    
    Note over C: æ‰€æœ‰åƒèˆ‡è€…éƒ½æº–å‚™å¥½<br/>æ±ºå®šæäº¤
    
    Note over C,P3: éšæ®µ 2: Commit
    C->>P1: Commit
    C->>P2: Commit
    C->>P3: Commit
    
    P1-->>C: å·²æäº¤
    P2-->>C: å·²æäº¤
    P3-->>C: å·²æäº¤
```

**å¤±æ•—å ´æ™¯**:

```mermaid
sequenceDiagram
    participant C as å”èª¿è€…
    participant P1 as åƒèˆ‡è€… 1
    participant P2 as åƒèˆ‡è€… 2
    participant P3 as åƒèˆ‡è€… 3
    
    Note over C,P3: éšæ®µ 1: Prepare
    C->>P1: Prepare
    C->>P2: Prepare
    C->>P3: Prepare
    
    P1-->>C: Yes
    P2-->>C: No (ç„¡æ³•æº–å‚™)
    P3-->>C: Yes
    
    Note over C: æœ‰åƒèˆ‡è€…ç„¡æ³•æº–å‚™<br/>æ±ºå®šå›æ»¾
    
    Note over C,P3: éšæ®µ 2: Abort
    C->>P1: Abort
    C->>P2: Abort
    C->>P3: Abort
```

**ğŸ’» å¯¦ä½œç¯„ä¾‹**:

```python
from enum import Enum

class Vote(Enum):
    YES = 1
    NO = 2

class Decision(Enum):
    COMMIT = 1
    ABORT = 2

class TwoPhaseCommitCoordinator:
    def __init__(self, participants):
        self.participants = participants
    
    def execute_transaction(self, transaction):
        """åŸ·è¡Œå…©éšæ®µæäº¤"""
        # éšæ®µ 1: Prepare
        votes = []
        for participant in self.participants:
            try:
                vote = participant.prepare(transaction)
                votes.append(vote)
            except Exception as e:
                print(f"åƒèˆ‡è€… {participant} æº–å‚™å¤±æ•—: {e}")
                votes.append(Vote.NO)
        
        # æ±ºç­–: æ‰€æœ‰åƒèˆ‡è€…éƒ½æŠ• Yes æ‰æäº¤
        decision = Decision.COMMIT if all(v == Vote.YES for v in votes) else Decision.ABORT
        
        # éšæ®µ 2: Commit æˆ– Abort
        for participant in self.participants:
            if decision == Decision.COMMIT:
                participant.commit(transaction)
            else:
                participant.abort(transaction)
        
        return decision

class Participant:
    def __init__(self, name):
        self.name = name
        self.prepared_transactions = {}
    
    def prepare(self, transaction):
        """æº–å‚™äº‹å‹™"""
        try:
            # æª¢æŸ¥æ˜¯å¦å¯ä»¥åŸ·è¡Œäº‹å‹™
            if self.can_execute(transaction):
                # é–ä½è³‡æº,å¯«å…¥ undo log
                self.prepared_transactions[transaction.id] = transaction
                return Vote.YES
            else:
                return Vote.NO
        except Exception:
            return Vote.NO
    
    def commit(self, transaction):
        """æäº¤äº‹å‹™"""
        # æ‡‰ç”¨è®Šæ›´,é‡‹æ”¾é–
        print(f"{self.name}: æäº¤äº‹å‹™ {transaction.id}")
        del self.prepared_transactions[transaction.id]
    
    def abort(self, transaction):
        """å›æ»¾äº‹å‹™"""
        # æ ¹æ“š undo log å›æ»¾,é‡‹æ”¾é–
        print(f"{self.name}: å›æ»¾äº‹å‹™ {transaction.id}")
        if transaction.id in self.prepared_transactions:
            del self.prepared_transactions[transaction.id]
    
    def can_execute(self, transaction):
        """æª¢æŸ¥æ˜¯å¦å¯ä»¥åŸ·è¡Œ"""
        # ç°¡åŒ–å¯¦ä½œ
        return True

# ä½¿ç”¨ç¯„ä¾‹
participants = [
    Participant("DB1"),
    Participant("DB2"),
    Participant("DB3")
]

coordinator = TwoPhaseCommitCoordinator(participants)

class Transaction:
    def __init__(self, txn_id):
        self.id = txn_id

txn = Transaction(txn_id=1)
decision = coordinator.execute_transaction(txn)
print(f"æœ€çµ‚æ±ºç­–: {decision}")
```

**âš ï¸ 2PC çš„å•é¡Œ**:

1. **é˜»å¡**: å”èª¿è€…æ•…éšœæ™‚,åƒèˆ‡è€…ç„¡é™ç­‰å¾…
2. **å–®é»æ•…éšœ**: å”èª¿è€…æ˜¯å–®é»
3. **æ€§èƒ½**: å…©è¼ªç¶²è·¯é€šä¿¡,å»¶é²é«˜

---

### ä¸‰éšæ®µæäº¤ (3PC)

**æ”¹é€²**: æ·»åŠ è¶…æ™‚æ©Ÿåˆ¶,é¿å…ç„¡é™é˜»å¡ã€‚

**æµç¨‹**:
1. **CanCommit**: è©¢å•æ˜¯å¦å¯ä»¥æäº¤
2. **PreCommit**: é€šçŸ¥åƒèˆ‡è€…æº–å‚™æäº¤
3. **DoCommit**: çœŸæ­£æäº¤

**ä½†ä»æœ‰å•é¡Œ**: ç¶²è·¯åˆ†å€æ™‚å¯èƒ½ç”¢ç”Ÿä¸ä¸€è‡´ã€‚

---

## ğŸŒ çœŸå¯¦ä¸–ç•Œæ¡ˆä¾‹

### æ¡ˆä¾‹ 1: Google Chubby (åŸºæ–¼ Paxos)

**ç”¨é€”**: åˆ†æ•£å¼é–æœå‹™

**æ¶æ§‹**:
- 5 å€‹å‰¯æœ¬ (å®¹å¿ 2 å€‹æ•…éšœ)
- ä½¿ç”¨ Multi-Paxos é¸èˆ‰ Master
- å®¢æˆ¶ç«¯åªèˆ‡ Master é€šä¿¡

**æ€§èƒ½**: è®€å–å»¶é² < 10ms,å¯«å…¥å»¶é² ~ 100ms

---

### æ¡ˆä¾‹ 2: etcd (åŸºæ–¼ Raft)

**ç”¨é€”**: Kubernetes çš„é…ç½®å­˜å„²

**ç‰¹æ€§**:
- å¼·ä¸€è‡´æ€§ (ç·šæ€§ä¸€è‡´æ€§)
- Watch API (ç›£è½éµè®Šæ›´)
- ç§Ÿç´„ (Lease) æ©Ÿåˆ¶

**ä½¿ç”¨ç¯„ä¾‹**:

```python
import etcd3

# é€£æ¥ etcd
client = etcd3.client(host='localhost', port=2379)

# ç·šæ€§ä¸€è‡´æ€§å¯«å…¥
client.put('config/database/host', 'localhost')

# è®€å–
value, metadata = client.get('config/database/host')
print(value.decode())

# Watch ç›£è½è®Šæ›´
watch_id = client.add_watch_callback('config/', lambda event: print(event))

# ç§Ÿç´„æ©Ÿåˆ¶ (ç”¨æ–¼æœå‹™ç™¼ç¾)
lease = client.lease(ttl=10)
client.put('services/api/instance1', 'http://api1:8080', lease=lease)
# 10 ç§’å¾Œè‡ªå‹•éæœŸ
```

---

### æ¡ˆä¾‹ 3: Spanner (å…¨çƒåˆ†æ•£å¼è³‡æ–™åº«)

**ç‰¹æ€§**:
- è·¨è³‡æ–™ä¸­å¿ƒçš„å¼·ä¸€è‡´æ€§
- å¤–éƒ¨ä¸€è‡´æ€§ (æ¯”ç·šæ€§ä¸€è‡´æ€§æ›´å¼·)
- åŸºæ–¼ TrueTime + Paxos

**æ ¸å¿ƒæŠ€è¡“**:
- **TrueTime API**: æä¾›æ™‚é–“å€é–“ [earliest, latest]
- **Commit Wait**: ç­‰å¾…æ™‚é–“å€é–“éå»å¾Œæ‰è¿”å›,ä¿è­‰å¤–éƒ¨ä¸€è‡´æ€§

```python
# å½ä»£ç¢¼: Spanner çš„ Commit Wait
def commit_transaction(txn):
    # ç²å–æäº¤æ™‚é–“æˆ³
    commit_timestamp = TrueTime.now().latest
    
    # ç­‰å¾…åˆ°è©²æ™‚é–“æˆ³ (ç¢ºä¿å…¶ä»–äººè®€åˆ°çš„æ™‚é–“ä¸æœƒæ—©æ–¼æ­¤)
    wait_until(TrueTime.now().earliest >= commit_timestamp)
    
    # è¿”å›æˆåŠŸ
    return commit_timestamp
```

---

## ğŸ¤” æ·±å…¥æ€è€ƒ

### ç·´ç¿’ 1: åˆ†æä¸€è‡´æ€§éœ€æ±‚

çµ¦å®šä»¥ä¸‹å ´æ™¯,é¸æ“‡åˆé©çš„ä¸€è‡´æ€§æ¨¡å‹:

**å ´æ™¯ A**: ç¤¾äº¤åª’é«”çš„è²¼æ–‡ç™¼å¸ƒ
- ç”¨æˆ¶ç™¼å¸ƒè²¼æ–‡å¾Œ,åˆ·æ–°é é¢æ‡‰è©²çœ‹åˆ°

**å ´æ™¯ B**: éŠ€è¡Œè½‰å¸³
- æ‰£æ¬¾å¾Œ,ç«‹å³æŸ¥è©¢é¤˜é¡æ‡‰è©²åæ˜ è®Šæ›´

**å ´æ™¯ C**: DNS æ›´æ–°
- æ›´æ–° DNS è¨˜éŒ„,å…è¨±ä¸€æ®µæ™‚é–“å¾Œç”Ÿæ•ˆ

<details>
<summary>ğŸ’¡ åƒè€ƒç­”æ¡ˆ</summary>

**å ´æ™¯ A: Read-Your-Writes ä¸€è‡´æ€§**
- ä¸éœ€è¦å…¨å±€ç·šæ€§ä¸€è‡´æ€§
- åªéœ€ä¿è­‰ç”¨æˆ¶è‡ªå·±èƒ½è®€åˆ°è‡ªå·±çš„å¯«å…¥

```python
class ReadYourWritesSession:
    def __init__(self, user_id):
        self.user_id = user_id
        self.last_write_version = None
    
    def write(self, post):
        version = db.write(post)
        self.last_write_version = version
    
    def read(self):
        # è®€å–æ™‚è¦æ±‚è‡³å°‘çœ‹åˆ°è‡ªå·±æœ€å¾Œçš„å¯«å…¥
        return db.read(min_version=self.last_write_version)
```

**å ´æ™¯ B: ç·šæ€§ä¸€è‡´æ€§**
- é‡‘èæ•¸æ“šè¦æ±‚å¼·ä¸€è‡´æ€§
- å¿…é ˆä½¿ç”¨ç·šæ€§ä¸€è‡´æ€§

```python
# ä½¿ç”¨æ”¯æŒç·šæ€§ä¸€è‡´æ€§çš„è³‡æ–™åº«
# å¦‚ etcd, Spanner, CockroachDB
```

**å ´æ™¯ C: æœ€çµ‚ä¸€è‡´æ€§**
- DNS æœ¬èº«è¨­è¨ˆç‚ºæœ€çµ‚ä¸€è‡´
- TTL æ©Ÿåˆ¶å…è¨±å»¶é²

```python
# DNS æ›´æ–°
update_dns_record('example.com', 'new-ip', ttl=3600)
# 1 å°æ™‚å…§é€æ¼¸ç”Ÿæ•ˆ
```

</details>

---

### ç·´ç¿’ 2: è¨­è¨ˆåˆ†æ•£å¼é–

**éœ€æ±‚**:
- äº’æ–¥: åŒæ™‚åªæœ‰ä¸€å€‹å®¢æˆ¶ç«¯æŒæœ‰é–
- æ­»é–è‡ªç”±: æŒé–è€…å´©æ½°å¾Œ,é–è‡ªå‹•é‡‹æ”¾
- å®¹éŒ¯: å®¹å¿ç¯€é»æ•…éšœ

**å˜—è©¦è¨­è¨ˆä¸€å€‹æ–¹æ¡ˆ**ã€‚

<details>
<summary>ğŸ’¡ åƒè€ƒç­”æ¡ˆ</summary>

**æ–¹æ¡ˆ: åŸºæ–¼ etcd çš„åˆ†æ•£å¼é– + Fencing Token**

```python
import etcd3
import time
import uuid

class DistributedLock:
    def __init__(self, etcd_client, lock_name, ttl=10):
        self.client = etcd_client
        self.lock_name = f"/locks/{lock_name}"
        self.ttl = ttl
        self.lease = None
        self.lock_id = None
    
    def acquire(self):
        """ç²å–é–"""
        # å‰µå»ºç§Ÿç´„
        self.lease = self.client.lease(ttl=self.ttl)
        self.lock_id = str(uuid.uuid4())
        
        # å˜—è©¦ç²å–é– (ä½¿ç”¨äº‹å‹™ä¿è­‰åŸå­æ€§)
        success, responses = self.client.transaction(
            compare=[
                # æª¢æŸ¥é–æ˜¯å¦å­˜åœ¨
                self.client.transactions.create(self.lock_name) == 0
            ],
            success=[
                # ä¸å­˜åœ¨å‰‡å‰µå»º
                self.client.transactions.put(
                    self.lock_name,
                    self.lock_id,
                    lease=self.lease
                )
            ],
            failure=[]
        )
        
        if success:
            # ç²å–é–çš„ç‰ˆæœ¬è™Ÿä½œç‚º Fencing Token
            _, metadata = self.client.get(self.lock_name)
            return metadata.mod_revision
        else:
            return None
    
    def release(self):
        """é‡‹æ”¾é–"""
        # åªé‡‹æ”¾è‡ªå·±æŒæœ‰çš„é–
        self.client.transaction(
            compare=[
                self.client.transactions.value(self.lock_name) == self.lock_id.encode()
            ],
            success=[
                self.client.transactions.delete(self.lock_name)
            ],
            failure=[]
        )
        
        # æ’¤éŠ·ç§Ÿç´„
        if self.lease:
            self.lease.revoke()
    
    def keep_alive(self):
        """ä¿æŒé–æ´»èº"""
        if self.lease:
            self.lease.refresh()

# ä½¿ç”¨ç¯„ä¾‹
client = etcd3.client()
lock = DistributedLock(client, "my-resource")

token = lock.acquire()
if token:
    try:
        print(f"ç²å–é–æˆåŠŸ,ä»¤ç‰Œ: {token}")
        
        # åŸ·è¡Œé—œéµæ“ä½œ (å‚³éä»¤ç‰Œ)
        perform_critical_operation(token=token)
        
    finally:
        lock.release()
else:
    print("ç²å–é–å¤±æ•—")
```

**ç‰¹æ€§**:
- âœ… äº’æ–¥: etcd äº‹å‹™ä¿è­‰
- âœ… æ­»é–è‡ªç”±: ç§Ÿç´„è‡ªå‹•éæœŸ
- âœ… å®¹éŒ¯: etcd ä½¿ç”¨ Raft ä¿è­‰é«˜å¯ç”¨
- âœ… Fencing: ä½¿ç”¨ç‰ˆæœ¬è™Ÿé˜²æ­¢éæœŸé–

</details>

---

## ğŸ“š ç¸½çµ

### æ ¸å¿ƒè¦é»

```mermaid
graph TD
    A["ä¸€è‡´æ€§èˆ‡å…±è­˜"] --> B["ä¸€è‡´æ€§æ¨¡å‹"]
    A --> C["å…±è­˜ç®—æ³•"]
    A --> D["åŸå­æäº¤"]
    
    B --> B1["ç·šæ€§ä¸€è‡´æ€§: æœ€å¼·"]
    B --> B2["å› æœä¸€è‡´æ€§: å¹³è¡¡"]
    B --> B3["æœ€çµ‚ä¸€è‡´æ€§: æœ€å¼±"]
    
    C --> C1["Raft: æ˜“ç†è§£"]
    C --> C2["Paxos: ç¶“å…¸"]
    
    D --> D1["2PC: é˜»å¡"]
    D --> D2["3PC: æ”¹é€²ä½†ä»æœ‰å•é¡Œ"]
```

### é¸æ“‡æŒ‡å—

| å¦‚æœä½ éœ€è¦... | é¸æ“‡... |
|---------------|---------|
| å¼·ä¸€è‡´æ€§ + é«˜å¯ç”¨ | Raft/Paxos + å¤šæ•¸æ´¾ |
| å…¨çƒåˆ†ä½ˆ + å¼·ä¸€è‡´ | Spanner (TrueTime) |
| ä½å»¶é² + é«˜å¯ç”¨ | æœ€çµ‚ä¸€è‡´æ€§ (Dynamo é¢¨æ ¼) |
| åˆ†æ•£å¼é– | etcd (Raft) æˆ– Chubby (Paxos) |
| åˆ†æ•£å¼äº‹å‹™ | é¿å…æˆ–ä½¿ç”¨ Saga æ¨¡å¼ |

---

## ğŸ”— åƒè€ƒè³‡æ–™

1. **æ›¸ç±**:
   - Martin Kleppmann, *Designing Data-Intensive Applications*, Chapter 9
   - Diego Ongaro, *In Search of an Understandable Consensus Algorithm (Raft)*

2. **è«–æ–‡**:
   - [Paxos Made Simple](https://lamport.azurewebsites.net/pubs/paxos-simple.pdf)
   - [The Raft Consensus Algorithm](https://raft.github.io/raft.pdf)
   - [Spanner: Google's Globally-Distributed Database](https://research.google/pubs/pub39966/)

3. **æŠ€è¡“æ–‡ä»¶**:
   - [etcd Documentation](https://etcd.io/docs/)
   - [Consul Consensus Protocol](https://www.consul.io/docs/architecture/consensus)

4. **å¯è¦–åŒ–å·¥å…·**:
   - [Raft Visualization](http://thesecretlivesofdata.com/raft/)
   - [Paxos Visualization](https://harry.me/blog/2014/12/27/neat-algorithms-paxos/)

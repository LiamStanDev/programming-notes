# 07 - åˆ†æ•£å¼ç³»çµ±çš„å›°å¢ƒ (The Trouble with Distributed Systems)

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å¾Œ,ä½ å°‡èƒ½å¤ :
- ç†è§£åˆ†æ•£å¼ç³»çµ±ä¸­çš„æ ¹æœ¬æ€§æŒ‘æˆ°
- èªè­˜ç¶²è·¯ã€æ™‚é˜ã€é€²ç¨‹æ•…éšœçš„å½±éŸ¿
- æŒæ¡è¨­è¨ˆå®¹éŒ¯ç³»çµ±çš„åŸºæœ¬åŸå‰‡
- ç†è§£ç‚ºä»€éº¼åˆ†æ•£å¼ç³»çµ±æ¯”å–®æ©Ÿç³»çµ±å›°é›£å¾—å¤š

---

## ğŸ’¡ æ ¸å¿ƒæ¦‚å¿µ

### åˆ†æ•£å¼ç³»çµ±çš„æ ¹æœ¬å•é¡Œ

**Murphy å®šå¾‹åœ¨åˆ†æ•£å¼ç³»çµ±ä¸­çš„é«”ç¾**: ä»»ä½•å¯èƒ½å‡ºéŒ¯çš„äº‹æƒ…,éƒ½æœƒå‡ºéŒ¯ã€‚

```mermaid
graph TD
    A["åˆ†æ•£å¼ç³»çµ±çš„ä¸‰å¤§å›°å¢ƒ"] --> B["ç¶²è·¯ä¸å¯é <br/>Network Unreliability"]
    A --> C["æ™‚é˜ä¸å¯ä¿¡<br/>Clock Unreliability"]
    A --> D["é€²ç¨‹æœƒæ•…éšœ<br/>Process Failures"]
    
    B --> B1["å»¶é²ã€ä¸ŸåŒ…ã€äº‚åº"]
    C --> C1["æ™‚é˜æ¼‚ç§»ã€è·³èº"]
    D --> D1["å´©æ½°ã€æš«åœã€æ‹œå åº­æ•…éšœ"]
```

**ç‚ºä»€éº¼è¦ä½¿ç”¨åˆ†æ•£å¼ç³»çµ±?**

| åŸå›  | èªªæ˜ |
|------|------|
| **æ“´å±•æ€§** | å–®æ©Ÿå®¹é‡æœ‰é™ |
| **å®¹éŒ¯æ€§** | å–®é»æ•…éšœé¢¨éšª |
| **ä½å»¶é²** | åœ°ç†åˆ†å¸ƒçš„ä½¿ç”¨è€… |
| **æˆæœ¬** | å•†ç”¨ç¡¬é«”æ¯”å¤§å‹æ©Ÿä¾¿å®œ |

**ä½†æ˜¯**: åˆ†æ•£å¼ç³»çµ±é æ¯”å–®æ©Ÿç³»çµ±è¤‡é›œ,å¿…é ˆæ‡‰å°å„ç¨®ä¸ç¢ºå®šæ€§ã€‚

---

## ğŸŒ ç¶²è·¯ä¸å¯é 

### å¸¸è¦‹ç¶²è·¯å•é¡Œ

```mermaid
sequenceDiagram
    participant A as ç¯€é» A
    participant N as ç¶²è·¯
    participant B as ç¯€é» B
    
    Note over A,B: æƒ…æ³ 1: è«‹æ±‚ä¸Ÿå¤±
    A->>N: ç™¼é€è«‹æ±‚
    N-xB: âŒ ä¸ŸåŒ…
    Note over A: æ°¸é ç­‰ä¸åˆ°å›æ‡‰
    
    Note over A,B: æƒ…æ³ 2: è«‹æ±‚å»¶é²
    A->>N: ç™¼é€è«‹æ±‚
    Note over N: å»¶é² 30 ç§’
    N->>B: åˆ°é” (ä½† A å·²è¶…æ™‚)
    
    Note over A,B: æƒ…æ³ 3: å›æ‡‰ä¸Ÿå¤±
    A->>B: ç™¼é€è«‹æ±‚
    B->>N: ç™¼é€å›æ‡‰
    N-xA: âŒ ä¸ŸåŒ…
    Note over A: ä¸çŸ¥é“ B å·²è™•ç†
    
    Note over A,B: æƒ…æ³ 4: ç¯€é»æ•…éšœ
    A->>B: ç™¼é€è«‹æ±‚
    Note over B: âŒ ç¯€é»å´©æ½°
    Note over A: ç„¡æ³•å€åˆ†æ˜¯ç¶²è·¯å•é¡Œ<br/>é‚„æ˜¯ç¯€é»æ•…éšœ
```

### çœŸå¯¦ä¸–ç•Œçš„ç¶²è·¯æ•…éšœ

**ğŸ¢ æ¡ˆä¾‹ 1: GitHub 2012 ç¶²è·¯åˆ†å€**

- **äº‹ä»¶**: è³‡æ–™ä¸­å¿ƒé–“çš„ç¶²è·¯é€£æ¥æ•…éšœ
- **æŒçºŒæ™‚é–“**: ç´„ 1 å°æ™‚
- **å½±éŸ¿**: ä¸»å¾è³‡æ–™åº«ç„¡æ³•åŒæ­¥,å°è‡´è…¦è£‚ (Split-brain)
- **å¾Œæœ**: éƒ¨åˆ†å¯«å…¥ä¸Ÿå¤±,éœ€æ‰‹å‹•ä¿®å¾©

**ğŸ¢ æ¡ˆä¾‹ 2: Amazon S3 2017 æ•…éšœ**

- **äº‹ä»¶**: å…§éƒ¨ç¶²è·¯é…ç½®éŒ¯èª¤
- **æŒçºŒæ™‚é–“**: 4 å°æ™‚
- **å½±éŸ¿**: å¤§é‡ä¾è³´ S3 çš„æœå‹™ä¸­æ–·
- **æ•™è¨“**: å³ä½¿æ˜¯é›²æœå‹™å•†,ç¶²è·¯ä¹Ÿæœƒå‡ºå•é¡Œ

### è¶…æ™‚èˆ‡é‡è©¦

**å•é¡Œ**: å¦‚ä½•åˆ¤æ–·è«‹æ±‚å¤±æ•—?

```python
import time
import random

def send_request(node, request, timeout=5.0):
    """ç™¼é€è«‹æ±‚,å¸¶è¶…æ™‚æ©Ÿåˆ¶"""
    start = time.time()
    
    try:
        response = node.send(request, timeout=timeout)
        return response
    except TimeoutError:
        # è¶…æ™‚äº†,ä½†ä¸çŸ¥é“ç™¼ç”Ÿäº†ä»€éº¼:
        # 1. è«‹æ±‚ä¸Ÿå¤±?
        # 2. ç¯€é»æ•…éšœ?
        # 3. è«‹æ±‚æ­£åœ¨è™•ç†,ä½†å¾ˆæ…¢?
        # 4. å›æ‡‰ä¸Ÿå¤±?
        
        elapsed = time.time() - start
        print(f"è«‹æ±‚è¶…æ™‚ (ç­‰å¾… {elapsed:.2f} ç§’)")
        
        # âš ï¸ ç„¡æ³•åˆ¤æ–·æ˜¯å¦æ‡‰è©²é‡è©¦
        raise

# ä½¿ç”¨ç¯„ä¾‹
try:
    response = send_request(node_b, {"action": "transfer", "amount": 100})
except TimeoutError:
    # æ‡‰è©²é‡è©¦å—?
    # - å¦‚æœè«‹æ±‚å·²åŸ·è¡Œ,é‡è©¦æœƒå°è‡´é‡è¤‡æ“ä½œ (è½‰å¸³å…©æ¬¡!)
    # - å¦‚æœè«‹æ±‚æœªåŸ·è¡Œ,ä¸é‡è©¦æœƒå°è‡´æ“ä½œå¤±æ•—
    pass
```

**è¶…æ™‚æ™‚é–“çš„é¸æ“‡**:

```mermaid
graph LR
    A["è¶…æ™‚æ™‚é–“"] --> B["éçŸ­"]
    A --> C["é©ä¸­"]
    A --> D["éé•·"]
    
    B --> B1["èª¤åˆ¤: ç¯€é»æ­£å¸¸ä½†è¢«æ¨™è¨˜ç‚ºæ•…éšœ"]
    C --> C1["å¹³è¡¡: å¿«é€Ÿæª¢æ¸¬çœŸå¯¦æ•…éšœ"]
    D --> D1["å»¶é²: æ•…éšœæª¢æ¸¬å¤ªæ…¢"]
```

**ğŸ’» è‡ªé©æ‡‰è¶…æ™‚å¯¦ä½œ**:

```python
import time
from collections import deque

class AdaptiveTimeout:
    def __init__(self, initial_timeout=1.0, window_size=100):
        self.timeout = initial_timeout
        self.response_times = deque(maxlen=window_size)
    
    def record_response_time(self, response_time):
        """è¨˜éŒ„å›æ‡‰æ™‚é–“"""
        self.response_times.append(response_time)
        
        # æ›´æ–°è¶…æ™‚: å¹³å‡å€¼ + 2 * æ¨™æº–å·®
        if len(self.response_times) >= 10:
            avg = sum(self.response_times) / len(self.response_times)
            variance = sum((x - avg) ** 2 for x in self.response_times) / len(self.response_times)
            stddev = variance ** 0.5
            
            self.timeout = avg + 2 * stddev
    
    def get_timeout(self):
        return self.timeout

# ä½¿ç”¨ç¯„ä¾‹
timeout_manager = AdaptiveTimeout()

for _ in range(1000):
    start = time.time()
    try:
        response = send_request(node, request, timeout=timeout_manager.get_timeout())
        elapsed = time.time() - start
        timeout_manager.record_response_time(elapsed)
    except TimeoutError:
        # è¶…æ™‚,ä¸æ›´æ–°çµ±è¨ˆ
        pass
```

---

### å†ªç­‰æ€§ (Idempotence)

**å®šç¾©**: å¤šæ¬¡åŸ·è¡Œç›¸åŒæ“ä½œ,çµæœèˆ‡åŸ·è¡Œä¸€æ¬¡ç›¸åŒã€‚

**ç‚ºä»€éº¼é‡è¦**: ç¶²è·¯ä¸å¯é æ™‚,å®¢æˆ¶ç«¯å¯èƒ½é‡è©¦,å¿…é ˆä¿è­‰é‡è¤‡è«‹æ±‚çš„å®‰å…¨æ€§ã€‚

**ğŸ’» å†ªç­‰æ“ä½œç¯„ä¾‹**:

```python
# âœ… å†ªç­‰: è¨­ç½®å€¼
def set_user_email(user_id, email):
    db.execute("UPDATE users SET email = ? WHERE id = ?", (email, user_id))
    # åŸ·è¡Œ 1 æ¬¡æˆ– 10 æ¬¡,çµæœç›¸åŒ

# âœ… å†ªç­‰: åˆªé™¤
def delete_user(user_id):
    db.execute("DELETE FROM users WHERE id = ?", (user_id,))
    # é‡è¤‡åˆªé™¤ä¸å½±éŸ¿çµæœ

# âŒ éå†ªç­‰: å¢åŠ å€¼
def increment_counter(key):
    value = db.get(key)
    db.set(key, value + 1)
    # åŸ·è¡Œ 2 æ¬¡æœƒå¢åŠ  2,è€Œä¸æ˜¯ 1

# âœ… æ”¹é€²: ä½¿ç”¨å†ªç­‰éµ
def increment_counter_idempotent(key, request_id):
    # æª¢æŸ¥è«‹æ±‚æ˜¯å¦å·²è™•ç†
    if db.exists(f"processed:{request_id}"):
        return  # å·²è™•ç†,è·³é
    
    value = db.get(key)
    db.set(key, value + 1)
    db.set(f"processed:{request_id}", "1", ex=3600)  # æ¨™è¨˜å·²è™•ç†,1 å°æ™‚éæœŸ
```

**HTTP API çš„å†ªç­‰æ€§è¨­è¨ˆ**:

| HTTP æ–¹æ³• | å†ªç­‰æ€§ | ç¯„ä¾‹ |
|-----------|--------|------|
| GET | âœ… æ˜¯ | æŸ¥è©¢è³‡æ–™ |
| PUT | âœ… æ˜¯ | æ›´æ–°æ•´å€‹è³‡æº |
| DELETE | âœ… æ˜¯ | åˆªé™¤è³‡æº |
| POST | âŒ å¦* | å‰µå»ºè³‡æºã€æäº¤è¡¨å–® |
| PATCH | âŒ å¦* | éƒ¨åˆ†æ›´æ–° |

*å¯é€šéè¨­è¨ˆå¯¦ç¾å†ªç­‰æ€§

**POST å†ªç­‰æ€§è¨­è¨ˆ**:

```python
from flask import Flask, request
import uuid

app = Flask(__name__)
processed_requests = set()

@app.route('/transfer', methods=['POST'])
def transfer():
    # å®¢æˆ¶ç«¯ç”Ÿæˆå”¯ä¸€è«‹æ±‚ ID
    request_id = request.headers.get('X-Request-ID')
    
    if not request_id:
        return {"error": "ç¼ºå°‘ X-Request-ID"}, 400
    
    # æª¢æŸ¥æ˜¯å¦å·²è™•ç†
    if request_id in processed_requests:
        return {"status": "å·²è™•ç† (å†ªç­‰)"}
    
    # è™•ç†è½‰å¸³
    amount = request.json['amount']
    from_account = request.json['from']
    to_account = request.json['to']
    
    perform_transfer(from_account, to_account, amount)
    
    # è¨˜éŒ„å·²è™•ç†
    processed_requests.add(request_id)
    
    return {"status": "æˆåŠŸ"}

# å®¢æˆ¶ç«¯ä½¿ç”¨
import requests

request_id = str(uuid.uuid4())

# å¯å®‰å…¨é‡è©¦
for attempt in range(3):
    try:
        response = requests.post(
            'http://api.example.com/transfer',
            json={"from": "Alice", "to": "Bob", "amount": 100},
            headers={"X-Request-ID": request_id},
            timeout=5
        )
        break
    except requests.Timeout:
        print(f"é‡è©¦ç¬¬ {attempt + 1} æ¬¡")
```

---

## ğŸ•°ï¸ æ™‚é˜ä¸å¯ä¿¡

### å…©ç¨®æ™‚é˜

```mermaid
graph TD
    A["è¨ˆç®—æ©Ÿæ™‚é˜"] --> B["Time-of-Day Clock<br/>ç‰†ä¸Šæ™‚é˜"]
    A --> C["Monotonic Clock<br/>å–®èª¿æ™‚é˜"]
    
    B --> B1["ç”¨é€”: é¡¯ç¤ºæ™‚é–“æˆ³"]
    B --> B2["å•é¡Œ: å¯èƒ½è·³èº (NTP åŒæ­¥)"]
    
    C --> C1["ç”¨é€”: æ¸¬é‡æ™‚é–“é–“éš”"]
    C --> C2["ç‰¹æ€§: ä¿è­‰å–®èª¿éå¢"]
```

### Time-of-Day Clock (ç‰†ä¸Šæ™‚é˜)

**ç‰¹æ€§**: è¿”å›ç•¶å‰æ—¥æœŸæ™‚é–“,å¯ä»¥èˆ‡ NTP åŒæ­¥ã€‚

**å•é¡Œ 1: æ™‚é˜è·³èº**

```python
import time

# æ¸¬é‡æ“ä½œè€—æ™‚ (éŒ¯èª¤ç”¨æ³•)
start = time.time()  # ä½¿ç”¨ time-of-day clock
do_something()
end = time.time()
elapsed = end - start

# âš ï¸ å•é¡Œ: å¦‚æœä¸­é–“ç™¼ç”Ÿ NTP åŒæ­¥,elapsed å¯èƒ½æ˜¯è² æ•¸æˆ–ç•°å¸¸å¤§!

# ç¯„ä¾‹: NTP åŒæ­¥å°è‡´æ™‚é–“å›æ’¥
# start = 1609459200.5  (2021-01-01 00:00:00.5)
# [NTP åŒæ­¥: æ™‚é˜å›æ’¥ 1 ç§’]
# end = 1609459199.8    (2020-12-31 23:59:59.8)
# elapsed = -0.7 ç§’ (è² æ•¸!)
```

**æ­£ç¢ºåšæ³•: ä½¿ç”¨ Monotonic Clock**

```python
import time

# âœ… æ­£ç¢º: ä½¿ç”¨å–®èª¿æ™‚é˜
start = time.monotonic()  # å–®èª¿æ™‚é˜,ä¸å— NTP å½±éŸ¿
do_something()
end = time.monotonic()
elapsed = end - start  # ä¿è­‰éè² 
```

---

### å•é¡Œ 2: æ™‚é˜åç§» (Clock Skew)

**å®šç¾©**: ä¸åŒæ©Ÿå™¨çš„æ™‚é˜ä¸ä¸€è‡´ã€‚

```mermaid
sequenceDiagram
    participant A as ç¯€é» A (æ™‚é˜: 10:00:00)
    participant B as ç¯€é» B (æ™‚é˜: 10:00:05)
    
    Note over A: å¯«å…¥äº‹ä»¶<br/>æ™‚é–“æˆ³: 10:00:00
    A->>B: ç™¼é€äº‹ä»¶
    
    Note over B: æ”¶åˆ°äº‹ä»¶<br/>æœ¬åœ°æ™‚é˜: 10:00:05
    Note over B: âŒ äº‹ä»¶çœ‹èµ·ä¾†ä¾†è‡ª 5 ç§’å‰
```

**å¯¦éš›å½±éŸ¿ç¯„ä¾‹**:

```python
# Last-Write-Wins (LWW) ç­–ç•¥
class LWWRegister:
    def __init__(self):
        self.value = None
        self.timestamp = 0
    
    def write(self, value, timestamp):
        # åªä¿ç•™æ™‚é–“æˆ³æœ€å¤§çš„å¯«å…¥
        if timestamp > self.timestamp:
            self.value = value
            self.timestamp = timestamp

# ç¯€é» A (æ™‚é˜æ…¢ 5 ç§’)
register_a = LWWRegister()
register_a.write("A", timestamp=100)  # å¯¦éš›æ‡‰è©²æ˜¯ 105

# ç¯€é» B (æ™‚é˜æº–ç¢º)
register_b = LWWRegister()
register_b.write("B", timestamp=103)

# åˆä½µæ™‚
register_a.merge(register_b)
print(register_a.value)  # "B" (æ­£ç¢º)

# ä½†å¦‚æœ A çš„æ™‚é˜å¿« 5 ç§’:
register_a.write("A", timestamp=110)  # å¯¦éš›æ‡‰è©²æ˜¯ 103
register_a.merge(register_b)
print(register_a.value)  # "A" (éŒ¯èª¤! æ‡‰è©²æ˜¯ B)
```

**ğŸ¢ çœŸå¯¦æ¡ˆä¾‹: Amazon çš„ NTP æ•…éšœ**

- **äº‹ä»¶**: DynamoDB æŸäº›ç¯€é»çš„ NTP åŒæ­¥å¤±æ•—
- **å½±éŸ¿**: æ™‚é˜åç§»å°è‡´æ•¸æ“šç‰ˆæœ¬åˆ¤æ–·éŒ¯èª¤
- **æ•™è¨“**: ä¸èƒ½å®Œå…¨ä¿¡ä»»æ™‚é–“æˆ³é€²è¡Œç‰ˆæœ¬æ§åˆ¶

---

### æ™‚é˜åŒæ­¥: NTP

**NTP (Network Time Protocol)** é€šéç¶²è·¯åŒæ­¥æ™‚é˜ã€‚

```mermaid
graph LR
    A["æœ¬åœ°æ™‚é˜<br/>10:00:00"] -->|1. ç™¼é€æ™‚é–“æˆ³| B["NTP ä¼ºæœå™¨<br/>10:00:10"]
    B -->|2. è¿”å›æ­£ç¢ºæ™‚é–“| A
    A -->|3. èª¿æ•´æ™‚é˜| C["æœ¬åœ°æ™‚é˜<br/>10:00:10"]
```

**å•é¡Œ**:

1. **ç¶²è·¯å»¶é²**: NTP ä¼ºæœå™¨çš„æ™‚é–“åˆ°é”éœ€è¦æ™‚é–“,ç²¾åº¦å—é™
2. **æ™‚é˜è·³èº**: å¦‚æœåç§»è¼ƒå¤§,æ™‚é˜æœƒçªç„¶è·³èº
3. **NTP ä¼ºæœå™¨æ•…éšœ**: å¦‚æœç„¡æ³•é€£æ¥,æ™‚é˜é€æ¼¸æ¼‚ç§»

**ç²¾åº¦ç¯„åœ**:

| æ¢ä»¶ | ç²¾åº¦ |
|------|------|
| æœ¬åœ°ç¶²è·¯ NTP ä¼ºæœå™¨ | Â±1-10 æ¯«ç§’ |
| å…¬ç¶² NTP ä¼ºæœå™¨ | Â±10-100 æ¯«ç§’ |
| ç„¡ NTP åŒæ­¥ | æ¯å¤©æ¼‚ç§» Â±å¹¾ç§’ |
| ç¡¬é«”æ™‚é˜ (GPS/åŸå­é˜) | Â±å¾®ç§’ç´š |

**Google Spanner çš„ TrueTime API**:

```python
# TrueTime è¿”å›æ™‚é–“å€é–“ [earliest, latest]
tt = TrueTime.now()
print(f"ç•¶å‰æ™‚é–“: {tt.earliest} - {tt.latest}")
# è¼¸å‡º: ç•¶å‰æ™‚é–“: 1609459200.000 - 1609459200.007

# ä¿è­‰: å¯¦éš›æ™‚é–“ä¸€å®šåœ¨é€™å€‹å€é–“å…§
# Google ä½¿ç”¨ GPS å’ŒåŸå­é˜å°‡èª¤å·®æ§åˆ¶åœ¨ 7ms ä»¥å…§
```

---

### ä¾è³´æ™‚é˜çš„å±éšª

**æ¡ˆä¾‹: ä½¿ç”¨æ™‚é–“æˆ³ä½œç‚ºéµ**

```python
# âŒ å±éšª: ä½¿ç”¨æ™‚é–“æˆ³ä½œç‚ºå”¯ä¸€éµ
def generate_order_id():
    return int(time.time() * 1000000)  # å¾®ç§’æ™‚é–“æˆ³

# å•é¡Œ 1: æ™‚é˜å›æ’¥å¯èƒ½ç”¢ç”Ÿé‡è¤‡ ID
order1 = generate_order_id()  # 1609459200000000
# [NTP åŒæ­¥,æ™‚é˜å›æ’¥]
order2 = generate_order_id()  # 1609459199000000 (æ›´å°!)

# å•é¡Œ 2: ä¸åŒç¯€é»çš„æ™‚é˜åç§»å¯èƒ½ç”¢ç”Ÿäº‚åº ID
# ç¯€é» A (æ™‚é˜å¿«): 1609459205000000
# ç¯€é» B (æ™‚é˜æ…¢): 1609459200000000
```

**âœ… æ›´å¥½çš„æ–¹æ¡ˆ: æ··åˆæ™‚é˜ (Hybrid Logical Clock)**

```python
class HybridLogicalClock:
    def __init__(self, node_id):
        self.node_id = node_id
        self.logical_time = 0
        self.last_physical_time = 0
    
    def now(self):
        """ç”Ÿæˆæ··åˆé‚è¼¯æ™‚é˜æ™‚é–“æˆ³"""
        physical_time = int(time.time() * 1000)  # æ¯«ç§’
        
        # å¦‚æœç‰©ç†æ™‚é˜å‰é€²,é‡ç½®é‚è¼¯æ™‚é˜
        if physical_time > self.last_physical_time:
            self.last_physical_time = physical_time
            self.logical_time = 0
        else:
            # ç‰©ç†æ™‚é˜æœªå‰é€²(æˆ–å›æ’¥),é‚è¼¯æ™‚é˜éå¢
            self.logical_time += 1
        
        # è¿”å› (ç‰©ç†æ™‚é–“, é‚è¼¯è¨ˆæ•¸, ç¯€é» ID)
        return (self.last_physical_time, self.logical_time, self.node_id)
    
    def update(self, remote_timestamp):
        """æ¥æ”¶é ç¨‹æ™‚é–“æˆ³,æ›´æ–°æœ¬åœ°æ™‚é˜"""
        remote_physical, remote_logical, _ = remote_timestamp
        local_physical = int(time.time() * 1000)
        
        # å–æœ€å¤§çš„ç‰©ç†æ™‚é–“
        self.last_physical_time = max(local_physical, remote_physical, self.last_physical_time)
        
        # å¦‚æœç‰©ç†æ™‚é–“ç›¸åŒ,å–æœ€å¤§é‚è¼¯æ™‚é–“ + 1
        if self.last_physical_time == remote_physical:
            self.logical_time = max(self.logical_time, remote_logical) + 1
        else:
            self.logical_time = 0

# ä½¿ç”¨ç¯„ä¾‹
clock_a = HybridLogicalClock(node_id="A")
clock_b = HybridLogicalClock(node_id="B")

# ç¯€é» A ç”Ÿæˆæ™‚é–“æˆ³
ts_a = clock_a.now()  # (1609459200000, 0, "A")

# ç¯€é» B æ”¶åˆ°äº‹ä»¶,æ›´æ–°æ™‚é˜
clock_b.update(ts_a)
ts_b = clock_b.now()  # (1609459200000, 1, "B")

# ä¿è­‰: ts_b > ts_a (å³ä½¿ç‰©ç†æ™‚é˜ç›¸åŒ)
```

---

## ğŸ’£ é€²ç¨‹æœƒæ•…éšœ

### é€²ç¨‹æš«åœçš„åŸå› 

```mermaid
graph TD
    A["é€²ç¨‹å¯èƒ½æš«åœ"] --> B["åƒåœ¾å›æ”¶ (GC)<br/>å¯èƒ½æš«åœæ•¸ç§’"]
    A --> C["è™›æ“¬æ©Ÿæš«åœ<br/>live migration"]
    A --> D["æ“ä½œç³»çµ±æ›é <br/>swap to disk"]
    A --> E["SIGSTOP ä¿¡è™Ÿ<br/>é€²ç¨‹è¢«æš«åœ"]
    A --> F["ç­†è¨˜æœ¬åˆè“‹<br/>é€²ç¨‹å‡çµ"]
```

**å•é¡Œ**: é€²ç¨‹ç„¡æ³•æ„ŸçŸ¥è‡ªå·±è¢«æš«åœäº†å¤šä¹…ã€‚

### å±éšªçš„å‡è¨­

**éŒ¯èª¤å‡è¨­: ç¨‹å¼æœƒé€£çºŒåŸ·è¡Œ**

```python
import time

def unsafe_lease_checker():
    """âŒ ä¸å®‰å…¨çš„ç§Ÿç´„æª¢æŸ¥"""
    lease_expiry = time.time() + 10  # 10 ç§’ç§Ÿç´„
    
    # åŸ·è¡Œé—œéµæ“ä½œ
    while time.time() < lease_expiry:
        perform_critical_operation()
        time.sleep(1)
    
    # âš ï¸ å•é¡Œ: å¦‚æœ GC æš«åœäº† 15 ç§’,
    # é€²ç¨‹æœƒåœ¨ç§Ÿç´„éæœŸå¾Œç¹¼çºŒåŸ·è¡Œ!

# æ™‚é–“ç·š:
# t=0: ç²å–ç§Ÿç´„,åˆ° t=10 éæœŸ
# t=1: perform_critical_operation()
# t=2: [GC é–‹å§‹,æš«åœ 15 ç§’]
# t=17: [GC çµæŸ,æ¢å¾©åŸ·è¡Œ]
# t=17: while æ¢ä»¶åˆ¤æ–· (17 < 10? False) â† ä½†å·²ç¶“åŸ·è¡Œäº† 16 ç§’!
```

**ç¾å¯¦å ´æ™¯**:

```mermaid
sequenceDiagram
    participant L as Leader (æŒæœ‰é–)
    participant S as å­˜å„²
    participant F as Follower
    
    Note over L: æŒæœ‰é–,æœ‰æ•ˆæœŸ 10 ç§’
    L->>S: å¯«å…¥è³‡æ–™
    
    Note over L: [GC æš«åœ 15 ç§’]
    
    Note over S: é–éæœŸ,åˆ†é…çµ¦ Follower
    F->>S: ç²å–é–
    F->>S: å¯«å…¥è³‡æ–™
    
    Note over L: [GC æ¢å¾©]
    L->>S: ç¹¼çºŒå¯«å…¥è³‡æ–™
    
    Note over S: âŒ å…©å€‹ç¯€é»åŒæ™‚å¯«å…¥!
```

---

### è§£æ±ºæ–¹æ¡ˆ: Fencing Token

**è¨­è¨ˆ**: ä½¿ç”¨éå¢çš„ä»¤ç‰Œ (Token) ä¿è­·è³‡æºã€‚

```mermaid
sequenceDiagram
    participant C1 as å®¢æˆ¶ç«¯ 1
    participant Lock as é–æœå‹™
    participant S as å­˜å„²
    participant C2 as å®¢æˆ¶ç«¯ 2
    
    C1->>Lock: ç²å–é–
    Lock-->>C1: æˆåŠŸ,ä»¤ç‰Œ=33
    
    C1->>S: å¯«å…¥ (ä»¤ç‰Œ=33)
    S-->>C1: æˆåŠŸ (è¨˜éŒ„ max_token=33)
    
    Note over C1: [GC æš«åœ]
    
    Note over Lock: é–éæœŸ
    
    C2->>Lock: ç²å–é–
    Lock-->>C2: æˆåŠŸ,ä»¤ç‰Œ=34
    
    C2->>S: å¯«å…¥ (ä»¤ç‰Œ=34)
    S-->>C2: æˆåŠŸ (è¨˜éŒ„ max_token=34)
    
    Note over C1: [GC æ¢å¾©]
    
    C1->>S: å¯«å…¥ (ä»¤ç‰Œ=33)
    S-->>C1: âŒ æ‹’çµ• (33 < 34)
```

**ğŸ’» å¯¦ä½œç¯„ä¾‹**:

```python
class FencedStorage:
    def __init__(self):
        self.data = {}
        self.max_token = 0
    
    def write(self, key, value, token):
        """å¯«å…¥è³‡æ–™,æª¢æŸ¥ä»¤ç‰Œ"""
        if token < self.max_token:
            raise ValueError(f"ä»¤ç‰ŒéæœŸ: {token} < {self.max_token}")
        
        self.max_token = token
        self.data[key] = value
        return True

class LockService:
    def __init__(self):
        self.token_counter = 0
        self.lock_holder = None
    
    def acquire_lock(self, client_id):
        """ç²å–é–,è¿”å›éå¢ä»¤ç‰Œ"""
        if self.lock_holder is not None:
            return None
        
        self.token_counter += 1
        self.lock_holder = client_id
        return self.token_counter

# ä½¿ç”¨ç¯„ä¾‹
storage = FencedStorage()
lock_service = LockService()

# å®¢æˆ¶ç«¯ 1
token1 = lock_service.acquire_lock("client1")  # token=1
storage.write("key", "value1", token1)  # æˆåŠŸ

# å®¢æˆ¶ç«¯ 2 (åœ¨å®¢æˆ¶ç«¯ 1 æš«åœå¾Œç²å–é–)
token2 = lock_service.acquire_lock("client2")  # token=2
storage.write("key", "value2", token2)  # æˆåŠŸ

# å®¢æˆ¶ç«¯ 1 æ¢å¾© (ä½¿ç”¨èˆŠä»¤ç‰Œ)
try:
    storage.write("key", "value1", token1)  # token=1
except ValueError:
    print("ä»¤ç‰ŒéæœŸ,å¯«å…¥è¢«æ‹’çµ•")  # âœ… å®‰å…¨!
```

---

## ğŸ¯ çœŸå¯¦ä¸–ç•Œæ¡ˆä¾‹

### æ¡ˆä¾‹ 1: AWS DynamoDB çš„ 2015 æ•…éšœ

**äº‹ä»¶**: é¬§é˜ç³»çµ±è»Ÿé«” bug å°è‡´æ™‚é˜è·³èº

**å½±éŸ¿**:
- ç§Ÿç´„éæœŸåˆ¤æ–·éŒ¯èª¤
- å¤šå€‹ç¯€é»èªç‚ºè‡ªå·±æ˜¯ä¸»ç¯€é»
- éƒ¨åˆ†å¯«å…¥ä¸Ÿå¤±

**æ•™è¨“**: ä¸èƒ½å‡è¨­æ™‚é˜ç¸½æ˜¯æ­£ç¢ºçš„

---

### æ¡ˆä¾‹ 2: Cloudflare çš„ 2020 æ•…éšœ

**äº‹ä»¶**: SSD æ•…éšœå°è‡´ä¸€å€‹è³‡æ–™ä¸­å¿ƒä¸å¯ç”¨

**å½±éŸ¿**:
- å…¨çƒæµé‡ç„¡æ³•è·¯ç”±åˆ°è©²è³‡æ–™ä¸­å¿ƒ
- è² è¼‰å‡è¡¡å™¨èŠ±äº† 30 åˆ†é˜æ‰å°‡æµé‡åˆ‡èµ°

**æ•™è¨“**: æ•…éšœæª¢æ¸¬å¿…é ˆè¶³å¤ å¿«,ä½†ä¸èƒ½å¤ªæ•æ„Ÿ

---

### æ¡ˆä¾‹ 3: GitHub çš„ 2018 ç¶²è·¯åˆ†å€

**äº‹ä»¶**: ç¶²è·¯ç¶­è­·å°è‡´ç¾åœ‹æ±è¥¿æµ·å²¸è³‡æ–™ä¸­å¿ƒæ–·é–‹ 43 ç§’

**å½±éŸ¿**:
- å…©å€‹è³‡æ–™ä¸­å¿ƒéƒ½èªç‚ºå°æ–¹æ•…éšœ
- å„è‡ªé¸èˆ‰ä¸»ç¯€é»,ç”¢ç”Ÿè…¦è£‚
- 43 ç§’å…§çš„å¯«å…¥ä¸ä¸€è‡´

**æ¢å¾©**:
- åœæ­¢æœå‹™ 24 å°æ™‚é€²è¡Œè³‡æ–™ä¿®å¾©
- ä½¿ç”¨ MySQL binlog å°æ¯”å’Œä¿®å¾©ä¸ä¸€è‡´çš„è³‡æ–™

**æ•™è¨“**: å³ä½¿çŸ­æš«çš„ç¶²è·¯åˆ†å€ä¹Ÿå¯èƒ½å°è‡´åš´é‡å¾Œæœ

---

## ğŸ›¡ï¸ è¨­è¨ˆåŸå‰‡

### åŸå‰‡ 1: æ‹œå åº­å°‡è»å•é¡Œ vs éæ‹œå åº­æ•…éšœ

**éæ‹œå åº­æ•…éšœ (Crash-Stop Failure)**:
- ç¯€é»æœƒå´©æ½°,ä½†ä¸æœƒèªªè¬Š
- ç¶²è·¯å¯èƒ½ä¸ŸåŒ…,ä½†ä¸æœƒç¯¡æ”¹è¨Šæ¯

**æ‹œå åº­æ•…éšœ (Byzantine Failure)**:
- ç¯€é»å¯èƒ½æƒ¡æ„è¡Œç‚º,ç™¼é€éŒ¯èª¤è¨Šæ¯
- ç¶²è·¯å¯èƒ½è¢«æ”»æ“Šè€…æ§åˆ¶

```mermaid
graph TD
    A["æ•…éšœæ¨¡å‹"] --> B["éæ‹œå åº­<br/>(Crash-Stop)"]
    A --> C["æ‹œå åº­<br/>(Byzantine)"]
    
    B --> B1["å‡è¨­: ç¯€é»èª å¯¦ä½†å¯èƒ½æ•…éšœ"]
    B --> B2["é©ç”¨: å¯ä¿¡ç’°å¢ƒ (ä¼æ¥­å…§éƒ¨)"]
    B --> B3["ç¯„ä¾‹: Raft, Paxos"]
    
    C --> C1["å‡è¨­: ç¯€é»å¯èƒ½æƒ¡æ„"]
    C --> C2["é©ç”¨: ä¸å¯ä¿¡ç’°å¢ƒ (å€å¡Šéˆ)"]
    C --> C3["ç¯„ä¾‹: PBFT, æ¯”ç‰¹å¹£"]
```

**å¤§å¤šæ•¸ç³»çµ±å‡è¨­éæ‹œå åº­æ•…éšœ**: å¯¦ä½œç°¡å–®,æ€§èƒ½æ›´å¥½ã€‚

---

### åŸå‰‡ 2: ç³»çµ±æ¨¡å‹

**åŒæ­¥æ¨¡å‹ (Synchronous Model)**:
- å‡è¨­: ç¶²è·¯å»¶é²æœ‰ä¸Šç•Œ,æ™‚é˜èª¤å·®æœ‰ä¸Šç•Œ
- ç¾å¯¦: ä¸å­˜åœ¨ (ç¶²è·¯å¯èƒ½ä»»æ„å»¶é²)

**ç•°æ­¥æ¨¡å‹ (Asynchronous Model)**:
- å‡è¨­: ç¶²è·¯å»¶é²ç„¡é™,æ™‚é˜ä¸å¯ç”¨
- ç¾å¯¦: å¤ªæ‚²è§€,ç„¡æ³•è¨­è¨ˆå¯¦ç”¨ç³»çµ±

**éƒ¨åˆ†åŒæ­¥æ¨¡å‹ (Partially Synchronous Model)**:
- å‡è¨­: å¤§éƒ¨åˆ†æ™‚é–“åŒæ­¥,å¶çˆ¾ç•°æ­¥
- ç¾å¯¦: ç¬¦åˆå¯¦éš›æƒ…æ³
- **å¤§å¤šæ•¸åˆ†æ•£å¼ç®—æ³•åŸºæ–¼æ­¤æ¨¡å‹**

---

### åŸå‰‡ 3: å®¹éŒ¯è¨­è¨ˆ

**å‡è¨­æ‰€æœ‰å¯èƒ½å‡ºéŒ¯çš„éƒ½æœƒå‡ºéŒ¯**:

```python
class RobustDistributedSystem:
    def send_request(self, node, request):
        """å¥å£¯çš„è«‹æ±‚ç™¼é€"""
        max_retries = 3
        timeout = 5.0
        
        for attempt in range(max_retries):
            try:
                # 1. ä½¿ç”¨è¶…æ™‚
                response = node.send(request, timeout=timeout)
                
                # 2. é©—è­‰å›æ‡‰
                if not self.is_valid_response(response):
                    raise ValueError("ç„¡æ•ˆå›æ‡‰")
                
                # 3. æª¢æŸ¥å†ªç­‰æ€§
                if self.is_duplicate_response(response):
                    return response  # é‡è¤‡è«‹æ±‚,è¿”å›å¿«å–çµæœ
                
                return response
                
            except TimeoutError:
                # 4. è¶…æ™‚é‡è©¦
                if attempt < max_retries - 1:
                    # æŒ‡æ•¸é€€é¿
                    time.sleep(2 ** attempt)
                    continue
                else:
                    # 5. æœ€çµ‚å¤±æ•—,é™ç´šè™•ç†
                    return self.fallback_handler()
            
            except Exception as e:
                # 6. è¨˜éŒ„éŒ¯èª¤
                self.log_error(e)
                raise
    
    def is_valid_response(self, response):
        """é©—è­‰å›æ‡‰çš„å®Œæ•´æ€§"""
        # æª¢æŸ¥ checksum, ç°½åç­‰
        return True
    
    def is_duplicate_response(self, response):
        """æª¢æŸ¥æ˜¯å¦ç‚ºé‡è¤‡å›æ‡‰"""
        request_id = response.get('request_id')
        return request_id in self.processed_requests
    
    def fallback_handler(self):
        """é™ç´šè™•ç†"""
        # è¿”å›å¿«å–è³‡æ–™æˆ–é»˜èªå€¼
        return {"status": "degraded"}
```

---

## ğŸ¤” æ·±å…¥æ€è€ƒ

### ç·´ç¿’ 1: åˆ†ææ•…éšœå ´æ™¯

**å ´æ™¯**: åˆ†æ•£å¼é–æœå‹™,ä½¿ç”¨ç§Ÿç´„æ©Ÿåˆ¶:

```python
class DistributedLock:
    def acquire(self, resource, ttl=10):
        """ç²å–é–,æœ‰æ•ˆæœŸ ttl ç§’"""
        return self.set_if_not_exists(resource, "locked", ttl)
    
    def release(self, resource):
        """é‡‹æ”¾é–"""
        self.delete(resource)

# å®¢æˆ¶ç«¯ä½¿ç”¨
lock = DistributedLock()
if lock.acquire("resource1"):
    # åŸ·è¡Œé—œéµæ“ä½œ
    process_critical_section()
    lock.release("resource1")
```

**å•é¡Œ**:
1. å¦‚æœå®¢æˆ¶ç«¯åœ¨ `process_critical_section()` ä¸­ GC æš«åœ 15 ç§’,æœƒç™¼ç”Ÿä»€éº¼?
2. å¦‚æœç¶²è·¯åˆ†å€å°è‡´ `lock.release()` å¤±æ•—,æœƒç™¼ç”Ÿä»€éº¼?
3. å¦‚ä½•æ”¹é€²è¨­è¨ˆ?

<details>
<summary>ğŸ’¡ åƒè€ƒç­”æ¡ˆ</summary>

**å•é¡Œ 1: GC æš«åœå°è‡´çš„é–éæœŸ**

```mermaid
sequenceDiagram
    participant C1 as å®¢æˆ¶ç«¯ 1
    participant Lock as é–æœå‹™
    participant C2 as å®¢æˆ¶ç«¯ 2
    
    C1->>Lock: acquire (TTL=10s)
    Lock-->>C1: æˆåŠŸ
    
    Note over C1: é–‹å§‹è™•ç†<br/>[GC æš«åœ 15s]
    
    Note over Lock: é–éæœŸ (10s å¾Œ)
    
    C2->>Lock: acquire
    Lock-->>C2: æˆåŠŸ
    
    Note over C1: [GC æ¢å¾©]<br/>ç¹¼çºŒè™•ç†
    
    Note over C1,C2: âŒ å…©å€‹å®¢æˆ¶ç«¯<br/>åŒæ™‚è™•ç†
```

**å•é¡Œ 2: ç¶²è·¯åˆ†å€å°è‡´ç„¡æ³•é‡‹æ”¾é–**
- é–æœƒåœ¨ TTL éæœŸå¾Œè‡ªå‹•é‡‹æ”¾
- ä½†æœŸé–“å…¶ä»–å®¢æˆ¶ç«¯ç„¡æ³•ç²å–é– (å¯ç”¨æ€§é™ä½)

**æ”¹é€²æ–¹æ¡ˆ**: ä½¿ç”¨ Fencing Token

```python
class ImprovedDistributedLock:
    def __init__(self):
        self.token_counter = 0
    
    def acquire(self, resource, ttl=10):
        """ç²å–é–,è¿”å›éå¢ä»¤ç‰Œ"""
        self.token_counter += 1
        token = self.token_counter
        
        if self.set_if_not_exists(resource, token, ttl):
            return token
        return None

# å®¢æˆ¶ç«¯ä½¿ç”¨
token = lock.acquire("resource1")
if token:
    # å‚³éä»¤ç‰Œçµ¦å¾Œç«¯æœå‹™
    backend.process(resource="resource1", token=token)

# å¾Œç«¯æœå‹™
class Backend:
    def __init__(self):
        self.max_token = {}
    
    def process(self, resource, token):
        # æª¢æŸ¥ä»¤ç‰Œ
        if token <= self.max_token.get(resource, 0):
            raise ValueError("ä»¤ç‰ŒéæœŸ")
        
        self.max_token[resource] = token
        # åŸ·è¡Œæ“ä½œ
```

</details>

---

### ç·´ç¿’ 2: è¨­è¨ˆå®¹éŒ¯çš„åˆ†æ•£å¼è¨ˆæ•¸å™¨

**éœ€æ±‚**:
- å¤šå€‹ç¯€é»ä¸¦ç™¼å¢åŠ è¨ˆæ•¸
- å®¹å¿ç¶²è·¯åˆ†å€
- å®¹å¿ç¯€é»æ•…éšœ
- æœ€çµ‚ä¸€è‡´æ€§

**å˜—è©¦è¨­è¨ˆä¸€å€‹æ–¹æ¡ˆ**ã€‚

<details>
<summary>ğŸ’¡ åƒè€ƒç­”æ¡ˆ</summary>

**æ–¹æ¡ˆ: PN-Counter (Positive-Negative Counter)**

```python
class PNCounter:
    """åˆ†æ•£å¼è¨ˆæ•¸å™¨,æ”¯æŒå¢åŠ å’Œæ¸›å°‘"""
    
    def __init__(self, node_id):
        self.node_id = node_id
        self.positive = {}  # {node_id: count}
        self.negative = {}  # {node_id: count}
    
    def increment(self, delta=1):
        """å¢åŠ è¨ˆæ•¸"""
        if self.node_id not in self.positive:
            self.positive[self.node_id] = 0
        self.positive[self.node_id] += delta
    
    def decrement(self, delta=1):
        """æ¸›å°‘è¨ˆæ•¸"""
        if self.node_id not in self.negative:
            self.negative[self.node_id] = 0
        self.negative[self.node_id] += delta
    
    def value(self):
        """ç•¶å‰è¨ˆæ•¸å€¼"""
        pos_sum = sum(self.positive.values())
        neg_sum = sum(self.negative.values())
        return pos_sum - neg_sum
    
    def merge(self, other):
        """åˆä½µå…¶ä»–ç¯€é»çš„ç‹€æ…‹"""
        # å–æ¯å€‹ç¯€é»çš„æœ€å¤§å€¼
        for node, count in other.positive.items():
            self.positive[node] = max(
                self.positive.get(node, 0),
                count
            )
        
        for node, count in other.negative.items():
            self.negative[node] = max(
                self.negative.get(node, 0),
                count
            )

# ä½¿ç”¨ç¯„ä¾‹
counter1 = PNCounter("node1")
counter1.increment(5)  # +5

counter2 = PNCounter("node2")
counter2.increment(3)  # +3

# ç¶²è·¯åˆ†å€å¾Œåˆä½µ
counter1.merge(counter2)
print(counter1.value())  # 8

# ç‰¹æ€§:
# âœ… ç„¡éœ€å”èª¿,æœ¬åœ°æ“ä½œ
# âœ… åˆä½µæ˜¯å†ªç­‰çš„
# âœ… æœ€çµ‚ä¸€è‡´æ€§
```

</details>

---

## ğŸ“š ç¸½çµ

### æ ¸å¿ƒè¦é»

```mermaid
graph TD
    A["åˆ†æ•£å¼ç³»çµ±çš„å›°å¢ƒ"] --> B["ç¶²è·¯ä¸å¯é "]
    A --> C["æ™‚é˜ä¸å¯ä¿¡"]
    A --> D["é€²ç¨‹æœƒæ•…éšœ"]
    
    B --> B1["è§£æ±º: è¶…æ™‚ã€é‡è©¦ã€å†ªç­‰æ€§"]
    C --> C1["è§£æ±º: é¿å…ä¾è³´æ™‚é˜,ä½¿ç”¨é‚è¼¯æ™‚é˜"]
    D --> D1["è§£æ±º: Fencing Token"]
    
    style A fill:#ffcccc
    style B fill:#ffffcc
    style C fill:#ccffcc
    style D fill:#ccccff
```

### è¨­è¨ˆæ¸…å–®

åœ¨è¨­è¨ˆåˆ†æ•£å¼ç³»çµ±æ™‚,æª¢æŸ¥ä»¥ä¸‹å•é¡Œ:

- [ ] **ç¶²è·¯**: æ˜¯å¦è™•ç†è¶…æ™‚å’Œé‡è©¦?
- [ ] **å†ªç­‰æ€§**: é‡è¤‡è«‹æ±‚æ˜¯å¦å®‰å…¨?
- [ ] **æ™‚é˜**: æ˜¯å¦ä¾è³´äº†ä¸å¯é çš„æ™‚é˜?
- [ ] **æ•…éšœæª¢æ¸¬**: å¦‚ä½•å€åˆ†æ…¢éŸ¿æ‡‰å’Œç¯€é»æ•…éšœ?
- [ ] **ç§Ÿç´„**: æ˜¯å¦æœ‰ç§Ÿç´„éæœŸå¾Œä»åŸ·è¡Œçš„é¢¨éšª?
- [ ] **è…¦è£‚**: æ˜¯å¦å¯èƒ½å‡ºç¾å¤šå€‹ä¸»ç¯€é»?
- [ ] **é™ç´š**: éƒ¨åˆ†çµ„ä»¶æ•…éšœæ™‚ç³»çµ±å¦‚ä½•é™ç´š?

---

## ğŸ”— åƒè€ƒè³‡æ–™

1. **æ›¸ç±**:
   - Martin Kleppmann, *Designing Data-Intensive Applications*, Chapter 8
   - Leslie Lamport, *Time, Clocks, and the Ordering of Events in a Distributed System*

2. **è«–æ–‡**:
   - [Harvest, Yield, and Scalable Tolerant Systems](http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.24.3690)
   - [The Network is Reliable (åè«·)](https://queue.acm.org/detail.cfm?id=2655736)

3. **æŠ€è¡“æ–‡ä»¶**:
   - [AWS Best Practices for DynamoDB](https://docs.aws.amazon.com/amazondynamodb/latest/developerguide/best-practices.html)
   - [Google Spanner TrueTime](https://cloud.google.com/spanner/docs/true-time-external-consistency)

4. **äº‹æ•…å ±å‘Š**:
   - [GitHub Availability This Week](https://github.blog/2018-10-30-oct21-post-incident-analysis/)
   - [Summary of the Amazon S3 Service Disruption](https://aws.amazon.com/message/41926/)

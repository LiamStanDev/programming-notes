# 33. 設計社交網路 Feed 系統

## 一、Feed 系統設計理論

### 1. 需求分析
- **即時性**：用戶希望即時看到好友或關注對象的最新動態。
- **可擴展性**：需支援數百萬甚至數十億用戶的高併發讀寫。
- **個人化**：每位用戶看到的 Feed 順序、內容都不同，需支援推薦與排序。
- **高可用性**：Feed 服務需 24/7 穩定運作，不能因單點故障而中斷。
- **成本控制**：需在效能與成本間取得平衡。

### 2. 核心挑戰
- **資料量龐大**：動態數據量極大，且需快速查詢與組合。
- **高併發讀寫**：Feed 讀取遠高於寫入，需優化讀取效能。
- **個人化排序與推薦**：需根據用戶行為、社交關係、內容特徵動態排序。
- **即時推播與拉取**：如何平衡推（Push）與拉（Pull）模式。
- **快取一致性**：快取資料需與原始資料保持一致，避免過期或髒讀。

### 3. 常見設計模式
- **拉取（Pull）模式**：用戶每次開啟 App 時即時查詢 Feed，適合動態變化快、用戶數多的場景。
- **推播（Push）模式**：當有新動態時，預先將 Feed 寫入用戶的收件箱，適合關係網較小或明星帳號。
- **混合模式**：針對不同用戶、不同 Feed 類型採用不同策略（如明星帳號用推播，普通用戶用拉取）。
- **快取策略**：利用 Redis/Memcached 快取熱門 Feed、用戶收件箱，減少資料庫壓力。
- **分散式儲存**：將 Feed 資料分片儲存於多個節點，提升可用性與擴展性。

---

## 二、Feed 系統架構圖

```mermaid
flowchart TD
    subgraph 用戶端
        A[用戶 App/瀏覽器]
    end
    subgraph API層
        B[Feed API Gateway]
    end
    subgraph 業務層
        C[Feed 生成服務]
        D[Feed 推播服務]
        E[Feed 拉取服務]
        F[個人化排序/推薦引擎]
    end
    subgraph 快取層
        G[Feed 快取 (Redis/Memcached)]
    end
    subgraph 資料儲存層
        H[Feed 資料庫 (NoSQL/分片)]
        I[用戶關係資料庫]
        J[內容資料庫]
    end

    A -- 請求Feed --> B
    B -- 轉發 --> E
    E -- 查詢快取 --> G
    G -- 命中 --> E
    G -- 未命中 --> C
    C -- 生成Feed --> F
    F -- 個人化排序 --> E
    E -- 回傳Feed --> B
    B -- 回應Feed --> A

    C -- 寫入Feed --> G
    C -- 寫入Feed --> H
    D -- 推播Feed --> G
    D -- 推播Feed --> H
    C -- 查詢用戶關係 --> I
    C -- 查詢內容 --> J
```

---

## 三、API/資料流設計與真實世界範例

### 1. Feed 生成 API 範例

#### (1) 拉取 Feed API
```http
GET /api/v1/feed?user_id={user_id}&limit=20&cursor={cursor}
```
- **參數說明**：
  - `user_id`：用戶 ID
  - `limit`：每次拉取數量
  - `cursor`：分頁游標

- **回應範例**：
```json
{
  "feeds": [
    {
      "feed_id": "12345",
      "author_id": "67890",
      "content": "這是一則動態",
      "created_at": "2025-09-17T08:00:00Z"
    }
  ],
  "next_cursor": "abcdef"
}
```

#### (2) 發佈動態 API
```http
POST /api/v1/feed
Content-Type: application/json

{
  "author_id": "67890",
  "content": "這是一則動態"
}
```

### 2. 資料表設計（NoSQL 範例）

#### (1) Feed 資料表
| 欄位         | 說明           |
|--------------|----------------|
| feed_id      | 動態唯一 ID    |
| author_id    | 發佈者 ID      |
| content      | 內容           |
| created_at   | 發佈時間       |
| visibility   | 可見性設定     |

#### (2) 用戶收件箱（Inbox）表
| 欄位         | 說明           |
|--------------|----------------|
| user_id      | 用戶 ID        |
| feed_ids     | Feed ID 陣列   |
| updated_at   | 最後更新時間   |

### 3. 快取策略
- **熱門 Feed 快取**：將熱門動態快取於 Redis，減少資料庫查詢。
- **用戶收件箱快取**：將用戶 Inbox 快取，提升個人化 Feed 查詢速度。
- **快取失效策略**：採用 LRU、TTL 或主動失效，確保資料新鮮度。
- **一致性處理**：Feed 發佈、刪除時同步更新快取與資料庫。

---

## 四、架構師實務建議與 Trade-off 分析

### 1. 即時性 vs. 可用性
- **推播模式**可提升即時性，但需處理大量寫入與快取同步，適合明星帳號或高互動用戶。
- **拉取模式**可提升可用性與擴展性，適合大多數一般用戶，但即時性略低。

### 2. 可擴展性
- **分片儲存**與**分散式快取**可支援大規模用戶與資料量。
- **微服務架構**可獨立擴展 Feed 生成、推播、排序等服務。

### 3. 成本與複雜度
- **推播模式**需維護大量 Inbox、快取同步，系統複雜度高，硬體成本也較高。
- **拉取模式**架構較簡單，成本較低，但熱門用戶 Feed 查詢壓力大。

### 4. 維運建議
- **監控快取命中率**、資料庫延遲、API QPS，及時調整資源。
- **分層快取**（如 CDN + Redis）可進一步減輕後端壓力。
- **資料一致性**可採用最終一致性，降低寫入延遲。

---

## 五、結論

Feed 系統設計需根據業務需求、用戶規模、即時性要求選擇合適的設計模式與架構。建議採用混合推拉模式、分層快取、分散式儲存，並持續監控與優化系統效能與成本。

# 12 - ç³»çµ±è¨­è¨ˆæ¬Šè¡¡åˆ†æ (System Design Trade-offs)

## ğŸ¯ å­¸ç¿’ç›®æ¨™

å®Œæˆæœ¬ç« å¾Œ,ä½ å°‡èƒ½å¤ :
- ç†è§£ç³»çµ±è¨­è¨ˆä¸­çš„æ ¸å¿ƒæ¬Šè¡¡
- æŒæ¡ CAP å’Œ PACELC å®šç†çš„å¯¦éš›æ‡‰ç”¨
- åˆ†æä¸åŒå ´æ™¯ä¸‹çš„æœ€ä½³é¸æ“‡
- é€²è¡Œç³»çµ±è¨­è¨ˆçš„æˆæœ¬æ•ˆç›Šåˆ†æ

---

## ğŸ’¡ æ ¸å¿ƒæ¦‚å¿µ

### æ²’æœ‰å®Œç¾çš„ç³»çµ±

**æ ¹æœ¬çœŸç†**: æ‰€æœ‰ç³»çµ±è¨­è¨ˆéƒ½æ˜¯æ¬Šè¡¡çš„çµæœã€‚

```mermaid
graph TD
    A["ç³»çµ±è¨­è¨ˆ"] --> B["æ€§èƒ½ vs ä¸€è‡´æ€§"]
    A --> C["å¯ç”¨æ€§ vs æ­£ç¢ºæ€§"]
    A --> D["è¤‡é›œæ€§ vs å¯ç¶­è­·æ€§"]
    A --> E["æˆæœ¬ vs åŠŸèƒ½"]
    
    style A fill:#ffcccc
```

**è¨­è¨ˆå“²å­¸**:
- æ²’æœ‰"æœ€å¥½"çš„è¨­è¨ˆ,åªæœ‰"æœ€é©åˆ"çš„è¨­è¨ˆ
- æ ¹æ“šæ¥­å‹™éœ€æ±‚é¸æ“‡æ¬Šè¡¡æ–¹å‘
- æ˜ç¢ºèªªæ˜è¨­è¨ˆæ±ºç­–çš„ç†ç”±

---

## ğŸ“Š CAP å®šç†æ·±å…¥åˆ†æ

### CAP ä¸‰è§’

```mermaid
graph TD
    A["CAP å®šç†"] --> B["Consistency<br/>ä¸€è‡´æ€§"]
    A --> C["Availability<br/>å¯ç”¨æ€§"]
    A --> D["Partition Tolerance<br/>åˆ†å€å®¹éŒ¯"]
    
    B --> E["CP ç³»çµ±<br/>HBase, MongoDB"]
    C --> F["AP ç³»çµ±<br/>Cassandra, DynamoDB"]
    D --> G["å¿…é ˆä¿è­‰<br/>(ç¶²è·¯ç¸½æœƒåˆ†å€)"]
    
    style D fill:#ffeb99
```

### ğŸ’» å¯¦éš›æ¡ˆä¾‹åˆ†æ

**å ´æ™¯: è³¼ç‰©è»Šç³»çµ±**

**CP é¸æ“‡ (çŠ§ç‰²å¯ç”¨æ€§)**:

```python
class CPShoppingCart:
    """å¼·ä¸€è‡´æ€§è³¼ç‰©è»Š (ä½¿ç”¨ etcd)"""
    
    def __init__(self, etcd_client):
        self.etcd = etcd_client
    
    def add_item(self, user_id, item_id, quantity):
        """æ·»åŠ å•†å“åˆ°è³¼ç‰©è»Š"""
        try:
            # ä½¿ç”¨åˆ†æ•£å¼é–ä¿è­‰ä¸€è‡´æ€§
            with self.etcd.lock(f"cart:{user_id}", ttl=10):
                # è®€å–ç•¶å‰è³¼ç‰©è»Š
                cart = self.get_cart(user_id)
                
                # æª¢æŸ¥åº«å­˜ (å¼·ä¸€è‡´æ€§æŸ¥è©¢)
                stock = self.check_stock_consistent(item_id)
                if stock < quantity:
                    raise InsufficientStockError()
                
                # æ›´æ–°è³¼ç‰©è»Š
                cart[item_id] = cart.get(item_id, 0) + quantity
                self.etcd.put(f"cart:{user_id}", json.dumps(cart))
                
                return True
        except LockTimeout:
            # ç¶²è·¯åˆ†å€æ™‚ç„¡æ³•ç²å–é–
            raise ServiceUnavailableError("è³¼ç‰©è»Šæœå‹™æš«æ™‚ä¸å¯ç”¨")
```

**AP é¸æ“‡ (çŠ§ç‰²ä¸€è‡´æ€§)**:

```python
class APShoppingCart:
    """é«˜å¯ç”¨è³¼ç‰©è»Š (ä½¿ç”¨ Cassandra)"""
    
    def __init__(self, cassandra_session):
        self.session = cassandra_session
    
    def add_item(self, user_id, item_id, quantity):
        """æ·»åŠ å•†å“åˆ°è³¼ç‰©è»Š (æœ€çµ‚ä¸€è‡´æ€§)"""
        
        # ä½¿ç”¨ LWW (Last-Write-Wins)
        self.session.execute("""
            INSERT INTO shopping_carts (user_id, item_id, quantity, updated_at)
            VALUES (%s, %s, %s, %s)
        """, (user_id, item_id, quantity, datetime.now()))
        
        # âœ… å³ä½¿ç¶²è·¯åˆ†å€ä¹Ÿèƒ½å¯«å…¥
        # âš ï¸ å¯èƒ½çŸ­æš«ä¸ä¸€è‡´
        return True
    
    def get_cart(self, user_id):
        """è®€å–è³¼ç‰©è»Š (å¯èƒ½è®€åˆ°èˆŠè³‡æ–™)"""
        rows = self.session.execute("""
            SELECT item_id, quantity FROM shopping_carts 
            WHERE user_id = %s
        """, (user_id,))
        
        return {row.item_id: row.quantity for row in rows}
```

**æ¬Šè¡¡åˆ†æ**:

| æ–¹é¢ | CP (etcd) | AP (Cassandra) |
|------|-----------|----------------|
| **ç¶²è·¯åˆ†å€æ™‚** | æ‹’çµ•æœå‹™ âŒ | ç¹¼çºŒæœå‹™ âœ… |
| **ä¸€è‡´æ€§** | å¼·ä¸€è‡´æ€§ âœ… | æœ€çµ‚ä¸€è‡´æ€§ âš ï¸ |
| **ç”¨æˆ¶é«”é©—** | å¯èƒ½ç„¡æ³•åŠ å…¥è³¼ç‰©è»Š | ç¸½èƒ½åŠ å…¥è³¼ç‰©è»Š |
| **é©ç”¨å ´æ™¯** | é‡‘èäº¤æ˜“ | ç¤¾äº¤åª’é«” |

**Amazon çš„é¸æ“‡**: AP (è³¼ç‰©è»Šè¨­è¨ˆç‚ºé«˜å¯ç”¨,å¯§å¯å¶çˆ¾å¤šåŠ å•†å“ä¹Ÿä¸èƒ½è®“ç”¨æˆ¶ç„¡æ³•è³¼ç‰©)

---

## ğŸ“ PACELC å®šç†

### æ›´å…¨é¢çš„æ¬Šè¡¡æ¨¡å‹

**PACELC**: 
- **P**artition: ç¶²è·¯åˆ†å€æ™‚,é¸æ“‡ **A**vailability æˆ– **C**onsistency
- **E**lse: æ­£å¸¸æƒ…æ³ä¸‹,é¸æ“‡ **L**atency æˆ– **C**onsistency

```mermaid
graph TD
    A["PACELC"] --> B["åˆ†å€æ™‚ (P)"]
    A --> C["æ­£å¸¸æ™‚ (E)"]
    
    B --> B1["å¯ç”¨æ€§ (A)"]
    B --> B2["ä¸€è‡´æ€§ (C)"]
    
    C --> C1["ä½å»¶é² (L)"]
    C --> C2["ä¸€è‡´æ€§ (C)"]
    
    D["PA/EL<br/>Cassandra"] --> B1
    D --> C1
    
    E["PC/EC<br/>HBase"] --> B2
    E --> C2
    
    F["PA/EC<br/>MongoDB"] --> B1
    F --> C2
```

### ğŸ’» å¯¦éš›ç³»çµ±åˆ†é¡

**PA/EL ç³»çµ± (Cassandra, DynamoDB)**:

```python
# Cassandra é…ç½®
CREATE KEYSPACE shopping WITH replication = {
    'class': 'NetworkTopologyStrategy',
    'dc1': 3,
    'dc2': 3
};

# è®€å¯«é…ç½®: æ³•å®šäººæ•¸
READ CONSISTENCY = ONE;    # å¿«é€Ÿè®€å– (çŠ§ç‰²ä¸€è‡´æ€§)
WRITE CONSISTENCY = ONE;   # å¿«é€Ÿå¯«å…¥ (çŠ§ç‰²ä¸€è‡´æ€§)

# ç‰¹æ€§:
# - åˆ†å€æ™‚: å¯ç”¨ (A)
# - æ­£å¸¸æ™‚: ä½å»¶é² (L)
# - æœ€çµ‚ä¸€è‡´æ€§
```

**PC/EC ç³»çµ± (HBase, Google Spanner)**:

```python
# HBase é…ç½®
# æ‰€æœ‰è®€å¯«éƒ½ç¶“é Region Server (å–®é»å¯«å…¥)

# ç‰¹æ€§:
# - åˆ†å€æ™‚: å°‘æ•¸åˆ†å€ä¸å¯ç”¨ (C)
# - æ­£å¸¸æ™‚: å¼·ä¸€è‡´æ€§,ä½†å»¶é²è¼ƒé«˜ (C)
# - é©åˆéœ€è¦å¼·ä¸€è‡´æ€§çš„å ´æ™¯
```

**PA/EC ç³»çµ± (MongoDB)**:

```python
# MongoDB é…ç½®
db.users.insert(
    {...},
    writeConcern: { w: "majority" }  # å¤šæ•¸æ´¾ç¢ºèª (ä¸€è‡´æ€§)
)

db.users.find({...}).readPreference("primaryPreferred")  # å„ªå…ˆä¸»ç¯€é»

# ç‰¹æ€§:
# - åˆ†å€æ™‚: å¯ç”¨ (å…è¨±å¾å‰¯æœ¬è®€å–)
# - æ­£å¸¸æ™‚: å¼·ä¸€è‡´æ€§ (å¯«å…¥éœ€è¦å¤šæ•¸æ´¾)
```

---

## âš–ï¸ æ ¸å¿ƒæ¬Šè¡¡ç¶­åº¦

### 1. æ€§èƒ½ vs ä¸€è‡´æ€§

**å¯«å…¥æ€§èƒ½å°æ¯”**:

```python
import time

class PerformanceTest:
    def test_eventual_consistency(self):
        """æœ€çµ‚ä¸€è‡´æ€§ (å¿«)"""
        start = time.time()
        
        # ç•°æ­¥å¯«å…¥,ç«‹å³è¿”å›
        for i in range(1000):
            cassandra.execute_async(
                "INSERT INTO data VALUES (%s)", (i,)
            )
        
        elapsed = time.time() - start
        print(f"æœ€çµ‚ä¸€è‡´æ€§: {elapsed:.2f}ç§’")  # ~0.5 ç§’
    
    def test_strong_consistency(self):
        """å¼·ä¸€è‡´æ€§ (æ…¢)"""
        start = time.time()
        
        # åŒæ­¥å¯«å…¥,ç­‰å¾…å¤šæ•¸æ´¾ç¢ºèª
        for i in range(1000):
            etcd.put(f"key_{i}", str(i))
        
        elapsed = time.time() - start
        print(f"å¼·ä¸€è‡´æ€§: {elapsed:.2f}ç§’")  # ~5 ç§’
```

**é¸æ“‡æŒ‡å—**:

| å ´æ™¯ | é¸æ“‡ | ç†ç”± |
|------|------|------|
| ç¤¾äº¤åª’é«”æŒ‰è®š | æœ€çµ‚ä¸€è‡´æ€§ | å»¶é²å¯æ¥å—,æ€§èƒ½å„ªå…ˆ |
| éŠ€è¡Œè½‰å¸³ | å¼·ä¸€è‡´æ€§ | æ­£ç¢ºæ€§è‡³é—œé‡è¦ |
| æœç´¢ç´¢å¼• | æœ€çµ‚ä¸€è‡´æ€§ | è¼•å¾®å»¶é²å¯æ¥å— |
| åº«å­˜æ‰£æ¸› | å¼·ä¸€è‡´æ€§ | é¿å…è¶…è³£ |

---

### 2. æ­£è¦åŒ– vs åæ­£è¦åŒ–

**æ­£è¦åŒ– (Normalized)**:

```sql
-- ç”¨æˆ¶è¡¨
CREATE TABLE users (
    user_id INT PRIMARY KEY,
    username VARCHAR(50),
    email VARCHAR(100)
);

-- è¨‚å–®è¡¨
CREATE TABLE orders (
    order_id INT PRIMARY KEY,
    user_id INT REFERENCES users(user_id),
    order_date TIMESTAMP,
    total_amount DECIMAL(10, 2)
);

-- æŸ¥è©¢éœ€è¦ JOIN
SELECT u.username, o.order_id, o.total_amount
FROM users u
JOIN orders o ON u.user_id = o.user_id
WHERE u.user_id = 123;
```

**åæ­£è¦åŒ– (Denormalized)**:

```sql
-- è¨‚å–®è¡¨ (å†—é¤˜ç”¨æˆ¶è³‡è¨Š)
CREATE TABLE orders_denorm (
    order_id INT PRIMARY KEY,
    user_id INT,
    username VARCHAR(50),      -- å†—é¤˜
    email VARCHAR(100),        -- å†—é¤˜
    order_date TIMESTAMP,
    total_amount DECIMAL(10, 2)
);

-- æŸ¥è©¢ç„¡éœ€ JOIN (å¿«!)
SELECT username, order_id, total_amount
FROM orders_denorm
WHERE user_id = 123;
```

**æ¬Šè¡¡åˆ†æ**:

| ç¶­åº¦ | æ­£è¦åŒ– | åæ­£è¦åŒ– |
|------|--------|---------|
| **è®€å–æ€§èƒ½** | âŒ æ…¢ (éœ€è¦ JOIN) | âœ… å¿« (å–®è¡¨æŸ¥è©¢) |
| **å¯«å…¥æ€§èƒ½** | âœ… å¿« (åªå¯«ä¸€æ¬¡) | âŒ æ…¢ (éœ€è¦æ›´æ–°å¤šè™•) |
| **å­˜å„²ç©ºé–“** | âœ… çœç©ºé–“ | âŒ å†—é¤˜è³‡æ–™ |
| **ä¸€è‡´æ€§** | âœ… å–®ä¸€æ•¸æ“šæº | âš ï¸ éœ€è¦åŒæ­¥æ›´æ–° |
| **é©ç”¨å ´æ™¯** | OLTP (é »ç¹æ›´æ–°) | OLAP (é »ç¹æŸ¥è©¢) |

**æ··åˆç­–ç•¥**:

```python
class HybridDataModel:
    """æ··åˆæ­£è¦åŒ–èˆ‡åæ­£è¦åŒ–"""
    
    def update_user_profile(self, user_id, new_username):
        """æ›´æ–°ç”¨æˆ¶è³‡æ–™"""
        
        # 1. æ›´æ–°ä¸»è¡¨ (æ­£è¦åŒ–)
        self.db.execute("""
            UPDATE users SET username = %s WHERE user_id = %s
        """, (new_username, user_id))
        
        # 2. ç•°æ­¥æ›´æ–°åæ­£è¦åŒ–è¡¨
        self.queue.publish({
            'event': 'user_updated',
            'user_id': user_id,
            'username': new_username
        })
    
    def sync_denormalized_data(self, event):
        """å¾Œå°åŒæ­¥åæ­£è¦åŒ–è³‡æ–™"""
        self.db.execute("""
            UPDATE orders_denorm 
            SET username = %s 
            WHERE user_id = %s
        """, (event['username'], event['user_id']))
```

---

### 3. åŒæ­¥ vs ç•°æ­¥

**åŒæ­¥è™•ç†**:

```python
def sync_order_processing(order):
    """åŒæ­¥è¨‚å–®è™•ç† (æ…¢ä½†å¯é )"""
    
    # æ‰£æ¸›åº«å­˜
    inventory.reduce_stock(order.item_id, order.quantity)
    
    # è™•ç†ä»˜æ¬¾
    payment.charge(order.user_id, order.amount)
    
    # ç™¼é€é€šçŸ¥
    notification.send_email(order.user_id, "è¨‚å–®ç¢ºèª")
    
    # æ›´æ–°è¨‚å–®ç‹€æ…‹
    orders.update_status(order.id, "COMPLETED")
    
    return "è¨‚å–®è™•ç†å®Œæˆ"

# ç‰¹æ€§:
# - ç”¨æˆ¶ç­‰å¾…æ‰€æœ‰æ­¥é©Ÿå®Œæˆ (~3-5 ç§’)
# - ä»»ä½•æ­¥é©Ÿå¤±æ•—éƒ½æœƒå›æ»¾
# - ç°¡å–®æ˜“ç†è§£
```

**ç•°æ­¥è™•ç†**:

```python
def async_order_processing(order):
    """ç•°æ­¥è¨‚å–®è™•ç† (å¿«ä½†è¤‡é›œ)"""
    
    # ç«‹å³è¿”å›
    orders.create(order)
    
    # ç™¼é€åˆ°è¨Šæ¯ä½‡åˆ—
    queue.publish('order_created', order)
    
    return "è¨‚å–®å·²æäº¤"

# å¾Œå°è™•ç†å™¨
class OrderProcessor:
    def process(self, order):
        try:
            inventory.reduce_stock(order.item_id, order.quantity)
            payment.charge(order.user_id, order.amount)
            notification.send_email(order.user_id, "è¨‚å–®ç¢ºèª")
            orders.update_status(order.id, "COMPLETED")
        except Exception as e:
            # å¤±æ•—é‡è©¦æˆ–è£œå„Ÿ
            self.handle_failure(order, e)

# ç‰¹æ€§:
# - ç”¨æˆ¶ç«‹å³å¾—åˆ°å›æ‡‰ (~100ms)
# - å¤±æ•—éœ€è¦é‡è©¦æ©Ÿåˆ¶
# - å¯¦ä½œè¼ƒè¤‡é›œ
```

**é¸æ“‡æŒ‡å—**:

```mermaid
graph TD
    A["é¸æ“‡åŒæ­¥æˆ–ç•°æ­¥?"] --> B{"æ“ä½œå¿…é ˆç«‹å³å®Œæˆ?"}
    B -->|æ˜¯| C["åŒæ­¥"]
    B -->|å¦| D{"æ“ä½œå¯èƒ½å¤±æ•—?"}
    
    D -->|æ˜¯ä¸”å¯é‡è©¦| E["ç•°æ­¥"]
    D -->|å¦| F{"å»¶é²è¦æ±‚?"}
    
    F -->|ä½å»¶é²| E
    F -->|å¯æ¥å—| C
    
    C --> G["ä¾‹: ä»˜æ¬¾è™•ç†"]
    E --> H["ä¾‹: ç™¼é€éƒµä»¶"]
```

---

### 4. å–®é«” vs å¾®æœå‹™

**å–®é«”æ¶æ§‹**:

```python
# å–®ä¸€æ‡‰ç”¨ç¨‹å¼
class MonolithicEcommerce:
    def __init__(self):
        self.user_service = UserService()
        self.product_service = ProductService()
        self.order_service = OrderService()
        self.payment_service = PaymentService()
    
    def create_order(self, user_id, items):
        """æ‰€æœ‰é‚è¼¯åœ¨åŒä¸€é€²ç¨‹"""
        user = self.user_service.get_user(user_id)
        products = self.product_service.get_products(items)
        order = self.order_service.create_order(user, products)
        payment = self.payment_service.process_payment(order)
        
        return order

# å„ªé»:
# - ç°¡å–®éƒ¨ç½² (å–®ä¸€å¯åŸ·è¡Œæª”)
# - ç„¡ç¶²è·¯å»¶é² (æœ¬åœ°å‡½æ•¸èª¿ç”¨)
# - æ˜“æ–¼èª¿è©¦ (å–®ä¸€é€²ç¨‹)

# ç¼ºé»:
# - é›£ä»¥æ“´å±• (å¿…é ˆæ•´é«”æ“´å±•)
# - å–®é»æ•…éšœ (ä»»ä½• bug å½±éŸ¿å…¨éƒ¨)
# - æŠ€è¡“æ£§é–å®š (é›£ä»¥ä½¿ç”¨ä¸åŒèªè¨€)
```

**å¾®æœå‹™æ¶æ§‹**:

```python
# ç”¨æˆ¶æœå‹™ (ç¨ç«‹éƒ¨ç½²)
class UserService:
    def get_user(self, user_id):
        return requests.get(f"http://user-service/users/{user_id}").json()

# è¨‚å–®æœå‹™ (ç¨ç«‹éƒ¨ç½²)
class OrderService:
    def create_order(self, user_id, items):
        # èª¿ç”¨å…¶ä»–æœå‹™
        user = self.user_service.get_user(user_id)
        products = self.product_service.get_products(items)
        
        # æœ¬åœ°é‚è¼¯
        order = Order(user=user, items=products)
        self.db.save(order)
        
        # ç™¼å¸ƒäº‹ä»¶
        self.event_bus.publish('order_created', order)
        
        return order

# å„ªé»:
# - ç¨ç«‹æ“´å±• (æ¯å€‹æœå‹™æŒ‰éœ€æ“´å±•)
# - æŠ€è¡“å¤šæ¨£æ€§ (ä¸åŒæœå‹™ç”¨ä¸åŒèªè¨€)
# - æ•…éšœéš”é›¢ (ä¸€å€‹æœå‹™æ•…éšœä¸å½±éŸ¿å…¶ä»–)

# ç¼ºé»:
# - ç¶²è·¯å»¶é² (æœå‹™é–“èª¿ç”¨)
# - åˆ†æ•£å¼è¤‡é›œæ€§ (éœ€è¦æœå‹™ç™¼ç¾ã€è² è¼‰å‡è¡¡ç­‰)
# - é‹ç¶­æˆæœ¬é«˜ (å¤šå€‹æœå‹™éƒ¨ç½²ç›£æ§)
```

**æ±ºç­–æ¨¹**:

```mermaid
graph TD
    A["é¸æ“‡å–®é«”æˆ–å¾®æœå‹™?"] --> B{"åœ˜éšŠè¦æ¨¡?"}
    B -->|< 10 äºº| C["å–®é«”"]
    B -->|> 20 äºº| D["å¾®æœå‹™"]
    B -->|10-20 äºº| E{"æ¥­å‹™è¤‡é›œåº¦?"}
    
    E -->|ç°¡å–®| C
    E -->|è¤‡é›œ| F{"æœ‰åˆ†æ•£å¼ç¶“é©—?"}
    
    F -->|æœ‰| D
    F -->|ç„¡| G["æ¨¡çµ„åŒ–å–®é«”<br/>(å…ˆæº–å‚™)"]
```

---

## ğŸ’° æˆæœ¬æ•ˆç›Šåˆ†æ

### 1. è¨ˆç®—æˆæœ¬

**é›²æœå‹™æˆæœ¬ä¼°ç®—**:

```python
class CloudCostEstimator:
    """é›²æœå‹™æˆæœ¬ä¼°ç®—å™¨"""
    
    def __init__(self):
        # AWS åƒ¹æ ¼ (2024, us-east-1)
        self.ec2_prices = {
            't3.medium': 0.0416,   # $/å°æ™‚
            'm5.large': 0.096,
            'c5.2xlarge': 0.34
        }
        
        self.rds_prices = {
            'db.t3.medium': 0.068,
            'db.m5.large': 0.182
        }
        
        self.s3_price = 0.023  # $/GB/æœˆ
        self.data_transfer_price = 0.09  # $/GB
    
    def estimate_monthly_cost(self, architecture):
        """ä¼°ç®—æœˆåº¦æˆæœ¬"""
        
        cost = 0
        
        # è¨ˆç®—ä¼ºæœå™¨æˆæœ¬
        for instance_type, count in architecture['ec2'].items():
            hourly_cost = self.ec2_prices[instance_type] * count
            monthly_cost = hourly_cost * 24 * 30
            cost += monthly_cost
            print(f"{instance_type} x{count}: ${monthly_cost:.2f}/æœˆ")
        
        # è¨ˆç®—è³‡æ–™åº«æˆæœ¬
        for db_type, count in architecture['rds'].items():
            hourly_cost = self.rds_prices[db_type] * count
            monthly_cost = hourly_cost * 24 * 30
            cost += monthly_cost
            print(f"{db_type} x{count}: ${monthly_cost:.2f}/æœˆ")
        
        # è¨ˆç®—å­˜å„²æˆæœ¬
        storage_gb = architecture['storage_gb']
        storage_cost = storage_gb * self.s3_price
        cost += storage_cost
        print(f"S3 å­˜å„² {storage_gb}GB: ${storage_cost:.2f}/æœˆ")
        
        # è¨ˆç®—æµé‡æˆæœ¬
        data_transfer_gb = architecture['data_transfer_gb']
        transfer_cost = data_transfer_gb * self.data_transfer_price
        cost += transfer_cost
        print(f"è³‡æ–™å‚³è¼¸ {data_transfer_gb}GB: ${transfer_cost:.2f}/æœˆ")
        
        print(f"\nç¸½æˆæœ¬: ${cost:.2f}/æœˆ (${cost * 12:.2f}/å¹´)")
        return cost

# ä½¿ç”¨ç¯„ä¾‹
estimator = CloudCostEstimator()

# å°å‹æ¶æ§‹
small_architecture = {
    'ec2': {'t3.medium': 2},
    'rds': {'db.t3.medium': 1},
    'storage_gb': 100,
    'data_transfer_gb': 500
}

# å¤§å‹æ¶æ§‹
large_architecture = {
    'ec2': {'m5.large': 10, 'c5.2xlarge': 5},
    'rds': {'db.m5.large': 3},
    'storage_gb': 10000,
    'data_transfer_gb': 50000
}

print("=== å°å‹æ¶æ§‹ ===")
estimator.estimate_monthly_cost(small_architecture)
# è¼¸å‡º: ~$150/æœˆ

print("\n=== å¤§å‹æ¶æ§‹ ===")
estimator.estimate_monthly_cost(large_architecture)
# è¼¸å‡º: ~$10,000/æœˆ
```

### 2. æ€§èƒ½æˆæœ¬æ¬Šè¡¡

**æ¡ˆä¾‹: å¿«å–ç­–ç•¥é¸æ“‡**

```python
class CacheStrategyAnalysis:
    """å¿«å–ç­–ç•¥æˆæœ¬åˆ†æ"""
    
    def analyze_no_cache(self, qps, db_latency_ms):
        """ç„¡å¿«å–æ–¹æ¡ˆ"""
        return {
            'strategy': 'ç„¡å¿«å–',
            'latency_p99': db_latency_ms,  # 100ms
            'db_load': qps,  # 1000 QPS
            'cost': self.calculate_db_cost(qps),  # $500/æœˆ
            'complexity': 'ç°¡å–®'
        }
    
    def analyze_redis_cache(self, qps, cache_hit_rate, db_latency_ms, cache_latency_ms):
        """Redis å¿«å–æ–¹æ¡ˆ"""
        cache_qps = qps * cache_hit_rate
        db_qps = qps * (1 - cache_hit_rate)
        
        avg_latency = (
            cache_qps * cache_latency_ms + db_qps * db_latency_ms
        ) / qps
        
        return {
            'strategy': 'Redis å¿«å–',
            'latency_p99': avg_latency,  # ~15ms (90% å‘½ä¸­ç‡)
            'db_load': db_qps,  # 100 QPS
            'cost': self.calculate_db_cost(db_qps) + 50,  # $100 + $50 Redis
            'complexity': 'ä¸­ç­‰'
        }
    
    def analyze_cdn_cache(self, qps, cdn_hit_rate):
        """CDN å¿«å–æ–¹æ¡ˆ"""
        origin_qps = qps * (1 - cdn_hit_rate)
        
        return {
            'strategy': 'CDN å¿«å–',
            'latency_p99': 5,  # ~5ms (é‚Šç·£ç¯€é»)
            'db_load': origin_qps,  # 50 QPS
            'cost': self.calculate_db_cost(origin_qps) + 100,  # $50 + $100 CDN
            'complexity': 'ä¸­ç­‰'
        }
    
    def recommend(self, qps, requirements):
        """æ¨è–¦æœ€ä½³æ–¹æ¡ˆ"""
        strategies = [
            self.analyze_no_cache(qps, 100),
            self.analyze_redis_cache(qps, 0.9, 100, 1),
            self.analyze_cdn_cache(qps, 0.95)
        ]
        
        # æ ¹æ“šéœ€æ±‚ç¯©é¸
        if requirements['max_latency_ms'] < 20:
            strategies = [s for s in strategies if s['latency_p99'] < 20]
        
        if requirements['max_budget'] < 200:
            strategies = [s for s in strategies if s['cost'] < 200]
        
        # é¸æ“‡æœ€ä½æˆæœ¬æ–¹æ¡ˆ
        best = min(strategies, key=lambda s: s['cost'])
        return best

# ä½¿ç”¨ç¯„ä¾‹
analyzer = CacheStrategyAnalysis()
recommendation = analyzer.recommend(
    qps=1000,
    requirements={
        'max_latency_ms': 20,
        'max_budget': 300
    }
)

print(f"æ¨è–¦æ–¹æ¡ˆ: {recommendation['strategy']}")
print(f"å»¶é²: {recommendation['latency_p99']}ms")
print(f"æˆæœ¬: ${recommendation['cost']}/æœˆ")
```

---

## ğŸ¯ æ±ºç­–æ¡†æ¶

### ç³»çµ±è¨­è¨ˆæ±ºç­–æµç¨‹

```mermaid
graph TD
    A["ç³»çµ±è¨­è¨ˆéœ€æ±‚"] --> B["è­˜åˆ¥æ ¸å¿ƒéœ€æ±‚"]
    B --> C["åˆ—å‡ºå¯é¸æ–¹æ¡ˆ"]
    C --> D["è©•ä¼°å„æ–¹æ¡ˆ"]
    D --> E["é‡åŒ–æ¬Šè¡¡"]
    E --> F["åšå‡ºæ±ºç­–"]
    F --> G["è¨˜éŒ„æ±ºç­–ç†ç”±"]
    
    D --> D1["æ€§èƒ½"]
    D --> D2["æˆæœ¬"]
    D --> D3["è¤‡é›œæ€§"]
    D --> D4["å¯ç¶­è­·æ€§"]
```

### æ±ºç­–æ–‡ä»¶ç¯„æœ¬

```markdown
# æ¶æ§‹æ±ºç­–è¨˜éŒ„ (ADR)

## èƒŒæ™¯
ç•¶å‰ç³»çµ±é¢è‡¨é«˜ä½µç™¼å ´æ™¯,è³‡æ–™åº«æˆç‚ºç“¶é ¸ã€‚

## éœ€æ±‚
- QPS: 10,000
- å»¶é²: P99 < 50ms
- é ç®—: < $2,000/æœˆ

## å¯é¸æ–¹æ¡ˆ

### æ–¹æ¡ˆ 1: å‚ç›´æ“´å±•è³‡æ–™åº«
- å„ªé»: ç°¡å–®,ç„¡éœ€æ”¹ç¨‹å¼ç¢¼
- ç¼ºé»: æˆæœ¬é«˜ ($5,000/æœˆ),æœ‰ä¸Šé™
- å»¶é²: P99 30ms

### æ–¹æ¡ˆ 2: æ·»åŠ  Redis å¿«å–
- å„ªé»: æˆæœ¬é©ä¸­ ($1,500/æœˆ),å»¶é²ä½
- ç¼ºé»: å¢åŠ è¤‡é›œæ€§,éœ€è™•ç†å¿«å–å¤±æ•ˆ
- å»¶é²: P99 15ms

### æ–¹æ¡ˆ 3: è®€å¯«åˆ†é›¢ + å¿«å–
- å„ªé»: æˆæœ¬æœ€ä½ ($1,200/æœˆ)
- ç¼ºé»: è¤‡é›œæ€§æœ€é«˜,æœ€çµ‚ä¸€è‡´æ€§
- å»¶é²: P99 20ms

## æ±ºç­–
é¸æ“‡æ–¹æ¡ˆ 2: æ·»åŠ  Redis å¿«å–

## ç†ç”±
- æ»¿è¶³æ€§èƒ½éœ€æ±‚ (15ms < 50ms)
- ç¬¦åˆé ç®—ç´„æŸ ($1,500 < $2,000)
- è¤‡é›œæ€§å¯æ§ (åœ˜éšŠæœ‰ Redis ç¶“é©—)
- å¯é€æ­¥é·ç§»,é¢¨éšªè¼ƒä½

## å¾Œæœ
- éœ€è¦å¯¦ä½œå¿«å–é ç†±é‚è¼¯
- éœ€è¦ç›£æ§å¿«å–å‘½ä¸­ç‡
- éœ€è¦è™•ç†å¿«å–ç©¿é€ã€é›ªå´©å•é¡Œ
```

---

## ğŸ“š ç¸½çµ

### æ ¸å¿ƒæ¬Šè¡¡åŸå‰‡

```mermaid
mindmap
  root((ç³»çµ±è¨­è¨ˆ<br/>æ¬Šè¡¡))
    æ€§èƒ½
      å»¶é² vs ååé‡
      å¿«å– vs å¯¦æ™‚æ€§
    å¯é æ€§
      ä¸€è‡´æ€§ vs å¯ç”¨æ€§
      æŒä¹…æ€§ vs æ€§èƒ½
    æˆæœ¬
      è¨ˆç®—æˆæœ¬
      å­˜å„²æˆæœ¬
      äººåŠ›æˆæœ¬
    è¤‡é›œæ€§
      ç°¡å–® vs éˆæ´»
      å–®é«” vs å¾®æœå‹™
```

### æ±ºç­–æ¸…å–®

è¨­è¨ˆç³»çµ±æ™‚,æª¢æŸ¥ä»¥ä¸‹å•é¡Œ:

- [ ] **æ€§èƒ½éœ€æ±‚**: QPS? å»¶é²? ååé‡?
- [ ] **ä¸€è‡´æ€§éœ€æ±‚**: å¼·ä¸€è‡´æ€§æˆ–æœ€çµ‚ä¸€è‡´æ€§?
- [ ] **å¯ç”¨æ€§éœ€æ±‚**: SLA? å®¹å¿åœæ©Ÿæ™‚é–“?
- [ ] **æˆæœ¬ç´„æŸ**: é ç®—ä¸Šé™?
- [ ] **åœ˜éšŠèƒ½åŠ›**: åœ˜éšŠç¶“é©—èˆ‡æŠ€èƒ½?
- [ ] **æ™‚é–“é™åˆ¶**: ä¸Šç·šæœŸé™?
- [ ] **æ“´å±•æ€§**: æœªä¾†æµé‡é æœŸ?

### å¸¸è¦‹åæ¨¡å¼

**âŒ éåº¦è¨­è¨ˆ**:
```python
# ä¸å¿…è¦çš„è¤‡é›œæ€§
# æ—¥æ´» 100 äººçš„æ‡‰ç”¨ä½¿ç”¨ Kubernetes + å¾®æœå‹™
```

**âŒ éæ—©å„ªåŒ–**:
```python
# åœ¨éœ€æ±‚ä¸æ˜ç¢ºæ™‚å°±é€²è¡Œè¤‡é›œå„ªåŒ–
```

**âŒ å¿½è¦–æˆæœ¬**:
```python
# ä½¿ç”¨æœ€è²´çš„æœå‹™è€Œä¸è€ƒæ…® ROI
```

**âœ… æ­£ç¢ºæ–¹æ³•**:
- å¾ç°¡å–®é–‹å§‹
- æ ¹æ“šå¯¦éš›éœ€æ±‚å„ªåŒ–
- æŒçºŒç›£æ§å’Œèª¿æ•´

---

## ğŸ”— åƒè€ƒè³‡æ–™

1. **æ›¸ç±**:
   - Martin Kleppmann, *Designing Data-Intensive Applications*
   - Sam Newman, *Building Microservices*

2. **è«–æ–‡**:
   - [CAP Twelve Years Later](https://www.infoq.com/articles/cap-twelve-years-later-how-the-rules-have-changed/)
   - [Life beyond Distributed Transactions](https://queue.acm.org/detail.cfm?id=3025012)

3. **è³‡æº**:
   - [AWS Cost Calculator](https://calculator.aws/)
   - [System Design Primer](https://github.com/donnemartin/system-design-primer)

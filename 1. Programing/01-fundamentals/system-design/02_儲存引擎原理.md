# å„²å­˜å¼•æ“åŸç†

## ğŸ¯ å­¸ç¿’ç›®æ¨™

æœ¬ç« å°‡å¹«åŠ©ä½ ç†è§£ï¼š
- è³‡æ–™åº«å¦‚ä½•åœ¨ç£ç¢Ÿä¸Šå„²å­˜èˆ‡æª¢ç´¢è³‡æ–™
- LSM-Tree vs B-Tree çš„æ¬Šè¡¡
- OLTP vs OLAP çš„å·®ç•°
- ç´¢å¼•çµæ§‹èˆ‡æ•ˆèƒ½å„ªåŒ–
- åˆ—å¼å„²å­˜çš„å„ªå‹¢

---

## ğŸ’¡ å„²å­˜å¼•æ“çš„é‡è¦æ€§

**é¸æ“‡åˆé©çš„å„²å­˜å¼•æ“ï¼Œæ•ˆèƒ½å¯èƒ½å·®è· 10-1000 å€**

```mermaid
graph TD
    A["æ‡‰ç”¨ç¨‹å¼"] --> B["è³‡æ–™åº« API"]
    B --> C["æŸ¥è©¢å„ªåŒ–å™¨"]
    C --> D["å„²å­˜å¼•æ“"]
    D --> E["ç£ç¢Ÿ"]
    
    style D fill:#f96
```

å„²å­˜å¼•æ“æ±ºå®šï¼š
- **å¯«å…¥æ•ˆèƒ½**ï¼šå¦‚ä½•é«˜æ•ˆå¯«å…¥è³‡æ–™
- **è®€å–æ•ˆèƒ½**ï¼šå¦‚ä½•å¿«é€ŸæŸ¥è©¢è³‡æ–™
- **ç©ºé–“æ•ˆç‡**ï¼šè³‡æ–™å£“ç¸®èˆ‡å„²å­˜
- **ä¸¦ç™¼æ§åˆ¶**ï¼šå¤šç”¨æˆ¶åŒæ™‚å­˜å–

---

## ğŸ” æœ€ç°¡å–®çš„è³‡æ–™åº«

### Append-Only Log

**ä¸–ç•Œä¸Šæœ€ç°¡å–®çš„è³‡æ–™åº«**

```bash
#!/bin/bash

# å¯«å…¥ï¼šè¿½åŠ åˆ°æª”æ¡ˆæœ«å°¾
db_set() {
  echo "$1,$2" >> database.txt
}

# è®€å–ï¼šå¾å¾Œå¾€å‰æ‰¾æœ€æ–°çš„å€¼
db_get() {
  grep "^$1," database.txt | tail -n 1 | cut -d, -f2
}
```

**ä½¿ç”¨ç¯„ä¾‹**

```bash
$ db_set "name" "Alice"
$ db_set "age" "25"
$ db_set "name" "Bob"    # æ›´æ–° name
$ db_get "name"
Bob                       # è¿”å›æœ€æ–°å€¼

$ cat database.txt
name,Alice
age,25
name,Bob
```

**æ•ˆèƒ½åˆ†æ**

```yaml
å¯«å…¥ (Append):
  - æ™‚é–“è¤‡é›œåº¦: O(1)
  - å„ªé»: æ¥µå¿«
  - åŸå› : é †åºå¯«å…¥ç£ç¢Ÿ

è®€å– (Scan):
  - æ™‚é–“è¤‡é›œåº¦: O(n)
  - ç¼ºé»: æ¥µæ…¢
  - åŸå› : éœ€è¦æƒææ•´å€‹æª”æ¡ˆ
```

### åŠ å…¥ç´¢å¼•

**ç‚ºäº†åŠ é€Ÿè®€å–ï¼Œæˆ‘å€‘éœ€è¦ç´¢å¼•**

```mermaid
graph LR
    A["ç´¢å¼•<br/>Hash Table"] --> B["Key: name<br/>Value: offset 42"]
    A --> C["Key: age<br/>Value: offset 28"]
    
    B -.->|æŒ‡å‘| D["æª”æ¡ˆä½ç½® 42:<br/>name,Bob"]
    C -.->|æŒ‡å‘| E["æª”æ¡ˆä½ç½® 28:<br/>age,25"]
```

**æ”¹é€²ç‰ˆæœ¬**

```python
import os

class SimpleDB:
    def __init__(self, filename):
        self.filename = filename
        self.index = {}  # Key -> File Offset
        self._build_index()
    
    def _build_index(self):
        """å•Ÿå‹•æ™‚é‡å»ºç´¢å¼•"""
        if not os.path.exists(self.filename):
            return
        
        with open(self.filename, 'r') as f:
            offset = 0
            for line in f:
                key = line.split(',')[0]
                self.index[key] = offset
                offset = f.tell()
    
    def set(self, key, value):
        """å¯«å…¥è³‡æ–™"""
        with open(self.filename, 'a') as f:
            offset = f.tell()
            f.write(f"{key},{value}\n")
            self.index[key] = offset  # æ›´æ–°ç´¢å¼•
    
    def get(self, key):
        """è®€å–è³‡æ–™"""
        if key not in self.index:
            return None
        
        with open(self.filename, 'r') as f:
            f.seek(self.index[key])  # ç›´æ¥è·³åˆ°ä½ç½®
            line = f.readline()
            return line.split(',')[1].strip()
```

**æ•ˆèƒ½æ”¹é€²**

```yaml
å¯«å…¥:
  - æ™‚é–“è¤‡é›œåº¦: O(1)
  - ç¶­è­·ç´¢å¼•: O(1)
  - ç¸½é«”: O(1)

è®€å–:
  - æŸ¥ç´¢å¼•: O(1) - Hash Table
  - è®€æª”æ¡ˆ: O(1) - ç›´æ¥ seek
  - ç¸½é«”: O(1)

å•é¡Œ:
  - âŒ æª”æ¡ˆç„¡é™å¢é•·
  - âŒ åˆªé™¤çš„è³‡æ–™ä»å ç©ºé–“
  - âŒ ç•¶æ©Ÿæ™‚ç´¢å¼•éºå¤±
```

---

## ğŸ“Š Hash ç´¢å¼•èˆ‡ Compaction

### å•é¡Œï¼šæª”æ¡ˆæŒçºŒå¢é•·

**è§£æ±ºæ–¹æ¡ˆï¼šSegmentation + Compaction**

```mermaid
graph TD
    A["Segment 1<br/>(èˆŠ)"] --> D["Compaction"]
    B["Segment 2"] --> D
    C["Segment 3<br/>(æ–°)"] --> E["æŒçºŒå¯«å…¥"]
    
    D --> F["åˆä½µå¾Œçš„ Segment<br/>åªä¿ç•™æœ€æ–°å€¼"]
    
    subgraph "Compaction éç¨‹"
        G["name,Alice<br/>age,25<br/>name,Bob"] --> H["name,Bob<br/>age,25"]
    end
```

### Bitcask æ¨¡å‹

**Riak çš„é è¨­å„²å­˜å¼•æ“**

```mermaid
graph LR
    A["å¯«å…¥"] --> B["ç•¶å‰ Segment"]
    B -->|å¤§å°é”åˆ°é–¾å€¼| C["å‡çµ"]
    C --> D["æ–° Segment"]
    
    E["èƒŒæ™¯åŸ·è¡Œç·’"] --> F["åˆä½µèˆŠ Segments"]
    F --> G["åˆªé™¤é‡è¤‡ Key"]
    
    H["è®€å–"] --> I["æŸ¥è©¢æ‰€æœ‰ Segment"]
    I --> J["å¾æ–°åˆ°èˆŠæŸ¥æ‰¾"]
```

**è¨­è¨ˆè¦é»**

```yaml
æª”æ¡ˆæ ¼å¼:
  - äºŒé€²åˆ¶æ ¼å¼æ›´é«˜æ•ˆ
  - æ¯æ¢è¨˜éŒ„: [Keyé•·åº¦][Valueé•·åº¦][Key][Value]

åˆªé™¤è¨˜éŒ„:
  - å¯«å…¥ç‰¹æ®Šæ¨™è¨˜ (Tombstone)
  - Compaction æ™‚ç§»é™¤

ç•¶æ©Ÿæ¢å¾©:
  - é‡å»ºç´¢å¼•è€—æ™‚
  - è§£æ³•: å®šæœŸå„²å­˜ç´¢å¼•å¿«ç…§

ä¸¦ç™¼æ§åˆ¶:
  - å–®ä¸€å¯«å…¥åŸ·è¡Œç·’
  - å¤šå€‹è®€å–åŸ·è¡Œç·’

éƒ¨åˆ†æ›´æ–°:
  - ä¸æ”¯æ´
  - å¿…é ˆé‡å¯«æ•´å€‹å€¼
```

**Hash ç´¢å¼•çš„é™åˆ¶**

```yaml
å„ªå‹¢:
  - âœ… è®€å¯«éƒ½æ˜¯ O(1)
  - âœ… å¯¦ä½œç°¡å–®
  - âœ… é †åºå¯«å…¥å¿«é€Ÿ

åŠ£å‹¢:
  - âŒ ç´¢å¼•å¿…é ˆæ”¾è¨˜æ†¶é«”
  - âŒ ä¸æ”¯æ´ç¯„åœæŸ¥è©¢
  - âŒ Key æ•¸é‡å—é™æ–¼è¨˜æ†¶é«”å¤§å°
```

---

## ğŸŒ² LSM-Tree (Log-Structured Merge Tree)

### SSTable (Sorted String Table)

**é—œéµæ”¹é€²ï¼šSegment å…§éƒ¨ Key æ’åº**

```
æ™®é€š Segment:
name,Bob
age,25
city,Taipei
name,Alice     # Key å¯é‡è¤‡

SSTable:
age,25
city,Taipei
name,Alice     # Key æŒ‰å­—å…¸åºæ’åˆ—
```

**SSTable çš„å„ªå‹¢**

```mermaid
graph TD
    A["SSTable"] --> B["Key å·²æ’åº"]
    B --> C["åˆä½µæ•ˆç‡é«˜<br/>é¡ä¼¼ Merge Sort"]
    B --> D["ç´¢å¼•å¯ä»¥ç¨€ç–<br/>çœè¨˜æ†¶é«”"]
    B --> E["æ”¯æ´ç¯„åœæŸ¥è©¢"]
    
    D --> D1["åªéœ€è¨˜éŒ„éƒ¨åˆ† Key<br/>å…¶ä»–ç”¨äºŒåˆ†æœå°‹"]
```

### LSM-Tree å®Œæ•´æ¶æ§‹

```mermaid
graph TD
    A["å¯«å…¥"] --> B["MemTable<br/>(è¨˜æ†¶é«”, ç´…é»‘æ¨¹)"]
    B -->|é”åˆ°é–¾å€¼| C["å¯«å…¥ç£ç¢Ÿ<br/>SSTable Level 0"]
    
    C --> D["Level 0<br/>å¤šå€‹ SSTable"]
    D -->|Compaction| E["Level 1<br/>åˆä½µå¾Œ SSTable"]
    E -->|Compaction| F["Level 2"]
    F --> G["..."]
    
    H["è®€å–"] --> I["æŸ¥ MemTable"]
    I --> J["æŸ¥ Level 0"]
    J --> K["æŸ¥ Level 1..."]
```

**å¯«å…¥æµç¨‹**

```python
class LSMTree:
    def __init__(self):
        self.memtable = {}  # è¨˜æ†¶é«”è¡¨ (å¯¦éš›ç”¨ç´…é»‘æ¨¹)
        self.wal = WAL()    # Write-Ahead Log
        self.sstables = []  # ç£ç¢Ÿä¸Šçš„ SSTable
    
    def put(self, key, value):
        # 1. å…ˆå¯« WAL (é˜²æ­¢ç•¶æ©Ÿ)
        self.wal.append(key, value)
        
        # 2. å¯«å…¥ MemTable
        self.memtable[key] = value
        
        # 3. MemTable å¤ªå¤§æ™‚åˆ·åˆ°ç£ç¢Ÿ
        if len(self.memtable) > THRESHOLD:
            self._flush_memtable()
    
    def _flush_memtable(self):
        # å°‡ MemTable æ’åºå¾Œå¯«å…¥ SSTable
        sorted_data = sorted(self.memtable.items())
        new_sstable = SSTable.create(sorted_data)
        self.sstables.append(new_sstable)
        
        # æ¸…ç©º MemTable
        self.memtable = {}
        self.wal.clear()
        
        # è§¸ç™¼ Compaction
        self._maybe_compact()
```

**è®€å–æµç¨‹**

```python
    def get(self, key):
        # 1. å…ˆæŸ¥ MemTable
        if key in self.memtable:
            return self.memtable[key]
        
        # 2. å¾æ–°åˆ°èˆŠæŸ¥ SSTable
        for sstable in reversed(self.sstables):
            value = sstable.get(key)
            if value is not None:
                return value
        
        return None  # æ‰¾ä¸åˆ°
```

### Bloom Filter å„ªåŒ–

**å•é¡Œï¼šæŸ¥è©¢ä¸å­˜åœ¨çš„ Key å¾ˆæ…¢**

```mermaid
graph LR
    A["æŸ¥è©¢ 'xyz'"] --> B["æŸ¥ MemTable<br/>æ²’æœ‰"]
    B --> C["æŸ¥ SSTable 1<br/>æ²’æœ‰"]
    C --> D["æŸ¥ SSTable 2<br/>æ²’æœ‰"]
    D --> E["æŸ¥ SSTable 3<br/>æ²’æœ‰"]
    E --> F["..."]
    
    style A fill:#f99
```

**è§£æ±ºæ–¹æ¡ˆï¼šBloom Filter**

```python
class BloomFilter:
    """ç©ºé–“é«˜æ•ˆçš„æ¦‚ç‡æ€§è³‡æ–™çµæ§‹"""
    
    def __init__(self, size, hash_count):
        self.bit_array = [0] * size
        self.hash_count = hash_count
    
    def add(self, key):
        for i in range(self.hash_count):
            index = hash(key, i) % len(self.bit_array)
            self.bit_array[index] = 1
    
    def might_contain(self, key):
        """å¯èƒ½åŒ…å« (å¯èƒ½èª¤åˆ¤) æˆ– ç¢ºå®šä¸åŒ…å«"""
        for i in range(self.hash_count):
            index = hash(key, i) % len(self.bit_array)
            if self.bit_array[index] == 0:
                return False  # ç¢ºå®šä¸å­˜åœ¨
        return True  # å¯èƒ½å­˜åœ¨
```

**ä½¿ç”¨ Bloom Filter å¾Œ**

```python
    def get(self, key):
        # å¿«é€Ÿæª¢æŸ¥ï¼šé€™å€‹ SSTable å¯èƒ½æœ‰é€™å€‹ Key å—ï¼Ÿ
        for sstable in reversed(self.sstables):
            if not sstable.bloom_filter.might_contain(key):
                continue  # è·³éé€™å€‹ SSTable
            
            value = sstable.get(key)
            if value is not None:
                return value
```

**Bloom Filter ç‰¹æ€§**

```yaml
å„ªé»:
  - ç©ºé–“æ¥µå° (æ¯å€‹ Key ç´„ 10 bits)
  - æŸ¥è©¢æ¥µå¿« (å¹¾æ¬¡ Hash)

ç¼ºé»:
  - å¯èƒ½èª¤åˆ¤ (èªªæœ‰ä½†æ²’æœ‰)
  - çµ•ä¸æ¼åˆ¤ (èªªæ²’æœ‰å°±çœŸæ²’æœ‰)

é…ç½®:
  - 1% èª¤åˆ¤ç‡: ç´„ 10 bits per key
  - 0.1% èª¤åˆ¤ç‡: ç´„ 15 bits per key
```

### Compaction ç­–ç•¥

**Size-Tiered Compaction** (Cassandra, HBase)

```mermaid
graph TD
    A["Level 0:<br/>4 å€‹ SSTable"] -->|å¤§å°ç›¸ä¼¼æ™‚åˆä½µ| B["Level 1:<br/>1 å€‹å¤§ SSTable"]
    B --> C["Level 2:<br/>æ›´å¤§çš„ SSTable"]
```

**Leveled Compaction** (LevelDB, RocksDB)

```mermaid
graph TD
    A["Level 0:<br/>å…è¨±é‡ç–Š"] --> B["Level 1:<br/>10 MB æ¯å€‹, ä¸é‡ç–Š"]
    B --> C["Level 2:<br/>100 MB æ¯å€‹, ä¸é‡ç–Š"]
    C --> D["Level 3:<br/>1 GB æ¯å€‹"]
```

**æ¬Šè¡¡å°æ¯”**

```yaml
Size-Tiered:
  å¯«å…¥æ”¾å¤§: ä½
  è®€å–æ”¾å¤§: é«˜ (éœ€æŸ¥å¤šå€‹æª”æ¡ˆ)
  ç©ºé–“æ”¾å¤§: é«˜ (èˆŠè³‡æ–™å»¶é²åˆªé™¤)
  é©åˆ: å¯«å…¥å¯†é›†

Leveled:
  å¯«å…¥æ”¾å¤§: é«˜ (éœ€å¤šæ¬¡é‡å¯«)
  è®€å–æ”¾å¤§: ä½ (æ¯å±¤æœ€å¤šä¸€å€‹æª”æ¡ˆ)
  ç©ºé–“æ”¾å¤§: ä½
  é©åˆ: è®€å–å¯†é›†
```

### LSM-Tree å¯¦éš›æ‡‰ç”¨

```yaml
LevelDB:
  - Google é–‹ç™¼
  - å–®æ©Ÿ Key-Value Store
  - Chrome IndexedDB åº•å±¤

RocksDB:
  - Facebook åŸºæ–¼ LevelDB
  - æ•ˆèƒ½å„ªåŒ–ã€å¯é…ç½®
  - MyRocks (MySQL), MongoDB ä½¿ç”¨

Cassandra:
  - åˆ†æ•£å¼ LSM-Tree
  - Size-Tiered Compaction
  - é«˜å¯«å…¥ååé‡

HBase:
  - åŸºæ–¼ Hadoop
  - LSM-Tree æ¶æ§‹
  - å¤§è³‡æ–™å ´æ™¯
```

---

## ğŸŒ³ B-Tree

### B-Tree çš„æ ¸å¿ƒæ¦‚å¿µ

**å‚³çµ±é—œè¯å¼è³‡æ–™åº«çš„æ¨™æº–ç´¢å¼•**

```mermaid
graph TD
    A["Root<br/>[20 | 50]"] --> B["[5|10|15]"]
    A --> C["[25|30|40]"]
    A --> D["[55|60|70]"]
    
    B --> B1["1-4"]
    B --> B2["5-9"]
    B --> B3["10-14"]
    B --> B4["15-19"]
    
    style A fill:#9cf
```

**B-Tree vs äºŒå…ƒæ¨¹**

```yaml
äºŒå…ƒæ¨¹:
  - æ¯å€‹ç¯€é»æœ€å¤š 2 å€‹å­ç¯€é»
  - æ·±åº¦ logâ‚‚(n)
  - ç£ç¢Ÿ I/O å¤š

B-Tree:
  - æ¯å€‹ç¯€é»æ•¸ç™¾å€‹å­ç¯€é»
  - æ·±åº¦ logâ‚â‚€â‚€(n) 
  - ç£ç¢Ÿ I/O å°‘
  
ç¯„ä¾‹:
  1 å„„ç­†è³‡æ–™
  - äºŒå…ƒæ¨¹æ·±åº¦: ~27 å±¤
  - B-Tree æ·±åº¦: ~4 å±¤
```

### B-Tree çš„æ“ä½œ

**æŸ¥è©¢æµç¨‹**

```python
def search(root, key):
    node = root
    
    while not node.is_leaf:
        # åœ¨ç¯€é»å…§äºŒåˆ†æœå°‹
        i = binary_search(node.keys, key)
        
        if node.keys[i] == key:
            return node.values[i]  # æ‰¾åˆ°
        
        # å¾€ä¸‹èµ°
        node = node.children[i]
    
    # åœ¨è‘‰ç¯€é»æŸ¥æ‰¾
    return node.get(key)
```

**æ’å…¥æµç¨‹**

```mermaid
graph TD
    A["æ’å…¥ Key"] --> B{è‘‰ç¯€é»æœ‰ç©ºé–“?}
    B -->|æ˜¯| C["ç›´æ¥æ’å…¥"]
    B -->|å¦| D["åˆ†è£‚ç¯€é»"]
    
    D --> E["ä¸­é–“ Key ä¸Šæ¨"]
    E --> F{çˆ¶ç¯€é»æœ‰ç©ºé–“?}
    F -->|æ˜¯| G["æ’å…¥çˆ¶ç¯€é»"]
    F -->|å¦| H["éè¿´åˆ†è£‚"]
    
    H -->|åˆ° Root| I["å‰µå»ºæ–° Root<br/>æ¨¹é•·é«˜"]
```

**ç¯„ä¾‹ï¼šæ’å…¥å°è‡´åˆ†è£‚**

```
åˆå§‹ç‹€æ…‹:
[10 | 20 | 30 | 40]  (å·²æ»¿, æœ€å¤š 4 å€‹ Key)

æ’å…¥ 25:
[10 | 20] â†’ 30 â†‘ â† [40 | 25æ’åºå¾Œ = 25,40]
           
çµæœ:
          [30]
         /    \
    [10|20]  [25|40]
```

### B-Tree vs LSM-Tree å°æ¯”

```mermaid
graph TB
    subgraph "B-Tree"
        A1["å¯«å…¥"] --> A2["åŸåœ°æ›´æ–°"]
        A2 --> A3["éš¨æ©Ÿå¯«å…¥"]
    end
    
    subgraph "LSM-Tree"
        B1["å¯«å…¥"] --> B2["è¿½åŠ æ—¥èªŒ"]
        B2 --> B3["é †åºå¯«å…¥"]
    end
```

**è©³ç´°å°æ¯”**

| ç‰¹æ€§ | B-Tree | LSM-Tree |
|-----|--------|----------|
| **å¯«å…¥** | åŸåœ°æ›´æ–°ã€éš¨æ©Ÿ I/O | é †åºè¿½åŠ ã€é«˜åå |
| **è®€å–** | å–®æ¬¡æŸ¥è©¢å¿« | éœ€æŸ¥å¤šå€‹æª”æ¡ˆ |
| **å¯«å…¥æ”¾å¤§** | ä½ (åªæ›´æ–°å¿…è¦é ) | é«˜ (Compaction é‡å¯«) |
| **ç©ºé–“æ”¾å¤§** | ä¸­ (ç¢ç‰‡) | ä½åˆ°é«˜ (è¦–ç­–ç•¥) |
| **ä¸¦ç™¼** | é ç´šé– | æ›´å¥½ (ä¸è®Šæª”æ¡ˆ) |
| **ç¯„åœæŸ¥è©¢** | å„ªç§€ (è‘‰ç¯€é»ç›¸é€£) | è‰¯å¥½ |
| **æˆç†Ÿåº¦** | æ¥µé«˜ (40+ å¹´) | è¼ƒæ–° |
| **é©ç”¨å ´æ™¯** | è®€å¤šå¯«å°‘ã€OLTP | å¯«å¤šè®€å°‘ã€æ—¥èªŒ |

**å¯«å…¥æ”¾å¤§è¨ˆç®—**

```python
# B-Tree ç¯„ä¾‹
æ¯æ¬¡å¯«å…¥ 1 KB è³‡æ–™
ä½†éœ€è¦:
  - æ›´æ–°è‘‰ç¯€é» (4 KB é )
  - æ›´æ–°çˆ¶ç¯€é» (4 KB é )
  - æ›´æ–° WAL (1 KB)
å¯¦éš›å¯«å…¥: 9 KB
å¯«å…¥æ”¾å¤§: 9x

# LSM-Tree ç¯„ä¾‹
å¯«å…¥ 1 KB åˆ° MemTable
å¾ŒçºŒ Compaction:
  - Level 0â†’1: é‡å¯« 1 æ¬¡
  - Level 1â†’2: é‡å¯« 10 æ¬¡
  - Level 2â†’3: é‡å¯« 10 æ¬¡
ç¸½å¯«å…¥æ”¾å¤§: å¯é” 10-30x (è¦– Compaction ç­–ç•¥)
```

---

## ğŸ“ˆ OLTP vs OLAP

### å…©ç¨®å·¥ä½œè² è¼‰

```mermaid
graph LR
    A["è³‡æ–™åº«å·¥ä½œè² è¼‰"] --> B["OLTP<br/>ç·šä¸Šäº¤æ˜“è™•ç†"]
    A --> C["OLAP<br/>ç·šä¸Šåˆ†æè™•ç†"]
    
    B --> B1["å°æ‰¹é‡è³‡æ–™"]
    B --> B2["é«˜ä¸¦ç™¼"]
    B --> B3["æ¯«ç§’ç´šå›æ‡‰"]
    
    C --> C1["å¤§æ‰¹é‡è³‡æ–™"]
    C --> C2["è¤‡é›œæŸ¥è©¢"]
    C --> C3["ç§’/åˆ†é˜ç´š"]
```

**ç‰¹æ€§å°æ¯”**

| ç‰¹æ€§ | OLTP | OLAP |
|-----|------|------|
| **è®€å–æ¨¡å¼** | å°‘é‡è¨˜éŒ„ï¼Œä¾ Key | å¤§é‡è¨˜éŒ„èšåˆ |
| **å¯«å…¥æ¨¡å¼** | éš¨æ©Ÿå¯«å…¥ï¼Œä½å»¶é² | æ‰¹é‡åŒ¯å…¥ (ETL) |
| **ä½¿ç”¨è€…** | çµ‚ç«¯ç”¨æˆ¶ï¼Œæˆåƒä¸Šè¬ | å…§éƒ¨åˆ†æå¸«ï¼Œå°‘æ•¸ |
| **è³‡æ–™é‡** | GB ~ TB | TB ~ PB |
| **æŸ¥è©¢ç¯„ä¾‹** | æŸ¥è©¢ç”¨æˆ¶è¨‚å–® | æœ¬å­£åº¦éŠ·å”®åˆ†æ |
| **ç“¶é ¸** | ç£ç¢Ÿ seek æ™‚é–“ | ç£ç¢Ÿé »å¯¬ |

**ç¯„ä¾‹å°æ¯”**

```sql
-- OLTP æŸ¥è©¢
SELECT * FROM orders 
WHERE order_id = 'ord_123456';
-- æŸ¥è©¢ 1 ç­†, 0.001 ç§’

-- OLAP æŸ¥è©¢
SELECT 
  product_category,
  SUM(revenue) as total_revenue,
  COUNT(*) as order_count
FROM orders
WHERE order_date >= '2024-01-01'
  AND order_date < '2024-04-01'
GROUP BY product_category
ORDER BY total_revenue DESC;
-- æƒææ•¸ç™¾è¬ç­†, 10 ç§’
```

### è³‡æ–™å€‰å„² (Data Warehouse)

**ç‚ºä»€éº¼éœ€è¦åˆ†é›¢ï¼Ÿ**

```mermaid
graph TB
    A["OLTP è³‡æ–™åº«"] -.->|ETL<br/>Extract Transform Load| B["è³‡æ–™å€‰å„²<br/>OLAP"]
    
    A --> A1["è™•ç†æ¥­å‹™äº¤æ˜“"]
    A --> A2["ç¶­æŒä½å»¶é²"]
    
    B --> B1["è¤‡é›œåˆ†æ"]
    B --> B2["æ­·å²è³‡æ–™"]
    B --> B3["BI å ±è¡¨"]
    
    C["åˆ†æå¸«æŸ¥è©¢"] -.->|ä¸å½±éŸ¿| A
    C --> B
```

**ETL æµç¨‹**

```python
# ç°¡åŒ–çš„ ETL ç¯„ä¾‹
def etl_daily():
    # Extract: å¾ OLTP æå–è³‡æ–™
    orders = extract_from_postgres(
        "SELECT * FROM orders WHERE date = YESTERDAY"
    )
    
    # Transform: è½‰æ›èˆ‡è±å¯Œ
    transformed = []
    for order in orders:
        transformed.append({
            'order_id': order['id'],
            'revenue': order['amount'],
            'product_category': lookup_category(order['product_id']),
            'customer_segment': classify_customer(order['customer_id']),
            'date': order['created_at'].date()
        })
    
    # Load: è¼‰å…¥è³‡æ–™å€‰å„²
    load_to_warehouse(transformed, table='fact_orders')
```

### Star Schema vs Snowflake Schema

**Star Schema (æ˜Ÿå‹æ¶æ§‹)**

```mermaid
erDiagram
    FACT_SALES ||--o{ DIM_DATE : "date_id"
    FACT_SALES ||--o{ DIM_PRODUCT : "product_id"
    FACT_SALES ||--o{ DIM_CUSTOMER : "customer_id"
    FACT_SALES ||--o{ DIM_STORE : "store_id"
    
    FACT_SALES {
        int sale_id PK
        int date_id FK
        int product_id FK
        int customer_id FK
        int store_id FK
        decimal revenue
        int quantity
    }
    
    DIM_PRODUCT {
        int product_id PK
        string name
        string category
        decimal price
    }
```

**Snowflake Schema (é›ªèŠ±æ¶æ§‹)**

```mermaid
erDiagram
    FACT_SALES ||--o{ DIM_PRODUCT : "product_id"
    DIM_PRODUCT ||--o{ DIM_CATEGORY : "category_id"
    DIM_CATEGORY ||--o{ DIM_DEPARTMENT : "dept_id"
    
    FACT_SALES {
        int sale_id PK
        int product_id FK
        decimal revenue
    }
    
    DIM_PRODUCT {
        int product_id PK
        string name
        int category_id FK
    }
    
    DIM_CATEGORY {
        int category_id PK
        string name
        int dept_id FK
    }
    
    DIM_DEPARTMENT {
        int dept_id PK
        string name
    }
```

**é¸æ“‡å»ºè­°**

```yaml
Star Schema:
  å„ªé»:
    - æŸ¥è©¢ç°¡å–® (JOIN å°‘)
    - æ•ˆèƒ½å¥½
    - æ˜“æ–¼ç†è§£
  ç¼ºé»:
    - è³‡æ–™é‡è¤‡ (åæ­£è¦åŒ–)

Snowflake Schema:
  å„ªé»:
    - ç¯€çœç©ºé–“
    - æ­£è¦åŒ–
  ç¼ºé»:
    - æŸ¥è©¢è¤‡é›œ (æ›´å¤š JOIN)
    - æ•ˆèƒ½è¼ƒå·®

æ¨è–¦: Star Schema (ç£ç¢Ÿä¾¿å®œï¼Œæ•ˆèƒ½é‡è¦)
```

---

## ğŸ“Š åˆ—å¼å„²å­˜ (Column-Oriented Storage)

### ç‚ºä»€éº¼éœ€è¦åˆ—å¼å„²å­˜ï¼Ÿ

**OLAP æŸ¥è©¢çš„ç‰¹é»**

```sql
-- å…¸å‹ OLAP æŸ¥è©¢ï¼šåªéœ€å°‘æ•¸æ¬„ä½
SELECT 
  product_category,
  SUM(revenue) 
FROM sales
WHERE date >= '2024-01-01'
GROUP BY product_category;

-- å•é¡Œï¼šè¡¨æœ‰ 100 å€‹æ¬„ä½
-- ä½†æŸ¥è©¢åªç”¨åˆ° 3 å€‹ (date, product_category, revenue)
-- å‚³çµ±è¡Œå¼å„²å­˜ä»éœ€è®€å–æ‰€æœ‰æ¬„ä½ï¼
```

### è¡Œå¼ vs åˆ—å¼å„²å­˜

```mermaid
graph TB
    subgraph "è¡Œå¼å„²å­˜ (Row-Oriented)"
        A1["Row 1: id=1, name=Alice, age=25, city=Taipei, ..."]
        A2["Row 2: id=2, name=Bob, age=30, city=Tokyo, ..."]
        A3["Row 3: id=3, name=Carol, age=28, city=Taipei, ..."]
    end
    
    subgraph "åˆ—å¼å„²å­˜ (Column-Oriented)"
        B1["id: 1, 2, 3, ..."]
        B2["name: Alice, Bob, Carol, ..."]
        B3["age: 25, 30, 28, ..."]
        B4["city: Taipei, Tokyo, Taipei, ..."]
    end
```

**åˆ—å¼å„²å­˜çš„å„ªå‹¢**

```python
# è¡Œå¼å„²å­˜ï¼šè®€å– 1 å„„è¡Œï¼Œæ¯è¡Œ 100 æ¬„ä½
# éœ€è¦è®€å–: 100 å„„å€‹å€¼

# åˆ—å¼å„²å­˜ï¼šåªè®€å–éœ€è¦çš„æ¬„ä½
# éœ€è¦è®€å–: 3 å„„å€‹å€¼ (åƒ…éœ€è¦çš„ 3 å€‹æ¬„ä½)

# æ¸›å°‘ I/O: 97% çš„è³‡æ–™ä¸éœ€è¦è®€å–ï¼
```

### åˆ—å¼å£“ç¸®

**Bitmap Encoding**

```
åŸå§‹è³‡æ–™ (country æ¬„ä½):
Taiwan, USA, Taiwan, Japan, USA, Taiwan, USA

Bitmap:
Taiwan: 1001010
USA:    0101001
Japan:  0010000

æŸ¥è©¢ "Taiwan æˆ– USA":
1001010 OR 0101001 = 1101011
-> Row 0,1,3,4,6

å„ªå‹¢:
- æ¥µé«˜å£“ç¸®æ¯”
- ä½å…ƒé‹ç®—æ¥µå¿«
- é©åˆä½åŸºæ•¸æ¬„ä½
```

**Run-Length Encoding**

```
åŸå§‹è³‡æ–™:
Taiwan, Taiwan, Taiwan, USA, USA, Japan, Japan, Japan, Japan

ç·¨ç¢¼:
Taiwan: 3, USA: 2, Japan: 4

æŸ¥è©¢ç¯„åœ:
Row 0-2: Taiwan
Row 3-4: USA
Row 5-8: Japan
```

**çœŸå¯¦æ¡ˆä¾‹ï¼šæ•ˆèƒ½æå‡**

```yaml
Scenario: 10 å„„è¡Œè³‡æ–™ï¼Œ100 å€‹æ¬„ä½

è¡Œå¼å„²å­˜:
  - åŸå§‹å¤§å°: 1 TB
  - æŸ¥è©¢éœ€è®€å–: 1 TB
  - æŸ¥è©¢æ™‚é–“: 60 ç§’

åˆ—å¼å„²å­˜ + å£“ç¸®:
  - å£“ç¸®å¾Œå¤§å°: 100 GB (10x)
  - æŸ¥è©¢éœ€è®€å–: 3 GB (åªè®€ 3 å€‹æ¬„ä½)
  - æŸ¥è©¢æ™‚é–“: 2 ç§’ (30x faster!)
```

### åˆ—å¼å„²å­˜çš„å¯«å…¥

**å•é¡Œï¼šå¯«å…¥è®Šè¤‡é›œ**

```mermaid
graph TD
    A["æ–°å¢ä¸€è¡Œè³‡æ–™"] --> B["éœ€è¦å¯«å…¥æ¯å€‹æ¬„ä½æª”æ¡ˆ"]
    B --> C["100 å€‹æ¬„ä½<br/>= 100 æ¬¡éš¨æ©Ÿå¯«å…¥"]
    
    style C fill:#f99
```

**è§£æ±ºæ–¹æ¡ˆï¼šLSM-Tree æ··åˆ**

```yaml
æ¶æ§‹:
  - å¯«å…¥: å…ˆåˆ° MemTable (è¡Œå¼)
  - å®šæœŸåˆ·åˆ°ç£ç¢Ÿæ™‚: è½‰æ›ç‚ºåˆ—å¼æ ¼å¼
  - è®€å–: åˆä½µ MemTable + åˆ—å¼æª”æ¡ˆ

ç¯„ä¾‹: Apache Parquet, ORC
```

### å¯¦éš›ç”¢å“

```yaml
ClickHouse:
  - æ¥µè‡´åˆ—å¼å„²å­˜
  - å³æ™‚ OLAP
  - æ•¸åå„„è¡Œç§’ç´šæŸ¥è©¢

Apache Parquet:
  - Hadoop ç”Ÿæ…‹æ¨™æº–
  - åˆ—å¼æª”æ¡ˆæ ¼å¼
  - Spark, Hive æ”¯æ´

Amazon Redshift:
  - é›²ç«¯è³‡æ–™å€‰å„²
  - åˆ—å¼å„²å­˜
  - MPP æ¶æ§‹

Google BigQuery:
  - Serverless
  - åˆ—å¼å„²å­˜ (Capacitor)
  - PB ç´šè³‡æ–™åˆ†æ
```

---

## ğŸ’» å¯¦æˆ°ï¼šé¸æ“‡åˆé©çš„å„²å­˜å¼•æ“

### æ±ºç­–æµç¨‹åœ–

```mermaid
graph TD
    A["é¸æ“‡å„²å­˜å¼•æ“"] --> B{å·¥ä½œè² è¼‰?}
    
    B -->|OLTP| C{è®€å¯«æ¯”?}
    B -->|OLAP| D["åˆ—å¼å„²å­˜"]
    
    C -->|å¯«å¤š| E["LSM-Tree"]
    C -->|è®€å¤š| F["B-Tree"]
    C -->|å¹³è¡¡| G["B-Tree"]
    
    E --> E1["RocksDB<br/>Cassandra"]
    F --> F1["PostgreSQL<br/>MySQL"]
    D --> D1["ClickHouse<br/>Redshift"]
```

### å ´æ™¯å°æ‡‰è¡¨

| å ´æ™¯ | æ¨è–¦å¼•æ“ | åŸå›  |
|-----|---------|------|
| ç”¨æˆ¶è³‡æ–™ã€è¨‚å–® | B-Tree (PostgreSQL) | äº‹å‹™ã€ä¸€è‡´æ€§ |
| æ™‚åºè³‡æ–™ã€æ—¥èªŒ | LSM-Tree (InfluxDB) | é«˜å¯«å…¥åå |
| å³æ™‚åˆ†æ | åˆ—å¼ (ClickHouse) | èšåˆæŸ¥è©¢å¿« |
| å¿«å–ã€è¨ˆæ•¸å™¨ | Hash Index (Redis) | æ¥µä½å»¶é² |
| å…¨æ–‡æœå°‹ | å€’æ’ç´¢å¼• (Elasticsearch) | æ–‡å­—æŸ¥è©¢ |
| åœ–é—œä¿‚ | é„°æ¥è¡¨ (Neo4j) | è·¯å¾‘æŸ¥è©¢ |

---

## ğŸ¤” æ€è€ƒé¡Œ

### 1. ç‚ºä»€éº¼ SSD ä»ç„¶åå¥½é †åºå¯«å…¥ï¼Ÿ

<details>
<summary>ç­”æ¡ˆ</summary>

é›–ç„¶ SSD éš¨æ©Ÿè®€å–å¾ˆå¿«ï¼Œä½†ï¼š

1. **å¯«å…¥æ”¾å¤§**ï¼šSSD éœ€ä»¥ Block ç‚ºå–®ä½æŠ¹é™¤
2. **ä¸¦è¡Œæ€§**ï¼šé †åºå¯«å…¥èƒ½åˆ©ç”¨å¤šé€šé“ä¸¦è¡Œ
3. **é å–**ï¼šOS èƒ½é æ¸¬é †åºå­˜å–æ¨¡å¼
4. **ç£¨æå‡è¡¡**ï¼šéš¨æ©Ÿå¯«å…¥åŠ é€Ÿç£¨æ

å¯¦æ¸¬ï¼šSSD é †åºå¯«å…¥ä»æ¯”éš¨æ©Ÿå¯«å…¥å¿« 3-5 å€
</details>

### 2. ä½•æ™‚æ‡‰è©²ä½¿ç”¨è¦†è“‹ç´¢å¼• (Covering Index)ï¼Ÿ

<details>
<summary>ç­”æ¡ˆ</summary>

**è¦†è“‹ç´¢å¼•**ï¼šç´¢å¼•åŒ…å«æŸ¥è©¢æ‰€éœ€çš„æ‰€æœ‰æ¬„ä½

```sql
-- æŸ¥è©¢åªéœ€è¦ user_id å’Œ email
SELECT user_id, email 
FROM users 
WHERE status = 'active';

-- å¦‚æœç´¢å¼•æ˜¯ (status, user_id, email)
-- å‰‡ä¸éœ€è¦å›è¡¨æŸ¥è©¢ (Index-Only Scan)
```

**é©ç”¨å ´æ™¯**ï¼š
- æŸ¥è©¢æ¬„ä½å°‘
- æŸ¥è©¢é »ç¹
- æ¬„ä½è³‡æ–™å°

**Trade-off**ï¼š
- âœ… æŸ¥è©¢å¿«
- âŒ ç´¢å¼•æ›´å¤§
- âŒ å¯«å…¥è®Šæ…¢
</details>

---

## ğŸ“š æœ¬ç« ç¸½çµ

### æ ¸å¿ƒè¦é»

1. **ç´¢å¼•æ˜¯æ•ˆèƒ½é—œéµ**ï¼šé¸å°ç´¢å¼•ï¼Œå¿« 1000 å€
2. **å…©å¤§é™£ç‡Ÿ**ï¼š
   - LSM-Treeï¼šå¯«å…¥å„ªåŒ–ã€é †åº I/O
   - B-Treeï¼šè®€å–å„ªåŒ–ã€åŸåœ°æ›´æ–°
3. **OLTP vs OLAP**ï¼šä¸åŒå·¥ä½œè² è¼‰éœ€è¦ä¸åŒå¼•æ“
4. **åˆ—å¼å„²å­˜**ï¼šOLAP çš„é©å‘½æ€§æ”¹é€²

### é¸æ“‡å»ºè­°

```yaml
é è¨­é¸æ“‡:
  - OLTP: PostgreSQL (B-Tree)
  - é«˜å¯«å…¥: RocksDB (LSM-Tree)
  - OLAP: ClickHouse (åˆ—å¼)

æŒçºŒç›£æ§:
  - å¯«å…¥ååé‡
  - æŸ¥è©¢å»¶é²
  - ç£ç¢Ÿä½¿ç”¨é‡
  - Compaction ç‹€æ³

é©æ™‚èª¿æ•´:
  - ç´¢å¼•ç­–ç•¥
  - Compaction åƒæ•¸
  - è³‡æ–™åˆ†å€
```

### ä¸‹ä¸€ç« é å‘Š

åœ¨ä¸‹ä¸€ç« ã€Šè³‡æ–™ç·¨ç¢¼èˆ‡æ¼”åŒ–ã€‹ä¸­ï¼Œæˆ‘å€‘å°‡æ¢è¨ï¼š
- è³‡æ–™åºåˆ—åŒ–æ ¼å¼
- å‘å‰/å‘å¾Œç›¸å®¹æ€§
- Schema æ¼”åŒ–ç­–ç•¥
- è³‡æ–™æµæ¨¡å¼

---

## åƒè€ƒè³‡æ–™ (References)

1. Martin Kleppmann, *Designing Data-Intensive Applications*, Chapter 3 (O'Reilly, 2017)
2. [LevelDB Implementation](https://github.com/google/leveldb)
3. [RocksDB Tuning Guide](https://github.com/facebook/rocksdb/wiki/RocksDB-Tuning-Guide)
4. Patrick O'Neil et al., ["The Log-Structured Merge-Tree (LSM-Tree)"](http://www.cs.umb.edu/~poneil/lsmtree.pdf) (1996)
5. [ClickHouse Documentation](https://clickhouse.com/docs/)
6. [Parquet File Format](https://parquet.apache.org/docs/)

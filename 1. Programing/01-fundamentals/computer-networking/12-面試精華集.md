# 12 é¢è©¦ç²¾è¯é›†

## ç›®éŒ„
1. [åŸºç¤æ¦‚å¿µå•ç­”](#åŸºç¤æ¦‚å¿µå•ç­”)
2. [å”è­°æ·±åº¦å•é¡Œ](#å”è­°æ·±åº¦å•é¡Œ)
3. [æ•ˆèƒ½å„ªåŒ–å•é¡Œ](#æ•ˆèƒ½å„ªåŒ–å•é¡Œ)
4. [æ•…éšœæ’æŸ¥å•é¡Œ](#æ•…éšœæ’æŸ¥å•é¡Œ)
5. [ç³»çµ±è¨­è¨ˆå•é¡Œ](#ç³»çµ±è¨­è¨ˆå•é¡Œ)
6. [ç·¨ç¨‹å¯¦ä½œé¡Œ](#ç·¨ç¨‹å¯¦ä½œé¡Œ)
7. [é¢è©¦ç­–ç•¥èˆ‡æŠ€å·§](#é¢è©¦ç­–ç•¥èˆ‡æŠ€å·§)

## åŸºç¤æ¦‚å¿µå•ç­”

### OSI ä¸ƒå±¤æ¨¡å‹ç›¸é—œ

**Q1: è§£é‡‹ OSI ä¸ƒå±¤æ¨¡å‹ï¼Œä¸¦èªªæ˜ TCP/IP å››å±¤æ¨¡å‹èˆ‡å…¶å°æ‡‰é—œä¿‚**

**æ¨™æº–ç­”æ¡ˆ:**
```
OSI ä¸ƒå±¤æ¨¡å‹:
- æ‡‰ç”¨å±¤ (Application Layer): HTTP, FTP, SMTP
- è¡¨ç¤ºå±¤ (Presentation Layer): æ•¸æ“šåŠ å¯†ã€å£“ç¸®ã€æ ¼å¼è½‰æ›
- æœƒè©±å±¤ (Session Layer): å»ºç«‹ã€ç®¡ç†ã€çµ‚æ­¢æœƒè©±
- å‚³è¼¸å±¤ (Transport Layer): TCP, UDP, ç«¯åˆ°ç«¯å¯é å‚³è¼¸
- ç¶²è·¯å±¤ (Network Layer): IP, è·¯ç”±é¸æ“‡
- è³‡æ–™éˆçµå±¤ (Data Link Layer): ä¹™å¤ªç¶², å¹€æ ¼å¼
- å¯¦é«”å±¤ (Physical Layer): é›»çºœã€å…‰çº–ã€ç„¡ç·šä¿¡è™Ÿ

TCP/IP å°æ‡‰é—œä¿‚:
- æ‡‰ç”¨å±¤ â†’ OSI æ‡‰ç”¨å±¤ + è¡¨ç¤ºå±¤ + æœƒè©±å±¤
- å‚³è¼¸å±¤ â†’ OSI å‚³è¼¸å±¤
- ç¶²è·¯å±¤ â†’ OSI ç¶²è·¯å±¤  
- ç¶²è·¯ä»‹é¢å±¤ â†’ OSI è³‡æ–™éˆçµå±¤ + å¯¦é«”å±¤
```

**é€²éšè¿½å•:** "ç‚ºä»€éº¼å¯¦éš›æ‡‰ç”¨ä¸­ TCP/IP æ¯” OSI æ›´æ™®åŠï¼Ÿ"

**Q2: èªªæ˜ TCP ä¸‰æ¬¡æ¡æ‰‹å’Œå››æ¬¡æ®æ‰‹çš„è©³ç´°éç¨‹**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// ä¸‰æ¬¡æ¡æ‰‹ç‹€æ…‹è½‰æ›
typedef enum {
    TCP_CLOSED = 0,
    TCP_LISTEN,
    TCP_SYN_SENT,
    TCP_SYN_RECEIVED,
    TCP_ESTABLISHED
} tcp_handshake_state_t;

// ä¸‰æ¬¡æ¡æ‰‹éç¨‹:
// 1. Client â†’ Server: SYN (seq=x)
// 2. Server â†’ Client: SYN+ACK (seq=y, ack=x+1)  
// 3. Client â†’ Server: ACK (ack=y+1)

// å››æ¬¡æ®æ‰‹ç‹€æ…‹
typedef enum {
    TCP_FIN_WAIT_1,
    TCP_FIN_WAIT_2,
    TCP_TIME_WAIT,
    TCP_CLOSE_WAIT,
    TCP_LAST_ACK
} tcp_close_state_t;

// å››æ¬¡æ®æ‰‹éç¨‹:
// 1. Client â†’ Server: FIN (seq=u)
// 2. Server â†’ Client: ACK (ack=u+1)
// 3. Server â†’ Client: FIN (seq=v)
// 4. Client â†’ Server: ACK (ack=v+1)
```

**é€²éšè¿½å•:** "TIME_WAIT ç‹€æ…‹ç‚ºä»€éº¼è¦ç­‰å¾… 2MSLï¼Ÿ"

### ç¶²è·¯åœ°å€èˆ‡è·¯ç”±

**Q3: è§£é‡‹ CIDR è¨˜æ³•å’Œå­ç¶²è·¯åŠƒåˆ†**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// CIDR è¨ˆç®—å‡½æ•¸
typedef struct {
    uint32_t network;      // ç¶²è·¯åœ°å€
    uint32_t netmask;      // å­ç¶²è·¯é®ç½©  
    uint32_t broadcast;    // å»£æ’­åœ°å€
    uint32_t host_min;     // ä¸»æ©Ÿæœ€å°åœ°å€
    uint32_t host_max;     // ä¸»æ©Ÿæœ€å¤§åœ°å€
    uint32_t host_count;   // å¯ç”¨ä¸»æ©Ÿæ•¸
} cidr_info_t;

cidr_info_t calculate_cidr(uint32_t ip, uint8_t prefix_len) {
    cidr_info_t info;
    
    // è¨ˆç®—å­ç¶²è·¯é®ç½©
    info.netmask = htonl(~((1ULL << (32 - prefix_len)) - 1));
    
    // è¨ˆç®—ç¶²è·¯åœ°å€
    info.network = ip & info.netmask;
    
    // è¨ˆç®—å»£æ’­åœ°å€
    info.broadcast = info.network | (~info.netmask);
    
    // è¨ˆç®—ä¸»æ©Ÿç¯„åœ
    info.host_min = info.network + 1;
    info.host_max = info.broadcast - 1;
    info.host_count = (1ULL << (32 - prefix_len)) - 2;
    
    return info;
}

// ç¤ºä¾‹: 192.168.1.0/24
// ç¶²è·¯åœ°å€: 192.168.1.0
// å­ç¶²è·¯é®ç½©: 255.255.255.0
// å¯ç”¨ä¸»æ©Ÿ: 254 å€‹ (192.168.1.1 - 192.168.1.254)
```

**Q4: è§£é‡‹ ARP å”è­°å·¥ä½œåŸç†å’Œ ARP æ¬ºé¨™æ”»æ“Š**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// ARP å°åŒ…çµæ§‹
typedef struct {
    uint16_t hardware_type;    // ç¡¬é«”é¡å‹ (ä¹™å¤ªç¶² = 1)
    uint16_t protocol_type;    // å”è­°é¡å‹ (IPv4 = 0x0800)
    uint8_t hardware_len;      // ç¡¬é«”åœ°å€é•·åº¦ (6)
    uint8_t protocol_len;      // å”è­°åœ°å€é•·åº¦ (4)
    uint16_t operation;        // æ“ä½œç¢¼ (è«‹æ±‚=1, å›æ‡‰=2)
    uint8_t sender_mac[6];     // ç™¼é€è€… MAC
    uint32_t sender_ip;        // ç™¼é€è€… IP
    uint8_t target_mac[6];     // ç›®æ¨™ MAC
    uint32_t target_ip;        // ç›®æ¨™ IP
} __attribute__((packed)) arp_packet_t;

// ARP å·¥ä½œæµç¨‹:
// 1. ä¸»æ©Ÿ A è¦èˆ‡ä¸»æ©Ÿ B é€šè¨Šï¼Œä½†åªçŸ¥é“ B çš„ IP
// 2. A å»£æ’­ ARP è«‹æ±‚: "èª°æœ‰ IP x.x.x.xï¼Ÿè«‹å‘Šè¨´ MAC aa:bb:cc:dd:ee:ff"
// 3. B æ”¶åˆ°è«‹æ±‚ï¼Œç™¼é€ ARP å›æ‡‰: "IP x.x.x.x åœ¨ MAC ff:ee:dd:cc:bb:aa"
// 4. A æ›´æ–° ARP è¡¨ï¼Œå¾ŒçºŒé€šè¨Šç›´æ¥ä½¿ç”¨ MAC åœ°å€

// ARP æ¬ºé¨™é˜²è­·
int detect_arp_spoofing(arp_packet_t* arp_pkt, 
                       uint8_t expected_mac[6]) {
    if (arp_pkt->operation == ntohs(2)) { // ARP å›æ‡‰
        if (memcmp(arp_pkt->sender_mac, expected_mac, 6) != 0) {
            printf("ARP spoofing detected! Expected MAC vs Received MAC\n");
            return 1; // æª¢æ¸¬åˆ° ARP æ¬ºé¨™
        }
    }
    return 0;
}
```

## å”è­°æ·±åº¦å•é¡Œ

### TCP æ·±åº¦åˆ†æ

**Q5: TCP æ“å¡æ§åˆ¶æ¼”ç®—æ³•æœ‰å“ªäº›ï¼Ÿå„è‡ªçš„ç‰¹é»ï¼Ÿ**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// TCP æ“å¡æ§åˆ¶ç‹€æ…‹
typedef enum {
    TCP_CA_SLOW_START,     // æ…¢å•Ÿå‹•
    TCP_CA_CONGESTION_AVOID, // æ“å¡é¿å…
    TCP_CA_FAST_RECOVERY,  // å¿«é€Ÿæ¢å¾©
    TCP_CA_LOSS_RECOVERY   // æå¤±æ¢å¾©
} tcp_ca_state_t;

// ä¸»è¦æ¼”ç®—æ³•æ¯”è¼ƒ
typedef struct {
    const char* name;
    const char* characteristics;
    const char* use_case;
    double efficiency;
} tcp_algorithm_t;

tcp_algorithm_t tcp_algorithms[] = {
    {
        "Reno", 
        "åŸºæ–¼ä¸ŸåŒ…æª¢æ¸¬ï¼Œä¸‰é‡è¤‡ ACK è§¸ç™¼å¿«é€Ÿé‡å‚³",
        "å‚³çµ±ç¶²è·¯ï¼Œä¸­ç­‰å¸¶å¯¬",
        0.7
    },
    {
        "Cubic", 
        "ç«‹æ–¹å‡½æ•¸å¢é•·ï¼Œèˆ‡ RTT ç„¡é—œçš„å…¬å¹³æ€§",
        "é«˜å¸¶å¯¬é•·å»¶é²ç¶²è·¯ (Linux é è¨­)",
        0.85
    },
    {
        "BBR",
        "åŸºæ–¼é »å¯¬å’Œ RTT ä¼°ç®—ï¼Œä¸»å‹•æ¢æ¸¬",
        "Google é–‹ç™¼ï¼Œé©åˆå„ç¨®ç¶²è·¯ç’°å¢ƒ",
        0.95
    },
    {
        "Vegas",
        "åŸºæ–¼ RTT è®ŠåŒ–é æ¸¬æ“å¡ï¼Œä¸»å‹•å¼",
        "å»¶é²æ•æ„Ÿæ‡‰ç”¨",
        0.8
    }
};

// BBR æ ¸å¿ƒæ¦‚å¿µå¯¦ç¾
typedef struct {
    uint64_t delivery_rate;    // å‚³è¼¸é€Ÿç‡
    uint32_t min_rtt;         // æœ€å° RTT
    uint64_t max_bw;          // æœ€å¤§é »å¯¬
    uint32_t cwnd;            // æ“å¡è¦–çª—
} bbr_state_t;

void bbr_update_model(bbr_state_t* bbr, uint32_t delivered, 
                     uint32_t interval, uint32_t rtt) {
    // æ›´æ–°å‚³è¼¸é€Ÿç‡
    if (interval > 0) {
        bbr->delivery_rate = delivered * 1000000 / interval; // bytes/sec
    }
    
    // æ›´æ–°æœ€å¤§é »å¯¬
    if (bbr->delivery_rate > bbr->max_bw) {
        bbr->max_bw = bbr->delivery_rate;
    }
    
    // æ›´æ–°æœ€å° RTT
    if (rtt < bbr->min_rtt) {
        bbr->min_rtt = rtt;
    }
    
    // è¨ˆç®—ç†æƒ³æ“å¡è¦–çª—
    bbr->cwnd = (bbr->max_bw * bbr->min_rtt) / 1000000;
}
```

**Q6: TCP Keep-Alive å’Œæ‡‰ç”¨å±¤å¿ƒè·³çš„å€åˆ¥ï¼Ÿ**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// TCP Keep-Alive é…ç½®
typedef struct {
    int keepalive_enable;      // æ˜¯å¦å•Ÿç”¨
    int keepalive_idle;        // ç©ºé–’æ™‚é–“ (ç§’)
    int keepalive_interval;    // æ¢æ¸¬é–“éš” (ç§’)  
    int keepalive_probes;      // æ¢æ¸¬æ¬¡æ•¸
} tcp_keepalive_config_t;

// è¨­ç½® TCP Keep-Alive
int setup_tcp_keepalive(int sockfd) {
    tcp_keepalive_config_t config = {
        .keepalive_enable = 1,
        .keepalive_idle = 600,     // 10 åˆ†é˜å¾Œé–‹å§‹æ¢æ¸¬
        .keepalive_interval = 60,   // æ¯åˆ†é˜æ¢æ¸¬ä¸€æ¬¡
        .keepalive_probes = 3       // æ¢æ¸¬ 3 æ¬¡å¾Œæ–·é–‹
    };
    
    setsockopt(sockfd, SOL_SOCKET, SO_KEEPALIVE, 
              &config.keepalive_enable, sizeof(config.keepalive_enable));
    setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPIDLE,
              &config.keepalive_idle, sizeof(config.keepalive_idle));
    setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPINTVL,
              &config.keepalive_interval, sizeof(config.keepalive_interval));
    setsockopt(sockfd, IPPROTO_TCP, TCP_KEEPCNT,
              &config.keepalive_probes, sizeof(config.keepalive_probes));
    
    return 0;
}

// æ‡‰ç”¨å±¤å¿ƒè·³å¯¦ç¾
typedef struct {
    uint32_t sequence;         // åºåˆ—è™Ÿ
    uint64_t timestamp;        // æ™‚é–“æˆ³
    uint32_t payload_len;      // è² è¼‰é•·åº¦
    char payload[];            // è² è¼‰æ•¸æ“š
} heartbeat_packet_t;

// å€åˆ¥ç¸½çµ:
// TCP Keep-Alive:
// - å‚³è¼¸å±¤å¯¦ç¾ï¼Œé€æ˜ä¸ä½”ç”¨æ‡‰ç”¨é »å¯¬
// - åªèƒ½æª¢æ¸¬ç¶²è·¯é€£æ¥ï¼Œç„¡æ³•æª¢æ¸¬æ‡‰ç”¨ç‹€æ…‹
// - é…ç½®é¸é …æœ‰é™ï¼Œä¸å¤ éˆæ´»

// æ‡‰ç”¨å±¤å¿ƒè·³:
// - æ‡‰ç”¨å±¤å¯¦ç¾ï¼Œå¯æ”œå¸¶æ¥­å‹™æ•¸æ“š
// - èƒ½æª¢æ¸¬å®Œæ•´æ‡‰ç”¨éˆè·¯å¥åº·ç‹€æ…‹
// - éˆæ´»é…ç½®ï¼Œæ”¯æ´è¤‡é›œé‚è¼¯
```

### HTTP/HTTPS æ·±åº¦å•é¡Œ

**Q7: HTTP/1.1, HTTP/2, HTTP/3 çš„ä¸»è¦å€åˆ¥ï¼Ÿ**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// HTTP ç‰ˆæœ¬ç‰¹æ€§æ¯”è¼ƒ
typedef struct {
    const char* version;
    const char* transport;
    bool multiplexing;
    bool header_compression;
    bool server_push;
    bool binary_protocol;
    const char* main_improvements;
} http_version_info_t;

http_version_info_t http_versions[] = {
    {
        "HTTP/1.1",
        "TCP",
        false,
        false,
        false, 
        false,
        "æŒä¹…é€£æ¥ã€ç®¡é“åŒ–ã€åˆ†å¡Šå‚³è¼¸"
    },
    {
        "HTTP/2",
        "TCP + TLS",
        true,
        true,
        true,
        true,
        "å¤šè·¯å¾©ç”¨ã€é ­éƒ¨å£“ç¸®ã€ä¼ºæœå™¨æ¨é€"
    },
    {
        "HTTP/3", 
        "QUIC (UDP)",
        true,
        true,
        true,
        true,
        "åŸºæ–¼ UDPã€æ¸›å°‘ RTTã€æŠ—ä¸ŸåŒ…"
    }
};

// HTTP/2 å¹€çµæ§‹
typedef struct {
    uint32_t length:24;        // å¹€é•·åº¦ (24 bits)
    uint8_t type;              // å¹€é¡å‹
    uint8_t flags;             // æ¨™èªŒä½
    uint32_t stream_id:31;     // æµ ID (31 bits)
    uint8_t reserved:1;        // ä¿ç•™ä½ (1 bit)
    uint8_t payload[];         // å¹€è² è¼‰
} __attribute__((packed)) http2_frame_t;

// HTTP/2 å¹€é¡å‹
#define HTTP2_FRAME_DATA         0x0
#define HTTP2_FRAME_HEADERS      0x1
#define HTTP2_FRAME_PRIORITY     0x2
#define HTTP2_FRAME_RST_STREAM   0x3
#define HTTP2_FRAME_SETTINGS     0x4
#define HTTP2_FRAME_PUSH_PROMISE 0x5
#define HTTP2_FRAME_PING         0x6
#define HTTP2_FRAME_GOAWAY       0x7
#define HTTP2_FRAME_WINDOW_UPDATE 0x8
#define HTTP2_FRAME_CONTINUATION 0x9
```

**Q8: HTTPS æ¡æ‰‹éç¨‹è©³è§£**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// TLS æ¡æ‰‹éšæ®µ
typedef enum {
    TLS_CLIENT_HELLO = 1,
    TLS_SERVER_HELLO,
    TLS_CERTIFICATE,
    TLS_SERVER_KEY_EXCHANGE,
    TLS_CERTIFICATE_REQUEST,
    TLS_SERVER_HELLO_DONE,
    TLS_CERTIFICATE_CLIENT,
    TLS_CLIENT_KEY_EXCHANGE,
    TLS_CERTIFICATE_VERIFY,
    TLS_CHANGE_CIPHER_SPEC,
    TLS_FINISHED
} tls_handshake_type_t;

// TLS æ¡æ‰‹éç¨‹:
// 1. Client Hello: 
//    - æ”¯æ´çš„ TLS ç‰ˆæœ¬ã€åŠ å¯†å¥—ä»¶
//    - éš¨æ©Ÿæ•¸ (Client Random)
//    - SNI (Server Name Indication)

// 2. Server Hello:
//    - é¸æ“‡çš„ TLS ç‰ˆæœ¬ã€åŠ å¯†å¥—ä»¶  
//    - éš¨æ©Ÿæ•¸ (Server Random)
//    - Session ID

// 3. Certificate:
//    - ä¼ºæœå™¨è­‰æ›¸éˆ
//    - å…¬é‘°è³‡è¨Š

// 4. Server Key Exchange (å¯é¸):
//    - DHE/ECDHE é‡‘é‘°äº¤æ›åƒæ•¸

// 5. Certificate Request (å¯é¸):
//    - è¦æ±‚å®¢æˆ¶ç«¯è­‰æ›¸

// 6. Server Hello Done:
//    - ä¼ºæœå™¨æ¡æ‰‹è³‡è¨ŠçµæŸ

// 7. Client Key Exchange:
//    - é ä¸»å¯†é‘° (Pre-Master Secret)
//    - ç”¨ä¼ºæœå™¨å…¬é‘°åŠ å¯†

// 8. Change Cipher Spec:
//    - å•Ÿç”¨å”å•†çš„åŠ å¯†åƒæ•¸

// 9. Finished:
//    - é©—è­‰æ¡æ‰‹å®Œæ•´æ€§

// TLS 1.3 å„ªåŒ– (1-RTT æ¡æ‰‹)
typedef struct {
    uint8_t client_random[32];
    uint8_t server_random[32]; 
    uint8_t pre_shared_key[32];
    uint8_t session_ticket[256];
} tls13_session_t;

// TLS 1.3 ä¸»è¦æ”¹é€²:
// - 1-RTT æ¡æ‰‹ (vs 2-RTT in TLS 1.2)
// - 0-RTT æ¢å¾©é€£æ¥
// - å‰å‘å®‰å…¨æ€§ (Perfect Forward Secrecy)
// - ç§»é™¤ä¸å®‰å…¨çš„åŠ å¯†æ¼”ç®—æ³•
```

## æ•ˆèƒ½å„ªåŒ–å•é¡Œ

### é«˜ä½µç™¼ç¶²è·¯ç¨‹å¼è¨­è¨ˆ

**Q9: epoll çš„å·¥ä½œåŸç†å’Œå„ªå‹¢ï¼ŸET æ¨¡å¼å’Œ LT æ¨¡å¼çš„å€åˆ¥ï¼Ÿ**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// epoll äº‹ä»¶çµæ§‹
struct epoll_event {
    uint32_t events;    // äº‹ä»¶é¡å‹
    epoll_data_t data;  // ç”¨æˆ¶æ•¸æ“š
};

// epoll å·¥ä½œåŸç†ç¤ºä¾‹
int setup_epoll_server(int listen_port) {
    // 1. å‰µå»º epoll å¯¦ä¾‹
    int epfd = epoll_create1(EPOLL_CLOEXEC);
    if (epfd < 0) {
        return -1;
    }
    
    // 2. å‰µå»ºç›£è½ socket
    int listenfd = socket(AF_INET, SOCK_STREAM, 0);
    // ... bind, listen ç­‰è¨­ç½®
    
    // 3. å°‡ç›£è½ socket åŠ å…¥ epoll
    struct epoll_event ev;
    ev.events = EPOLLIN;  // é—œæ³¨å¯è®€äº‹ä»¶
    ev.data.fd = listenfd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &ev);
    
    // 4. äº‹ä»¶å¾ªç’°
    struct epoll_event events[MAX_EVENTS];
    while (1) {
        int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);
        
        for (int i = 0; i < nfds; i++) {
            if (events[i].data.fd == listenfd) {
                // è™•ç†æ–°é€£æ¥
                handle_new_connection(epfd, listenfd);
            } else {
                // è™•ç†å®¢æˆ¶ç«¯æ•¸æ“š
                handle_client_data(events[i].data.fd);
            }
        }
    }
    
    return 0;
}

// ET (Edge Triggered) vs LT (Level Triggered) æ¨¡å¼
void demonstrate_et_vs_lt() {
    // LT æ¨¡å¼ (é è¨­):
    // - åªè¦ fd å¯è®€/å¯å¯«ï¼Œæ¯æ¬¡ epoll_wait éƒ½æœƒè¿”å›
    // - ç·¨ç¨‹ç°¡å–®ï¼Œä¸å®¹æ˜“éºæ¼äº‹ä»¶
    // - æ•ˆèƒ½ç›¸å°è¼ƒä½
    
    // ET æ¨¡å¼:
    // - åªåœ¨ fd ç‹€æ…‹ç™¼ç”Ÿè®ŠåŒ–æ™‚è¿”å›
    // - å¿…é ˆä¸€æ¬¡æ€§è®€å®Œæ‰€æœ‰æ•¸æ“š
    // - æ•ˆèƒ½æ›´é«˜ï¼Œä½†ç·¨ç¨‹è¤‡é›œ
    
    // ET æ¨¡å¼æ­£ç¢ºè®€å–ç¤ºä¾‹:
    ssize_t n;
    char buffer[4096];
    while ((n = read(fd, buffer, sizeof(buffer))) > 0) {
        // è™•ç†æ•¸æ“š
        process_data(buffer, n);
    }
    
    if (n < 0 && errno != EAGAIN) {
        // çœŸæ­£çš„éŒ¯èª¤
        handle_error();
    }
}

// epoll å„ªå‹¢:
// 1. O(1) è¤‡é›œåº¦ (vs select/poll çš„ O(n))
// 2. æ²’æœ‰ fd æ•¸é‡é™åˆ¶ (vs select çš„ 1024 é™åˆ¶)
// 3. åªè¿”å›æ´»èºçš„ fd
// 4. æ”¯æ´å¤§é‡ä½µç™¼é€£æ¥ (C10K å•é¡Œçš„è§£æ±ºæ–¹æ¡ˆ)
```

**Q10: å¦‚ä½•è™•ç† C10K/C10M å•é¡Œï¼Ÿ**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// C10K å•é¡Œè§£æ±ºæ–¹æ¡ˆæ¼”é€²
typedef struct {
    const char* approach;
    int max_connections;
    const char* limitations;
    const char* solutions;
} scalability_approach_t;

scalability_approach_t approaches[] = {
    {
        "Thread per connection",
        1000,
        "åŸ·è¡Œç·’é–‹éŠ·å¤§ã€ä¸Šä¸‹æ–‡åˆ‡æ›é–‹éŠ·ã€è¨˜æ†¶é«”æ¶ˆè€—",
        "åŸ·è¡Œç·’æ± ã€éé˜»å¡ I/O"
    },
    {
        "select/poll",
        10000,
        "O(n) è¤‡é›œåº¦ã€fd æ•¸é‡é™åˆ¶",
        "epoll/kqueue"
    },
    {
        "epoll/kqueue", 
        100000,
        "ç³»çµ±èª¿ç”¨é–‹éŠ·ã€ç”¨æˆ¶æ…‹/æ ¸å¿ƒæ…‹åˆ‡æ›",
        "ç”¨æˆ¶æ…‹ç¶²è·¯å †ç–Š"
    },
    {
        "User-space networking (DPDK)",
        10000000,
        "è¤‡é›œåº¦é«˜ã€ç¡¬é«”ä¾è³´",
        "å°ˆæ¥­åŒ–æ‡‰ç”¨"
    }
};

// C10M æ¶æ§‹è¨­è¨ˆ
typedef struct {
    // ç¶²è·¯å±¤å„ªåŒ–
    bool use_dpdk;               // ä½¿ç”¨ DPDK
    bool kernel_bypass;          // æ ¸å¿ƒç¹é
    bool zero_copy;              // é›¶æ‹·è²
    
    // è¨˜æ†¶é«”ç®¡ç†
    bool hugepages;              // å¤§é è¨˜æ†¶é«”
    bool numa_aware;             // NUMA æ„ŸçŸ¥
    bool lock_free;              // ç„¡é–æ•¸æ“šçµæ§‹
    
    // CPU å„ªåŒ–  
    bool cpu_affinity;           // CPU è¦ªå’Œæ€§
    bool polling_mode;           // è¼ªè©¢æ¨¡å¼
    bool batch_processing;       // æ‰¹é‡è™•ç†
} high_performance_config_t;

// å¯¦éš›å„ªåŒ–ç­–ç•¥
void optimize_for_c10m() {
    // 1. æ ¸å¿ƒåƒæ•¸èª¿å„ª
    // echo 1000000 > /proc/sys/fs/file-max
    // echo 1000000 > /proc/sys/net/core/somaxconn
    
    // 2. è¨˜æ†¶é«”å„ªåŒ–
    // ä½¿ç”¨å¤§é è¨˜æ†¶é«”æ¸›å°‘ TLB æœªå‘½ä¸­
    void* hugepage_mem = mmap(NULL, HUGEPAGE_SIZE,
                             PROT_READ | PROT_WRITE,
                             MAP_ANONYMOUS | MAP_HUGETLB, -1, 0);
    
    // 3. CPU è¦ªå’Œæ€§
    cpu_set_t cpuset;
    CPU_ZERO(&cpuset);
    CPU_SET(0, &cpuset);  // ç¶å®šåˆ° CPU 0
    pthread_setaffinity_np(pthread_self(), sizeof(cpuset), &cpuset);
    
    // 4. ç„¡é–ç·¨ç¨‹
    // ä½¿ç”¨åŸå­æ“ä½œæ›¿ä»£é–
    atomic_int connection_count = ATOMIC_VAR_INIT(0);
    atomic_fetch_add(&connection_count, 1);
}
```

### è¨˜æ†¶é«”å’Œ CPU å„ªåŒ–

**Q11: é›¶æ‹·è²æŠ€è¡“æœ‰å“ªäº›ï¼Ÿå„è‡ªçš„é©ç”¨å ´æ™¯ï¼Ÿ**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// é›¶æ‹·è²æŠ€è¡“æ¯”è¼ƒ
typedef struct {
    const char* technique;
    const char* system_call;
    const char* use_case;
    int copy_operations;
    const char* limitations;
} zero_copy_tech_t;

zero_copy_tech_t zero_copy_techs[] = {
    {
        "sendfile()",
        "sendfile(out_fd, in_fd, offset, count)",
        "æ–‡ä»¶åˆ° socket å‚³è¼¸",
        0,
        "åªæ”¯æ´æ–‡ä»¶åˆ° socketï¼Œç„¡æ³•ä¿®æ”¹æ•¸æ“š"
    },
    {
        "splice()",
        "splice(fd_in, off_in, fd_out, off_out, len, flags)",
        "ç®¡é“æ•¸æ“šå‚³è¼¸",
        0,
        "éœ€è¦å…¶ä¸­ä¸€å€‹ fd æ˜¯ç®¡é“"
    },
    {
        "mmap()",
        "mmap(addr, length, prot, flags, fd, offset)",
        "æ–‡ä»¶æ˜ å°„åˆ°è¨˜æ†¶é«”",
        1,
        "å¯èƒ½è§¸ç™¼é é¢éŒ¯èª¤ï¼Œéœ€è¦è™•ç† SIGBUS"
    },
    {
        "MSG_ZEROCOPY",
        "send(fd, buf, len, MSG_ZEROCOPY)",
        "socket ç™¼é€å¤§æ•¸æ“š",
        0,
        "Linux 4.14+ï¼Œéœ€è¦è™•ç†å®Œæˆé€šçŸ¥"
    }
};

// sendfile ç¤ºä¾‹
ssize_t zero_copy_file_transfer(int socket_fd, int file_fd, size_t file_size) {
    off_t offset = 0;
    ssize_t total_sent = 0;
    
    while (total_sent < file_size) {
        ssize_t sent = sendfile(socket_fd, file_fd, &offset, 
                               file_size - total_sent);
        if (sent < 0) {
            if (errno == EAGAIN) {
                continue; // éé˜»å¡æ¨¡å¼ï¼Œç¨å¾Œé‡è©¦
            }
            return -1;
        }
        total_sent += sent;
    }
    
    return total_sent;
}

// MSG_ZEROCOPY ç¤ºä¾‹
int zero_copy_send_with_notification(int sockfd, const void* buf, size_t len) {
    // ç™¼é€æ•¸æ“š
    ssize_t sent = send(sockfd, buf, len, MSG_ZEROCOPY);
    if (sent < 0) {
        return -1;
    }
    
    // ç­‰å¾…å®Œæˆé€šçŸ¥
    struct msghdr msg = {0};
    struct cmsghdr* cmsg;
    char control[CMSG_SPACE(sizeof(struct sock_extended_err))];
    
    msg.msg_control = control;
    msg.msg_controllen = sizeof(control);
    
    int ret = recvmsg(sockfd, &msg, MSG_ERRQUEUE);
    if (ret >= 0) {
        cmsg = CMSG_FIRSTHDR(&msg);
        if (cmsg && cmsg->cmsg_level == SOL_IP && 
            cmsg->cmsg_type == IP_RECVERR) {
            // é›¶æ‹·è²æ“ä½œå®Œæˆï¼Œå¯ä»¥å®‰å…¨é‡‹æ”¾ç·©è¡å€
            return 0;
        }
    }
    
    return -1;
}
```

## æ•…éšœæ’æŸ¥å•é¡Œ

### ç¶²è·¯å•é¡Œè¨ºæ–·

**Q12: å¦‚ä½•æ’æŸ¥ç¶²è·¯å»¶é²å•é¡Œï¼Ÿ**

**æ¨™æº–ç­”æ¡ˆ:**
```bash
#!/bin/bash
# ç¶²è·¯å»¶é²è¨ºæ–·è…³æœ¬

# 1. åŸºç¤é€£é€šæ€§æ¸¬è©¦
echo "=== åŸºç¤é€£é€šæ€§æ¸¬è©¦ ==="
target_host="google.com"
ping -c 10 $target_host

# 2. è·¯ç”±è¿½è¹¤
echo "=== è·¯ç”±è¿½è¹¤ ==="
traceroute $target_host
mtr -r -c 10 $target_host

# 3. DNS è§£æå»¶é²
echo "=== DNS è§£ææ¸¬è©¦ ==="
time nslookup $target_host
dig $target_host +stats

# 4. TCP é€£æ¥å»ºç«‹å»¶é²
echo "=== TCP é€£æ¥æ¸¬è©¦ ==="
time timeout 5 telnet $target_host 80

# 5. HTTP è«‹æ±‚å„éšæ®µå»¶é²
echo "=== HTTP è«‹æ±‚åˆ†æ ==="
curl -w "DNSè§£æ: %{time_namelookup}s\né€£æ¥å»ºç«‹: %{time_connect}s\nTLSæ¡æ‰‹: %{time_appconnect}s\né–‹å§‹å‚³è¼¸: %{time_starttransfer}s\nç¸½æ™‚é–“: %{time_total}s\n" \
     -o /dev/null -s "https://$target_host"

# 6. ç¶²è·¯ä»‹é¢çµ±è¨ˆ
echo "=== ç¶²è·¯ä»‹é¢çµ±è¨ˆ ==="
cat /proc/net/dev
ss -i  # é¡¯ç¤ºè©³ç´°çš„ socket è³‡è¨Š

# 7. ç³»çµ±ç¶²è·¯é…ç½®æª¢æŸ¥
echo "=== ç³»çµ±é…ç½®æª¢æŸ¥ ==="
sysctl net.ipv4.tcp_congestion_control
cat /proc/sys/net/core/rmem_max
cat /proc/sys/net/core/wmem_max
```

**å»¶é²æ’æŸ¥æ€è·¯:**
```c
// å»¶é²åˆ†ææ¡†æ¶
typedef struct {
    const char* layer;
    const char* potential_issues;
    const char* diagnostic_tools;
    const char* optimization_strategies;
} latency_analysis_t;

latency_analysis_t latency_layers[] = {
    {
        "æ‡‰ç”¨å±¤",
        "ç¨‹å¼ç¢¼æ•ˆç‡ã€è³‡æ–™åº«æŸ¥è©¢ã€æ¼”ç®—æ³•è¤‡é›œåº¦",
        "profiler, strace, gdb",
        "ç¨‹å¼ç¢¼å„ªåŒ–ã€å¿«å–ã€éåŒæ­¥è™•ç†"
    },
    {
        "å‚³è¼¸å±¤", 
        "TCP æ“å¡æ§åˆ¶ã€ç·©è¡å€å¤§å°ã€Nagle æ¼”ç®—æ³•",
        "ss, netstat, tcpdump",
        "èª¿æ•´ TCP åƒæ•¸ã€ç¦ç”¨ Nagleã€å¢å¤§ç·©è¡å€"
    },
    {
        "ç¶²è·¯å±¤",
        "è·¯ç”±é¸æ“‡ã€åˆ†ç‰‡ã€QoS",
        "traceroute, mtr, ping",
        "å„ªåŒ–è·¯ç”±ã€é¿å…åˆ†ç‰‡ã€é…ç½® QoS"
    },
    {
        "å¯¦é«”å±¤",
        "ç¶²è·¯è¨­å‚™æ•ˆèƒ½ã€éˆè·¯å“è³ªã€è·é›¢",
        "iperf3, ç¡¬é«”ç›£æ§å·¥å…·",
        "å‡ç´šè¨­å‚™ã€å„ªåŒ–ç¶²è·¯æ‹“æ’²"
    }
};
```

**Q13: å¦‚ä½•åˆ†æç¶²è·¯å°åŒ…ä¸Ÿå¤±å•é¡Œï¼Ÿ**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// å°åŒ…ä¸Ÿå¤±åˆ†æå·¥å…·
typedef struct {
    uint64_t rx_packets;       // æ¥æ”¶å°åŒ…æ•¸
    uint64_t rx_dropped;       // æ¥æ”¶ä¸Ÿæ£„æ•¸
    uint64_t rx_errors;        // æ¥æ”¶éŒ¯èª¤æ•¸
    uint64_t tx_packets;       // ç™¼é€å°åŒ…æ•¸
    uint64_t tx_dropped;       // ç™¼é€ä¸Ÿæ£„æ•¸
    uint64_t tx_errors;        // ç™¼é€éŒ¯èª¤æ•¸
} network_stats_t;

// æª¢æŸ¥ç¶²è·¯ä»‹é¢çµ±è¨ˆ
void check_interface_stats(const char* interface) {
    char path[256];
    FILE* fp;
    
    // æª¢æŸ¥æ¥æ”¶çµ±è¨ˆ
    snprintf(path, sizeof(path), 
             "/sys/class/net/%s/statistics/rx_dropped", interface);
    fp = fopen(path, "r");
    if (fp) {
        uint64_t rx_dropped;
        fscanf(fp, "%lu", &rx_dropped);
        printf("RX dropped: %lu\n", rx_dropped);
        fclose(fp);
    }
    
    // æª¢æŸ¥ç™¼é€çµ±è¨ˆ
    snprintf(path, sizeof(path),
             "/sys/class/net/%s/statistics/tx_dropped", interface);  
    fp = fopen(path, "r");
    if (fp) {
        uint64_t tx_dropped;
        fscanf(fp, "%lu", &tx_dropped);
        printf("TX dropped: %lu\n", tx_dropped);
        fclose(fp);
    }
}

// TCP é‡å‚³æª¢æŸ¥
void check_tcp_retransmissions() {
    printf("=== TCP é‡å‚³çµ±è¨ˆ ===\n");
    system("cat /proc/net/netstat | grep TcpExt");
    system("ss -i | grep -E 'retrans|unacked'");
}
```

```bash
# å°åŒ…ä¸Ÿå¤±è¨ºæ–·è…³æœ¬
#!/bin/bash

echo "=== å°åŒ…ä¸Ÿå¤±è¨ºæ–· ==="

# 1. ç¶²è·¯ä»‹é¢çµ±è¨ˆ
echo "ç¶²è·¯ä»‹é¢çµ±è¨ˆ:"
cat /proc/net/dev | grep -E "(eth0|em1)" | \
awk '{print "Interface: " $1 ", RX drops: " $5 ", TX drops: " $13}'

# 2. æ ¸å¿ƒç¶²è·¯çµ±è¨ˆ
echo "æ ¸å¿ƒç¶²è·¯çµ±è¨ˆ:"
cat /proc/net/snmp | grep -E "(Ip|Tcp|Udp)"

# 3. Socket ç·©è¡å€æº¢ä½
echo "Socket ç·©è¡å€çµ±è¨ˆ:"
cat /proc/net/sockstat

# 4. ç¶²å¡ç¡¬é«”éšŠåˆ—çµ±è¨ˆ
echo "ç¶²å¡ç¡¬é«”çµ±è¨ˆ:"
ethtool -S eth0 | grep -E "(drop|error|miss)"

# 5. é˜²ç«ç‰†ä¸ŸåŒ…
echo "é˜²ç«ç‰†çµ±è¨ˆ:"
iptables -nvL | grep -v "^Chain\|^target"

# 6. å¯¦æ™‚å°åŒ…ç›£æ§
echo "å¯¦æ™‚å°åŒ…ç›£æ§ (5ç§’):"
timeout 5 tcpdump -i eth0 -nn | wc -l
```

## ç³»çµ±è¨­è¨ˆå•é¡Œ

### åˆ†æ•£å¼ç³»çµ±ç¶²è·¯è¨­è¨ˆ

**Q14: è¨­è¨ˆä¸€å€‹é«˜å¯ç”¨çš„å¾®æœå‹™ç¶²è·¯æ¶æ§‹**

**æ¨™æº–ç­”æ¡ˆ:**
```mermaid
graph TB
    Client[å®¢æˆ¶ç«¯] --> LB[è² è¼‰å‡è¡¡å™¨]
    LB --> Gateway[API Gateway]
    Gateway --> Service1[æœå‹™ A]
    Gateway --> Service2[æœå‹™ B] 
    Gateway --> Service3[æœå‹™ C]
    
    Service1 --> Cache[å¿«å–å±¤]
    Service2 --> Cache
    Service3 --> Cache
    
    Service1 --> MQ[æ¶ˆæ¯éšŠåˆ—]
    Service2 --> MQ
    Service3 --> MQ
    
    Service1 --> DB1[(è³‡æ–™åº« A)]
    Service2 --> DB2[(è³‡æ–™åº« B)]
    Service3 --> DB3[(è³‡æ–™åº« C)]
    
    subgraph "æœå‹™ç™¼ç¾"
        Registry[æœå‹™è¨»å†Šä¸­å¿ƒ]
    end
    
    subgraph "ç›£æ§"
        Monitor[ç›£æ§ç³»çµ±]
        Tracing[éˆè·¯è¿½è¹¤]
    end
```

**æ¶æ§‹è¨­è¨ˆè€ƒæ…®:**
```c
// æœå‹™ç™¼ç¾æ¥å£
typedef struct {
    char service_name[64];
    char host[128];
    uint16_t port;
    char health_check_url[256];
    uint64_t last_heartbeat;
    bool is_healthy;
} service_instance_t;

// è² è¼‰å‡è¡¡ç­–ç•¥
typedef enum {
    LB_ROUND_ROBIN,      // è¼ªè©¢
    LB_WEIGHTED_RR,      // åŠ æ¬Šè¼ªè©¢
    LB_LEAST_CONNECTIONS, // æœ€å°‘é€£æ¥
    LB_CONSISTENT_HASH,  // ä¸€è‡´æ€§é›œæ¹Š
    LB_RANDOM            // éš¨æ©Ÿ
} load_balance_strategy_t;

// ç†”æ–·å™¨ç‹€æ…‹
typedef enum {
    CIRCUIT_CLOSED,      // é—œé–‰ç‹€æ…‹ï¼ˆæ­£å¸¸ï¼‰
    CIRCUIT_OPEN,        // é–‹å•Ÿç‹€æ…‹ï¼ˆç†”æ–·ï¼‰
    CIRCUIT_HALF_OPEN    // åŠé–‹ç‹€æ…‹ï¼ˆæ¸¬è©¦ï¼‰
} circuit_breaker_state_t;

typedef struct {
    circuit_breaker_state_t state;
    uint32_t failure_count;
    uint32_t failure_threshold;
    uint64_t last_failure_time;
    uint64_t timeout_duration;
    uint32_t success_threshold;
} circuit_breaker_t;

// ç†”æ–·å™¨å¯¦ç¾
bool circuit_breaker_allow_request(circuit_breaker_t* cb) {
    uint64_t now = time(NULL) * 1000; // æ¯«ç§’
    
    switch (cb->state) {
        case CIRCUIT_CLOSED:
            return true;
            
        case CIRCUIT_OPEN:
            if (now - cb->last_failure_time > cb->timeout_duration) {
                cb->state = CIRCUIT_HALF_OPEN;
                return true;
            }
            return false;
            
        case CIRCUIT_HALF_OPEN:
            return true;
    }
    
    return false;
}

void circuit_breaker_record_success(circuit_breaker_t* cb) {
    if (cb->state == CIRCUIT_HALF_OPEN) {
        cb->failure_count = 0;
        cb->state = CIRCUIT_CLOSED;
    }
}

void circuit_breaker_record_failure(circuit_breaker_t* cb) {
    cb->failure_count++;
    cb->last_failure_time = time(NULL) * 1000;
    
    if (cb->failure_count >= cb->failure_threshold) {
        cb->state = CIRCUIT_OPEN;
    }
}
```

**Q15: å¦‚ä½•è¨­è¨ˆä¸€å€‹ä½å»¶é²çš„äº¤æ˜“ç³»çµ±ç¶²è·¯æ¶æ§‹ï¼Ÿ**

**æ¨™æº–ç­”æ¡ˆ:**
```c
// ä½å»¶é²äº¤æ˜“ç³»çµ±æ¶æ§‹
typedef struct {
    // ç¶²è·¯å„ªåŒ–
    bool kernel_bypass;          // æ ¸å¿ƒç¹é (DPDK)
    bool zero_copy_networking;   // é›¶æ‹·è²ç¶²è·¯
    bool hardware_timestamping;  // ç¡¬é«”æ™‚é–“æˆ³
    
    // CPU å„ªåŒ–
    bool cpu_isolation;          // CPU éš”é›¢
    bool numa_optimization;      // NUMA å„ªåŒ–
    bool lock_free_structures;   // ç„¡é–æ•¸æ“šçµæ§‹
    
    // è¨˜æ†¶é«”å„ªåŒ–
    bool hugepages;              // å¤§é è¨˜æ†¶é«”
    bool memory_preallocation;   // è¨˜æ†¶é«”é åˆ†é…
    bool cache_line_alignment;   // å¿«å–è¡Œå°é½Š
    
    // æ‡‰ç”¨å„ªåŒ–
    bool message_batching;       // è¨Šæ¯æ‰¹è™•ç†
    bool persistent_connections; // æŒä¹…é€£æ¥
    bool binary_protocol;        // äºŒé€²ä½å”è­°
} low_latency_config_t;

// ä½å»¶é²è¨Šæ¯çµæ§‹
typedef struct {
    uint64_t timestamp_ns;       // å¥ˆç§’ç´šæ™‚é–“æˆ³
    uint32_t sequence_number;    // åºåˆ—è™Ÿ
    uint16_t message_type;       // è¨Šæ¯é¡å‹
    uint16_t length;             // è¨Šæ¯é•·åº¦
    char payload[];              // è² è¼‰è³‡æ–™
} __attribute__((packed, aligned(64))) low_latency_message_t;

// é—œéµæ•ˆèƒ½æŒ‡æ¨™
typedef struct {
    uint64_t market_data_latency_ns;  // å¸‚å ´è³‡æ–™å»¶é²
    uint64_t order_processing_ns;     // è¨‚å–®è™•ç†å»¶é²
    uint64_t risk_check_ns;           // é¢¨æ§æª¢æŸ¥å»¶é²
    uint64_t order_send_ns;           // è¨‚å–®ç™¼é€å»¶é²
    double throughput_ops_per_sec;    // ååé‡
} trading_system_metrics_t;

// å»¶é²ç›®æ¨™
#define TARGET_MARKET_DATA_LATENCY_NS    500    // 0.5Î¼s
#define TARGET_ORDER_PROCESSING_NS       2000   // 2Î¼s  
#define TARGET_RISK_CHECK_NS            1000    // 1Î¼s
#define TARGET_ORDER_SEND_NS            1500    // 1.5Î¼s
#define TARGET_TOTAL_LATENCY_NS         5000    // 5Î¼s
```

## ç·¨ç¨‹å¯¦ä½œé¡Œ

### Socket ç¨‹å¼è¨­è¨ˆ

**Q16: å¯¦ç¾ä¸€å€‹æ”¯æ´ä¸¦ç™¼çš„ TCP Echo ä¼ºæœå™¨**

**æ¨™æº–ç­”æ¡ˆ:**
```c
#include <sys/epoll.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <fcntl.h>
#include <unistd.h>
#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define MAX_EVENTS 1024
#define BUFFER_SIZE 4096

// è¨­ç½®éé˜»å¡æ¨¡å¼
int set_nonblocking(int fd) {
    int flags = fcntl(fd, F_GETFL);
    if (flags < 0) return -1;
    
    return fcntl(fd, F_SETFL, flags | O_NONBLOCK);
}

// è™•ç†æ–°é€£æ¥
void handle_new_connection(int epfd, int listenfd) {
    struct sockaddr_in client_addr;
    socklen_t client_len = sizeof(client_addr);
    
    int clientfd = accept(listenfd, (struct sockaddr*)&client_addr, &client_len);
    if (clientfd < 0) {
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("accept");
        }
        return;
    }
    
    // è¨­ç½®éé˜»å¡
    if (set_nonblocking(clientfd) < 0) {
        close(clientfd);
        return;
    }
    
    // åŠ å…¥ epoll
    struct epoll_event ev;
    ev.events = EPOLLIN | EPOLLET;  // ET æ¨¡å¼
    ev.data.fd = clientfd;
    
    if (epoll_ctl(epfd, EPOLL_CTL_ADD, clientfd, &ev) < 0) {
        perror("epoll_ctl");
        close(clientfd);
    }
    
    printf("New connection: fd=%d\n", clientfd);
}

// è™•ç†å®¢æˆ¶ç«¯æ•¸æ“š
void handle_client_data(int epfd, int clientfd) {
    char buffer[BUFFER_SIZE];
    ssize_t n;
    
    while ((n = read(clientfd, buffer, BUFFER_SIZE)) > 0) {
        // Echo å›å®¢æˆ¶ç«¯
        ssize_t written = 0;
        while (written < n) {
            ssize_t w = write(clientfd, buffer + written, n - written);
            if (w < 0) {
                if (errno == EAGAIN || errno == EWOULDBLOCK) {
                    // ä¿®æ”¹ç‚ºé—œæ³¨å¯«äº‹ä»¶
                    struct epoll_event ev;
                    ev.events = EPOLLOUT | EPOLLET;
                    ev.data.fd = clientfd;
                    epoll_ctl(epfd, EPOLL_CTL_MOD, clientfd, &ev);
                    return;
                } else {
                    perror("write");
                    goto close_connection;
                }
            }
            written += w;
        }
    }
    
    if (n < 0) {
        if (errno != EAGAIN && errno != EWOULDBLOCK) {
            perror("read");
            goto close_connection;
        }
    } else if (n == 0) {
        // å®¢æˆ¶ç«¯é—œé–‰é€£æ¥
        goto close_connection;
    }
    
    return;

close_connection:
    printf("Connection closed: fd=%d\n", clientfd);
    epoll_ctl(epfd, EPOLL_CTL_DEL, clientfd, NULL);
    close(clientfd);
}

// ä¸»å‡½æ•¸
int main(int argc, char* argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <port>\n", argv[0]);
        return 1;
    }
    
    int port = atoi(argv[1]);
    
    // å‰µå»ºç›£è½ socket
    int listenfd = socket(AF_INET, SOCK_STREAM, 0);
    if (listenfd < 0) {
        perror("socket");
        return 1;
    }
    
    // è¨­ç½®åœ°å€é‡ç”¨
    int opt = 1;
    setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &opt, sizeof(opt));
    
    // ç¶å®šåœ°å€
    struct sockaddr_in server_addr;
    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    server_addr.sin_addr.s_addr = INADDR_ANY;
    server_addr.sin_port = htons(port);
    
    if (bind(listenfd, (struct sockaddr*)&server_addr, sizeof(server_addr)) < 0) {
        perror("bind");
        return 1;
    }
    
    // é–‹å§‹ç›£è½
    if (listen(listenfd, SOMAXCONN) < 0) {
        perror("listen");
        return 1;
    }
    
    // è¨­ç½®éé˜»å¡
    set_nonblocking(listenfd);
    
    // å‰µå»º epoll
    int epfd = epoll_create1(EPOLL_CLOEXEC);
    if (epfd < 0) {
        perror("epoll_create1");
        return 1;
    }
    
    // å°‡ç›£è½ socket åŠ å…¥ epoll
    struct epoll_event ev;
    ev.events = EPOLLIN;
    ev.data.fd = listenfd;
    epoll_ctl(epfd, EPOLL_CTL_ADD, listenfd, &ev);
    
    printf("Echo server listening on port %d\n", port);
    
    // äº‹ä»¶å¾ªç’°
    struct epoll_event events[MAX_EVENTS];
    while (1) {
        int nfds = epoll_wait(epfd, events, MAX_EVENTS, -1);
        if (nfds < 0) {
            perror("epoll_wait");
            break;
        }
        
        for (int i = 0; i < nfds; i++) {
            if (events[i].data.fd == listenfd) {
                handle_new_connection(epfd, listenfd);
            } else {
                handle_client_data(epfd, events[i].data.fd);
            }
        }
    }
    
    close(epfd);
    close(listenfd);
    return 0;
}
```

### å°åŒ…è™•ç†ç¨‹å¼è¨­è¨ˆ

**Q17: å¯¦ç¾ä¸€å€‹ç°¡å–®çš„å°åŒ…åˆ†æå™¨**

**æ¨™æº–ç­”æ¡ˆ:**
```c
#include <pcap.h>
#include <netinet/ip.h>
#include <netinet/tcp.h>
#include <netinet/udp.h>
#include <netinet/if_ether.h>
#include <arpa/inet.h>

// çµ±è¨ˆçµæ§‹
typedef struct {
    uint64_t total_packets;
    uint64_t ip_packets;
    uint64_t tcp_packets;
    uint64_t udp_packets;
    uint64_t icmp_packets;
    uint64_t other_packets;
    uint64_t total_bytes;
} packet_stats_t;

static packet_stats_t stats = {0};

// å°åŒ…è™•ç†å‡½æ•¸
void packet_handler(u_char* user_data, const struct pcap_pkthdr* pkthdr, 
                   const u_char* packet) {
    stats.total_packets++;
    stats.total_bytes += pkthdr->len;
    
    // è§£æä¹™å¤ªç¶²é ­
    struct ethhdr* eth_header = (struct ethhdr*)packet;
    
    if (ntohs(eth_header->h_proto) == ETH_P_IP) {
        stats.ip_packets++;
        
        // è§£æ IP é ­
        struct iphdr* ip_header = (struct iphdr*)(packet + sizeof(struct ethhdr));
        
        printf("Packet #%lu: ", stats.total_packets);
        printf("Src IP: %s, ", inet_ntoa(*(struct in_addr*)&ip_header->saddr));
        printf("Dst IP: %s, ", inet_ntoa(*(struct in_addr*)&ip_header->daddr));
        printf("Protocol: ");
        
        switch (ip_header->protocol) {
            case IPPROTO_TCP: {
                stats.tcp_packets++;
                struct tcphdr* tcp_header = (struct tcphdr*)
                    (packet + sizeof(struct ethhdr) + ip_header->ihl * 4);
                printf("TCP (Port %d -> %d)", 
                       ntohs(tcp_header->source), ntohs(tcp_header->dest));
                break;
            }
            case IPPROTO_UDP: {
                stats.udp_packets++;
                struct udphdr* udp_header = (struct udphdr*)
                    (packet + sizeof(struct ethhdr) + ip_header->ihl * 4);
                printf("UDP (Port %d -> %d)",
                       ntohs(udp_header->source), ntohs(udp_header->dest));
                break;
            }
            case IPPROTO_ICMP:
                stats.icmp_packets++;
                printf("ICMP");
                break;
            default:
                stats.other_packets++;
                printf("Other (%d)", ip_header->protocol);
                break;
        }
        
        printf(", Length: %d bytes\n", pkthdr->len);
    }
}

// åˆ—å°çµ±è¨ˆè³‡è¨Š
void print_statistics() {
    printf("\n=== Packet Statistics ===\n");
    printf("Total packets: %lu\n", stats.total_packets);
    printf("Total bytes: %lu\n", stats.total_bytes);
    printf("IP packets: %lu (%.2f%%)\n", stats.ip_packets,
           (double)stats.ip_packets / stats.total_packets * 100);
    printf("TCP packets: %lu (%.2f%%)\n", stats.tcp_packets,
           (double)stats.tcp_packets / stats.total_packets * 100);
    printf("UDP packets: %lu (%.2f%%)\n", stats.udp_packets,
           (double)stats.udp_packets / stats.total_packets * 100);
    printf("ICMP packets: %lu (%.2f%%)\n", stats.icmp_packets,
           (double)stats.icmp_packets / stats.total_packets * 100);
    printf("Other packets: %lu (%.2f%%)\n", stats.other_packets,
           (double)stats.other_packets / stats.total_packets * 100);
}

int main(int argc, char* argv[]) {
    char* device = NULL;
    char errbuf[PCAP_ERRBUF_SIZE];
    pcap_t* handle;
    
    // ç²å–é è¨­ç¶²è·¯ä»‹é¢
    device = pcap_lookupdev(errbuf);
    if (device == NULL) {
        fprintf(stderr, "Could not find default device: %s\n", errbuf);
        return 1;
    }
    
    printf("Capturing on device: %s\n", device);
    
    // é–‹å•Ÿè¨­å‚™é€²è¡Œå°åŒ…æ•ç²
    handle = pcap_open_live(device, BUFSIZ, 1, 1000, errbuf);
    if (handle == NULL) {
        fprintf(stderr, "Could not open device %s: %s\n", device, errbuf);
        return 1;
    }
    
    // è¨­ç½®ä¿¡è™Ÿè™•ç†ç¨‹åº
    signal(SIGINT, print_statistics);
    
    // é–‹å§‹æ•ç²å°åŒ…
    pcap_loop(handle, 0, packet_handler, NULL);
    
    // é—œé–‰è¨­å‚™
    pcap_close(handle);
    
    return 0;
}
```

## é¢è©¦ç­–ç•¥èˆ‡æŠ€å·§

### å›ç­”æŠ€å·§

**é€šç”¨ç­–ç•¥:**
1. **åˆ†å±¤å›ç­”** - å¾åŸºç¤æ¦‚å¿µåˆ°æ·±å…¥å¯¦ç¾
2. **èˆ‰ä¾‹èªªæ˜** - ç”¨å…·é«”æ¡ˆä¾‹è¼”åŠ©èªªæ˜
3. **ä¸»å‹•å±•ç¤º** - å±•ç¤ºç›¸é—œé …ç›®ç¶“é©—
4. **æ‰¿èªä¸è¶³** - ä¸çŸ¥é“æ™‚èª å¯¦èªªæ˜ï¼Œä½†è¡¨ç¤ºå­¸ç¿’æ„é¡˜

**æŠ€è¡“å•é¡Œå›ç­”æ¡†æ¶:**
```
1. æ¦‚å¿µå®šç¾© - ç°¡æ½”æº–ç¢ºåœ°å®šç¾©æ¦‚å¿µ
2. å·¥ä½œåŸç† - èªªæ˜åº•å±¤å¯¦ç¾æ©Ÿåˆ¶
3. å„ªç¼ºé»å°æ¯” - åˆ†ææŠ€è¡“ç‰¹é»
4. ä½¿ç”¨å ´æ™¯ - èªªæ˜é©ç”¨çš„å¯¦éš›å ´æ™¯
5. å€‹äººç¶“é©— - åˆ†äº«ç›¸é—œé …ç›®ç¶“é©—
```

### å¸¸è¦‹é¢è©¦é™·é˜±

**é™·é˜± 1: éåº¦æŠ€è¡“ç´°ç¯€**
- éŒ¯èª¤: ä¸€é–‹å§‹å°±è¬›è¤‡é›œçš„å¯¦ç¾ç´°ç¯€
- æ­£ç¢º: å…ˆè¬›å¤§æ¡†æ¶ï¼Œå†æ ¹æ“šé¢è©¦å®˜åæ‡‰æ·±å…¥

**é™·é˜± 2: çµ•å°åŒ–è¡¨è¿°**
- éŒ¯èª¤: "TCP ä¸€å®šæ¯” UDP å¯é "
- æ­£ç¢º: "åœ¨å¤§å¤šæ•¸æƒ…æ³ä¸‹ï¼ŒTCP æä¾›äº†æ¯” UDP æ›´å¥½çš„å¯é æ€§ä¿è­‰"

**é™·é˜± 3: ä¸æ‰¿èªä¸çŸ¥é“**
- éŒ¯èª¤: çŒœæ¸¬æˆ–ç·¨é€ ç­”æ¡ˆ
- æ­£ç¢º: "é€™å€‹å•é¡Œæˆ‘ä¸å¤ªç¢ºå®šï¼Œä½†æˆ‘çš„ç†è§£æ˜¯..."

### æŠ€è¡“æ·±åº¦å±•ç¤º

**åˆç´šå·¥ç¨‹å¸« (1-3å¹´):**
- ç†Ÿæ‚‰åŸºæœ¬æ¦‚å¿µå’Œå”è­°
- èƒ½è§£é‡‹å¸¸è¦‹ç¶²è·¯å•é¡Œ
- æœ‰åŸºç¤çš„ Socket ç¨‹å¼è¨­è¨ˆç¶“é©—

**ä¸­ç´šå·¥ç¨‹å¸« (3-7å¹´):**
- æ·±å…¥ç†è§£å”è­°å¯¦ç¾
- æœ‰æ•ˆèƒ½å„ªåŒ–ç¶“é©—
- èƒ½è¨­è¨ˆä¸­ç­‰è¤‡é›œåº¦çš„ç¶²è·¯æ¶æ§‹

**é«˜ç´šå·¥ç¨‹å¸« (7å¹´+):**
- ç²¾é€šåº•å±¤å¯¦ç¾æ©Ÿåˆ¶
- æœ‰å¤§è¦æ¨¡ç³»çµ±è¨­è¨ˆç¶“é©—
- èƒ½è§£æ±ºè¤‡é›œçš„æ•ˆèƒ½å’Œå¯é æ€§å•é¡Œ

## ç¸½çµ

ç¶²è·¯æŠ€è¡“é¢è©¦æº–å‚™è¦é»ï¼š

### æ ¸å¿ƒçŸ¥è­˜é ˜åŸŸ
1. **å”è­°åŸºç¤** - TCP/IPã€HTTPã€DNS ç­‰æ ¸å¿ƒå”è­°
2. **æ•ˆèƒ½å„ªåŒ–** - å»¶é²ã€ååé‡ã€ä½µç™¼è™•ç†
3. **æ•…éšœæ’æŸ¥** - å•é¡Œè¨ºæ–·å’Œè§£æ±ºèƒ½åŠ›
4. **ç³»çµ±è¨­è¨ˆ** - å¤§è¦æ¨¡ç¶²è·¯æ¶æ§‹è¨­è¨ˆ

### æº–å‚™å»ºè­°
- **ç†è«–èˆ‡å¯¦è¸çµåˆ** - ä¸åƒ…è¦æ‡‚åŸç†ï¼Œé‚„è¦æœ‰å¯¦éš›ç¶“é©—
- **æ·±åº¦èˆ‡å»£åº¦ä¸¦é‡** - æ—¢è¦æœ‰å°ˆç²¾é ˜åŸŸï¼Œä¹Ÿè¦äº†è§£ç›¸é—œæŠ€è¡“
- **æŒçºŒå­¸ç¿’æ›´æ–°** - é—œæ³¨æ–°æŠ€è¡“è¶¨å‹¢å’Œæœ€ä½³å¯¦è¸
- **é …ç›®ç¶“é©—ç¸½çµ** - æº–å‚™å¥½å…·é«”çš„é …ç›®æ¡ˆä¾‹å’ŒæŠ€è¡“ç´°ç¯€

ç¥æ‚¨é¢è©¦é †åˆ©ï¼ğŸš€
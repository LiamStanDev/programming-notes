source: [技術蛋老師](https://www.bilibili.com/video/BV1EU4y1v7ju/?spm_id_from=333.880.my_history.page.click&vd_source=81381cbff2baf8dfd1b22050d029f496)

# 基礎概念
---
### 分層模型
* 物理層: 
	* 使用光、電或電磁波等方式將數據進行傳播，提供數據傳播的功能。
	* 數據: bit
	* 設備: 中繼器、集線器
* 數據鏈路層: 
	* 提供在同一網路中找到目標的功能。 
	* 數據: Frame (楨)，在封裝成楨時會添加 MAC 地址 (每個網卡獨有的)
	* 功能: 封裝成楨、差錯檢測與控制、流量控制
	* 設備: 交換機 (依照 MAC 地址找到對應的網卡)
* 網路層: 
	* 提供找到指定網路的功能
	* 數據: Datagram (包)
	* 功能: 尋址與路由選擇
	* 設備: 路由器
	* 協議: IP，ICMP
* 傳輸層:
	* 提供找到對應進程的功能 (端口)
	* 數據: Segment (段)
	* 功能: 流量控制、錯誤控制 (確定數據完整無誤)
	* 協議: TCP, UDP, QUIC
* 會話層:
	* 提供同步功能、管理狀態 (e.g. 登入狀態) 與恢復。
*  表示層:
	* 提供不同計算機之間表達方式的轉換，提供編碼與解碼功能 (加密解密) 與數據壓縮
* 應用層:
	* 協議: HTTP、FTP、SMTP
	* 與表示層和會話層的數據合併叫 Message (報文)
### 交換機 vs. 路由器
* 交換機: 
	位於數據鏈路層(第二層)，故又叫做二層設備，具有多個端口，每個端口都可以連接設備，自己會維護一個 MAC 地址表，當 Frame 進來時查看 MAC 地址發送到指定端口。
* 路由器: 
	分為 WAN 口與 LAN 口，WAN 口連接網際網路， LAN 口連接內網，若路由器只有 LAN 口就是交換機。由 TCP/IP 協議規定不同網路之間是不能互通的，只能透過網關進行，路由器就扮演這個功能，WAN 與 LAN 口分別連接這兩個子網，並配有這兩個子網的 ip 地址。過程如下:
	發送方確認接收方 ip 是否為同一個子網，若相同則直接填入接收方的 MAC 地址進行轉發，若不同則填入默認網關 MAC 地址，路由器接收到後查詢路由表，將數據發送出去。
	
### 數據流通
* 重點:
	* MAC 地址就像是名子，是給交換機看的
	* IP 地址就是門牌，是給路由器看的
#### 單播、組播、廣播與任播
1. unicast (單播): 一對一，只有對方能收到
2. multicast (組播or多播): 組聊，組內都能收到
3. broadcast (廣播): 群聊，就是整個交換機下所有設備都能收到
4. anycast (任播): 與廣播相同，但只有其中之一可以收到
![[Pasted image 20231101104932.png]]

#### 客戶端與服務端分屬不同網路
1. 客戶端將 Message 添加服務端端口號成為 Segment，然後添加服務端 IP 地址變成 Datagram，最後添加 MAC 地址封裝成楨。
2. 但是客戶端若不知道默認網關的 MAC 地址，無法封裝成楨且無法將數據發送到默認網關，故使用 ARP 協議進行廣播取得默認網關 MAC 地址，就可以封裝成楨。
3. 由交換機依照 MAC 地址發送到默認網關，默認網關進行解包，發現 MAC 地址是自己的，繼續解包發現 ip 不是自己的，就知道自己要送貨，故將數據發送到網際網路。
4. 數據到達服務端的默認網關，一樣進行解包發現 MAC 地址是自己的，就進行解包發現 ip 地址不是自己的，就，但默認網關知道 ip 對應的 MAC 地址，故將其封裝成楨填上服務端的 MAC 地址。
5. 經由交換機順利交給服務端。

### IPv4
為四個 8 bits 以 `.` 區隔，以前將網路分為 ABCDE 類分配網路號與主機號，但現在已經幾乎不用。現在採用子網掩碼 (mask) 與 Classless Inter-Domain Routing (CIDR)。子網掩碼與 IPv4 表達方式相同，而 CIDR 是子網掩碼的一種表示方法。 
#### 子網掩碼
例子: 我們希望一個網路只包含 196.168.0.0, 196.168.0.1, 196.168.0.2, 196.168.0.3，則該如何做?
196.168.0.0 = 11000000.10101000.00000000.00000000
196.168.0.1 = 11000000.10101000.00000000.00000001
196.168.0.2 = 11000000.10101000.00000000.00000010
196.168.0.3 = 11000000.10101000.00000000.00000011
故子網掩碼中1表示鎖定位，0表示不鎖定位則子網掩碼為 
11111111.11111111.11111111.11111100 = 255.255.255.252
共有30個1，故以上 IPv4 使用 CIDR 表示為分別為 
196.168.0.0/30, 196.168.0.1/30, 196.168.0.2/30, 196.168.0.3/30

#### 公網與私網
問題: 我們很常看到不同網路下兩台電腦的 ip 地址相同，為甚麼不會衝突 (無法區別) ?
透過 NET 技術在有限的 IPv4 地址下還是能繼續續命。
##### NET 技術
1. SNET技術: 就是源地址轉換技術，將私網 ip 地址透過網關為公網 ip 在進行發送。
2. DNET技術: 就是目標地址轉換技術，將返回數據中 ip 地址透過網關轉發給指定主機。
![[Pasted image 20231101101554.png | 1200]]
###### 若一個私網中有多台主機呢?
返回數據只指定公網 ip 地址，該如何將數據返回給通一個私網中的主機呢? 可以透過傳輸層進行處理，不同協議採用不同方式:
1. TCP 與 UDP:
	採用端口號進行標記。
	若 PC1 為 192.168.1.11 端口號為 1234，PC2 為 192.168.1.12 端口號為 1234，則透過 SNET 會將 
	1. PC1 IP 轉為 32.156.22.64 端口號轉為 5443，並記錄返回數據若是端口號 5543 要給 PC1 的 1234 端口。 
	2. PC2 IP 轉為 32.156.22.64 端口號轉為 2231，並記錄返回數據若是端口號 2231 要給 PC2 的 1234 端口。
2. ICMP: 
	因為是網路層協議沒有辦法使用端口，是透過協議中的 type + code 進行標記。

### IPv6
IPv6 可以提供給全世界人每一根毛都唯一識別還綽綽有餘，採用 128 bits，採16進制並以`:` 分隔表示，前 64 bits 為網路號，後 64 bits 為接口號 (因為一台主機可能會有多個網路接口)。
![[Pasted image 20231101103244.png | 500]]
> 前 48 bits 由網路供應商提供

#### 其他細節
* IPv6 沒有廣播，故也沒有 ARP 協議
* IPv6 支持任播


### DNS
Domain Name System (DNS) 域名解析過程。
每台主機都可以藉由 ip 地址識別，但是由於數字很難記憶，故使用更讓人容易理解的英文字母來做為地址識別，但是實際上還是需要轉為 ip 地址，故就需要 DNS。

以 www.bilibili.com 為例，www 表示主站，由 bilibili 管理，而其又被 com 管理。所有域名都是由 . (.root) 進行管理
![[Pasted image 20231102143120.png | 500]]
![[Pasted image 20231102143558.png | 500]]


## 協議
---
### TCP 與 UDP
#### TCP
TCP 為面相連接的傳輸層協議，可靠連接透過以下步驟達成:
##### 1. 三次握手:
	![[Pasted image 20231101111056.png]]
	* 為甚麼是三次握手而不是兩次握手?
		因為若客戶端發送 SYN 包時網路信道發生問題，客戶端沒收到 SYN+ACK 包，會再次發送 SYN 包，此時服務端回復 SYN + ACK 包就建立連接的話，若原本發生問題的信道恢復，服務端又會收到一個已經失效的 SYN 包，服務端就會建立兩個連接發生錯誤。
		-> 在不可靠的信道上建立可靠的連接
##### 2. 傳輸確認: 雙方都會進行傳輸確認 (TCP 是全雙工通道)
因為 TCP 會將 Message 拆成一個個 Segment，所以會產生丟包與亂序問題，故 TCP 將發送的數據每一個自節都編上序列號由0到N，並每一個 Segment 都會標記長度，故接收者每次接收都要回復確認 (ACK=序列號+長度)，發送方看到 ACK 就知道要發送起始序列號，接收方就能無丟失且順序正確。
##### 3. 四次揮手: 雙方都可以主動發起斷開連接
![[Pasted image 20231101134404.png]]
* 雙方都會向對方發送 FIN 包，並且接收 ACK 包
* 為甚麼是四次揮手?
	因為 TCP 的半關閉特性，當一方關閉連接還是能接收對方的消息，所以情況像是 
	A 說: "我沒什麼好說的"， 
	B 說: "我知道了"，此時 A 向 B 的連接釋放了，
	B 可能還有話要說，故 B 又說了一大堆東西，
	B 說: "我說完了"，
	A 說: "知道了"，B 就釋放連接。
* 為甚麼需要進行第四次揮手的超時等待?
	因為最後一次的 ACK 包可能因為網路問題導致另一方沒接收到，此時另一端會以為沒接收到而再次發起一次 FIN 包，若沒有超時等待直接關閉，對方會完全無發收到 ACK 包，導致單方面關閉連接。
##### TCP 其他特性
1. TCP 慢啟動: TCP 為達到壅塞控制，所以會先慢慢傳輸，用來取得網路實際情形，然後才慢慢增大，所以新訪問網頁刷新較慢。

#### UDP
直接將數據裝成 Segment 後，就直接透過網卡發送。
優點:
1. 性能損耗小: 不用建立可靠連接的三部曲
2. 資源占用少
缺點: 傳輸不可靠。




### HTTP
#### Request
* Status line: 方法 url 版本
* Header: Host, User-Agent (瀏覽器), Accept (允許接收格式)....
* Body
```tex
GET /path/to/resource HTTP/1.1\r\n 
Host: www.example.com\r\n 
User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, 
			like Gecko) Chrome/95.0.4638.54 Safari/537.36\r\n 
Accept: text/html,application/xhtml+xml,application/xml; 
		q=0.9,image/webp,*/*;q=0.8\r\n 
Accept-Language: en-US,en;q=0.5\r\n 
Accept-Encoding: gzip, deflate\r\n 
Connection: keep-alive\r\n 
\r\n 
{"key": "value", "foo": "bar"}
```
#### Response
* Status line: 版本 狀態碼 原因短語
* Header: Content-type, Lenght
* Body
```tex
HTTP/1.1 200 OK\r\n 
Content-Type: text/html\r\n 
Content-Length: 1024\r\n 
\r\n 
<!DOCTYPE html> 
<html> 
	<head> 
		<title>Example Page</title> 
	</head> 
	<body> 
		<h1>Hello, World!</h1> 
		<p>This is an example page.</p> 
	</body> 
</html>
```

|狀態碼|原因|
|--|--|
|2XX|Success|
|3XX|Redirection (表示資源已經移到別的地方)|
|4XX|Client Error|
|5XX|Server Error|
##### 常見狀態瑪
* 200: OK
* 201: Created，用於 POST 創建用戶
* 204: No Content
* 301: Move Permenent，表示資源已經永久移動了並返回新地址
* 302: Found，表示資源臨時轉移返回臨時資源地址
* 304: Not Modified，表示未修改直接返回緩存
* 400: Bad Request，表示客戶端語法錯誤，服務端無法理解
* 401: Unauthorized，表示沒有你這個人，未認證
* 403: Forbidden，權限不足，你只是普通用戶
* 404: Not Found，地址寫錯或資源已不在
* 409: Conflict，可能問題出在新老版本問題
* 500: Internet Server Error，服務器內部任一錯誤
* 502: Bad Gateway，網關錯誤
* 503: Service Unavalible，服務器超載或維護

#### 持久連接
因為 Http 協議中只能請求一個 url，若每次請求時都要建立一次 TCP 連接就很浪費資源，故 HTTP/1.1 中採用持久連接，第一次請求會在 Header 添加 Connection: open，後續的添加 Connection: keep-alive，最後一個請求添加 Connection: close
> 網頁請求時通常是先取得 html 文件，在看需要 css, js 再逐個請求，所以顯示一個網頁是有多次請求的。 

但是連接是有時間限制的，因為服務需要紀錄戶端的連接，若連接太多會導致服務氣崩潰。
#### 無狀態
服務器若需要紀錄客戶端信息，會使服務端在客戶端過多時崩潰，故 HTTP 在設計時就是無狀態的，那如何維持狀態呢? Cookie技術可由服務端設置，然後每次請求時都會帶上。

#### HTTP各版本
##### HTTP 1.1 
* 特性:
	1. 一次一個請求，需要等到前面請求的響應才能發起下一個請求。
	2. Body 壓縮
* 問題:
	* *HTTP 隊頭阻塞*: 比如說瀏覽器先請求 HTML，當到 CSS 時阻塞了，後面的 JS 文件也無法請求。
	* 消耗過大: 
		1. HTTP Header為明文並未進行壓縮 e.g. 大量 Cookies
		2. TCP 三次握手
		3. TCP 慢啟動
* 解決方式:
	* 瀏覽器默認多個連接，同時發起請求 e.g. chrome 默認為6，但連接數高可能會導致 DDoS攻擊。
##### HTTP 2
* 特性:
	1. 多路復用技術: 不用等待前一個請求的響應，並可以同時發起多個請求。
	2. Header 壓縮: 採用 HPACK 算法。
	3. 猜分 Header 與 Body: 將 Message 像是 Frame 一樣拆成兩分稱為 HTTP frame，並給予流編號，若是重複的首部可以在二次請求中去掉。
	4. Cookie 加入動態表中: 可以用來省每次傳輸的資源消耗。
	5. HTTP frame 使用二進制: 解析更有效率
	6. 服務器推送: 服務器將解析請求中未來可能的請求一次推送給客戶端，這樣就不用瀏覽器一次次發起請求
* HTTP 2 更好的安全性
	1. 採用二進制編碼
	2. 通常 HTTP 2 都會採取 TLS 加密
* 問題:
	1. DDoS 非對稱攻擊: 由於服務器推送，導致只要發起一個請求就會導致服務器大量的推送，形成一個槓桿。
	2. TCP 隊頭阻塞: 在 HTTP/2 中，所有的流都在同一个 TCP 連接上，如果這個連接中的一个數據包丟失，那整個 TCP 連接上的數據流都需要等待該數據包被確認收到并重傳。这就是所謂的 TCP 層面的隊頭阻塞問題。
##### HTTP 3
因為問題不在應用層而是傳輸層，但 TCP 是交由操作系統實作的，所以只能更換傳輸層協議。
目前看不懂先跳....
### HTTPS
#### HTTPS 會話密鑰原理
用顏色比喻如下圖所示，小青與小紅分別有自己的私人顏色(私鑰)，互相決定好一個公共顏色(公鑰)，雙方透過私人顏色搭配公共顏色變成合成色(私鑰+公鑰)，雙方互換混合色，交換完的混褐色再加上私人顏色變成超混合色(密鑰)，雙方使用超混合色進行加密通訊。
![[Pasted image 20231101165628.png]]
* 安全理由: 在網路上傳遞的資訊無法湊出密鑰，因為都需要使用自己的私鑰才能湊出來。

#### SSL證書
是由第三方機構 Certificate Authority (CA) 提供的，這個證書存放在服務器中，用來表示這個網站是可信任的，其中這個證書是有一個成對的公私鑰的。

#### HTTPS 通信過程
1. 先進行 TCP 三次握手
2. 進行 SSL/TLS 握手
	1. Client Hello: Client 發送 TSL 版本、支持加密套件與第一個隨機數
	2. Server Hello: Server 發送 TSL 版本、選擇的加密套件與第二個隨機數
	3. Certificate: Server 發送證書
	4. Server Key Exchange:  Server 發送公鑰
	5. Server Hello Down: Server 結束
	6. Client Key Exchange, Change Ciper Spec:
		這步驟客戶端會生成第三隨機數，又更為預主密鑰，但與前兩次不同會將其用 Server 在前面給予的公鑰進行加密，後發送給服務端。客戶端會利用這三個隨機數生成會話密鑰。
	7. Encrypted Handshake Message: 
		服務端會利用私鑰解密預主密鑰，然後利用這三個隨機數生成會話密鑰，才發送此訊息表示可以使用會話密鑰進行溝通。
> 非對稱加密發生在 Server Key Exchange 與 Encrypted Handshake Message 這步驟，之後都是使用會話密鑰進行對稱加密。

##### 加密總結
* Client 給 Server 第一隨機數 (未加密)
* Server 給 Client 第二隨機數 (未加密)
* Server 給 Client 公鑰，自己保留私鑰
* Client 生成第三隨機數並使用公鑰加密發給 Server
* Server 解密後，將三個隨機數生成會話密鑰，Client 也有三個隨機數也可以生成會畫密鑰。
> 為什麼要有三個隨機數？ 因為可以增加隨機性，也可以避免單一方的密鑰被破解。
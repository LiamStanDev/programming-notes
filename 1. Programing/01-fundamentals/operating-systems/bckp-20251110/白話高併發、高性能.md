# 第一章 - 進程與線程
---
### 從 CPU 開始
#### CPU 只知道的兩件事
1. 取址：從內存中取出指令放入寄存器
2. 執行：執行指令
* cpu 要取的下一個地址存放在 PC (Program Counter) 裡。

### CPU 到操作系統
編譯器編譯完的程序，其中一定有程序入口也就是 Main 函數，它會存放在磁盤中，需要執行它只要讓 PC 指向入口的地址就能執行。沒有操作系統也能夠執行程序，但執行時需要做兩件事情：
1. 在內存中找到合適大小放入程序
2. 找到函數入口，設定好 PC 寄存器
以上兩件事非常繁瑣，故工程師建立了一個程序自動化以上操作，這個程序就是 OS (Operating System)。

程序進入內存中需要有數據結構來描述它，也就是[[Ch2 - Process Management#進程的組成 - Process Control Block (PCB) | PCB (Process Control Block)]]。

### 進程到線程
當我們進入多核心 CPU 時代，我們就會希望多個核心運行一個程序，那麼開啟多個進程不是就能解決問題了嗎？但這樣會產生以下幾個問題：
1. 進程 PCB 需要佔用內存空間，只是相同程序的話，這樣會內存空間的浪費。
2. 若任務涉及到通信，因為各個進程處於不同的內存地址空間，這樣就需要借助 OS 的幫助，增加編成難度也增加系統開銷。

#### 線程的誕生
進程簡單來說就是在內存保存的一塊區域，想要執行它只要將 PC 指向 Main 函數的第一個地址，那麼我們**將 PC 指向非 Main 函數的函數，此時就誕生線程**。
![[Pasted image 20231224214426.png]]
* 線程就是一個獨立的執行流
線程也需要有一個數據結構來維護線程訊息也就是[[Ch2 - Process Management#TCB 線程控制塊| TCB (Thread Control Block)]]，但顯然所需要的開銷會小於 PCB。
#### 線程的一些特質
* 線程處於相同的進程空間，溝通非常容易。
* 線程也就是將 PC 指向非 Main 函數的第一個指令，所以建立線程一定需要指定一個函數入口，以下案例為 C# 建立線程
```cs
Thread thread = new Thread(DoSomthing);
thread.Start();
```
* 開啟線程是需要在進程中開闢一個棧空間用來存放運行信息，會消耗內存空間。


# 第二章 - I/O 多路復用
---
### I/O 的本質
**IO 本質就是 copy 數據**，分為
1. Input: 將數據從內存 copy 外部設備
2. Output: 將數據從外部設備 copy 內存
![[Pasted image 20231225000731.png]]

### I/O 與 CPU
CPU 頻率以 GHz 起跳，而磁盤操作為 ms 級別，故兩者速度有極大的差異，故操作系統實現如下，以寫入為例子：
1. 線程執行寫入操作，使用系統調用 `read`
2. 磁盤向內存 copy 數據，線程進入阻塞隊列，並剝奪 cpu 控制權交給其他就緒隊列線程。
> 現代磁盤不需要借助 cpu 來完成寫入，這個技術稱為 DMA (Direct Memory Access)，它會自己讀取內存進行寫入。
3. 磁盤完成寫入發起外設中斷，OS 將被阻塞的線程放入就緒隊列中。

### 文件是什麼？
![[Pasted image 20231225083131.png]]
在 Linux 下一切都被抽象成文件，文件簡單理解就是 N bytes 序列，這一套簡潔的抽象可以使程序員使用一套接口就能對所有外部設備進行 I/O 操作。

#### 常見的 I/O 操作
* open: 打開文件
* seek: 改變讀寫位置
* read, write: 文件讀寫
* close: 關閉文件

### 文件描述符 (file descriptor)
**文件描述符是操作系統發給進程的號碼牌**，進程不用知道操作對象的磁盤物理地址、加載內存地址、以及如何進行管理，一切都交給操作系統，只須憑著號碼牌就能進行操作。
```shell
int fd = open("file_name");
read(fd, buff);
```
![[Pasted image 20231225085746.png]]

### 過多的文件描述符
假設我們有一個服務器，在建立 TCP 三次握手後可以使用 `accept` 獲取文件描述符號。
```shell
int socket_fd = accept(...);
```
但是 Server 不可能只有少數與客戶端的通信，所以會有成千上萬的文件描述符號，為了避免 I/O 組塞（因前面 I/O 未完成，導致後續 I/O 無法進行），如以下操作：
```shell
if (read(socket_fd1, buff) > 0) {
	...
} 
if (read(socked_fd2, buff) > 0) {
	...
}
```

故我們開啟多個線程分別處理每個通信，會產生以下問題：
* 產生大量的線程，導致大量的線程創建與銷毀，影響系統性能。

#### 優化策略 - 好了通知我
原先我們會讓線程使用 I/O 接口，不斷的去*主動*使用文件描述符詢問內核這些外設是否準備就緒，我們改讓*內核去監視這些文件描述符*，好了通知後再進一部處理。這種高效的方式就是**I/O 多路複用 (I/O multiplexing)**

### I/O 多路複用 Multiplexing
>Multiplex 用於通信工程中，表示使用一條信到處理多路的信號，這個機器稱為 Multiplexer。

#### I/O 多路複用過程
1. 進程拿到一多文件描述符（無論是網路、磁盤）。
2. 調用某個函數告訴內核，*"這函數先不要返回，替我監視這些文件描述符，當這些文件可以進行 I/O 操做時再返回"*。
3. 返回後就能知道哪些文件描述符可以進行操作。

#### Linux 下的多路復用機制
> 以下多路復用機制都是組塞式 I/O，也就是同步 I/O
##### 1. select
將文件描述符號集合作爲參數傳遞給 select ，select 會將這些文件描述符**拷貝**到內核中。
缺點：
* 文件描述符限制在 1024 個以下
* 需要進行拷貝: 性能低下
* 返回值只能知道裏面之中有些可以讀寫，但不知道是哪個，只能遍歷查找

##### 2. poll
與 select 很類似，只解決 1024 的文件描述符限制

##### 3. epoll
* 解決 1024 的限制
* 減少拷貝：select, poll 每次想要監聽都需要拷貝文件描述符，epoll 會一直持續間停直到主動停止，所以沒次 epoll 只需要傳遞之前沒監聽的。
* 採用 Event-Driven : 準確告訴你哪些檔案描述符準備好 I/O 或有其他條件待處理。這減少了遍歷檢查沒有活動的文件描述符的開銷。


# 異步
---
### 核心概念
同步與異步並不是兩者運行在各自的線程，而是兩個函數調用之間是否需要等待前一步完成
* 在不同線程上的同步操作
	IO 操作實際上就是通過系統調用方式向 OS 發出請求，但原線程組塞而同步。

### 異步調用
異步調用的函數會直接返回，不會阻塞當前線程，如下圖所示。
![[Pasted image 20231225142601.png]]
調用方如何知道異步調用是否完成呢？分爲以下兩種情況：
1. 調用方不關心執行結果：這種情況很簡單。
2. 調用方需要知道執行結果

#### 調用方需要知道執行結果
有以下兩種機制：
1. 通知機制：任務執行完成後發送信號(linux 中的 signal, 或信號量)
2. 回調機制: 也就是 callback 函數

# 協程
---
普通函數與協程唯一的不同就是協程可以有**多個返回點**。如下例子
```python
def func() {
	print("a")
	暫停返回
	print("b")
	暫停返回
	print("c")
}
```
與一般函數不同的是一般函數使用 `return` 返回後，線程空間就不會在保留原函數運行時的任何信息，而**協程暫停返回後的運行信息是會保存下來**的。
#### Show me the code
```python
def func() {
	print("a")
	yield
	print("b")
	yield
	print("c")
}

def main() {
	co = func()
	next(co)
	priint("in the main function")
	next(co)
	next(co)
}
```
```text
運行結果爲
a
in the main function
b
c
```


### 協程與線程
![[Pasted image 20231225145012.png]]
協程只是一個可以被掛起的函數，並且還可以回覆運行，這與 OS 對線程的調度一樣，**可以被暫停也可以恢復運行**。
* 協程爲用戶態線程：進程爲操作系統調度，程序員無法控制，但協程該如何暫停如何恢復是由程序員可控的，故稱之。

### 協程的實現
因爲協程可以被暫停又能被恢復，所以協程上下文 (Coroutine Context)，普通函數執行時上下文在 Stack 中，但協程是長時間生命周期，所以將上下文**存放在 heap**，但來回 copy 很浪費，所以就**直接在 heap 執行函數**。

### 協程細節
* 協程相比線程更小更輕量：進程佔用 1MB 左右空間，而協程只佔用幾百或者幾十 KB 左右。
* 線程是 OS 最小的執行單元，協程是基於線程，協程的創建、切換與銷毀都是在某個線程中進行的。
* 線程切換 vs. 協程切換的開銷：
	* 線程切換：
		1. 切換時需要將 CPU 寄存器存儲起來，讀入另外一個線程數據
		2. 高速緩存數據可能失效，導致需要從內存讀取
		3. 線程切換涉及用戶態到內核態切換，會運行上千條指令，涉及保存用戶態的上下文。
	* 協程切換：
		1. 寄存器保存與加載數據較小
		2. 高速緩存不容易失效
		3. 沒有用戶態切換內核態過程
		4. 協程是非搶佔式，線程式採用時間片算法的搶佔式，減少不必要的切換。

# 高性能服務器
---
## 多進程
在 linux 下可以使用 fork 系統調用創建多個進程。
優點：
	1. 寫起來簡單，容易理解
	2. 地址空間隔離，崩潰不會影響其他進程
	3. 充分利用多核心
	4. 不會阻塞
缺點：
	1. 進程通信複雜
	2. 進程開銷比線程要更大

## 多線程
優點：
	1. 共享地址空間，線程通信容易
	2. 線程開小較進程小
	3. 不會阻塞
缺點：
	1. 共享地址空間，線程崩潰可能導致進程退出
	2. 開銷還是太大，不能達到十萬級連接的服務器要求

## 事件驅動: Event Loop
![[Pasted image 20231225160739.png]]
僞代碼如下
```python
while (true) {
	event = getEvent()
	handler(event)
}
```

#### 爲什麼可以同時處理多個請求呢？
因爲用戶請求大部分時間花費在 I/O 操作，一個請求來 CPU 直需要運行少少的邏輯就要進行 I/O，我們可以不必等待 I/O 完成直接進行下一個請求，現代 OS 提供非組塞式的異步 IO，e.g. 
使用 `aio_read` 進行異步讀取，該函數會立刻返回，並且調用線程來檢測 IO 操作是否完成。

#### 事件來源
IO 多路復用技術，我們可以一次監控多個文件描述符，當某個文件可讀或可寫就能獲得通知。
* IO 多路復用技術就是 event loop 的原料供應商。

#### 缺點
無法利用多核心優勢

# 進程基本概念
---
#### 程序：
靜態的，存放在磁盤裡的可執行文件，就是一個指令集集合
#### 進程：
動態的，是程序的一次執行過程

### 進程的組成 - Process Control Block (PCB)
- 進程描述信息：
    1. Process ID (PID)
    2. User ID (UID)
- 進程管理資訊：
    1. CPU運行時間、磁盤使用情況、網路流量
    2. 進程當前狀態：就緒/阻塞/運行…
- 資源分配清單：
    1. 分配內存
    2. 正在使用哪些I/O設備
    3. 使用的文件
- 寄存器：PSW、PC與其他寄存器的值（用於進程恢復）

👉 這些資訊統一存放在PCB這個數據結構中 PCB是進程存在的唯一標誌，當程序運行時OS會創建PCB，結束時會回收PCB

### 進程的組成 - 程序段、數據段
- 程序段：也就是.text
- 數據段：也就是.data, .bss
這些都會隨者程序執行被加載到內存中。

💡 進程實體由PCB、程序段與數據段 
💡 進程實體：靜態的，為進程的某個時間點的快照

### 進程的特徵
1. 動態性：進程是程序的一次執行過程，動態發生變化
2. 併發性
3. 獨立性
4. 異步性
5. 結構性：每一個進程都有PCB、程序段與數據段

# 進程狀態與組織
---
## 進程的狀態
![[Untitled(4).png]]
- **創建態（New）**：表示可執行文件被讀入內存，OS分配系統資源與PCB的時間。
- **就緒態（Ready）**：完成創建之後，進入可以被執行的狀態，但目前沒有空閒的CPU可以執行。
- **運行態（Running）**：當CPU空閒時，OS會選擇一個就緒的進程進行運行。 
- **阻塞態（Waiting/Blocked）**：當應用程序主動請求等待某個事件發生（系統調用），進程就會被阻塞並釋放CPU時間片。
> 當等待事件發生，此時進程狀態就會從阻塞態變成就緒態
    
- **終止態（Terminated）**：當程序調用`exit`（系統調用），會釋放CPU時間片，並進行善後工作的期間
> 當善後工作完成，進程就會被銷毀，進程生命結束

## 進程的組織
> 多個進程應該使用什麼數據結構存放。
- 執行指針：指向運行態的進程
### 進程組織方式 - 鏈式 （大部分使用）
- 就緒隊列：存放就緒態的進程
- 阻塞隊列：存放阻塞的進程
    - e.g. 等待打印隊列、等待磁盤隊列等

### 進程組織方式 - 索引
- 就緒表指針：指向就緒索引表
- 阻塞表指針：指向阻塞索引表


# 進程控制
---
簡單來說就是就是要控制**進程狀態變換**

### 實現進程控制
需要使用原語，原語表示具有原子性的操作
#### 為何需要使用原語？
因為狀態轉換涉及多個操作，每個操作**都需要完全實現**，才能正常的進行狀態轉換，操作需要一氣呵成
#### 原語是如何實現？
- 是由兩個特權指令實現：**開中斷指令**、**關中斷中斷**
> CPU在執行每一條指令時，都會檢查是否有外部中斷信號，當運行關中斷指令時，執行語句不會檢查外部中斷信號，一直執行直到執行開中斷指令為止。

### 進程創建：創建 → 就緒
- 創建原語：
    1. 聲請空白PCB
    2. 分配進程所需資源
    3. 初始化PCB
    4. 將PCB插入就緒隊列
- 觸發時機
    1. 用戶登入：創建用戶管理進程
    2. 作業調度：表示存放在磁盤的程序（作業）被讀入內存
    3. 提供服務：某些系統調用，會創建獨立進程處理
    4. 應用請求：由應用程序請求開啟進程

### 進程終止 ：就緒/阻塞/運行 → 終止→ 無
- 撤銷原語：
    1. 從PCB集合中找到終止進程的PCB
    2. 若程序正在進行，立即剝奪CPU，將CPU分配給其他進程
    3. 終止其所有子進程
    4. 將資源歸還其父進程或者操作系統
    5. 刪除PCB
- 觸發時機
    1. 正常結束：`exit`系統調用
    2. 異常結束
    3. 外設中斷

### 進程阻塞：運行態 → 阻塞態
- 阻塞原語：
    1. 找到阻塞進程的PCB
    2. **保護進程現場**，將PCB轉為阻塞態後停止運行
    3. 將PCB插入對應的阻塞隊列
- 觸發時機：
    1. 需要等待系統分配某種資源
    2. 需要等待其他相互合作的進程完成工作

### 進程喚醒：阻塞態 → 就緒態
- 喚醒原語：
    1. 在等待隊列中找到PCB
    2. 從等待隊列中移除，並設置為就緒態
    3. 將PCB插入就緒隊列
- 觸發條件：
    1. 等待事件發生

### 進程切換：（舊）運行態→就緒態，（新）就緒態 → 運行態
- 切換原語：
    1. 將運行環境訊息存入PCB
		- [ ] 執行環境包含：PC, PSW, 通用寄存器，也就是進程上下文(Context)
    1. 將PCB插入相應隊列
    2. 選擇另一個進程執行，並更新PCB
    3. 根據PCB恢復新進程的執行環境
- 觸發條件：
    1. 進程時間片到
    2. 存在更高優先級進程到達

#### 進程控制原語做了以下三件事：
1. 更新PCB
2. 將PCB插入對應的隊列
3. 分配/回收資源 （創建以及終止時）

## 2.4 進程間通信
---
#### 為什麼進程間通信需要內核支持？
因為進程是系統資源分配的單位（包括內存地址空間），每個進程的內存地址空間都是獨立的，不能相互訪問以及修改（安全考慮），所以只能由操作系統來支持。

### 共享存儲
由操作系統在內存開闢一片區域，可以讓其他進程使用，為了避免錯誤需要使進程間訪問是互斥的（操作系統的P、V操作）

- Linux中有提供
    ```go
    int shm_open(...); // share memory open，為系統調用，申請一片共享區域
    void *mmap(...); // mmap系統調用將共享區的地址空間映射到進程自己的進程空間
    ```
    

### 消息傳遞
#### 方式一：直接通信
直接指名發送給誰
1. 進程P建立消息msg，包含消息頭（發送者pid , 接收者pid）以及消息體。
2. 進程P使用系統調用發送給Q -> 發送原語 `send(Q, msg)`。
3. msg被拷貝到內核空間中，並插入發送給Q的消息隊列。
4. 進程Q使用系統調用 - 接收原語 `receive(P, &msg)`。
5. OS會在發送給Q的消息對列查找P為pid的發送者，找到後將msg拷貝到Q的進程空間，並移出消息對列。

#### 方式二：間接通信(信箱通信)
指定發送信箱，多個進程可以生產與消費相同信箱
1. 進程P建立消息msg，只包含消息體。
2. 進程P使用系統調用發送到A信箱 - 發送原語 `send(A, msg)`。
3. msg被拷貝到內核空間中，並放到信箱A。
4. 進程Q使用系統調用 - 接收原語 `receive(A, &msg)`。
5. OS會將信箱A的msg，拷貝到Q的進程空間，並移出信箱。

### 管道通信
用系統調用聲請一個pipe文件（在內存中固定大小的緩衝區），這個文件是**FIFO**的數據結構（是一個循環隊列），並指支持單向數據流。
1. 進程P聲請pipe文件，並寫入數據
2. 進程Q從pipe文件中讀取數據。
> 與共享內存不同的是，共享內存想寫在哪讀寫都可以，但是管道只能安照順序寫入指定位置，以及讀取指定位置
- 管道只能支持**單向數據流**，若想要雙向的話就需要兩個管道
- 兩個進程需要**互斥的使用管道**（操作系統實現）
- **固定大小**
    - 寫滿的話寫進程會被阻塞，直到讀進程取走數據，寫進程才會被喚醒
    - 讀空的話讀進程會被阻塞，直到管道中有數據，讀進程才會被喚醒
- Linux中允許多個寫進程與讀進程，但是會輪流的進行（互斥）

## 2.5 線程基本概念
---
#### 為何要引入線程？
有些進程需要同時做很多事情，但傳統的進程只能串行的執行一個程序，故引入了線程來增加併發度。

### 線程概念
**線程是程序執行流的最小單位**，在尚未引入線程時，進程是程序執行流的最小單位，但引入線程之後CPU服務的對象不是進程而是進程中的線程。
- 線程是輕量級的進程
- 線程是基本的CPU執行單元
- 進程是除了CPU計算資源外的系統資源分配的單位（e.g. 印表機、地址空間）
> 進程是資源分配的基本單位，線程是調度的基本單位

### 系統開銷
- **進程**間切換需要切換進程執行環境，**系統開銷較大**
- **線程**間切換不用切換進程執行環境，**系統開銷較小**

### 線程屬性
1. 線程是調度的基本單位
2. 多核CPU下，線程可以分別佔用不同CPU
3. 每個線程都有各自的**線程ID**與**線程控制塊（TCB）**
4. 線程也有就緒、運行與阻塞三個狀態
5. 線程幾乎不擁有系統資源
6. **相同進程下的線程共享進程資源**
7. 線程間通信幾乎不需要系統干預：因為共用進程地址空間
8. **同一進程中的線程切換開銷較小**

# 線程的實現與線程模型
---
## 線程的實現
### 方式一：用戶級線程（User-Level Thread, ULT）[早期Unix系統]
由編程語言的庫(Thread Library)來實現，OS看到的還是進程，如下
```cpp
int main() {
		int i = 0;
		while(true) {
				if (i = 0) {執行線程1;}
				if (i = 1) {執行線程2;}
				if (i = 2) {執行線程3;}
				i = (i + 1) % 3;
		}
}
```
- 線程切換不需要請求系統線程管理。
> Thread Library就像是用戶級線程的運行時，用來管理哪個用戶級線程執行。
- 線程切換不用CPU執行狀態轉換（用戶態 → 內核態→ 選擇線程 → 用戶態），使需在用戶態就能完成。
- 操作系統不知道線程存在，只看得到進程。
- 優點：不需要CPU變態，所以可以減少執行環境切換的開銷 ⇒ 開銷小、效率高
- 缺點：
	1. 當某一個線程被阻塞（e.g. 系統調用），後面就不會執行，導致整個進程被阻塞。
	2. 線程無法在多核CPU並行運行。

### 方式二：內核級線程（Kernel-Level Thread, KLT）[Linux, Windows均支持]
由操作系統支持的線程，線程管理工作由操作系統提供
- 線程切換需要CPU變態
- 操作系統是知道線程的存在
- 優點：
	1. 某一線程阻塞時，別的線程可以繼續執行
	2. 多核CPU可以並行運行多個線程
- 缺點：線程切換涉及CPU變態，開銷較大

## 多線程模型
多線程模型指的是**一個進程(一個應用)**，如何搭配用戶級線程與內核級線程，將用戶級線程＋內核級線程搭配使用，就可以衍伸出不同的多線程模型。

> 操作系統只看得見內核級線程，內核級線程才是處理的基本單位 也就是OS分配與調度與管理是根據內核級線程

🔥 用戶級線程是“代碼邏輯”的載體 內核級線程是“運行機會”的載體

### 一對一模型：
**一個進程有多個內核級線程**，且一個用戶級線程對應一個內核級線程。
* 優缺點：同使用內核級線程
![[Pasted image 20230806153256.png]]
### 多對一模型：
**一個進程只有一個內核級線程**，且多個用戶級線程對一個內核級線程
- 優缺點：同用戶級線程，併發度低
![[Pasted image 20230806153005.png]]

### 多對多模型：
**一個進程有多個內核級線程**，且多個用戶級線程對應多個內核級線程
* 克服多對一模型併發度不高的問題，又克服內核級線程開銷過大的問題。
![[Pasted image 20230806153528.png]]

# 線程狀態轉換
---
![[Pasted image 20230806154356.png]]

# 線程的組織與控制
---
### TCB 線程控制塊

|線程標示|TID|
|---|---|
|**程序計數器PC**|紀錄執行到哪|
|**其他寄存器**|線程運行的中間結果|
|**堆棧指針（SP）**|函數調用位置與局部變量|
|線程運行狀態|運行/就緒/阻塞|
|優先級|線程調度、資源分配的參考|

- 粗體部分為線程切換上下文（需要保存與恢復）

### 線程組織
- 可以依照進程、狀態或其他條件，將線程放到thread table中作為儲存。

# 調度簡介(Scheduling)
---
### 名詞解釋
- 調度：因為資源有限，需要決定執行順序的行為稱之
- 作業：一個具體的任務

### 高級調度 - 作業調度（job scheduling)

> 用戶向系統提交一個作業$\approx$用戶讓操作系統啟動一個程序 ，但因為**內存資源有限**，不可能將所有作業讀入內存，所以**存在一個作業後備隊列**（外存中），從作業後備對列中取出讀入內存。

#### 為什麼需要作業調度？ 
cpu只會讀取內存中的指令，作業調度就是批量將作業放入就緒隊列（內存），讓cpu可以間斷的執行。 (外存 -> 內存)
- 每個作業只被調入一次，調出一次
- 調入時建立PCB，調出時銷毀PCB
🔥 旨在內存不足的情況下，**建立PCB**

### 中級調度- 內存調度（**memory scheduling**）

> 內存資源不夠時，可**將某些進程的資源移出至磁盤（外存）**，等內存空閒或者運行時需要再重新調入內存中。暫時被調到外存的進程狀態稱為掛起，被掛起的PCB會被組織成掛起隊列。

- 內存調度也就是決定使哪個掛起的進程重新進入內存
- 直觀的例子：
    - 當手機開了很多App當切換App時很快，那表示它存在內存中，當切換較慢表示他在進行內存調度。
🔥 旨在內存不足情況下，**存放PCB**

### 低級調度 - **進程調度**（處理機調度, **processor scheduling**）

> 按照某種策略**從就緒隊列中取出一個進程**，將處理機分配給它

- 進程調度是最基本的調度，且調度頻率很高（一般為10ms左右）⇒ 實現併發
🔥 旨在CPU核心不足情況下，**運行進程**

### 七狀態模型
![[Untitled(6).png]]
注意：就續掛起可能來自
1. 內存不足時，創建後將PCB放入外存
2. 內存不足時，就續後將PCB轉為放入外存
3. 內存不足時，運行結束後PCB放入外存
4. 內存不足時，阻塞等待事件發生後後PCB放入外存
🔥 掛起對列面對的是內存不足，使用外存來存放

### 三層調度對比

|做什麼|發生位置|頻率|對進程影響|
|--|---|---|---|---|
|作業調度|從後備隊列中，取出作業建立進程並放入內存|外存 → 內存|最低|無→ 創建態→就緒態|
|內存調度|從掛起對列中，取出進程，並放入內存|外存 → 內存|次之|掛起態→就續態 or 阻塞掛起 → 阻塞態|
|進程調度|從就緒隊列中，取出進程，並使處理機執行|內存 → CPU|最高|就緒態→運行態|

# 進程調度(Processing Scheduling)
---
按照某個算法選擇進程，並為其分配CPU

### 進程調度的時機
1. 當前進程主動放棄CPU
    - 程序正常終止
    - 運行異常終止
    - 系統調用的I/O等待
2. 被動放棄CPU
    - 時鐘中斷
    - 更緊急事件處理（e.g. I/O中斷）
    - 更高優先級的進程，進入就緒隊列

### 不能進行進程調度的時機（重要)
1. 中斷處理的過程：因為操作複雜且與底層硬件密切相關
2. 操作OS內核零界區：零界區表示需要**互斥訪問的資源**，內核零界區如就緒隊列等，會嚴重影響執行的稱為內核零界區
	🔥 因為訪問就緒隊列時會上鎖，若中途進程切換，鎖未釋放導致進程切換無法訪問就緒隊列，導致無法調度的問題（死鎖）
	💡 普通零界區可以進行進程切換，如等待打印機，因為等待時間緩慢會導致CPU空閒，且切換過程中不會導致內核調度的問題
3. 原子操作過程（原語）

### 調度方式
1. 非剝奪式：只支持進程主動放棄CPU，用於早期批處理系統
2. 剝奪式：支持進程被動放棄CPU，用於分時與實時操作系統

### 進程切換過程
1. 對原進程各種數據的保存
2. 對新進程各種數據的恢復
💡 包含：PC, PSW, 通用寄存器等，都存在PCB中，保存就是更新PCB，恢復就是讀取PCB
🔥 進程切換是有代價的，過於頻繁的進程切換雖可以增加併發度，但會使大部分時間浪費在切換上，導致效率下降。


# 調度器（Scheduler）
---
### 基本介紹
調度器決定
1. 讓誰運行
2. 執行多長
- 支持線程的操作系統，調度器調度的是**內核級線程**

### 調度時機
主要發生在就緒隊列發生改變、阻塞與中斷
- 創建新進程
- 進程退出
- 運行進程阻塞
- I/O中斷發生
#### 閒逛進程(idle)
當就緒隊列為空時，會讓CPU執行閒逛進程，不會讓CPU停下
特性：
- 進程優先度最低
- 操作**0寄存器**，不會使用其他寄存器，但又可以**佔用一個指令時間**（每次執行都會檢查中斷）
- 耗能低

### 調度算法的評量指標
1. CPU利用率：CPU忙碌的時間佔總時間的比例
2. 系統吞吐量：單位時間內完成多少作業
- 週轉時間：表示提交作業到完成作業所花費的時間
    - 週轉時間 = 完成時間 - 提交時間
- 平均週轉時間 = 週轉時間 / 作業數
- 權重週轉時間 = 週轉時間 / 運行時間
    🔥 表示執行一個程序所花的時間是**運行時間的幾倍**，越大表示調度越沒效率
- 平均權重週轉時間$=\left(\sum{\frac{作業運行時間}{總時間}\times週轉時間}\right) / 作業數$
- 等待時間 = 週轉時間 - 執行時間 - 等待I/O時間
    🔥 等待調度的時間
- 平均等待時間 $=(\sum等待時間)/作業數$
- 響應時間：提交作業到發生響應的時間

# 調度算法 - 批處理操作系統
---
### 先來先服務（First Come First Service, FCFS）
- 算法思想：從“公平”的角度考慮
- 算法規則：從作業/進程到達(就緒隊列、後備對列)的先後順序進行服務
- 使用場景：
    - 用於作業調度：考慮哪個作業先到**後備對列**
    - 用於進程調度：考慮哪個進程先到**就緒隊列**
- 是否搶佔式：非搶佔式，只有現在處理的進程主動放棄，啟用該調度算法
- 優點：實現容易、公平
- 缺點：在長作業（進程）後面的短作業（進程）很不利 ⇒ 對短作業不利
- 是否存在飢餓：不存在

### 短作業優先（Shortest Job First, SJF）
- 算法思想：追求更少的平均等待時間、平均週轉時間與權重週轉時間
- 算法規則：最短作業/進程優先進行服務
- 使用場景：
    - 用於作業調度
    - 用於進程調度的叫做**Short Process First (SPF)**
- 是否搶佔式：SJF與SPF是非搶佔式，搶佔式版本稱為最短剩餘時間優先算法（Shortest Remaining Time Next, SRTN）
    - SJF/SPF : 當前就緒態(後備對列)中運行時間最短的作為下一個執行
    - SRTN : 當就緒隊列發生改變，就要比較當前進程與就緒隊列中的進程進行比較，若就緒隊列進程運行時間較短，就發生搶佔。注：在其他時候與SPF相同。
- 優點：最短的平均週轉時間、平均等待時間
- 缺點：
    1. 不公平
    2. 對短作業有絕對優勢
    3. 另外運行時間是由用戶提供，可以任意設定，不一定能做到短作業優先
- 是否存在飢餓：若有源源不斷的短進程到來，長作業會餓死

### 高響應比優先（Hight Response Ratio Next, HRRN）
1. FCFS：考慮的是當下哪個**等待時間最短**
2. SJF : 考慮的是當下哪個**運行時間最短** 兩者都只考慮一個因素，所以綜合考慮就有HRRN

- 算法思想：同時考慮等待與運行時間
- 算法規則：每次調度時都計算各個作業/進程的響應比，選擇響應比最高的運行
    
$$ respose\ rate=\frac{waiting\: time＋run\: time}{run\: time}=1+\frac{waitting\: time}{run\:time} $$
- 使用場景：
    - 用於作業調度：考慮哪個作業先到**後備對列**
    - 用於進程調度：考慮哪個進程先到**就緒隊列**
- 是否搶佔式：非搶佔式，只有現在處理的進程主動放棄，啟用該調度算法
- 優點：
    1. 綜合考慮兩種因素
    2. 等待時間相同 ⇒ 選擇運行時間最短 (SJF優點)
    3. 運行時間相同 ⇒ 選擇等待時間最短 (FCFS優點)
- 缺點：X
- 是否存在飢餓：不存在，因為長作業等待時間越久，響應比就會變大

# 調度算法 - 分時與實時操作系統
---
### 時間片輪轉調度算法（Round-Robin Scheduling, RR）
- 算法思想：公平的、輪轉的給每一個進程服務，並讓每一個進程都可以在一定的時間內獲得響應
- 算法規則：按照加入就緒隊列的順序，依次讓個進程運行一個時間片，當進程完成一個時間片的運行，剝奪CPU使用，並將其添加到隊尾(默認下)重新排隊。
- 使用場景：用於進程調度，因為作業調度沒有CPU時間片的概念
- 是否搶佔式：搶佔式，因為進程要被時鐘中斷放棄CPU使用權
- 優點：
    1. 公平
    2. 響應時間快
    3. 適用於分時操作系統
- 缺點：
    1. 高頻率的進程切換會有切換開銷
    2. 不區分緊急程度
- 是否存在飢餓：不存在
🔥 時間片若設定太大，其實就會退化成FCFS
    
### 優先級調度算法

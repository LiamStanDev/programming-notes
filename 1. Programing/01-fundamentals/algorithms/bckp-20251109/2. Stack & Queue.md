Stack 與 Queue 就是一個**受限的數據結構**，它本質是 Array 或者 LinkedList，但暴露出的 API 只能操作頭尾。

### 1. Stack 與 Queue 轉換
#### 題目1: Stack 實現 Queue 
[Leetcode 232](https://leetcode.com/problems/implement-queue-using-stacks/description/)
```c#
public class MyQueue {
    Stack<int> s1 = new();
    Stack<int> s2 = new();

    public MyQueue() {}

    public void Push(int x) {
        s1.Push(x);
    }

    public int Pop() {
        if (s2.Count == 0) { // 注意
	        while(s1.Count > 0) {
                var temp = s1.Pop();
                s2.Push(temp);
            }
        }
        return s2.Pop();
    }

    public int Peek() {
        if (s2.Count == 0) { // 注意
            while(s1.Count > 0) {
                var temp = s1.Pop();
                s2.Push(temp);
            }    
        }
        return s2.Peek();
    }

    public bool Empty() {
        return s1.Count == 0 && s2.Count == 0;
    }
}
```

#### 題目2: Queue 實現 Stack 
[Leetcode 225](https://leetcode.com/problems/implement-stack-using-queues/description/)
```c#
public class MyStack {
    Queue<int> queue = new();

    public MyStack() {}
    
    public void Push(int x) {
	    int size = queue.Count;
	    queue.Enqueue(x);
	    
	    for (int i = 0; i < size; i++) { // 將新添加的放在對首
		    int temp = queue.Dequeue();
		    queue.Enqueue(temp);
	    }
    }
    
    public int Pop() {
	    return queue.Dequeue();
    }
    
    public int Top() {
	    return queue.Peek();
    }
    
    public bool Empty() {
	    return queue.Count == 0;
    }
}
```

#### 題目4: Valid Parentheses 
[Leetcode 20](https://leetcode.com/problems/valid-parentheses/)
```c#
public class Solution {

    public bool IsValid(string s) {

        Stack<char> stack = new();

        foreach (char c in s) {
            if (IsLeftParam(c)) {
                stack.Push(c);
            }

            if (IsRightParam(c)) {
                if (stack.Count == 0) { // 右括號太多
                    return false;
                }
                
                bool matched = MatchLeftParam(c) == stack.Pop();
                if (!matched) { 
                    return false;
                }
            }
        }

        if (stack.Count > 0) { // 左括號有剩
            return false;
        }
        return true;
    }

    public bool IsLeftParam(char c) {

        return c == '(' || c == '[' || c == '{';
    }

    public bool IsRightParam(char c) {
        return c == ')' || c == ']' || c == '}';
    }

    public char MatchLeftParam(char c) {
    
        if (c == ')') {
            return '(';
        } else if (c == ']') {
            return '[';
        } else {
            return '{';
        }
    }
}
```

##### 延伸1: Minimum Add to Make Parentheses Valid 
[Leetcode 921](https://leetcode.com/problems/minimum-add-to-make-parentheses-valid/)
注意: 遇到某個一個括號，現在的資訊是在該括號之前，所以補是要補之前。也就是說看到右括號若要進行補足是補右括號之前的，不是補在之後。

只要右括號沒有左括號，當下一定要補一個左括號，右括號則需要看完整個字串。
```c#
public class Solution {

    public int MinAddToMakeValid(string s) {
        int res = 0;
        int need = 0; // the need for right param
  
        foreach (char c in s) {
            if (c == '(') {
                need++;
            } else if (c == ')') {
                need--;
                if (need == -1) {
	                res++;
	                need = 0;
	            }
            }
        }
        return res + need;
    }
}
```

##### 延伸2: Minimum Insertions to Balance a Parentheses String
[Leetcode 1541](https://leetcode.com/problems/minimum-insertions-to-balance-a-parentheses-string/)
```c#
public class Solution {

    public int MinInsertions(string s) {
        int res = 0;
        int need = 0;

        foreach (char c in s) {
            // every time encounter '(' are the new begining
            if (c == '(') {
                if (need % 2 == 1) { // make right need param to even.
                    res++; // add right param
                    need--;
                }
                need += 2;
            } else if (c == ')') {
                need--;
                if (need == -1) {
                    res++; // add left param
                    need = 1;
                }
            }
        }
        return res + need;
    }
}
```


#### 題目5: Next Greater Element I (單調棧技巧)
[Leetcode 496](https://leetcode.com/problems/next-greater-element-i/)
首先想到由後往前找，然後將數據存入 stack 中，並每次都將比自己小的 pop 掉。
時間複雜度分析: 每一個元素都只會被 push 與 pop 一次，所以為 `O(n)`
```c#
public class Solution {

    public int[] NextGreaterElement(int[] nums1, int[] nums2) {

        Dictionary<int, int> dic = new();
        Stack<int> stack = new();

        for (int i = nums2.Length - 1; i >= 0; i--) {
            while(stack.Count > 0 && stack.Peek() < nums2[i]) {
                stack.Pop();
            }

            dic[nums2[i]] = stack.Count == 0 ? -1 : stack.Peek();
            stack.Push(nums2[i]);
        }

        int[] res = new int[nums1.Length];

        for (int i = 0; i < nums1.Length; i++ ) {
            res[i] = dic[nums1[i]];
        }
        return res;
    }
}
```
##### 延伸1: Daily Temperatures
[Leetcode 739](https://leetcode.com/problems/daily-temperatures/)
注意這題要計算的是距離，stack 可以放入 index，就可以反推距離。
```c#
public class Solution {
    public int[] DailyTemperatures(int[] temperatures) {
        int[] res = new int[temperatures.Length];
        Stack<int> stack = new();

        for (int i = temperatures.Length - 1; i >= 0; i--) {
            while (stack.Count > 0 && temperatures[stack.Peek()] <= temperatures[i]) {
                stack.Pop();
            }
            res[i] = stack.Count == 0 ? 0 : (stack.Peek() - i);
            stack.Push(i);
        }
        return res;
    }
}
```

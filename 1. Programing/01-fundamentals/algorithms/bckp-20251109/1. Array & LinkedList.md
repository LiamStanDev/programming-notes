## 數組
---
### 1. 前綴和數組
使用契機: 當原數組不變動，題目需要頻繁的使用子數組和時
難點:
* 如何設定前綴和?
是否要留第一個位置為0 => 防止數組越界
* 找到符合題目的利用子數組的計算公式
#### 題目一: 303. Range Sum Query - Immutable
```c# 
public class NumArray {

    int[] _preSum;

    public NumArray(int[] nums) {
        _preSum = new int[nums.Length];

        _preSum[0] = nums[0];
        for (int i = 1; i < nums.Length; i++) {
            _preSum[i] = _preSum[i - 1] + nums[i];
        }
    }

    public int SumRange(int left, int right) {
	    // left == 0 下防止數組越界
        return left != 0 ? _preSum[right] - _preSum[left - 1] : _preSum[right];
    }
}

```

#### 題目二: 304. Range Sum Query 2D - Immutable
* 難點: 
	* 該如何找到計算公式
	* 該如何設計前綴和 => 想法使用目標答案來設想公式
```c#
public class NumMatrix {

    int[,] _preSum;

    public NumMatrix(int[][] matrix) {
        _preSum = new int[matrix.Length, matrix[0].Length];

		// 建立前綴和
        for (int row = 0; row < matrix.Length; row++) {
            for (int col = 0; col < matrix[row].Length; col++) {
                _preSum[row, col] = getPreSum(row - 1, col) 
	                + getPreSum(row, col - 1) 
	                - getPreSum(row - 1, col - 1) 
	                + matrix[row][col];
            }
        }
    }
	// 實際要返回的函數
    public int SumRegion(int row1, int col1, int row2, int col2) {
        return getPreSum(row2, col2)
            - getPreSum(row1 - 1, col2)
            - getPreSum(row2, col1 - 1)
            + getPreSum(row1 - 1, col1 - 1);
    }
	// 同樣是避免數組訪問越界
    private int getPreSum(int row, int col) {
        if (row < 0 || col < 0) {
            return 0;
        }

        return _preSum[row, col];
    }
}
```

#### 題目三: 560. Subarray Sum Equals K
首先我們優先想到前綴和，但是得到了前綴和之後，發現在計算子數組合時，需要將所有子數組合都嘗試，這樣時間複雜度為 `O(n^2)` ，如下:
```c# 
public class Solution {
    public int SubarraySum(int[] nums, int k) {
        int[] preSum = new int[nums.Length + 1];
    
        preSum[0] = 0;
        for (int i = 1; i <= nums.Length; i++) {
            preSum[i] = preSum[i - 1] + nums[i - 1];
        }
    
        int res = 0;
        for (int i = 1; i < preSum.Length; i++) {
            for (int j = 0; j < i; j++) {
                if (preSum[i] - preSum[j] == k) {
                    res++;
                }
            }
        }
    
        return res;
    }
}

```
下面兩層 for 迴圈是最浪費時間的，發現其實只要找到 preSum - k 之後，有哪些 preSum 與其相等就可以了。問題變成先計算一個 preSum - k，然後查找有幾個其他 preSum 與其相等，想到可以將 preSum 都放到 HashMap 其 key 為 preSum 值， value 為出現次數。

```c#
public class Solution {

    public int SubarraySum(int[] nums, int k) {
        Dictionary<int, int> preSum = new();

        preSum.Add(0, 1);
        int tempSum = 0;
        int res = 0;
        for (int i = 0; i < nums.Length; i++) {
            tempSum += nums[i];

            if (preSum.ContainsKey(tempSum - k)) {
                res += preSum[tempSum - k];
            }

            if (preSum.ContainsKey(tempSum)) {
                preSum[tempSum] += 1;
            } else {
                preSum[tempSum] = 1;
            }
        }
        return res;
    }
}

```
> 注意不要使用 Dictionary 的 Add 方法，他只會添加第一次，他不像 java 中的 put 方法會更新，若已經有 key 會拋出異常。


### 2. 差分數組
使用契機: 題目需要頻繁的對區間進行增減
差分數組的題目首先將整個數組變成差分數組，差分數組的第 0 位表示起始值，後面每一位都是增量，經過一系列操作後最後將其還原。可以在分析出使用差分數組技巧時，無腦寫下 Increament (用於增減) 與 Result (用於復原) 函數。
難點:
* 題目比較隱晦很難知道是否要使用差分數組
* 增減區間: 
	* 區間開始時若增加，要在區間結束 +1 的位置扣掉
	* 區間開始時若減少，要在區間結束 +1 的位置增加
#### 題目一: 1109. Corporate Flight Bookings
```c#
public class Solution {
    int[] diff;
    public int[] CorpFlightBookings(int[][] bookings, int n) {
        diff = new int[n];

        foreach (var booking in bookings) {
            Increament(booking[0], booking[1], booking[2]);
        }

        return Result();
    }

    private void Increament(int i, int j, int val) {
	    // 因為飛機是由 1 ... n
	    // 原指標為 i ... j + 1
	    // 對應到 index 為 0 ... n - 1
	    // 故指標就為 i - 1 到 j
        diff[i - 1] += val;
        if (j < diff.Length) {
            diff[j] -= val;
        }
    }

    private int[] Result() {
        int[] res = new int[diff.Length];
        res[0] = diff[0];
        for (int i = 1; i < diff.Length; i++) {
            res[i] = res[i - 1] + diff[i];
        }
        return res;
    }
}
```

#### 題目二: 1094. Car Pooling
```c#
public class Solution {
    private int[] diff;

    public bool CarPooling(int[][] trips, int capacity) {
        diff = new int[1000];
        
        foreach (var trip in trips) {
            Increament(trip[1], trip[2], trip[0]);
        }
        var res = Result();
        
        foreach (var amount in res) {
            if (amount > capacity) return false;
        }
        return true;
    }
    
    private void Increament(int i, int j, int val) {
        diff[i] += val;
		// 這邊不是 j + 1 主要是因為他一到站就下車了
        if (j < diff.Length) {
            diff[j] -= val;
        }
    }

    private int[] Result() {

        int[] res = new int[diff.Length];

        res[0] = diff[0];

        for (int i = 1; i < diff.Length; i++) {

            res[i] = res[i - 1] + diff[i];

        }
        return res;
    }
}
```


### 3. 雙指針
數組雙指針技巧分為左右指針與快慢指針，
* 左右指針: 兩指針相向而行或者相背而行，分為:
	* 相向而行: 整體回文，nSum，反轉
	* 相背而行: 局部回文
	* 二分查找
* 快慢指針: 表示兩個指針向相同方向前進，分為:
	1. 原地修改刪除型
	2. 原地修改移動型
	3. 滑動窗口
使用契機:
* 題目與**回文**有關則使用左右指針
* 題目要求**原地修改數組**，且只需要前面幾個元素後面不管，則使用快慢指針，或者需要使用滑動窗口
	* 原地修改題: fast 向前探路，達成條件操作 slow (刪除用覆蓋或移動用交換)，也就是說不管何種條件 fast 都應該繼續走，slow 走是在條件符合時。
	* 滑動窗口: 請見後面章節
##### 快慢指針框架
```c#
int slow = 0;
int fast = 0;
while (fast < arr.Length) {
	if (fast 達成甚麼條件) {
		// 以下兩行順序會依題目不同交換。
		arr[slow] = arr[fast]; // 直接覆蓋
		slow++;
	}
	fast++; // fast 一直走
}
```
#### 題目一: 26. Remove Duplicates from Sorted Array
題目希望原地修改，所以思考快慢指針，又因為移除所以使用覆蓋。
```c#
public class Solution {
    public int RemoveDuplicates(int[] nums) {

        if (nums.Length == 0) {
            return 0;
        }

        int slow = 0;
        int fast = 0;

        while (fast < nums.Length) {
            if (nums[slow] != nums[fast]) {
                slow++;
                nums[slow] = nums[fast];
            }
            fast++;
        }

        return slow + 1;
    }
}
```

#### 題目二: 27. Remove Element
題目希望原地修改，所以思考快慢指針，又因為是移除故使用覆蓋。
```c#
public class Solution {
    public int RemoveElement(int[] nums, int val) {
        if (nums.Length == 0) {
            return 0;
        }

        int slow = 0;
        int fast = 0;

        while (fast < nums.Length) {
            if (nums[fast] != val) {
                nums[slow] = nums[fast];
                slow++;
            }
            fast++;
        }
        return slow;
    }
}

```

#### 題目三: 283. Move Zeroes
這題也是原地修改且是移動所以使用交換。
```c#
public class Solution {
    private void Swap(int[] nums, int i, int j) {
        int temp = nums[i];
        nums[i] = nums[j];
        nums[j] = temp;
    }

    public void MoveZeroes(int[] nums) {
        if (nums.Length == 0) {
            return;
        }

        int slow = 0;
        int fast = 0;

        while (fast < nums.Length) {
            if (nums[fast] != 0) {
                Swap(nums, slow, fast);
                slow++;
            }
            fast++;
        }
    }
}
```

左右指針問題有 
1. nSum: 請見下文
2. 反轉: 很簡單跳過
3. 回文: 很簡單跳過

#### 題目四: 5. Longest Palindromic Substring
因為不是確定整題是否回文，故使用相背而行的左右指針，確認以每個字為中心向兩側檢查，要注意回文分為基數回文與偶數回文這兩個要分別處理。
```c#
public class Solution {

    private string Palindrome(string s, int l, int r) {
        while (l >= 0 && r < s.Length && s[l] == s[r]) {
            l--;
            r++;
        }

        return s.Substring(l + 1, r - l - 1); // [l + 1, r - 1] len = r - 1 - (l + 1) + 1
    }
    public string LongestPalindrome(string s) {
        string res = "";

        for (int i = 0; i < s.Length; i++) {
            string s1 = Palindrome(s, i, i);
            string s2 = Palindrome(s, i, i + 1);

            res = res.Length > s1.Length ? res : s1;
            res = res.Length > s2.Length ? res : s2;
        }
        return res;
    }
}
```

### 4. 滑動窗口
滑動窗口是快慢指針來維護一個窗口，由於其特殊性故單獨分類，窗口會因為各種條件擴大或者縮小，常用於解決子串問題。由於 left 與 right 指針只會增加不會減少，所以時間複雜度只有 `O(n)` 相較於暴力搜索快得多。實際概念為 **right 找到可行解，left 優化可行解**。

##### 滑動窗口框架
```c#
void SlidingWindow(string s) {
	Dictionary<char, int> need = new(); // optional
	Dictionary<char, int> window = new(); // dictionary
	
	int left = 0; // include
	int right = 0; // exclude
	// 右指針向左走找到可行解
	while (right < s.Length) {
		// 移入窗口元素
		var c = s[right];
		window.Add(c);
		// 窗口變大
		right++;
		/* Do something */
		
		/* Debug */
		// Console.WriteLine($"window: [{left}, {right})")

		// 判斷左指針是否收縮
		while (left < right && left need shrink) {
			// 移出窗口元素
			var c = s[left];
			window.Remove(c);
			// 窗口變小
			left++;
			/* Do something */
		}
	}
}
```
* 為甚麼第一個 while 是 `<` 而不是 `<=` ?
	* 因為是左閉右開，結束條件為 `right == s.Length`

#### 題目一: 76. Minimum Window Substring
子字串問題使用滑動窗口
```c#
public class Solution {
    public string MinWindow(string s, string t) {
        Dictionary<char, int> window = new();
        Dictionary<char, int> need = new();
		// 添加到 need 中
        foreach (var c in t) {
            if (need.ContainsKey(c)) {
                need[c]++;
            } else {
                need[c] = 1;
            }
        }

        int left = 0;
        int right = 0;
        // 用來記錄達成了 need 中幾個需求，完全達成就可以 shrink
        int valid = 0;
        // return index
        int start = 0;
        int len = int.MaxValue;

        while (right < s.Length) {
            var c = s[right];
            if (window.ContainsKey(c)) {
                window[c]++;
            } else {
                window[c] = 1;
            }

            right++;

            if (need.ContainsKey(c) && need[c] == window[c]) {
                valid++;
            }

            while (left < right && valid == need.Count) {
                if (len > right - left) {
                    start = left;
                    len = right - left;
                }

                var d = s[left];
				// 確認是需求的，且少了他就不滿足需求
                if (need.ContainsKey(d) && window[d] == need[d]) {
                    valid--;
                }
                window[d]--;
                left++;
            }
        }
        return len == int.MaxValue ? "" : s.Substring(start, len);
    }
}

```

#### 題目二: 567. Permutation in String
如何判定是否包含其排列?
1. 達成 need 中所有條件
2. 長度需相同

```c# 
public class Solution {
    public bool CheckInclusion(string s1, string s2) {
        Dictionary<char, int> window = new();
        Dictionary<char, int> need = new();

        foreach (char c in s1) {
            if (need.ContainsKey(c)) {
                need[c]++;
            } else {
                need[c] = 1;
            }
        }

        int left = 0;
        int right = 0;
        int valid = 0;


        while (right < s2.Length) {
            var c = s2[right];
            if (window.ContainsKey(c)) {
                window[c]++;
            } else {
                window[c] = 1;
            }
            right++;

            if (need.ContainsKey(c) && window[c] == need[c]) {
                valid++;
            }

            while (left < right && valid == need.Count()) {
                if (s1.Length == (right - left)) {
                    return true;
                }
                var d = s2[left];
                if (need.ContainsKey(d) && need[d] == window[d]) {
                    valid--;
                }
                window[d]--;
                left++;
            }

        }
        return false;
    }
}
```

#### 題目三: 438. Find All Anagrams in a String
這題秒殺
```c# 
public class Solution {
    public IList<int> FindAnagrams(string s, string p) {
        Dictionary<char, int> window = new();
        Dictionary<char, int> need = new();

        int left = 0;
        int right = 0;

        int valid = 0;

        List<int> res = new();

        foreach (var c in p) {
            if (need.ContainsKey(c)) {
                need[c]++;
            } else {
                need[c] = 1;
            }
        }

        while (right < s.Length) {
            char c = s[right];

            if (window.ContainsKey(c)) {
                window[c]++;
            } else {
                window[c] = 1;
            }

            right++;

            if (need.ContainsKey(c) && need[c] == window[c]) {
                valid++;
            }

            while (left < right && need.Count == valid) {
                if (p.Length == (right - left)) {
                    res.Add(left);
                }

                char d = s[left];
                window[d]--;
                if (need.ContainsKey(d) && need[d] == window[d]) {
                    valid--;
                }

                left++;
            }
        }

        return res;
    }
}
```


#### 題目四: 3. Longest Substring Without Repeating Characters 
```c#
public class Solution {
    public int LengthOfLongestSubstring(string s) {
        Dictionary<char, int> window = new();

        int left = 0;
        int right = 0;

        int res = 0;
        while (right < s.Length) {
            char c = s[right];

            if (window.ContainsKey(c)) {
                window[c]++;
            } else {
                window[c] = 1;
            }
            right++;

            while (left < right && window[c] > 1) {
                char d = s[left];
                left++;
                window[d]--;
            }

            res = Math.Max(res, right - left);
        }
        return res;
    }
}
```

### 5. 二分查找
想清出循環結束條件與左右邊界是否包含就沒問題了。
二分查找問題分為以下三種

1. 找一個數: 用左閉右閉
```c#
int l = 0; // inclusive
int r = nums.Length - 1; // inclusive
while (l <= r) {
	int mid = l + (r - l) / 2;
	if (target == nums[mid])  return mid;
	else if (target > nums[mid]) l = mid + 1;
	else r = mid - 1;
}
return -1;
```
2. 找一個數的左邊界: 用左閉右開
```c#
int l = 0; // inclusive 
int r = nums.Length; // exclusive
while (l < r) {
	int mid = l + (r - l) / 2;
	if (target == nums[mid]) r = mid;
	else if (target > nums[mid]) l = mid + 1;
	else r = mid;
}
return nums[l] == target ? l : -1; 
```
3. 找一個數的右邊界: 用左閉右開
```c#
int l = 0;
int r = nums.Length;
while (l < r) {
	int mid = l + (r - l) / 2;
	if (target == nums[mid]) l = mid + 1;
	else if (target > nums[mid]) l = mid + 1;
	else r = mid;
}
return nums[r - 1] == target ? r - 1: -1;
```
> 為何這邊要使用 r - 1，因為 r 是 inclusive。




## 鏈表
---
### 1. 基本技巧
#### 1. 合併兩個有序鏈表 [Leetcode 21](https://leetcode.com/problems/merge-two-sorted-lists/)
```c#
public class Solution {
	ListNode MergeTowList(ListNode l1, ListNode l2) {
		ListNode dummy = new ListNode(-1);
		ListNode p1 = l1;
		ListNode p2 = l2;
		ListNode cur = dummy;
		while (p1 != null && p2 != null) {
			if (p1.val <= p2.val) {
				cur.next = p1;
				p1 = p1.next;
			} else {
				cur.next = p2;
				p2 = p2.next;
			}
			cur = cur.next;
		}
		if (p1 != null) {
			cur.next = p1;	
		} 
		if (p2 != null) {
			cur.next= p2;
		}
		return dummy.next;
	}
}
```

#### 2. 合併 k 個升序鏈表 [Leetcode 23](https://leetcode.com/problems/merge-k-sorted-lists/description/)
解題關鍵在於想到每次只需要取得最小的放入就可，想到 PriorityQueue。
```c#
public class Solution {
       public ListNode MergeKLists(ListNode[] lists) {
       if (lists == null) {
	       return  null;
       }
       ListNode dummy = new ListNode(-1);
	   PriorityQueue<ListNode, int> pq = new();
	   ListNode cur = dummy;
	   foreach (var node in lists) {
			if (node != null) {
				pq.Enqueue(node, node.val);
			}
		}

		while (pq.Count > 0) {
			var node = pd.Dequeue();
			if (node.next != null) {
				pd.Enqueue(node.next, node.next.val);
			}
			cur.next = node;
			cur = cur.next;
		}
    }

}

```
#### 3. 移除鏈表倒數第 k 個節點 [Leetcode 19](https://leetcode.com/problems/remove-nth-node-from-end-of-list/)
```c#
public class Solution {
	ListNode FindNthFromEnd(ListNode head, int n) {
		ListNode slow = head;
		ListNode fast = head;
		for (int i = 0; i < n; i++) {
			fast = fast.next;
		}

		while (fast != null) {
			slow = slow.next;
			fast = fast.next;
		}

		return slow;
	}
    public ListNode RemoveNthFromEnd(ListNode head, int n) {
	    ListNode dummy = new ListNode(-1);
	    dummy.next = head;
	    var preDelNode = FindNthFromEnd(dummy, n + 1);
	    preDelNode.next = preDelNode.next.next;
	    return dummy.next;
    }
}
```

#### 4. 鏈表中點 [Leetcode 876](https://leetcode.com/problems/middle-of-the-linked-list/description/)
```c#
public class Solution {

    public ListNode MiddleNode(ListNode head) {
	    ListNode slow = head;
	    ListNode fast = head;
	    while (fast != null && fast.next != null) {
		    fast = fast.next.next;
		    slow = slow.next;
	    }
		return slow;
    }
}
```

#### 5. 鏈表是否成環 [Leetcode 141](https://leetcode.com/problems/linked-list-cycle/)
```c#
public class Solution {

    public bool HasCycle(ListNode head) {
	    ListNode fast = head;
	    ListNode slow = head;
	    while (fast != null && fast.next != null) {
		    fast = fast.next.next;
		    slow = slow.next;
		    if (fast == slow) {
			    return true;
		    }
	    }
	    return false;
    }
}
```

#### 6. 鏈表環的起始點 [Leetcode 142](https://leetcode.com/problems/linked-list-cycle-ii/)
```c#
public class Solution {

    public ListNode DetectCycle(ListNode head) {

        if (head == null || head.next == null) {
            return null;
        }
        ListNode fast = head;
        ListNode slow = head;

        while (fast != null && fast.next != null) {
            
            fast = fast.next.next;
            slow = slow.next;

            if (fast == slow) {
                slow = head;
                
                while (fast != slow) {
                    fast = fast.next;
                    slow = slow.next;
                }
                return slow;
            }
        }
        return null;
    }
}
```

#### 7. 兩鏈表是否相交 [Leetcode 160](https://leetcode.com/problems/intersection-of-two-linked-lists/description/)
```c#
public class Solution {

    public ListNode GetIntersectionNode(ListNode headA, ListNode headB) {
		if (headA == null || headB == null) {
			return null;
		}
		ListNode p1 = headA;
		ListNode p2 = headB;
		while (p1 != p2) {
			if (p1 == null) {
				p1 = headB;
			} else {
				p1 = p1.next;
			}
			if (p2 == null) {
				p2 = headA;
			} else {
				p2 = p2.next;
			}
		}
		return p1;
    }
}
```
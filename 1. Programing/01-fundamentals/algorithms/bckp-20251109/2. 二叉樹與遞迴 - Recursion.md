### 二叉樹解題思維
1. **遍歷**一遍就能得到答案: 可延伸出回朔算法。
	* 透過遍歷過程輔以外部變量求解答案。
	* 習慣上二叉樹使用 `void traverse()` 作為函數簽名，而回朔使用 `void backtrace()`
	* 均沒有返回值。
3. 透過子樹(子問題)來**分解**問題: 可延伸出動態規劃。
	* 要充分利用返回值來傳遞子樹結果。
	* 函數簽名會有返回值。
#### 共通點(均要思考)
到每一個節點需要做甚麼?是在前/中/後序哪個位置做?
* 快速排序: 為二叉樹的前序遍歷，目的是透過遍歷**將每個值排好**。
* 歸併排序: 為二叉樹的後續遍歷，目的是透過**將左右分別排好**，再一次排好。

#### 遍歷序的概念
1. 中序位置: 通常只用於將一個BST按照排列順序進行遍歷。
2. 前序位置: 自頂而下，將不是後序與中序敏感的計算放在這。**只能獲取父節點透過參數傳遞來的資訊**。
3. 後序位置(最特別): 自底向上，**能獲取父節點參數傳遞資訊 + 子樹返回值資訊**。

> 也就是說題目求解與子樹有關，先設定返回值然後在後序位置寫程式，其他輔助的都寫在前序位置。

##### 不利用遞迴方式實現
1. 前序遍歷(中左右)
	因為stack是後進先出，故要先壓入右邊，在押入左邊，又因為是前序遍歷，故自己彈出時要做對應的事情。
```c#
void PreorderTraversal(TreeNode root) {
	if (root != null) {
		return;
	}
	Stack<TreeNode> stack = new();
	stack.Push(root);

	while (stack.Count > 0) {
		TreeNode cur = stack.Pop();
		// Do someting
		Console.WriteLine(cur.val);

		// 棧是後進先出，故要先壓入右
		if (cur.right != null) {
			stack.Push(cur.right);
		}
		if (cur.left != null) {
			stack.Push(cur.left);
		}
	}
}
```

2. 中序遍歷(左中右)
	因為左邊開始，所以將左節點一直壓入，直到左邊結束，最後在切換右子樹。
```c#
void InorderTraversal(TreeNode root) {
	if (root == null) {
		return;
	}
	Stack<TreeNode> stack = new();

	// 一路走到最左下的節點，把路徑上都壓入
	// 最後在到右子樹
	TreeNode cur = root;
	while (cur != null || stack.Count > 0) {
		while (cur != null) {
			stack.Push(cur);
			cur = cur.left;
		}
		// Do Something
		cur = stack.Pop();
		Console.WriteLine(cur.val);

		// 切換成右樹
		cur = cur.right;
	}
}
```
> 第一個 while 迴圈中的 cur != null ，是因為 root 壓入前stack為空。 

3. 後序遍歷(左右中)
	需要兩個棧，用一個棧先寫出先序遍歷(但是先左再右)，然後將結果放入第二個棧中，最後第二個棧就是後續遍歷
```c#
void PostorderTraversal(TreeNode root) {
	if (root == null) {
		return;
	}
	Stack<TreeNode> stack1 = new();
	Stack<TreeNode> stack2 = new();
	stack1.Push(root);
	while (stack1.Count > 0) {
		TreeNode cur = stack1.Pop();
		stack2.Push(cur);

		if (cur.left != null) {
			stack1.Push(cur.left);
		}
		if (cur.right != null) {
			stack2.Push(cur.right);
		}
	}

	while (stack2.Count > 0) {
		TreeNode cur = stack2.Pop();
		// Do Something
		Console.WriteLine(cur.val);
	}
}
```

### 二叉樹基本解題概念
1. 統計節點數量:
	某解點以下節點為兩個子節點分別的子節點和 + 1 (自己)
2. 最大深度問題: 
	某節點最大深度為兩個子節點中最大的深度加上 + 1 (自己)
3. 最大直徑問題:
	某節點最大直徑為兩子節點最大深度的和

### 動態規劃/回溯算法/DFS與樹的聯繫
* 動態規劃: 屬於分解問題思路，關注於整顆*子樹*
* 回溯算法: 屬於遍歷思路，關注於節點間的*樹枝*
* DFS: 屬於遍歷思路，關注於單個*節點*

#### 回溯算法框架
可以使用多叉樹遍歷的概念來實現，關注點在樹枝，也就是節點到節點之間的移動的過程。
```c#
void backtrace(...) {
	for(int i = 0; i < ...; i++) {
		// 進入時
		// 做選擇
		...
		
		// 下層決策
		backtrace();
		
		// 回來時
		// 撤銷剛才的選擇
		...
	}
}
```

### 層序遍歷
```c#
void LevelTraversal(TreeNode root) {
	if (root == null) {
		return;
	}

	Queue<TreeNode> queue = new();
	queue.Enqueue(root);

	while (queue.Count > 0) {
		TreeNode cur = queue.Dequeue();

		// Do Something
		Console.WriteLine(cur.val);

		if (cur.left != null) {
			queue.Enqueue(cur.left);
		}
		if (cur.right != null) {
			queue.Enqueue(cur.right);
		}
	}
}
```

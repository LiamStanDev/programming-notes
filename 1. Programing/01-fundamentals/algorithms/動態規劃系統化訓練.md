# 動態規劃系統化訓練指南

> 本指南專門針對「理解狀態」和「掌握邊界條件」兩大核心難點設計

## 目錄
- [核心概念解析](#核心概念解析)
- [五步解題框架](#五步解題框架)
- [狀態定義專項訓練](#狀態定義專項訓練)
- [邊界條件專項訓練](#邊界條件專項訓練)
- [分級題庫與訓練路線](#分級題庫與訓練路線)
- [每日練習模板](#每日練習模板)

---

## 核心概念解析

### 什麼是「狀態」？

**白話解釋：** 狀態就是您在問的「一系列有規律的子問題」。

**數學表示：** `DP[i]`、`DP[i][j]` 或 `DP[i][j][k]`

**本質組成：**

| 部分              | 描述                    | 目的                |
| --------------- | --------------------- | ----------------- |
| **輸入 (Input)**  | `i, j, k...` 這些維度（索引） | 描述當前的子問題是什麼       |
| **輸出 (Output)** | `DP[i][j]` 這個值        | 描述這個子問題的最佳答案/解是什麼 |

### 經典範例對照

| 問題 | 狀態定義（您在問什麼？） | 狀態的維度（輸入） | 狀態的值（輸出） |
|------|------------------------|-------------------|-----------------|
| 費氏數列 | 第 i 項的值是多少？ | `i`（第 i 項） | `DP[i]` 的值 |
| 最長遞增子序列 (LIS) | 以第 i 個元素結尾的最長遞增子序列的長度是多少？ | `i`（子序列必須以 `A[i]` 結尾） | `DP[i]` 的值（長度） |
| 0/1 背包 | 在只考慮前 i 個物品，且背包容量上限為 j 的情況下，能得到的最大總價值是多少？ | `i`（物品編號）<br/>`j`（背包容量） | `DP[i][j]` 的值（最大總價值） |

### 定義狀態的思考框架

當您面對一個新的 DP 題目時：

1. **我要求什麼？** （通常是最大值、最小值、或總數）
   - → 這會成為 DP 陣列裡要存的值

2. **我的解會受到哪些變量/條件的影響？**
   - → 這些條件會成為 DP 陣列的維度（`i, j, k...`）

---

## 五步解題框架

### 📋 標準化解題流程

每次遇到 DP 題目，都按照以下五個步驟系統化思考：

#### 步驟 1: 確定「狀態」與「目標」

**思考問題：**
- 要求解的問題的「解」，會受到哪些變數的影響？
- DP 數組中要存什麼值？
- 最終的答案會是哪個狀態？

**輸出：**
- DP 數組的維度定義
- DP 數組每個位置的含義
- 最終目標狀態

#### 步驟 2: 建立「狀態轉移方程」

**思考問題：**
- 如何利用更小的子問題的解，推導出當前狀態的解？
- 為了達到 `DP[current]` 所做的最後一次選擇是什麼？
- 這個轉移是否滿足「無後效性」？

**輸出：**
- 數學遞推關係式（例如 `DP[i] = max(DP[j]) + 1`）

**關鍵技巧：** 思考「最後一步」

#### 步驟 3: 確定「遍歷方向」

**思考問題：**
- `DP[current]` 依賴於哪個 `DP[smaller]`？
- 計算順序應該是什麼？

**常見模式：**
- 一維 DP：通常從左到右 `i = 1 → N`
- 二維 DP：外層循環 `i`，內層循環 `j`
- 區間 DP：從短區間開始，逐漸擴大

#### 步驟 4: 處理「初始化與邊界條件」⭐

**初始化 (Initialization)：**

| 題目類型 | 初始化策略 | 原因 |
|---------|-----------|------|
| 求最大值 | `DP = -∞` | 確保任何有效解都能更新 |
| 求最小值 | `DP = +∞` | 確保任何有效解都能更新 |
| 求總數/可行性 | `DP = 0` 或 `false` | 表示初始無解 |

**邊界條件 (Base Case)：**

**思考問題：**
- 哪個狀態是「不依賴任何其他狀態」就可以直接確定的？
- 當 `i` 取到最小的有效值（通常是 0 或 1）時，答案是什麼？

**常見錯誤：**
- ❌ 試圖用轉移方程去計算邊界條件
- ❌ 求最小值卻初始化為 0（如果 0 也是可能的答案）

#### 步驟 5: 執行與優化

- 按照遍歷方向填滿 DP 數組
- 檢查是否能進行空間優化（降維）

---

## 狀態定義專項訓練

### 訓練目標
掌握「狀態」的定義，能夠快速識別影響答案的變量。

### 訓練方法

對於每個題目，強制自己回答以下三個問題：

1. **這個問題要求什麼？**（最大、最小、計數？）
2. **答案受哪些變量影響？**（位置、容量、長度、選擇？）
3. **如何用一句話描述 `DP[...]` 的含義？**

### 練習題組

#### 練習 1: 爬樓梯

**題目：** 有 n 階樓梯，每次可以爬 1 或 2 階，有多少種方法爬到頂？

**狀態分析：**
1. 要求什麼？→ **方法數**
2. 受什麼影響？→ **當前在第幾階**
3. DP 定義：`DP[i]` = 爬到第 i 階的方法數

**答案：**
- 狀態：一維 `DP[i]`
- 含義：爬到第 i 階的方法總數

#### 練習 2: 0/1 背包

**題目：** 有 n 個物品和一個容量為 W 的背包，每個物品有重量 `w[i]` 和價值 `v[i]`，求最大總價值。

**狀態分析：**
1. 要求什麼？→ **最大價值**
2. 受什麼影響？→ **考慮了哪些物品** + **剩餘容量**
3. DP 定義：`DP[i][j]` = 考慮前 i 個物品，容量為 j 時的最大價值

**答案：**
- 狀態：二維 `DP[i][j]`
- 含義：只使用前 i 個物品，背包容量為 j 時能獲得的最大價值

#### 練習 3: 最長公共子序列 (LCS)

**題目：** 給定兩個字串 s1 和 s2，求最長公共子序列的長度。

**狀態分析：**
1. 要求什麼？→ **最長長度**
2. 受什麼影響？→ **s1 考慮到第幾個字符** + **s2 考慮到第幾個字符**
3. DP 定義：`DP[i][j]` = s1 前 i 個字符與 s2 前 j 個字符的 LCS 長度

**答案：**
- 狀態：二維 `DP[i][j]`
- 含義：s1[0..i-1] 和 s2[0..j-1] 的最長公共子序列長度

---

## 邊界條件專項訓練

### 核心概念區分

| 概念 | 目的 | 思考方式 | 常見錯誤 |
|------|------|---------|---------|
| **初始值 (Initialization)** | 讓狀態轉移方程能正確進行比較和運算 | 「如果這個子問題無解，它應該是什麼值？」 | 求最小值卻初始化為 0 |
| **邊界條件 (Base Case)** | 整個遞推過程的起點，必須是已知的確定的解 | 「能用最簡單、最直接的方式解決的子問題是什麼？」 | 試圖用轉移方程去計算邊界 |

### 邊界條件設定案例

#### 案例 1: 零錢兌換

**問題：** 給定不同面額的硬幣和一個總金額，求最少需要幾個硬幣湊出總金額。

**狀態：** `DP[i]` = 兌換金額 i 需要的最少硬幣數

**邊界條件分析：**
- **Base Case：** `DP[0] = 0`
- **為什麼？** 兌換 0 元需要 0 個硬幣，這是確定的起點
- **初始值：** `DP[i] = ∞` (對於 i > 0)
- **為什麼？** 表示目前無解，等待被更新

**代碼示例：**
```python
def coinChange(coins, amount):
    # 初始化
    dp = [float('inf')] * (amount + 1)
    # 邊界條件
    dp[0] = 0
    
    for i in range(1, amount + 1):
        for coin in coins:
            if i >= coin:
                dp[i] = min(dp[i], dp[i - coin] + 1)
    
    return dp[amount] if dp[amount] != float('inf') else -1
```

#### 案例 2: 最長公共子序列 (LCS)

**狀態：** `DP[i][j]` = s1 前 i 個字符與 s2 前 j 個字符的 LCS 長度

**邊界條件分析：**
- **Base Case：** `DP[0][j] = 0` 且 `DP[i][0] = 0`
- **為什麼？** 當其中一個字串長度為 0 時，LCS 長度必然是 0
- **初始值：** 其他位置初始化為 0（因為長度不可能為負）

**代碼示例：**
```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    # 邊界條件已經隱含在初始化中（全部為 0）
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]
```

#### 案例 3: 0/1 背包

**狀態：** `DP[i][j]` = 考慮前 i 個物品，容量為 j 時的最大價值

**邊界條件分析：**
- **Base Case：** `DP[0][j] = 0`（不考慮任何物品，價值為 0）
- **Base Case：** `DP[i][0] = 0`（容量為 0，價值為 0）
- **初始值：** 其他位置初始化為 0（價值從 0 開始累積）

**代碼示例：**
```python
def knapsack(weights, values, W):
    n = len(weights)
    dp = [[0] * (W + 1) for _ in range(n + 1)]
    
    # 邊界條件已經隱含在初始化中
    
    for i in range(1, n + 1):
        for j in range(1, W + 1):
            # 不選第 i 個物品
            dp[i][j] = dp[i-1][j]
            # 如果能選第 i 個物品
            if j >= weights[i-1]:
                dp[i][j] = max(dp[i][j], dp[i-1][j-weights[i-1]] + values[i-1])
    
    return dp[n][W]
```

### 邊界條件檢查清單

每次設定邊界條件時，問自己：

- [ ] 我是否確定了「最小子問題」的答案？
- [ ] 這個答案是否可以直接確定，無需依賴其他狀態？
- [ ] 初始值是否能讓狀態轉移方程正確運作？
- [ ] 是否考慮了索引越界的情況？

---

## 分級題庫與訓練路線

### Level 1: 一維狀態（建立「狀態」直覺）

**學習目標：** 理解單一變量如何影響答案

| 題號 | 題目 | 狀態定義 | 核心考點 |
|------|------|---------|---------|
| 1 | 爬樓梯 | `DP[i]` = 爬到第 i 階的方法數 | 基礎狀態轉移 |
| 2 | 打家劫舍 | `DP[i]` = 考慮前 i 間房能偷到的最大金額 | 選擇問題 |
| 3 | 最大子數組和 | `DP[i]` = 以 `arr[i]` 結尾的最大子數組和 | 連續性約束 |
| 4 | 零錢兌換 | `DP[i]` = 兌換金額 i 的最少硬幣數 | 最小值問題 |
| 5 | 最長遞增子序列 (LIS) | `DP[i]` = 以 `arr[i]` 結尾的最長遞增子序列長度 | 雙重循環轉移 |

#### 詳細解析：Level 1-1 爬樓梯

**題目：** 有 n 階樓梯，每次可以爬 1 或 2 階，有多少種方法爬到頂？

**五步框架解析：**

**步驟 1: 狀態與目標**
- 影響答案的變量：當前在第幾階
- DP 定義：`DP[i]` = 爬到第 i 階的方法總數
- 最終目標：`DP[n]`

**步驟 2: 狀態轉移方程**
- 最後一步的選擇：到達第 i 階前，我可能從第 `i-1` 階爬 1 階，或從第 `i-2` 階爬 2 階
- 遞推關係：`DP[i] = DP[i-1] + DP[i-2]`
- 為什麼：兩種選擇的方法數相加

**步驟 3: 遍歷方向**
- 依賴關係：`DP[i]` 依賴 `DP[i-1]` 和 `DP[i-2]`
- 遍歷順序：從小到大，`i = 2 → n`

**步驟 4: 初始化與邊界**
- 初始值：`DP` 全部初始化為 0
- 邊界條件：
  - `DP[0] = 1`（0 階有 1 種方法：不動）
  - `DP[1] = 1`（1 階有 1 種方法：爬 1 階）
- 為什麼：這是遞推的起點，必須確定

**步驟 5: 程式碼實現**
```python
def climbStairs(n):
    if n <= 1:
        return 1
    
    dp = [0] * (n + 1)
    dp[0] = 1
    dp[1] = 1
    
    for i in range(2, n + 1):
        dp[i] = dp[i-1] + dp[i-2]
    
    return dp[n]

# 空間優化版本
def climbStairs_optimized(n):
    if n <= 1:
        return 1
    
    prev2 = 1  # dp[i-2]
    prev1 = 1  # dp[i-1]
    
    for i in range(2, n + 1):
        current = prev1 + prev2
        prev2 = prev1
        prev1 = current
    
    return prev1
```

#### 詳細解析：Level 1-2 打家劫舍

**題目：** 一排房屋，每間有一定金額，不能偷相鄰的房子，求最大金額。

**五步框架解析：**

**步驟 1: 狀態與目標**
- 影響答案的變量：考慮到第幾間房
- DP 定義：`DP[i]` = 考慮前 i 間房能偷到的最大金額
- 最終目標：`DP[n]`

**步驟 2: 狀態轉移方程**
- 最後一步的選擇：
  - **偷第 i 間**：`DP[i-2] + nums[i]`（不能偷 i-1）
  - **不偷第 i 間**：`DP[i-1]`（保持之前的最大值）
- 遞推關係：`DP[i] = max(DP[i-1], DP[i-2] + nums[i])`
- 為什麼：選擇能帶來更大收益的方案

**步驟 3: 遍歷方向**
- 依賴關係：`DP[i]` 依賴 `DP[i-1]` 和 `DP[i-2]`
- 遍歷順序：從小到大，`i = 2 → n`

**步驟 4: 初始化與邊界**
- 初始值：`DP` 全部初始化為 0
- 邊界條件：
  - `DP[0] = nums[0]`（只有一間房，直接偷）
  - `DP[1] = max(nums[0], nums[1])`（兩間房，偷價值大的）
- 為什麼：這是最小的子問題，可以直接確定

**步驟 5: 程式碼實現**
```python
def rob(nums):
    if not nums:
        return 0
    if len(nums) == 1:
        return nums[0]
    
    n = len(nums)
    dp = [0] * n
    dp[0] = nums[0]
    dp[1] = max(nums[0], nums[1])
    
    for i in range(2, n):
        dp[i] = max(dp[i-1], dp[i-2] + nums[i])
    
    return dp[n-1]

# 空間優化版本
def rob_optimized(nums):
    if not nums:
        return 0
    
    prev2 = 0  # dp[i-2]
    prev1 = 0  # dp[i-1]
    
    for num in nums:
        current = max(prev1, prev2 + num)
        prev2 = prev1
        prev1 = current
    
    return prev1
```

### Level 2: 二維狀態（理解「多維度影響」）

**學習目標：** 掌握多個變量同時影響答案的情況

| 題號 | 題目 | 狀態定義 | 核心考點 |
|------|------|---------|---------|
| 6 | 0/1 背包 | `DP[i][j]` = 前 i 個物品，容量 j 的最大價值 | 二維狀態經典 |
| 7 | 最長公共子序列 | `DP[i][j]` = s1 前 i 個與 s2 前 j 個的 LCS 長度 | 雙字串 DP |
| 8 | 編輯距離 | `DP[i][j]` = s1 前 i 個轉換為 s2 前 j 個的最少操作數 | 三種選擇 |
| 9 | 不同路徑 | `DP[i][j]` = 到達 (i, j) 的路徑數 | 二維格子 DP |
| 10 | 股票買賣（含冷凍期） | `DP[i][0/1]` = 第 i 天持有/不持有股票的最大利潤 | 狀態機 DP |

#### 詳細解析：Level 2-1 0/1 背包

**題目：** n 個物品，每個有重量 `w[i]` 和價值 `v[i]`，背包容量 W，求最大價值。

**五步框架解析：**

**步驟 1: 狀態與目標**
- 影響答案的變量：考慮了哪些物品 + 剩餘容量
- DP 定義：`DP[i][j]` = 考慮前 i 個物品，容量為 j 時的最大價值
- 最終目標：`DP[n][W]`

**步驟 2: 狀態轉移方程**
- 最後一步的選擇：
  - **不選第 i 個物品**：`DP[i-1][j]`
  - **選第 i 個物品**（如果放得下）：`DP[i-1][j-w[i]] + v[i]`
- 遞推關係：
  ```
  DP[i][j] = DP[i-1][j]  // 如果 j < w[i]
  DP[i][j] = max(DP[i-1][j], DP[i-1][j-w[i]] + v[i])  // 如果 j >= w[i]
  ```
- 為什麼：選擇能帶來更大價值的方案

**步驟 3: 遍歷方向**
- 依賴關係：`DP[i][j]` 依賴 `DP[i-1][...]`
- 遍歷順序：外層循環 i (1 → n)，內層循環 j (0 → W)

**步驟 4: 初始化與邊界**
- 初始值：`DP` 全部初始化為 0
- 邊界條件：
  - `DP[0][j] = 0`（不考慮任何物品，價值為 0）
  - `DP[i][0] = 0`（容量為 0，價值為 0）
- 為什麼：這些狀態的答案是確定的

**步驟 5: 程式碼實現**
```python
def knapsack_01(weights, values, W):
    n = len(weights)
    # 初始化
    dp = [[0] * (W + 1) for _ in range(n + 1)]
    
    # 邊界條件已經隱含在初始化中（全部為 0）
    
    for i in range(1, n + 1):
        for j in range(W + 1):
            # 不選第 i 個物品
            dp[i][j] = dp[i-1][j]
            # 如果能選第 i 個物品
            if j >= weights[i-1]:
                dp[i][j] = max(dp[i][j], dp[i-1][j-weights[i-1]] + values[i-1])
    
    return dp[n][W]

# 空間優化版本（滾動數組）
def knapsack_01_optimized(weights, values, W):
    dp = [0] * (W + 1)
    
    for i in range(len(weights)):
        # 必須從右向左遍歷，避免覆蓋還未使用的狀態
        for j in range(W, weights[i] - 1, -1):
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])
    
    return dp[W]
```

#### 詳細解析：Level 2-2 最長公共子序列 (LCS)

**題目：** 給定兩個字串，求最長公共子序列的長度。

**五步框架解析：**

**步驟 1: 狀態與目標**
- 影響答案的變量：s1 考慮到第幾個字符 + s2 考慮到第幾個字符
- DP 定義：`DP[i][j]` = s1 前 i 個字符與 s2 前 j 個字符的 LCS 長度
- 最終目標：`DP[m][n]`

**步驟 2: 狀態轉移方程**
- 最後一步的選擇：
  - **如果 `s1[i-1] == s2[j-1]`**：這個字符一定在 LCS 中
    - `DP[i][j] = DP[i-1][j-1] + 1`
  - **如果 `s1[i-1] != s2[j-1]`**：至少有一個字符不在 LCS 中
    - `DP[i][j] = max(DP[i-1][j], DP[i][j-1])`
- 為什麼：相等時可以延長序列；不等時取兩種可能的最大值

**步驟 3: 遍歷方向**
- 依賴關係：`DP[i][j]` 依賴 `DP[i-1][j-1]`、`DP[i-1][j]`、`DP[i][j-1]`
- 遍歷順序：外層循環 i (1 → m)，內層循環 j (1 → n)

**步驟 4: 初始化與邊界**
- 初始值：`DP` 全部初始化為 0
- 邊界條件：
  - `DP[0][j] = 0`（s1 為空，LCS 為 0）
  - `DP[i][0] = 0`（s2 為空，LCS 為 0）
- 為什麼：空字串與任何字串的 LCS 都是 0

**步驟 5: 程式碼實現**
```python
def longestCommonSubsequence(s1, s2):
    m, n = len(s1), len(s2)
    dp = [[0] * (n + 1) for _ in range(m + 1)]
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                dp[i][j] = dp[i-1][j-1] + 1
            else:
                dp[i][j] = max(dp[i-1][j], dp[i][j-1])
    
    return dp[m][n]

# 空間優化版本
def longestCommonSubsequence_optimized(s1, s2):
    m, n = len(s1), len(s2)
    # 使用滾動數組
    prev = [0] * (n + 1)
    curr = [0] * (n + 1)
    
    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if s1[i-1] == s2[j-1]:
                curr[j] = prev[j-1] + 1
            else:
                curr[j] = max(prev[j], curr[j-1])
        prev, curr = curr, prev
    
    return prev[n]
```

### Level 3: 複雜狀態轉移（掌握「選擇」的分析）

**學習目標：** 處理多種選擇和複雜約束

| 題號  | 題目     | 狀態定義                            | 核心考點   |
| --- | ------ | ------------------------------- | ------ |
| 11  | 完全背包   | `DP[i][j]` = 前 i 種物品，容量 j 的最大價值 | 物品可重複選 |
| 12  | 單詞拆分   | `DP[i]` = 字串前 i 個字符能否拆分         | 布林型 DP |
| 13  | 分割等和子集 | `DP[i][j]` = 前 i 個數能否湊出和 j      | 可行性 DP |
| 14  | 目標和    | `DP[i][j]` = 用前 i 個數湊出和 j 的方法數  | 計數型 DP |
| 15  | 鋼條切割   | `DP[i]` = 長度為 i 的鋼條最大收益         | 完全背包變形 |

#### 詳細解析：Level 3-1 完全背包

**題目：** n 種物品，每種數量無限，求容量 W 下的最大價值。

**與 0/1 背包的區別：** 每個物品可以選多次

**五步框架解析：**

**步驟 1: 狀態與目標**
- DP 定義：`DP[i][j]` = 考慮前 i 種物品，容量為 j 時的最大價值
- 最終目標：`DP[n][W]`

**步驟 2: 狀態轉移方程**
- 最後一步的選擇：
  - **不選第 i 種物品**：`DP[i-1][j]`
  - **選第 i 種物品**（可以選多次）：`DP[i][j-w[i]] + v[i]`
    - 注意：是 `DP[i][...]` 而不是 `DP[i-1][...]`
- 遞推關係：
  ```
  DP[i][j] = max(DP[i-1][j], DP[i][j-w[i]] + v[i])  // 如果 j >= w[i]
  ```

**步驟 3: 遍歷方向**
- 外層循環 i (1 → n)，內層循環 j (0 → W)

**步驟 4: 初始化與邊界**
- `DP[0][j] = 0`
- `DP[i][0] = 0`

**步驟 5: 程式碼實現**
```python
def unbounded_knapsack(weights, values, W):
    n = len(weights)
    dp = [[0] * (W + 1) for _ in range(n + 1)]
    
    for i in range(1, n + 1):
        for j in range(W + 1):
            dp[i][j] = dp[i-1][j]
            if j >= weights[i-1]:
                # 注意：這裡是 dp[i][j-weights[i-1]]，不是 dp[i-1][...]
                dp[i][j] = max(dp[i][j], dp[i][j-weights[i-1]] + values[i-1])
    
    return dp[n][W]

# 空間優化版本
def unbounded_knapsack_optimized(weights, values, W):
    dp = [0] * (W + 1)
    
    for i in range(len(weights)):
        # 完全背包：從左向右遍歷（與 0/1 背包相反）
        for j in range(weights[i], W + 1):
            dp[j] = max(dp[j], dp[j - weights[i]] + values[i])
    
    return dp[W]
```

**關鍵差異總結：**

| 特性 | 0/1 背包 | 完全背包 |
|------|---------|---------|
| 物品選擇 | 每個最多選一次 | 每個可選無限次 |
| 狀態轉移 | `DP[i-1][j-w[i]]` | `DP[i][j-w[i]]` |
| 空間優化遍歷方向 | 從右向左 | 從左向右 |

### Level 4: 進階技巧（狀態壓縮與優化）

**學習目標：** 掌握進階 DP 技巧

| 題號 | 題目 | 狀態定義 | 核心考點 |
|------|------|---------|---------|
| 16 | 最長回文子序列 | `DP[i][j]` = s[i..j] 的最長回文子序列長度 | 區間 DP |
| 17 | 俄羅斯套娃信封 | `DP[i]` = 以第 i 個信封結尾的最長序列 | 二維 LIS |
| 18 | 戳氣球 | `DP[i][j]` = 戳破 (i, j) 開區間氣球的最大收益 | 區間 DP |
| 19 | 正則表達式匹配 | `DP[i][j]` = s 前 i 個與 p 前 j 個是否匹配 | 複雜狀態轉移 |
| 20 | 最小路徑和 | `DP[i][j]` = 到達 (i, j) 的最小路徑和 | 基礎但重要 |

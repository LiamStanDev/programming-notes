# 預備知識
---
### Pod
![[Pasted image 20241208235116.png]]
Pod 中可以有多個 container，其中還有一個特殊的容器名為 Pause，有以下特性:
* Pod 內部第一個啟動的容器
* 初始化網路棧: 創建容器間互相共用的網路
* 掛載需要的存儲卷: 
* 回收殭屍進程

### 網路模型
Kubernetes 下所有 Pod 均能在一個**扁平網路**下進行直連通信:
1. 在沒有 NAT 下，集群的 Pod 能相互通信
2. 在沒有 NAT 下，同一節點的 Pod 能夠進行通信
3. 每個 Pod 都有自己的 IP 地址(唯一)，Pod 間能夠透過該地址進行訪問

#### CNI
只要滿足 CNI 標準任一個網路工具都能以插件的形式集成進 kubernetes 中，以**解決容器間的網路通信**，kubernetes 默認的網路插件路徑為 `/opt/cni/bin`

##### Pod 建立流程細節 (重要):
1. Pod 被 scheduler 綁定在某一個 node 上
2. kubelet 調用 CRI 插件 (caontainerd, podman...) 創建 Pod
3. CRI 創建 Pod Sandbox ID 與 Pod 網路命名空間
4. CRI 調用 CNI 插件配置 Pod 網路，執行 Flannel, Calico 等網路插件，透過他們執行
	1. 調用 Bridge 插件，連接主機與容器的網路
	2. 調用 IPAM 插件，分配 IP 地址
	3. 返回 Pod IP 地址
5. CRI 建立 Pause 容器，並添加到 Pod 網路命名空間中
6. Kubelet 調用 CRI 拉取應用容器鏡像
7. Kubelet 調用 CRI 啟動應用容器，並加入到 Pause 容器的網路 IPC PDI 的命名空間中

##### 網路插件

| 名稱     | 網路模型                  | 路由分發 | 網格網路 | 數據存儲         | 加密  |
| ------ | --------------------- | ---- | ---- | ------------ | --- |
| Fannel | 封裝 (VXLAN)            | 是    | 否    | k8s API      | 是   |
| Calico | 封裝 (VXLAN, IPIP) 或未封裝 | 是    | 是    | k8s API/etcd | 是   |
| Cilium | 封裝 (VXLAN)            | 是    | 是    | k8s API/etcd | 是   |
* 路由分發: 表示能不能透過 bgp 協議建立路由表
* 網格網路: 表示不同的 kubernetes 集群間 service 能否直連互通
* 封裝 vs. 非封裝:
	* 封裝網路 (underlay network): 現實的物理網路設備所搭建的網路，以確保兩點路由可達
	![[Pasted image 20241214141122.png|600]]
	上圖的 bgp routing 主要是透過 etcd 來存放該 Pod 的 IP 與節點 IP，類似路由表一樣的功能。
	* 非封裝網路 (overlay network): 在封裝網路之上透過虛擬化技術搭建的網路
		* e.g. vxLAN, GRE, TRILL
		![[Pasted image 20241214141040.png|600]]

# 實際搭建: 使用 rke2
---
因為官方列舉的很詳細，我這邊說一下其他要注意的細節:

### 主機配置
##### 配置主機名
```shell
# 為每台主機修改 hostname , e.g 主節點 1
hostnamectl hostname k8s-master01


# 修改 /etc/hosts
127.0.0.1   localhost localhost.localdomain localhost4 localhost4.localdomain4
::1         localhost localhost.localdomain localhost6 localhost6.localdomain6

192.168.66.11 k8s-master01 m1 # 主節點 1
192.168.66.12 k8s-master02 m2 # 主節點 2
192.168.66.13 k8s-master03 m3 # 主節點 2
192.168.66.14 k8s-node01 n1
192.168.66.15 k8s-node02 n2
```

### 疑難雜症
#### 高可用下配置: 使用 keepalived 建構 VIP
在 k8s-master01, k8s-master03, k8s-master03 下
```shell
dnf install keepalived

# master01: /etc/keepalived/keepalived.conf
vrrp_instance VI_1 {
    state MASTER                      # 這裡是 MASTER，其他節點設為 BACKUP
    interface ens160                  # 修改為實際網卡名稱
    virtual_router_id 51              # VRID，所有節點必須相同
    priority 100                      # 優先級，值越大優先級越高
    advert_int 1                      # 廣播間隔

    authentication {
        auth_type PASS
        auth_pass 12345678            # 密碼，所有節點必須相同
    }

    virtual_ipaddress {
        192.168.66.100                # VIP
    }
}


# master02: /etc/keepalived/keepalived.conf
vrrp_instance VI_1 {
    state MASTER                      # 這裡是 MASTER，其他節點設為 BACKUP
    interface ens160                  # 修改為實際網卡名稱
    virtual_router_id 51              # VRID，所有節點必須相同
    priority 90                       # 優先級，值越大優先級越高
    advert_int 1                      # 廣播間隔

    authentication {
        auth_type PASS
        auth_pass 12345678            # 密碼，所有節點必須相同
    }

    virtual_ipaddress {
        192.168.66.100                # VIP
    }
}


# master03: /etc/keepalived/keepalived.conf
vrrp_instance VI_1 {
    state MASTER                      # 這裡是 MASTER，其他節點設為 BACKUP
    interface ens160                  # 修改為實際網卡名稱
    virtual_router_id 51              # VRID，所有節點必須相同
    priority 80                       # 優先級，值越大優先級越高
    advert_int 1                      # 廣播間隔

    authentication {
        auth_type PASS
        auth_pass 12345678            # 密碼，所有節點必須相同
    }

    virtual_ipaddress {
        192.168.66.100                # VIP
    }
}

# 啟動 keepalived
systemctl enable --now keepalived
```

#### 高可用節點配置文件寫法
```yaml
# maser01: /etc/rancher/rke2/config.yaml
token: K1060986cb9676ede29c0b96601492d6fecbeefb9fcea1d26936a46eece77c0b330::server:6054facab58c094654ecd2d4b8b68790
tls-san:
  - 192.168.66.100
  - k8s-master01
  - k8s-master02
  - k8s-master03
  - 192.168.66.11
  - 192.168.66.12
  - 192.168.66.13
node-name: k8s-master01

# maser02
token: K1060986cb9676ede29c0b96601492d6fecbeefb9fcea1d26936a46eece77c0b330::server:6054facab58c094654ecd2d4b8b68790
tls-san:
  - 192.168.66.100
  - k8s-master01
  - k8s-master02
  - k8s-master03
  - 192.168.66.11
  - 192.168.66.12
  - 192.168.66.13
node-name: k8s-master02
server: https://192.168.66.100:9345

# maser03
token: K1060986cb9676ede29c0b96601492d6fecbeefb9fcea1d26936a46eece77c0b330::server:6054facab58c094654ecd2d4b8b68790
tls-san:
  - 192.168.66.100
  - k8s-master01
  - k8s-master02
  - k8s-master03
  - 192.168.66.11
  - 192.168.66.12
  - 192.168.66.13
node-name: k8s-master02
server: https://192.168.66.100:9345
```
> token 在 master1 中的 `/var/lib/rancher/rke2/server/node-token`

#### 連線
在可以連接到的主機上
```shell
dnf install kubernetes-client
mkdir ~/.kube
scp master01:/etc/rancher/rke2/rke2.yaml ~/.kube/config

# 修改裡面的 server 改成 VIP 的地址
```

# 實際搭建: 使用 kubeadm
---
### Step 1: 節點配置
##### 節點更新與安裝必要包
```shell
dnf update -y
dnf install -y curl wget vim net-tools
```

##### 關閉交換區
```shell
swapoff -a
sudo sed -i '/swap/d' /etc/fstab
```

##### 調整內核參數
```shell
net.bridge.bridge-nf-call-ip6tables = 1
net.bridge.bridge-nf-call-iptables = 1
net.ipv4.ip_forward = 1
```

##### 安裝容器運行時
```shell
dnf install -y padman cri-o # Podman 需要使用 cri-o 提供 Kubernetes CRI（Container Runtime Interface）支持
```

### Step 2: 路由配置

### Step 3: kubeadm 安裝 k8s 集群

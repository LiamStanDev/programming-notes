# PostgreSQL 效能監控與調優

## 效能監控體系

```mermaid
graph TB
    Monitor[監控體系]
    
    Monitor --> System[系統層級]
    Monitor --> PG[PostgreSQL 層級]
    Monitor --> Query[查詢層級]
    
    System --> CPU[CPU 使用率]
    System --> Memory[記憶體使用]
    System --> Disk[磁碟 I/O]
    System --> Network[網路流量]
    
    PG --> Conn[連線數]
    PG --> Cache[快取命中率]
    PG --> WAL[WAL 寫入]
    PG --> Vacuum[VACUUM 狀態]
    
    Query --> Slow[慢查詢]
    Query --> Lock[鎖等待]
    Query --> Stats[查詢統計]
```

## 系統統計視圖

### pg_stat_activity（當前活動）

```sql
-- 查看所有活動連線
SELECT 
    pid,
    usename,
    application_name,
    client_addr,
    state,
    query,
    query_start,
    state_change
FROM pg_stat_activity
WHERE state != 'idle'
ORDER BY query_start;

-- 查看長時間執行的查詢
SELECT 
    pid,
    now() - query_start AS duration,
    state,
    query
FROM pg_stat_activity
WHERE state != 'idle'
    AND now() - query_start > interval '5 minutes'
ORDER BY duration DESC;

-- 終止查詢
SELECT pg_cancel_backend(pid);  -- 取消查詢
SELECT pg_terminate_backend(pid);  -- 終止連線

-- 統計連線狀態
SELECT 
    state,
    COUNT(*) AS count
FROM pg_stat_activity
GROUP BY state;
```

### pg_stat_database（資料庫統計）

```sql
SELECT 
    datname AS database,
    numbackends AS connections,
    xact_commit AS commits,
    xact_rollback AS rollbacks,
    blks_read AS disk_reads,
    blks_hit AS cache_hits,
    tup_returned AS rows_returned,
    tup_fetched AS rows_fetched,
    tup_inserted AS rows_inserted,
    tup_updated AS rows_updated,
    tup_deleted AS rows_deleted,
    conflicts,
    deadlocks,
    pg_size_pretty(pg_database_size(datname)) AS size
FROM pg_stat_database
WHERE datname = current_database();

-- 計算快取命中率
SELECT 
    datname,
    blks_hit::float / NULLIF(blks_hit + blks_read, 0) * 100 AS cache_hit_ratio
FROM pg_stat_database
WHERE datname = current_database();
```

### pg_stat_user_tables（表統計）

```sql
-- 表級別統計
SELECT 
    schemaname,
    relname AS table_name,
    seq_scan AS sequential_scans,
    seq_tup_read AS seq_rows_read,
    idx_scan AS index_scans,
    idx_tup_fetch AS idx_rows_fetched,
    n_tup_ins AS rows_inserted,
    n_tup_upd AS rows_updated,
    n_tup_del AS rows_deleted,
    n_tup_hot_upd AS hot_updates,
    n_live_tup AS live_rows,
    n_dead_tup AS dead_rows,
    last_vacuum,
    last_autovacuum,
    last_analyze,
    last_autoanalyze
FROM pg_stat_user_tables
ORDER BY seq_scan DESC;

-- 找出需要 VACUUM 的表
SELECT 
    schemaname,
    relname,
    n_dead_tup,
    n_live_tup,
    n_dead_tup::float / NULLIF(n_live_tup, 0) AS dead_ratio,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
    AND n_dead_tup::float / NULLIF(n_live_tup, 0) > 0.1
ORDER BY dead_ratio DESC;
```

### pg_stat_user_indexes（索引統計）

```sql
-- 索引使用情況
SELECT 
    schemaname,
    tablename,
    indexrelname AS index_name,
    idx_scan AS index_scans,
    idx_tup_read AS index_rows_read,
    idx_tup_fetch AS index_rows_fetched,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
ORDER BY idx_scan ASC;

-- 找出未使用的索引
SELECT 
    schemaname,
    tablename,
    indexrelname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
WHERE idx_scan = 0
    AND indexrelname NOT LIKE '%_pkey'
ORDER BY pg_relation_size(indexrelid) DESC;
```

### pg_statio_user_tables（I/O 統計）

```sql
-- 表的 I/O 統計
SELECT 
    schemaname,
    relname,
    heap_blks_read AS heap_disk_reads,
    heap_blks_hit AS heap_cache_hits,
    heap_blks_hit::float / NULLIF(heap_blks_hit + heap_blks_read, 0) * 100 AS heap_hit_ratio,
    idx_blks_read AS idx_disk_reads,
    idx_blks_hit AS idx_cache_hits,
    idx_blks_hit::float / NULLIF(idx_blks_hit + idx_blks_read, 0) * 100 AS idx_hit_ratio
FROM pg_statio_user_tables
WHERE schemaname = 'public'
ORDER BY heap_blks_read DESC;
```

## 慢查詢分析

### 啟用慢查詢日誌

```conf
# postgresql.conf
log_min_duration_statement = 1000  # 記錄超過 1 秒的查詢（毫秒）
log_line_prefix = '%t [%p]: [%l-1] user=%u,db=%d,app=%a,client=%h '
log_statement = 'none'  # 'none', 'ddl', 'mod', 'all'
log_duration = off
log_connections = on
log_disconnections = on
log_lock_waits = on  # 記錄鎖等待
```

### pg_stat_statements 擴展

```sql
-- 安裝擴展
CREATE EXTENSION pg_stat_statements;

-- postgresql.conf
shared_preload_libraries = 'pg_stat_statements'
pg_stat_statements.track = all
pg_stat_statements.max = 10000

-- 重啟 PostgreSQL 後生效
```

**查詢統計**:
```sql
-- 最耗時的查詢
SELECT 
    query,
    calls,
    total_exec_time,
    mean_exec_time,
    max_exec_time,
    stddev_exec_time,
    rows
FROM pg_stat_statements
ORDER BY total_exec_time DESC
LIMIT 20;

-- 平均執行時間最長的查詢
SELECT 
    query,
    calls,
    mean_exec_time,
    max_exec_time
FROM pg_stat_statements
ORDER BY mean_exec_time DESC
LIMIT 20;

-- 呼叫次數最多的查詢
SELECT 
    query,
    calls,
    total_exec_time,
    mean_exec_time
FROM pg_stat_statements
ORDER BY calls DESC
LIMIT 20;

-- 重置統計
SELECT pg_stat_statements_reset();
```

### auto_explain 模組

```conf
# postgresql.conf
shared_preload_libraries = 'pg_stat_statements,auto_explain'
auto_explain.log_min_duration = 1000  # 毫秒
auto_explain.log_analyze = true
auto_explain.log_buffers = true
auto_explain.log_timing = true
auto_explain.log_verbose = true
auto_explain.log_nested_statements = true
```

## 鎖監控

### 查看當前鎖

```sql
-- 查看所有鎖
SELECT 
    locktype,
    database,
    relation::regclass,
    page,
    tuple,
    virtualxid,
    transactionid,
    mode,
    granted,
    pid
FROM pg_locks
WHERE NOT granted
ORDER BY pid;

-- 鎖等待詳情
SELECT 
    blocked_locks.pid AS blocked_pid,
    blocked_activity.usename AS blocked_user,
    blocking_locks.pid AS blocking_pid,
    blocking_activity.usename AS blocking_user,
    blocked_activity.query AS blocked_statement,
    blocking_activity.query AS current_statement_in_blocking_process,
    blocked_activity.application_name AS blocked_application,
    blocking_activity.application_name AS blocking_application
FROM pg_catalog.pg_locks blocked_locks
JOIN pg_catalog.pg_stat_activity blocked_activity ON blocked_activity.pid = blocked_locks.pid
JOIN pg_catalog.pg_locks blocking_locks 
    ON blocking_locks.locktype = blocked_locks.locktype
    AND blocking_locks.database IS NOT DISTINCT FROM blocked_locks.database
    AND blocking_locks.relation IS NOT DISTINCT FROM blocked_locks.relation
    AND blocking_locks.page IS NOT DISTINCT FROM blocked_locks.page
    AND blocking_locks.tuple IS NOT DISTINCT FROM blocked_locks.tuple
    AND blocking_locks.virtualxid IS NOT DISTINCT FROM blocked_locks.virtualxid
    AND blocking_locks.transactionid IS NOT DISTINCT FROM blocked_locks.transactionid
    AND blocking_locks.classid IS NOT DISTINCT FROM blocked_locks.classid
    AND blocking_locks.objid IS NOT DISTINCT FROM blocked_locks.objid
    AND blocking_locks.objsubid IS NOT DISTINCT FROM blocked_locks.objsubid
    AND blocking_locks.pid != blocked_locks.pid
JOIN pg_catalog.pg_stat_activity blocking_activity ON blocking_activity.pid = blocking_locks.pid
WHERE NOT blocked_locks.granted;
```

## 資料庫大小監控

```sql
-- 資料庫大小
SELECT 
    datname,
    pg_size_pretty(pg_database_size(datname)) AS size
FROM pg_database
ORDER BY pg_database_size(datname) DESC;

-- 表大小（含索引）
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) AS index_size
FROM pg_tables
WHERE schemaname = 'public'
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC
LIMIT 20;

-- 最大的表
SELECT 
    relname AS table_name,
    pg_size_pretty(pg_total_relation_size(relid)) AS total_size,
    pg_size_pretty(pg_relation_size(relid)) AS table_size,
    pg_size_pretty(pg_total_relation_size(relid) - pg_relation_size(relid)) AS indexes_size,
    n_live_tup AS estimated_rows
FROM pg_stat_user_tables
ORDER BY pg_total_relation_size(relid) DESC
LIMIT 10;

-- 索引大小排行
SELECT 
    schemaname,
    tablename,
    indexname,
    pg_size_pretty(pg_relation_size(indexrelid)) AS index_size
FROM pg_stat_user_indexes
ORDER BY pg_relation_size(indexrelid) DESC
LIMIT 20;
```

## VACUUM 與 Bloat 監控

### VACUUM 狀態

```sql
-- VACUUM 進度（PostgreSQL 12+）
SELECT 
    p.pid,
    p.datname,
    p.relid::regclass AS table_name,
    p.phase,
    p.heap_blks_total,
    p.heap_blks_scanned,
    p.heap_blks_vacuumed,
    p.index_vacuum_count,
    p.max_dead_tuples,
    p.num_dead_tuples
FROM pg_stat_progress_vacuum p;

-- Autovacuum 設定檢查
SELECT 
    relname,
    n_live_tup,
    n_dead_tup,
    n_dead_tup::float / NULLIF(n_live_tup, 0) AS dead_ratio,
    last_vacuum,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 0
ORDER BY n_dead_tup DESC;
```

### Bloat 檢查

```sql
-- 表膨脹檢查（估算）
SELECT 
    schemaname,
    tablename,
    pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
    n_live_tup,
    n_dead_tup,
    ROUND(100 * n_dead_tup::numeric / NULLIF(n_live_tup + n_dead_tup, 0), 2) AS dead_ratio
FROM pg_stat_user_tables
WHERE n_dead_tup > 1000
ORDER BY n_dead_tup DESC;
```

## 參數調優

### 記憶體配置

```mermaid
graph TB
    Memory[PostgreSQL 記憶體]
    
    Memory --> Shared[Shared Memory]
    Memory --> Local[Per-Backend Memory]
    
    Shared --> SharedBuffers[shared_buffers<br/>資料快取]
    Shared --> WALBuffers[wal_buffers<br/>WAL 緩衝]
    
    Local --> WorkMem[work_mem<br/>排序/雜湊]
    Local --> MaintenanceWorkMem[maintenance_work_mem<br/>VACUUM/CREATE INDEX]
    Local --> TempBuffers[temp_buffers<br/>臨時表]
```

**推薦配置**（16GB RAM 伺服器）:
```conf
# 共享記憶體
shared_buffers = 4GB                # 系統記憶體的 25%
effective_cache_size = 12GB         # 系統記憶體的 50-75%
wal_buffers = 16MB

# Per-backend 記憶體
work_mem = 16MB                     # 謹慎設定，總量 = work_mem * max_connections
maintenance_work_mem = 512MB        # 用於 VACUUM, CREATE INDEX
temp_buffers = 8MB

# 連線
max_connections = 100

# 計算公式
# 總記憶體使用 ≈ shared_buffers + (work_mem + temp_buffers) * max_connections
```

### 查詢優化器參數

```conf
# 成本參數
random_page_cost = 1.1              # SSD 使用較低值（預設 4.0）
effective_io_concurrency = 200      # SSD 可設定更高（預設 1）
seq_page_cost = 1.0

# 查詢計畫
default_statistics_target = 100     # 統計樣本數（預設 100）
```

### WAL 配置

```conf
# WAL 寫入
wal_level = replica
wal_buffers = 16MB
min_wal_size = 1GB
max_wal_size = 4GB

# 檢查點
checkpoint_timeout = 15min
checkpoint_completion_target = 0.9

# WAL 寫入器
wal_writer_delay = 200ms
wal_writer_flush_after = 1MB
```

### Autovacuum 配置

```conf
# 啟用 autovacuum
autovacuum = on
autovacuum_max_workers = 3

# Autovacuum 閾值
autovacuum_vacuum_threshold = 50
autovacuum_vacuum_scale_factor = 0.2

# 等價於: dead_tuples > 50 + 0.2 * total_tuples

# Autovacuum analyze
autovacuum_analyze_threshold = 50
autovacuum_analyze_scale_factor = 0.1

# 成本延遲（避免影響正常查詢）
autovacuum_vacuum_cost_delay = 20ms
autovacuum_vacuum_cost_limit = 200
```

## 監控工具

### pgAdmin
- 圖形化管理工具
- 查詢分析器
- 伺服器監控

### pg_top
```bash
# 安裝
sudo apt install pgtop

# 使用
pg_top -h localhost -U postgres
```

### pgBadger（日誌分析）
```bash
# 安裝
sudo apt install pgbadger

# 分析日誌
pgbadger /var/log/postgresql/postgresql-14-main.log -o report.html
```

### Prometheus + Grafana
```yaml
# postgres_exporter
# docker-compose.yml
version: '3'
services:
  postgres_exporter:
    image: prometheuscommunity/postgres-exporter
    environment:
      DATA_SOURCE_NAME: "postgresql://postgres:password@postgres:5432/postgres?sslmode=disable"
    ports:
      - "9187:9187"
```

## 常見效能問題排查

### 1. 連線數過多

```sql
-- 檢查連線數
SELECT COUNT(*) FROM pg_stat_activity;

-- 解決方案
-- 1. 增加 max_connections
-- 2. 使用連線池（PgBouncer）
```

### 2. 快取命中率低

```sql
-- 檢查快取命中率
SELECT 
    blks_hit::float / NULLIF(blks_hit + blks_read, 0) * 100 AS cache_hit_ratio
FROM pg_stat_database
WHERE datname = current_database();

-- 解決方案
-- 1. 增加 shared_buffers
-- 2. 優化查詢，減少全表掃描
```

### 3. 死行過多

```sql
-- 檢查死行
SELECT 
    schemaname,
    relname,
    n_dead_tup,
    last_autovacuum
FROM pg_stat_user_tables
WHERE n_dead_tup > 10000
ORDER BY n_dead_tup DESC;

-- 解決方案
-- 1. 手動 VACUUM
VACUUM VERBOSE table_name;

-- 2. 調整 autovacuum 參數
```

### 4. 索引未使用

```sql
-- 找出未使用的索引
SELECT 
    indexrelname,
    idx_scan,
    pg_size_pretty(pg_relation_size(indexrelid))
FROM pg_stat_user_indexes
WHERE idx_scan = 0
    AND indexrelname NOT LIKE '%_pkey';

-- 解決方案：刪除未使用的索引
```

## 小結

**監控重點**:
- 慢查詢（pg_stat_statements）
- 快取命中率（> 95%）
- 死行比例（< 10%）
- 索引使用情況
- 鎖等待
- 連線數

**調優策略**:
1. 先監控，找出瓶頸
2. 優化查詢和索引
3. 調整記憶體參數
4. 優化 VACUUM 策略
5. 使用連線池

**定期檢查**:
- 每日：慢查詢、鎖等待
- 每週：索引使用、死行比例
- 每月：資料庫大小、VACUUM 效果

# 04_效能優化

本章節針對 PostgreSQL 效能優化進行全面說明，涵蓋索引種類、查詢計劃解讀、Vacuum/Analyze、分區表、並行查詢等主題，並提供理論基礎、官方文件風格範例 SQL，以及專業實務建議，適合作為快速查詢手冊。

---

## 1. 索引種類與使用情境

### 1.1 B-tree 索引

**理論說明**：
B-tree 為預設索引類型，適用於大多數等值查詢與範圍查詢。

**範例 SQL**：
```sql
CREATE INDEX idx_users_name ON users (name);
```

**實務建議**：
- 適用於 `=`, `<`, `>`, `BETWEEN` 等操作。
- 大部分情境下首選，維護成本低。

---

### 1.2 Hash 索引

**理論說明**：
Hash 索引針對等值查詢最佳，但不支援範圍查詢。

**範例 SQL**：
```sql
CREATE INDEX idx_users_email_hash ON users USING hash (email);
```

**實務建議**：
- 僅用於大量等值查詢且無需排序的欄位。
- 較少用於生產環境，建議優先考慮 B-tree。

---

### 1.3 GIN 索引

**理論說明**：
GIN（Generalized Inverted Index）適用於陣列、JSONB、全文檢索等複雜資料型態。

**範例 SQL**：
```sql
CREATE INDEX idx_posts_tags_gin ON posts USING gin (tags);
```

**實務建議**：
- 適合 `@>`, `?`, `@@` 等操作。
- 建立 GIN 索引較慢，適合查詢遠大於寫入的場景。

---

### 1.4 GiST 索引

**理論說明**：
GiST（Generalized Search Tree）支援多種資料型態，如地理空間、範圍型資料。

**範例 SQL**：
```sql
CREATE INDEX idx_locations_geom_gist ON locations USING gist (geom);
```

**實務建議**：
- 適用於 PostGIS、範圍查詢等。
- 可自訂運算子類型，彈性高。

---

### 1.5 BRIN 索引

**理論說明**：
BRIN（Block Range INdexes）適合極大資料表，對於有序資料表效果最佳。

**範例 SQL**：
```sql
CREATE INDEX idx_logs_time_brin ON logs USING brin (log_time);
```

**實務建議**：
- 適合時間序列、日誌等 append-only 資料。
- 建立與維護成本極低，但查詢精確度較低。

---

## 2. 查詢計劃解讀

### 2.1 EXPLAIN 與 ANALYZE

**理論說明**：
`EXPLAIN` 用於顯示查詢計劃，`ANALYZE` 可執行實際查詢並顯示執行時間。

**範例 SQL**：
```sql
EXPLAIN SELECT * FROM users WHERE name = 'Alice';

EXPLAIN ANALYZE SELECT * FROM users WHERE name = 'Alice';
```

### 2.2 常見指標

- **Seq Scan**：全表掃描，通常效能較差。
- **Index Scan**：索引掃描，效率較高。
- **Bitmap Index Scan**：適合多索引條件。
- **Rows**：預估與實際處理的資料筆數。
- **Cost**：查詢成本評估（啟始/總成本）。
- **Actual Time**：實際執行時間（需 ANALYZE）。

**實務建議**：
- 優先避免 Seq Scan，適時建立索引。
- 比較預估與實際 rows，若差異大需更新統計資訊。
- 針對慢查詢，逐步優化 SQL 與索引設計。

---

## 3. Vacuum/Analyze

### 3.1 原理

- **Vacuum**：回收死資料列，避免資料膨脹。
- **Analyze**：收集統計資訊，協助查詢計劃最佳化。

### 3.2 執行時機

**範例 SQL**：
```sql
VACUUM users;
ANALYZE users;
VACUUM FULL users;
```

- 定期自動執行（autovacuum），或手動針對大量異動後執行。

### 3.3 注意事項

- `VACUUM FULL` 會鎖表，僅於必要時使用。
- 維持 autovacuum 設定，避免資料膨脹。
- 大量刪除或更新後，建議執行 `VACUUM` 與 `ANALYZE`。

**實務建議**：
- 監控 autovacuum 日誌，調整參數以符合業務需求。
- 定期手動執行以確保效能穩定。

---

## 4. 分區表

### 4.1 設計

**理論說明**：
分區表將大型資料表依條件（如時間、範圍）分割為多個子表，提升查詢與維護效率。

**範例 SQL**：
```sql
CREATE TABLE sales (
  id serial PRIMARY KEY,
  sale_date date NOT NULL,
  amount numeric
) PARTITION BY RANGE (sale_date);

CREATE TABLE sales_2024 PARTITION OF sales FOR VALUES FROM ('2024-01-01') TO ('2025-01-01');
CREATE TABLE sales_2025 PARTITION OF sales FOR VALUES FROM ('2025-01-01') TO ('2026-01-01');
```

> 注意:
> 1. 分區表與一般表示不同的結構，若要將舊表分區需要新建分區表，搬移舊資料。
> 2. 分區爲半閉半開區間

### 4.2 維護

- 定期新增、移除分區。
- 可針對分區個別執行 VACUUM/ANALYZE。

### 4.3 效能優化

- 查詢時務必包含分區鍵條件，才能發揮分區裁剪效果。
- 分區數量不宜過多，避免規劃複雜與效能下降。

**實務建議**：
- 適用於資料量極大且具明顯分割特徵的表。
- 規劃分區策略時，預估未來資料成長與維護成本。

---

## 5. 並行查詢（Parallel Query）

### 5.1 支援與原理

**理論說明**：
PostgreSQL 支援多核心並行查詢，可自動分配 worker 處理大型查詢。

### 5.2 調校參數

**範例 SQL**：
```sql
SET max_parallel_workers_per_gather = 4;
```

- `max_parallel_workers_per_gather`：單一查詢最大 worker 數。
- `max_parallel_workers`：全系統最大 worker 數。
- `parallel_leader_participation`：控制 leader 是否參與查詢。

### 5.3 最佳實踐

- 並行查詢適用於大型資料表與複雜聚合。
- 需根據硬體資源調整參數，避免過度競爭。
- 某些操作（如函數、外部表）不支援並行。

**實務建議**：
- 監控查詢計劃中的 `Workers Planned/Launched` 指標。
- 逐步調整參數，觀察效能變化。

---

## 6. 總結與最佳實踐

- 根據查詢型態選擇適合的索引。
- 定期執行 Vacuum/Analyze，維持資料表健康。
- 大型資料表建議採用分區設計。
- 善用並行查詢提升複雜查詢效能。
- 持續監控查詢計劃與系統資源，動態調整優化策略。

---

**參考文件**：
- [PostgreSQL: Index Types](https://www.postgresql.org/docs/current/indexes-types.html)
- [PostgreSQL: Query Planning](https://www.postgresql.org/docs/current/using-explain.html)
- [PostgreSQL: Vacuuming](https://www.postgresql.org/docs/current/routine-vacuuming.html)
- [PostgreSQL: Table Partitioning](https://www.postgresql.org/docs/current/ddl-partitioning.html)
- [PostgreSQL: Parallel Query](https://www.postgresql.org/docs/current/parallel-query.html)
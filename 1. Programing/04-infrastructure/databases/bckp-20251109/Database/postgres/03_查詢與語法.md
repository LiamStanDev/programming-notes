# 03 查詢與語法

本章節涵蓋 SQL 查詢與語法的核心知識，包含基本語法、進階查詢技巧、CTE、Window Function、JSON/JSONB 操作，並提供實務建議與範例，適合作為工程師的快速查詢手冊。

---

## 1. SQL 基本語法

### 1.1 SELECT

**功能**：用於查詢資料表中的資料。

**語法**：

```sql
SELECT column1, column2
FROM table_name
WHERE condition
ORDER BY column1 DESC;
```

**重點**：

- 僅選取所需欄位，避免 `SELECT *`，以提升效能與可維護性。
- 使用 `WHERE` 篩選條件，減少不必要的資料處理。
- `ORDER BY` 用於排序，預設為升序，可加上 `DESC` 表示降序。

**示例**：

```sql
SELECT name, age
FROM users
WHERE age > 18
ORDER BY age DESC;
```

**輸出解釋**：
假設 `users` 資料表如下：

| name  | age |
| ----- | --- |
| Alice | 25  |
| Bob   | 30  |
| Carol | 17  |

執行上述查詢後，輸出結果為：

| name  | age |
| ----- | --- |
| Bob   | 30  |
| Alice | 25  |

---

### 1.2 INSERT

**功能**：新增資料至資料表。

**語法**：

```sql
INSERT INTO table_name (column1, column2)
VALUES ('value1', 'value2');
```

**重點**：

- 明確指定欄位，避免欄位順序變動造成錯誤。
- 確保資料型別與欄位定義一致。

**示例**：

```sql
INSERT INTO users (name, age)
VALUES ('Alice', 25);
```

---

### 1.3 UPDATE

**功能**：更新資料表中的資料。

**語法**：

```sql
UPDATE table_name
SET column1 = 'new_value'
WHERE condition;
```

**重點**：

- 務必加上 `WHERE` 條件，避免全表更新。
- 可更新多個欄位，使用逗號分隔。

**示例**：

```sql
UPDATE users
SET age = 26
WHERE name = 'Alice';
```

---

### 1.4 DELETE

**功能**：刪除資料表中的資料。

**語法**：

```sql
DELETE FROM table_name
WHERE condition;
```

**重點**：

- 同樣需加上 `WHERE` 條件，避免誤刪所有資料。
- 可搭配 `RETURNING` 查看刪除的資料。

**示例**：

```sql
DELETE FROM users
WHERE age < 18;
```

---

### 1.5 JOIN

**功能**：合併多個資料表的資料。
**語法**：
```sql
SELECT a.column1, b.column2
FROM table_a AS a
INNER JOIN table_b AS b ON a.id = b.a_id;
```

**重點**：
- `INNER JOIN`：僅回傳兩表皆有的資料。
- `LEFT JOIN`：保留左表所有資料。
- `RIGHT JOIN`：保留右表所有資料。
- `FULL JOIN`：保留兩表所有資料。
- JOIN 條件務必明確，避免產生笛卡兒積。

**示例**：
```sql
SELECT users.name, orders.amount
FROM users
INNER JOIN orders ON users.id = orders.user_id;
```

**輸出解釋**：
假設 `users` 資料表如下：

| id | name |
|----|-------|
| 1 | Alice |
| 2 | Bob |

假設 `orders` 資料表如下：

| user_id | amount |
|---------|--------|
| 1 | 100 |
| 2 | 200 |

執行上述查詢後，輸出結果為：

| name | amount |
|-------|--------|
| Alice | 100 |
| Bob | 200 |

---

## 2. 進階查詢技巧

### 2.1 子查詢 (Subquery)

**功能**：查詢中嵌入另一個查詢。
**語法**：
```sql
SELECT column
FROM table
WHERE column IN (
  SELECT column
  FROM table
  WHERE condition
);
```

**重點**：
- 提高查詢可讀性。
- 複雜邏輯建議改用 CTE。

**示例**：
```sql
SELECT name
FROM employee
WHERE department_id IN (
  SELECT id FROM department WHERE name = 'IT'
);
```

**輸出解釋**：
假設 `employee` 資料表如下：

| name  | department_id |
| ----- | ------------- |
| Alice | 1             |
| Bob   | 2             |

假設 `department` 資料表如下：

| id  | name |
| --- | ---- |
| 1   | IT   |
| 2   | HR   |

執行上述查詢後，輸出結果為：

| name  |
| ----- |
| Alice |

---

### 2.2 聚合函數 (Aggregate Functions)

**功能**：對一組資料進行計算。
**語法**：
```sql
SELECT AGG_FUNC(column)
FROM table;
```

**常見函數**：
- `COUNT`：計算數量。
- `SUM`：計算總和。
- `AVG`：計算平均值。
- `MIN`：取得最小值。
- `MAX`：取得最大值。

**示例**：
```sql
SELECT COUNT(*), AVG(salary), MAX(age)
FROM employee;
```

**輸出解釋**：
假設 `employee` 資料表如下：

| name | salary | age |
|-------|--------|-----|
| Alice | 5000 | 25 |
| Bob | 7000 | 30 |

執行上述查詢後，輸出結果為：

| COUNT | AVG | MAX |
|-------|------|-----|
| 2 | 6000 | 30 |

---

### 2.3 GROUP BY

**功能**：分組統計。
**語法**：
```sql
SELECT column, AGG_FUNC(column)
FROM table
GROUP BY column;
```

**重點**：
- 必須搭配聚合函數使用。
- 分組後的欄位需出現在 `GROUP BY` 中。

**示例**：
```sql
SELECT department_id, COUNT(*)
FROM employee
GROUP BY department_id;
```

**輸出解釋**：
假設 `employee` 資料表如下：

| name | department_id |
|-------|---------------|
| Alice | 1 |
| Bob | 1 |
| Carol | 2 |

執行上述查詢後，輸出結果為：

| department_id | COUNT |
|---------------|-------|
| 1 | 2 |
| 2 | 1 |

---

### 2.4 HAVING

**功能**：對分組後的結果進行篩選。
**語法**：
```sql
SELECT column, AGG_FUNC(column)
FROM table
GROUP BY column
HAVING condition;
```

**重點**：
- `HAVING` 用於篩選聚合結果。
- 與 `WHERE` 的區別在於作用範圍不同。
**示例**：
```sql
SELECT department_id, COUNT(*) AS emp_count
FROM employee
GROUP BY department_id
HAVING COUNT(*) > 1;
```

**輸出解釋**：
假設 `employee` 資料表如下：

| name | department_id |
|-------|---------------|
| Alice | 1 |
| Bob | 1 |
| Carol | 2 |

執行上述查詢後，輸出結果為：

| department_id | emp_count |
|---------------|-----------|
| 1 | 2 |

---

### 2.5 DISTINCT

**功能**：去除重複值。
**語法**：
```sql
SELECT DISTINCT column
FROM table;
```

**示例**：
```sql
SELECT DISTINCT department_id
FROM employee;
```

**輸出解釋**：
假設 `employee` 資料表如下：

| name | department_id |
|-------|---------------|
| Alice | 1 |
| Bob | 1 |
| Carol | 2 |

執行上述查詢後，輸出結果為：

| department_id |
|---------------|
| 1 |
| 2 |

---

## 3. CTE（Common Table Expression）

### 3.1 WITH 語法

**功能**：定義臨時結果集，提升查詢可讀性。

**語法**：
```sql
WITH cte_name AS (
  SELECT column
  FROM table
  WHERE condition
)
SELECT *
FROM cte_name;
```

**重點**：
- 適合拆分複雜查詢。
- 可多次引用 CTE，提升效率。

**示例**：
```sql
WITH dept_count AS (
  SELECT department_id, COUNT(*) AS emp_count
  FROM employee
  GROUP BY department_id
)
SELECT *
FROM dept_count
WHERE emp_count >= 2;
```

**輸出解釋**：
假設 `employee` 資料表如下：

| department_id | name  |
|---------------|-------|
| 1             | Alice |
| 1             | Bob   |
| 2             | Carol |

執行上述查詢後，輸出結果為：

| department_id | emp_count |
|---------------|-----------|
| 1             | 2         |

---

### 3.2 遞迴 CTE

**功能**：用於階層式資料查詢（如組織樹）。

**語法**：
```sql
WITH RECURSIVE cte_name AS (
  SELECT column
  FROM table
  WHERE condition
  UNION ALL
  SELECT column
  FROM table
  INNER JOIN cte_name ON condition
)
SELECT *
FROM cte_name;
```

**重點**：
- 遞迴查詢需設計終止條件，避免無窮遞迴。

**示例**：
```sql
WITH RECURSIVE subordinates AS (
  SELECT id, name, manager_id
  FROM employee
  WHERE id = 1
  UNION ALL
  SELECT e.id, e.name, e.manager_id
  FROM employee e
  INNER JOIN subordinates s ON e.manager_id = s.id
)
SELECT * FROM subordinates;
```

**輸出解釋**：
假設 `employee` 資料表如下：

| id | name  | manager_id |
|----|-------|------------|
| 1  | Alice | NULL       |
| 2  | Bob   | 1          |
| 3  | Carol | 2          |

執行上述查詢後，輸出結果為：

| id | name  | manager_id |
|----|-------|------------|
| 1  | Alice | NULL       |
| 2  | Bob   | 1          |
| 3  | Carol | 2          |

---

## 4. Window Function（視窗函數）

**功能**：在查詢結果集上執行計算，不改變行數。視窗函數適合用於分析性查詢，例如排名、累計總和、移動平均等。

**語法**：
```sql
SELECT column, FUNC() OVER (PARTITION BY column ORDER BY column)
FROM table;
```

**詳細說明**：
- **`OVER` 子句**：定義視窗函數的範圍。
  - `PARTITION BY`：將資料分組，每組資料分別計算。
  - `ORDER BY`：定義分組內的排序方式。
- **視窗函數不會改變行數**：每一行的輸出都會保留，並附加計算結果。

**常見函數**：
- `ROW_NUMBER()`：為每行分配唯一的行號。
- `RANK()`：為每行分配排名，允許跳號。
- `DENSE_RANK()`：為每行分配排名，不跳號。
- `SUM() OVER`：計算累計總和。
- `AVG() OVER`：計算累計平均。

**示例**：
```sql
SELECT
  id,
  salary,
  AVG(salary) OVER (PARTITION BY department_id) AS avg_dept_salary,
  RANK() OVER (ORDER BY salary DESC) AS salary_rank
FROM employee;
```

**輸出解釋**：
假設 `employee` 資料表如下：

| id  | department_id | salary |
| --- | ------------- | ------ |
| 1   | 101           | 5000   |
| 2   | 101           | 7000   |
| 3   | 102           | 6000   |
| 4   | 102           | 8000   |

執行上述查詢後，輸出結果為：

| id  | salary | avg_dept_salary | salary_rank |
| --- | ------ | --------------- | ----------- |
| 4   | 8000   | 7000            | 1           |
| 3   | 6000   | 7000            | 2           |
| 2   | 7000   | 6000            | 1           |
| 1   | 5000   | 6000            | 2           |

---

## 5. JSON/JSONB 操作

### 5.1 存取與查詢

**功能**：PostgreSQL 支援 JSON/JSONB 欄位，可直接查詢與操作。

**語法**：
```sql
-- 取出 JSON 欄位中的屬性
SELECT data->>'key' AS value
FROM table;

-- 查詢 JSON 欄位包含特定鍵值
SELECT *
FROM table
WHERE data->>'key' = 'value';
```

**示例**：
```sql
SELECT data->>'name' AS name
FROM users;

SELECT *
FROM users
WHERE data->>'role' = 'admin';
```

---

### 5.2 JSONB 索引

**功能**：對 JSONB 欄位建立索引以提升查詢效能。

**語法**：
```sql
CREATE INDEX index_name ON table ((data->>'key'));

-- 建立 GIN 索引
CREATE INDEX index_name ON table USING GIN (data);
```

**示例**：
```sql
CREATE INDEX idx_users_data_role ON users ((data->>'role'));

CREATE INDEX idx_users_data_gin ON users USING GIN (data);
```

**重點**：
- 大量查詢 JSON 欄位時，建議建立 GIN 索引。

---

### 5.3 JSONB 更新與修改

**功能**：更新 JSONB 欄位中的特定鍵值或新增鍵值。

**語法**：
```sql
-- 更新 JSONB 欄位中的特定鍵值
UPDATE table
SET data = jsonb_set(data, '{key}', '"new_value"')
WHERE condition;

-- 新增鍵值到 JSONB 欄位
UPDATE table
SET data = data || '{"new_key": "value"}'::jsonb
WHERE condition;

-- 刪除 JSONB 欄位中的特定鍵值
UPDATE table
SET data = data - 'key'
WHERE condition;
```

**示例**：
```sql
-- 更新鍵值
UPDATE users
SET data = jsonb_set(data, '{role}', '"manager"')
WHERE id = 1;

-- 新增鍵值
UPDATE users
SET data = data || '{"department": "IT"}'::jsonb
WHERE id = 1;

-- 刪除鍵值
UPDATE users
SET data = data - 'role'
WHERE id = 1;
```

---

### 5.4 JSONB 聚合與過濾

**功能**：對 JSONB 欄位進行聚合操作或過濾。

**語法**：
```sql
-- 聚合 JSONB 欄位
SELECT jsonb_agg(data) AS aggregated_data
FROM table;

-- 過濾 JSONB 陣列中的元素
SELECT *
FROM table
WHERE data @> '{"key": "value"}';
```

**示例**：
```sql
-- 聚合 JSONB 欄位
SELECT jsonb_agg(data) AS aggregated_data
FROM users;

-- 過濾 JSONB 陣列中的元素
SELECT *
FROM users
WHERE data @> '{"role": "admin"}';
```

**重點**：
- `jsonb_agg` 用於將多行 JSONB 資料聚合成一個陣列。
- `@>` 運算符用於檢查 JSONB 是否包含特定鍵值對。

---

### 5.5 JSONB 函數

**功能**：PostgreSQL 提供多種 JSONB 操作函數。

**常見函數**：
- `jsonb_array_elements`：展開 JSONB 陣列為多行。
- `jsonb_object_keys`：列出 JSONB 物件的所有鍵。
- `jsonb_each`：展開 JSONB 物件為鍵值對。

**示例**：
```sql
-- 展開 JSONB 陣列
SELECT jsonb_array_elements(data->'tags') AS tag
FROM users;

-- 列出 JSONB 物件的所有鍵
SELECT jsonb_object_keys(data) AS key
FROM users;

-- 展開 JSONB 物件為鍵值對
SELECT key, value
FROM users,
LATERAL jsonb_each(data);
```

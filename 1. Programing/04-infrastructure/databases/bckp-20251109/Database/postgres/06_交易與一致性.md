# 06 交易與一致性

本章節說明資料庫交易（Transaction）與一致性相關理論、隔離級別、鎖定機制、死鎖排查，並提供標準 SQL 範例與專業實務建議，適用於 PostgreSQL、MySQL 等主流資料庫。

---

## 1. Transaction（交易）

### 理論簡述

交易（Transaction）是一組不可分割的資料庫操作，必須全部成功或全部失敗。交易具備 ACID 特性：

- **Atomicity（原子性）**：全部執行或全部不執行
- **Consistency（一致性）**：交易前後資料保持一致
- **Isolation（隔離性）**：交易間互不干擾
- **Durability（持久性）**：提交後資料永久保存

### 基本語法

```sql
-- 開始交易
BEGIN;

-- 執行多個 SQL 操作
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;

-- 提交交易
COMMIT;
```

### Savepoint（儲存點）

儲存點允許在交易內部分段回滾。

```sql
BEGIN;
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
SAVEPOINT sp1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
ROLLBACK TO SAVEPOINT sp1; -- 回到儲存點
COMMIT;
```

#### 實務建議

- 交易範圍應盡量小，避免長時間鎖定資源。
- 善用 Savepoint 處理複雜流程中的部分失敗。
- 交易內避免用戶互動或長時間等待。

---

## 2. Isolation Level（隔離級別）

### 理論簡述

隔離級別決定交易間可見的資料範圍，**影響一致性與效能**。常見現象：

- **Dirty Read**：讀到未提交資料
- **Non-repeatable Read**：同一查詢結果不一致
- **Phantom Read**：同條件查詢結果筆數變動

### 四種隔離級別

| 隔離級別             | Dirty Read | Non-repeatable Read | Phantom Read |
| ---------------- | :--------: | :-----------------: | :----------: |
| Read Uncommitted |     可能     |         可能          |      可能      |
| Read Committed   |     不會     |         可能          |      可能      |
| Repeatable Read  |     不會     |         不會          |      可能      |
| Serializable     |     不會     |         不會          |      不會      |

### 設定方式

**PostgreSQL:**

```sql
SET TRANSACTION ISOLATION LEVEL REPEATABLE READ;
BEGIN;
-- 交易操作
COMMIT;
```

#### 實務建議

- 預設 Read Committed 已足夠多數應用。
- 高一致性需求可用 Repeatable Read 或 Serializable，但效能較低。
- 依據業務需求選擇隔離級別，避免過度鎖定。

---

## 3. Locking（鎖定機制）

### 理論簡述

鎖定用於保護資料一致性，**防止同時修改造成衝突**。常見鎖種類：

- **行鎖（Row Lock）**：只鎖定被操作的資料列
- **表鎖（Table Lock）**：鎖定整個資料表
- **共享鎖（Shared Lock）**：允許多個交易讀取
- **排他鎖（Exclusive Lock）**：僅允許單一交易寫入

### 什麼時候要用鎖？

1. **多個交易同時修改同一筆資料時**
   - 例如：兩個人同時轉帳、同時修改同一個帳戶餘額，為避免資料競爭與不一致，需要鎖定該資料列。
2. **需要確保讀到的資料在交易期間不被其他交易更改**
   - 例如：你查詢一筆訂單資料後要根據它做後續操作，這時可以用 `SELECT ... FOR UPDATE` 鎖定該列，確保後續操作前資料不會被其他交易改變。
3. **批次作業或資料遷移時，避免其他交易同時寫入**
   - 例如：你要批次更新或刪除整個表的資料，可以用表鎖（`LOCK TABLE`）避免其他交易同時寫入。

### 實際例子

#### 1. 轉帳: 避免餘額競爭 (行鎖)

```sql
BEGIN;
SELECT balance FROM accounts WHERE id = 1 FOR UPDATE; -- 鎖定 SELECT 出來的 ROW
UPDATE accounts SET balance = balance - 100 WHERE id = 1;
UPDATE accounts SET balance = balance + 100 WHERE id = 2;
COMMIT;
```
> 這裡 `FOR UPDATE` 鎖定 id=1 的帳戶，確保同時只有一個交易能修改這筆資料。

#### 2. 批次刪除: 避免其他交易寫入 (表鎖)

```sql
BEGIN;
LOCK TABLE orders IN EXCLUSIVE MODE;
DELETE FROM orders WHERE created_at < '2023-01-01';
COMMIT;
```
> 這裡鎖定整個 orders 表，避免其他交易同時寫入或修改。

### 鎖等待與衝突

- 若資源已被鎖定，後續交易需等待或發生鎖衝突。
- 可設定鎖等待逾時（timeout）。

```sql
-- 設定鎖等待逾時（PostgreSQL）
SET lock_timeout = '5s';
```

#### 實務建議

- 優先使用行鎖，減少鎖定範圍。
- 交易內 SQL 執行順序應一致，降低死鎖風險。
- 設定合理鎖等待時間，避免長時間阻塞。

---

## 4. 死鎖排查

### 理論簡述

死鎖（Deadlock）指兩個或多個交易互相等待對方釋放資源，導致無限等待。

### 偵測與解決

- 多數資料庫會自動偵測死鎖並終止其中一個交易。
- 可查詢系統日誌或管理視圖獲取死鎖資訊。

**PostgreSQL 死鎖查詢：**

```sql
SELECT * FROM pg_locks WHERE granted = false;
```

### 預防方法

- 保持一致的資源存取順序。
- 將交易範圍縮到最小。
- 避免長交易與複雜邏輯。

#### 實務建議

- 定期監控鎖與死鎖狀態。
- 交易設計時預先考慮資源存取順序。
- 發生死鎖時，檢查應用程式邏輯與 SQL 執行順序。

---

## 5. 總結與最佳實踐

- 交易設計應兼顧一致性與效能。
- 隔離級別與鎖定策略需依業務需求調整。
- 定期檢查鎖與死鎖狀態，並優化交易流程。
- 參考官方文件以獲得最新最佳實踐。

---

### 官方文件參考

- [PostgreSQL: Transactions](https://www.postgresql.org/docs/current/tutorial-transactions.html)
- [MySQL: Transactional and Locking Statements](https://dev.mysql.com/doc/refman/8.0/en/commit.html)
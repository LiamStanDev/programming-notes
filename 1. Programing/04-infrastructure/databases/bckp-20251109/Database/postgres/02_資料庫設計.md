# 資料庫設計重點與必備知識

本筆記整理了資料庫設計的核心原則，涵蓋建表、命名慣例、欄位設計、資料型別選擇、主鍵與索引策略，以及 Schema 設計建議。每個部分均附有詳細解釋與 SQL 範例，幫助後端工程師快速掌握。

---

## 1. 建表原則

### 1.1 正規化 (Normalization)
- **目的**：消除資料冗餘，確保資料一致性。
- **階段**：
  - 第一正規化 (1NF)：確保每個欄位的值是不可分割的基本單元。
  - 第二正規化 (2NF)：消除部分函數依賴。
  - 第三正規化 (3NF)：消除傳遞函數依賴。
- **實務建議**：設計初期應遵循正規化，後期可根據效能需求適度反正規化。

#### 範例
將顧客資訊與訂單資訊分開存放，避免重複儲存顧客資料：
```sql
CREATE TABLE customer (
    customer_id SERIAL PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    email VARCHAR(255) UNIQUE NOT NULL
);

CREATE TABLE orders (
    order_id SERIAL PRIMARY KEY,
    customer_id INT NOT NULL REFERENCES customer(customer_id),
    order_date TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
);
```

---

### 1.2 命名慣例
- **表格命名**：使用小寫字母與底線分隔（如：`user_profile`），避免使用保留字。
- **欄位命名**：清楚描述內容，建議加上單位或型別（如：`created_at`、`price_cents`）。
- **一致性**：全專案統一命名規則。

#### 最佳實踐
- 制定命名規範文件，並在團隊內部統一執行。
- 避免使用模糊或過度縮寫的名稱。

---

### 1.3 欄位設計
- **單一職責**：每欄位僅存放一種資料。
- **預設值**：合理設定預設值，減少 NULL。
- **必要性**：非必要欄位可允許 NULL，必要欄位設為 NOT NULL。

#### 範例
```sql
CREATE TABLE user_profile (
    user_id      INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    username     VARCHAR(50) NOT NULL UNIQUE,
    email        VARCHAR(255) NOT NULL,
    created_at   TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP,
    is_active    BOOLEAN NOT NULL DEFAULT TRUE
);
```

---

## 2. 資料型別選擇

### 2.1 常用型別
- **整數**：`SMALLINT`、`INTEGER`、`BIGINT`
- **字串**：`VARCHAR(n)`、`TEXT`
- **日期時間**：`DATE`、`TIMESTAMP`
- **布林值**：`BOOLEAN`
- **浮點數/金額**：`NUMERIC(p,s)`、`DECIMAL`

### 2.2 特殊型別
- **UUID**：適用於分散式系統主鍵。
- **JSON/JSONB**：儲存結構化資料。
- **ARRAY**：儲存多值欄位。
- **ENUM**：定義有限集合。

### 2.3 選擇建議
- 根據實際需求選擇最精確型別，避免過度寬鬆（如：不用 `TEXT` 取代所有字串）。
- 金額建議用 `NUMERIC(12,2)`，避免浮點誤差。
- 優先使用原生型別，特殊需求再用特殊型別。

#### 範例
```sql
CREATE TABLE order_item (
    item_id     UUID PRIMARY KEY DEFAULT gen_random_uuid(),
    order_id    INTEGER NOT NULL,
    price       NUMERIC(12,2) NOT NULL,
    tags        TEXT[],
    status      order_status_enum NOT NULL
);

CREATE TYPE order_status_enum AS ENUM ('pending', 'paid', 'shipped', 'cancelled');
```

---

## 3. 主鍵與索引策略

### 3.1 主鍵設計
- **唯一性**：每筆資料唯一識別。
- **自增主鍵**：建議使用 `GENERATED ALWAYS AS IDENTITY`，取代 `SERIAL` 或 `BIGSERIAL`。
- **自然鍵 vs. 代理鍵**：建議使用代理鍵（如自增 ID 或 UUID）。

#### 範例
```sql
CREATE TABLE example_identity (
    id INTEGER GENERATED ALWAYS AS IDENTITY PRIMARY KEY,
    name VARCHAR(100) NOT NULL
);
```

---

### 3.2 索引策略
- **B-tree**：預設，適用大多數查詢。
- **Hash**：適用等值查詢。
- **GIN/GiST**：適用全文檢索、JSON、ARRAY。
- **Partial Index**：針對部分資料建立索引。

#### 範例
```sql
-- 唯一鍵
ALTER TABLE user_profile ADD CONSTRAINT unique_email UNIQUE (email);

-- 一般索引
CREATE INDEX idx_order_created_at ON orders (created_at);

-- 部分索引
CREATE INDEX idx_active_user ON user_profile (username) WHERE is_active = TRUE;

-- GIN 索引
CREATE INDEX idx_order_tags ON order_item USING GIN (tags);
```

---

## 4. Schema 設計建議

### 4.1 多 Schema 管理
- **用途**：隔離不同業務、環境（如：`public`、`audit`、`archive`）。
- **優點**：權限控管、結構清晰。

### 4.2 命名與隔離性
- Schema 命名應具描述性（如：`crm`、`analytics`）。
- 不同應用或租戶可用不同 schema 隔離。

#### 範例
```sql
-- 建立新 schema
CREATE SCHEMA analytics;

-- 在指定 schema 建表
CREATE TABLE analytics.event_log (
    event_id    BIGSERIAL PRIMARY KEY,
    event_type  VARCHAR(50) NOT NULL,
    occurred_at TIMESTAMP NOT NULL
);

-- 設定 schema 權限
GRANT USAGE ON SCHEMA analytics TO analyst_role;
```

---

## 5. 專業實務建議與最佳實踐

- **設計前先規劃資料流與查詢模式，避免後期大幅重構。**
- **欄位預設值與約束（constraint）可提升資料品質。**
- **定期檢查索引效能，移除不必要索引。**
- **Schema 與命名規則文件化，團隊共識一致。**
- **測試資料庫備份與還原流程，確保資料安全。**
- **善用資料庫原生功能（如：CHECK、FOREIGN KEY、TRIGGER）提升資料完整性。**

---

> 本筆記涵蓋資料庫設計的理論基礎、實務建議與標準範例，適用於日常設計與查詢參考。
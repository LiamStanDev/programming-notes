# 04 - 型別系統與零大小型別

## 概述

Rust 的型別系統提供強大的編譯期保證,通過零大小型別 (Zero-Sized Types, ZST)、`PhantomData`、型別狀態模式等技巧,可以在編譯期消除錯誤而無運行時開銷。

### 核心概念

- **Zero-Sized Types (ZST)**: 不占用記憶體的類型
- **Type-State Pattern**: 用型別系統編碼狀態機
- **Newtype Pattern**: 型別安全包裝
- **Memory Representation**: 控制記憶體佈局

---

## Zero-Sized Types (ZST) 優化

ZST 是大小為 0 的類型,編譯器會進行特殊優化。

### 常見的 ZST

```rust
fn main() {
    use std::mem::size_of;
    
    // 單元類型
    assert_eq!(size_of::<()>(), 0);
    
    // 空結構體
    struct Empty;
    assert_eq!(size_of::<Empty>(), 0);
    
    // 空數組
    assert_eq!(size_of::<[u8; 0]>(), 0);
    
    // PhantomData
    use std::marker::PhantomData;
    assert_eq!(size_of::<PhantomData<i32>>(), 0);
}
```

### ZST 的優化特性

#### 1. 無記憶體分配

```rust
fn main() {
    // 包含 ZST 的 Vec 不會分配記憶體
    let vec: Vec<()> = vec![(); 1_000_000];
    
    println!("Vec 長度: {}", vec.len()); // 1000000
    println!("Vec 容量: {}", vec.capacity()); // usize::MAX
}
```

#### 2. 無運行時開銷的標記

```rust
struct Meters(f64);
struct Kilometers(f64);

// 使用 ZST 作為標記
struct Distance<Unit> {
    value: f64,
    _marker: std::marker::PhantomData<Unit>,
}

fn main() {
    use std::mem::size_of;
    
    assert_eq!(size_of::<Distance<Meters>>(), size_of::<f64>());
    // PhantomData 不占空間
}
```

### ZST 在迭代器中的應用

```rust
use std::ops::Range;

fn main() {
    // Range<usize> 內部只存儲 start 和 end
    let range = 0..10;
    
    // iter() 返回的迭代器幾乎是 ZST
    let iter = (0..10).filter(|_| true);
    
    // 迭代器鏈式調用不增加額外開銷
    let result: Vec<_> = (0..100)
        .map(|x| x * 2)
        .filter(|x| x % 4 == 0)
        .collect();
}
```

---

## `PhantomData<T>` 使用場景

`PhantomData<T>` 告訴編譯器結構體"擁有" `T`,但實際不存儲 `T` 的值。

### 場景 1: 標記生命期

```rust
use std::marker::PhantomData;

struct Deserializer<'de> {
    data: &'de [u8],
    position: usize,
}

// 告訴編譯器 Slice 借用了 'de 生命期的數據
struct Slice<'de> {
    data: &'de [u8],
    _marker: PhantomData<&'de ()>,
}

impl<'de> Deserializer<'de> {
    fn new(data: &'de [u8]) -> Self {
        Deserializer { data, position: 0 }
    }
    
    fn read_slice(&mut self, len: usize) -> Slice<'de> {
        let slice = &self.data[self.position..self.position + len];
        self.position += len;
        Slice {
            data: slice,
            _marker: PhantomData,
        }
    }
}
```

### 場景 2: 型別參數未直接使用

```rust
use std::marker::PhantomData;

struct Buffer<T> {
    data: Vec<u8>,
    _marker: PhantomData<T>, // T 沒有直接存儲,但影響類型
}

impl<T> Buffer<T> {
    fn new() -> Self {
        Buffer {
            data: Vec::new(),
            _marker: PhantomData,
        }
    }
}

fn main() {
    let buffer: Buffer<i32> = Buffer::new();
    // Buffer<i32> 和 Buffer<f64> 是不同的類型
}
```

### 場景 3: 控制 Send/Sync 實現

```rust
use std::marker::PhantomData;
use std::rc::Rc;

// 默認情況下,T 會影響 Send/Sync
struct NotSendOrSync<T> {
    _marker: PhantomData<Rc<T>>, // Rc 不是 Send/Sync
}

fn main() {
    // NotSendOrSync 不會實現 Send/Sync
}
```

### 場景 4: Variance 控制

```rust
use std::marker::PhantomData;

// 協變
struct Covariant<'a, T> {
    _marker: PhantomData<&'a T>,
}

// 逆變
struct Contravariant<'a, T> {
    _marker: PhantomData<fn(&'a T)>,
}

// 不變
struct Invariant<'a, T> {
    _marker: PhantomData<&'a mut T>,
}
```

---

## 型別狀態模式 (Typestate Pattern)

使用型別系統編碼狀態機,在編譯期防止非法狀態轉換。

### 基礎示例: 文件狀態

```rust
use std::marker::PhantomData;

// 狀態標記 (ZST)
struct Open;
struct Closed;

struct File<State> {
    path: String,
    _state: PhantomData<State>,
}

impl File<Closed> {
    fn new(path: String) -> Self {
        File {
            path,
            _state: PhantomData,
        }
    }
    
    fn open(self) -> File<Open> {
        println!("打開文件: {}", self.path);
        File {
            path: self.path,
            _state: PhantomData,
        }
    }
}

impl File<Open> {
    fn read(&self) -> String {
        format!("讀取 {}", self.path)
    }
    
    fn close(self) -> File<Closed> {
        println!("關閉文件: {}", self.path);
        File {
            path: self.path,
            _state: PhantomData,
        }
    }
}

fn main() {
    let file = File::new("test.txt".to_string());
    // file.read(); // ❌ 編譯錯誤: Closed 狀態無法讀取
    
    let file = file.open();
    println!("{}", file.read()); // ✅ Open 狀態可以讀取
    
    let file = file.close();
    // file.read(); // ❌ 再次編譯錯誤
}
```

### 進階示例: HTTP 請求建構器

```rust
use std::marker::PhantomData;

// 狀態標記
struct NoUrl;
struct HasUrl;
struct NoMethod;
struct HasMethod;

struct RequestBuilder<UrlState, MethodState> {
    url: Option<String>,
    method: Option<String>,
    headers: Vec<(String, String)>,
    _url_state: PhantomData<UrlState>,
    _method_state: PhantomData<MethodState>,
}

impl RequestBuilder<NoUrl, NoMethod> {
    fn new() -> Self {
        RequestBuilder {
            url: None,
            method: None,
            headers: Vec::new(),
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<M> RequestBuilder<NoUrl, M> {
    fn url(self, url: String) -> RequestBuilder<HasUrl, M> {
        RequestBuilder {
            url: Some(url),
            method: self.method,
            headers: self.headers,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<U> RequestBuilder<U, NoMethod> {
    fn method(self, method: String) -> RequestBuilder<U, HasMethod> {
        RequestBuilder {
            url: self.url,
            method: Some(method),
            headers: self.headers,
            _url_state: PhantomData,
            _method_state: PhantomData,
        }
    }
}

impl<U, M> RequestBuilder<U, M> {
    fn header(mut self, key: String, value: String) -> Self {
        self.headers.push((key, value));
        self
    }
}

// 只有兩者都設定才能發送
impl RequestBuilder<HasUrl, HasMethod> {
    fn send(self) -> String {
        format!(
            "{} {} (headers: {})",
            self.method.unwrap(),
            self.url.unwrap(),
            self.headers.len()
        )
    }
}

fn main() {
    let request = RequestBuilder::new()
        .url("https://example.com".to_string())
        .method("GET".to_string())
        .header("Accept".to_string(), "application/json".to_string())
        .send();
    
    println!("{}", request);
    
    // ❌ 以下編譯錯誤
    // let incomplete = RequestBuilder::new()
    //     .url("https://example.com".to_string())
    //     .send(); // 缺少 method
}
```

---

## Newtype 模式與型別安全

### 基本 Newtype

```rust
struct UserId(u64);
struct ProductId(u64);

fn get_user(id: UserId) -> String {
    format!("User #{}", id.0)
}

fn main() {
    let user_id = UserId(123);
    let product_id = ProductId(456);
    
    println!("{}", get_user(user_id));
    // get_user(product_id); // ❌ 類型錯誤
}
```

### 為 Newtype 實現 Trait

```rust
use std::fmt;
use std::ops::Add;

#[derive(Debug, Clone, Copy, PartialEq)]
struct Meters(f64);

impl fmt::Display for Meters {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "{} m", self.0)
    }
}

impl Add for Meters {
    type Output = Meters;
    
    fn add(self, other: Meters) -> Meters {
        Meters(self.0 + other.0)
    }
}

fn main() {
    let distance = Meters(10.5) + Meters(5.3);
    println!("{}", distance); // 15.8 m
}
```

### 單位安全計算

```rust
use std::ops::{Add, Mul};

#[derive(Debug, Clone, Copy)]
struct Meters(f64);

#[derive(Debug, Clone, Copy)]
struct Seconds(f64);

#[derive(Debug, Clone, Copy)]
struct MetersPerSecond(f64);

impl Mul<Seconds> for MetersPerSecond {
    type Output = Meters;
    
    fn mul(self, rhs: Seconds) -> Meters {
        Meters(self.0 * rhs.0)
    }
}

fn main() {
    let speed = MetersPerSecond(10.0);
    let time = Seconds(5.0);
    let distance = speed * time; // Meters
    
    println!("距離: {:?}", distance);
}
```

---

## `repr` 屬性: 控制記憶體佈局

### `repr(Rust)` - 默認佈局

編譯器自由優化佈局,不保證順序。

```rust
// 默認 repr(Rust)
struct Example {
    a: u8,   // 1 byte
    b: u32,  // 4 bytes
    c: u16,  // 2 bytes
}

fn main() {
    use std::mem::size_of;
    println!("大小: {}", size_of::<Example>()); // 可能是 8, 編譯器優化
}
```

### `repr(C)` - C 兼容佈局

按聲明順序佈局,用於 FFI。

```rust
#[repr(C)]
struct CCompatible {
    a: u8,   // offset 0
    // padding 3 bytes
    b: u32,  // offset 4
    c: u16,  // offset 8
    // padding 2 bytes
}

fn main() {
    use std::mem::size_of;
    println!("大小: {}", size_of::<CCompatible>()); // 12 bytes
}
```

### `repr(packed)` - 無填充

移除所有 padding,可能導致未對齊訪問。

```rust
#[repr(packed)]
struct Packed {
    a: u8,   // offset 0
    b: u32,  // offset 1 (未對齊!)
    c: u16,  // offset 5
}

fn main() {
    use std::mem::size_of;
    println!("大小: {}", size_of::<Packed>()); // 7 bytes
    
    let p = Packed { a: 1, b: 2, c: 3 };
    
    // ⚠️ 直接引用可能導致未對齊訪問
    // let r = &p.b; // 危險!
    
    // 使用 read_unaligned
    let b = unsafe { std::ptr::read_unaligned(&p.b) };
    println!("b: {}", b);
}
```

### `repr(align(N))` - 指定對齊

```rust
#[repr(align(64))] // 對齊到 64 bytes (cache line)
struct CacheAligned {
    data: [u8; 16],
}

fn main() {
    use std::mem::{size_of, align_of};
    
    println!("大小: {}", size_of::<CacheAligned>()); // 64
    println!("對齊: {}", align_of::<CacheAligned>()); // 64
}
```

### `repr(transparent)` - 單字段透明包裝

保證與內部類型具有相同的記憶體佈局。

```rust
#[repr(transparent)]
struct Wrapper(u32);

fn main() {
    use std::mem::size_of;
    
    assert_eq!(size_of::<Wrapper>(), size_of::<u32>());
    
    // 可以安全地在 FFI 中轉換
}

// FFI 使用場景
extern "C" {
    fn process_value(value: u32);
}

fn safe_process(wrapper: Wrapper) {
    unsafe {
        process_value(std::mem::transmute(wrapper));
    }
}
```

---

## Const Generics 進階應用

### 基本用法

```rust
struct Array<T, const N: usize> {
    data: [T; N],
}

impl<T: Default + Copy, const N: usize> Array<T, N> {
    fn new() -> Self {
        Array {
            data: [T::default(); N],
        }
    }
}

fn main() {
    let arr: Array<i32, 10> = Array::new();
    println!("陣列大小: {}", arr.data.len());
}
```

### 編譯期計算

```rust
struct Matrix<T, const ROWS: usize, const COLS: usize> {
    data: [[T; COLS]; ROWS],
}

impl<T: Default + Copy, const ROWS: usize, const COLS: usize> 
    Matrix<T, ROWS, COLS> 
{
    fn new() -> Self {
        Matrix {
            data: [[T::default(); COLS]; ROWS],
        }
    }
    
    fn transpose(self) -> Matrix<T, COLS, ROWS> {
        let mut result = Matrix::new();
        for i in 0..ROWS {
            for j in 0..COLS {
                result.data[j][i] = self.data[i][j];
            }
        }
        result
    }
}

fn main() {
    let matrix: Matrix<i32, 3, 4> = Matrix::new();
    let transposed: Matrix<i32, 4, 3> = matrix.transpose();
}
```

### 固定大小緩衝區

```rust
struct FixedBuffer<const SIZE: usize> {
    buffer: [u8; SIZE],
    len: usize,
}

impl<const SIZE: usize> FixedBuffer<SIZE> {
    fn new() -> Self {
        FixedBuffer {
            buffer: [0; SIZE],
            len: 0,
        }
    }
    
    fn push(&mut self, value: u8) -> Result<(), &'static str> {
        if self.len >= SIZE {
            return Err("緩衝區已滿");
        }
        self.buffer[self.len] = value;
        self.len += 1;
        Ok(())
    }
    
    fn as_slice(&self) -> &[u8] {
        &self.buffer[..self.len]
    }
}

fn main() {
    let mut buf: FixedBuffer<256> = FixedBuffer::new();
    buf.push(42).unwrap();
    println!("內容: {:?}", buf.as_slice());
}
```

---

## GATs (Generic Associated Types)

在 Trait 中使用泛型關聯類型。

### 借用迭代器

```rust
trait LendingIterator {
    type Item<'a> where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

struct VecLending<T> {
    data: Vec<T>,
    index: usize,
}

impl<T> LendingIterator for VecLending<T> {
    type Item<'a> = &'a T where Self: 'a;
    
    fn next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
        if self.index < self.data.len() {
            let item = &self.data[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}
```

### Stream-like 抽象

```rust
trait Stream {
    type Item<'a> where Self: 'a;
    
    fn poll_next<'a>(&'a mut self) -> Option<Self::Item<'a>>;
}

struct ByteStream {
    buffer: Vec<u8>,
    position: usize,
}

impl Stream for ByteStream {
    type Item<'a> = &'a [u8];
    
    fn poll_next<'a>(&'a mut self) -> Option<Self::Item<'a>> {
        if self.position >= self.buffer.len() {
            return None;
        }
        
        let chunk_size = 64.min(self.buffer.len() - self.position);
        let chunk = &self.buffer[self.position..self.position + chunk_size];
        self.position += chunk_size;
        Some(chunk)
    }
}
```

---

## 實戰案例: 實現型別安全的狀態機

```rust
use std::marker::PhantomData;

// 交通燈狀態
struct Red;
struct Yellow;
struct Green;

struct TrafficLight<State> {
    duration: u32,
    _state: PhantomData<State>,
}

impl TrafficLight<Red> {
    fn new() -> Self {
        println!("交通燈: 紅燈");
        TrafficLight {
            duration: 30,
            _state: PhantomData,
        }
    }
    
    fn to_green(self) -> TrafficLight<Green> {
        println!("紅燈 -> 綠燈");
        TrafficLight {
            duration: 45,
            _state: PhantomData,
        }
    }
}

impl TrafficLight<Green> {
    fn to_yellow(self) -> TrafficLight<Yellow> {
        println!("綠燈 -> 黃燈");
        TrafficLight {
            duration: 5,
            _state: PhantomData,
        }
    }
}

impl TrafficLight<Yellow> {
    fn to_red(self) -> TrafficLight<Red> {
        println!("黃燈 -> 紅燈");
        TrafficLight {
            duration: 30,
            _state: PhantomData,
        }
    }
}

fn main() {
    let light = TrafficLight::new();
    let light = light.to_green();
    let light = light.to_yellow();
    let light = light.to_red();
    
    // ❌ 非法轉換會編譯失敗
    // let light = light.to_yellow(); // Red 無法直接到 Yellow
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_valid_transitions() {
        let light = TrafficLight::new();
        let light = light.to_green();
        let light = light.to_yellow();
        let _light = light.to_red();
    }
}
```

---

## 性能與記憶體分析

### ZST 編譯器優化驗證

```rust
use std::mem::size_of;

struct Empty;

fn main() {
    // ZST 的 Vec 不分配記憶體
    let v1: Vec<Empty> = vec![Empty; 1_000_000];
    let v2: Vec<i32> = vec![0; 1_000_000];
    
    println!("Vec<Empty> 大小: {}", size_of::<Vec<Empty>>());
    println!("Vec<i32> 大小: {}", size_of::<Vec<i32>>());
    
    // 兩者的 Vec 本身大小相同 (3 個 usize)
    assert_eq!(size_of::<Vec<Empty>>(), size_of::<Vec<i32>>());
}
```

### Repr 佈局對比

```bash
# 使用 cargo-show-asm 查看生成的代碼
cargo install cargo-show-asm
cargo asm --lib your_crate::function_name
```

---

## 參考資料

1. [The Rust Reference - Type Layout](https://doc.rust-lang.org/reference/type-layout.html)
2. [Rustonomicon - PhantomData](https://doc.rust-lang.org/nomicon/phantom-data.html)
3. [Zero-Sized Types](https://doc.rust-lang.org/nomicon/exotic-sizes.html#zero-sized-types-zsts)
4. [Const Generics MVP](https://blog.rust-lang.org/2021/02/26/const-generics-mvp-beta.html)
5. [Typestate Pattern in Rust](https://cliffle.com/blog/rust-typestate/)
6. [repr(Rust) vs repr(C)](https://doc.rust-lang.org/nomicon/other-reprs.html)
7. [GATs Initiative](https://rust-lang.github.io/generic-associated-types-initiative/)

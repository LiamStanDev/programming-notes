# 05 - 宏系統與元編程

## 概述

Rust 的宏系統提供強大的元編程能力,允許在編譯期生成代碼。Rust 有兩種宏系統:聲明式宏 (Declarative Macros) 和過程宏 (Procedural Macros)。

### 核心概念

- **聲明式宏** (`macro_rules!`): 基於模式匹配的代碼生成
- **過程宏**: 操作 token stream,功能更強大
- **宏衛生**: 防止宏展開時的變量名衝突
- **編譯期計算**: 零運行時開銷

---

## Declarative Macros (`macro_rules!`)

聲明式宏基於模式匹配,類似於 `match` 表達式。

### 基本語法

```rust
macro_rules! say_hello {
    () => {
        println!("Hello, world!");
    };
}

fn main() {
    say_hello!(); // 展開為 println!("Hello, world!");
}
```

### 帶參數的宏

```rust
macro_rules! create_function {
    ($func_name:ident) => {
        fn $func_name() {
            println!("函數 {} 被調用", stringify!($func_name));
        }
    };
}

create_function!(foo);
create_function!(bar);

fn main() {
    foo(); // 函數 foo 被調用
    bar(); // 函數 bar 被調用
}
```

### 指示符 (Designators)

宏參數可以使用不同的指示符:

| 指示符 | 說明 | 示例 |
|--------|------|------|
| `ident` | 識別符 | `x`, `foo` |
| `expr` | 表達式 | `1 + 2`, `vec![1, 2]` |
| `ty` | 型別 | `i32`, `Vec<String>` |
| `pat` | 模式 | `Some(x)`, `_` |
| `stmt` | 語句 | `let x = 5;` |
| `block` | 代碼塊 | `{ ... }` |
| `item` | 項目 | `fn`, `struct` |
| `meta` | 元屬性 | `cfg(test)` |
| `tt` | Token Tree | 任意 token |
| `literal` | 字面量 | `42`, `"hello"` |
| `path` | 路徑 | `std::vec::Vec` |

### 重複模式

```rust
macro_rules! vec_of_strings {
    ($($x:expr),* $(,)?) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x.to_string());
            )*
            temp_vec
        }
    };
}

fn main() {
    let v = vec_of_strings!["hello", "world", "rust"];
    println!("{:?}", v);
}
```

**重複語法**:
- `$(...)*`: 零次或多次
- `$(...)+`: 一次或多次
- `$(...)?`: 零次或一次

### 多模式匹配

```rust
macro_rules! calculate {
    (add $a:expr, $b:expr) => {
        $a + $b
    };
    (sub $a:expr, $b:expr) => {
        $a - $b
    };
    (mul $a:expr, $b:expr) => {
        $a * $b
    };
}

fn main() {
    let sum = calculate!(add 5, 3);
    let diff = calculate!(sub 10, 4);
    let product = calculate!(mul 2, 6);
    
    println!("{}, {}, {}", sum, diff, product);
}
```

### 遞歸宏

```rust
macro_rules! count {
    () => { 0 };
    ($x:tt $($xs:tt)*) => {
        1 + count!($($xs)*)
    };
}

fn main() {
    const COUNT: usize = count!(a b c d e);
    println!("數量: {}", COUNT); // 5
}
```

---

## 實戰案例: 實現 `vec!` 宏

```rust
macro_rules! my_vec {
    // 無元素
    () => {
        Vec::new()
    };
    
    // 重複元素: vec![elem; n]
    ($elem:expr; $n:expr) => {
        {
            let mut v = Vec::new();
            v.resize($n, $elem);
            v
        }
    };
    
    // 列表: vec![1, 2, 3]
    ($($x:expr),+ $(,)?) => {
        {
            let mut temp_vec = Vec::new();
            $(
                temp_vec.push($x);
            )+
            temp_vec
        }
    };
}

fn main() {
    let v1 = my_vec![];
    let v2 = my_vec![1, 2, 3];
    let v3 = my_vec![0; 5];
    
    println!("{:?}", v1); // []
    println!("{:?}", v2); // [1, 2, 3]
    println!("{:?}", v3); // [0, 0, 0, 0, 0]
}
```

---

## Procedural Macros (過程宏)

過程宏在編譯期執行代碼,處理 token stream。

### 三種過程宏類型

#### 1. Derive Macros (派生宏)

最常用的過程宏,用 `#[derive(...)]` 調用。

```rust
// 使用示例
#[derive(Debug, Clone, PartialEq)]
struct Point {
    x: i32,
    y: i32,
}
```

**實現派生宏**:

```toml
# Cargo.toml
[lib]
proc-macro = true

[dependencies]
syn = "2.0"
quote = "1.0"
proc-macro2 = "1.0"
```

```rust
// lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    let ast = parse_macro_input!(input as DeriveInput);
    let name = &ast.ident;
    
    let gen = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello from {}", stringify!(#name));
            }
        }
    };
    
    gen.into()
}

// 使用
// #[derive(HelloMacro)]
// struct MyStruct;
//
// fn main() {
//     MyStruct::hello_macro(); // Hello from MyStruct
// }
```

#### 2. Attribute Macros (屬性宏)

類似於自定義屬性,可以附加到各種 Rust 項目上。

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn timing(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    let fn_name = &input.sig.ident;
    let fn_block = &input.block;
    let fn_sig = &input.sig;
    
    let output = quote! {
        #fn_sig {
            let start = std::time::Instant::now();
            let result = (|| #fn_block)();
            let elapsed = start.elapsed();
            println!("{} 耗時: {:?}", stringify!(#fn_name), elapsed);
            result
        }
    };
    
    output.into()
}

// 使用
// #[timing]
// fn slow_function() {
//     std::thread::sleep(std::time::Duration::from_millis(100));
// }
```

#### 3. Function-like Macros (類函數宏)

看起來像函數調用的宏。

```rust
use proc_macro::TokenStream;
use quote::quote;

#[proc_macro]
pub fn sql(input: TokenStream) -> TokenStream {
    let input_str = input.to_string();
    
    let gen = quote! {
        {
            let query = #input_str;
            println!("執行 SQL: {}", query);
            query
        }
    };
    
    gen.into()
}

// 使用
// let query = sql!(SELECT * FROM users WHERE id = 1);
```

---

## 宏衛生 (Macro Hygiene)

Rust 宏具有衛生性,防止變量名衝突。

### 衛生性示例

```rust
macro_rules! using_a {
    ($e:expr) => {
        {
            let a = 42; // 宏內部的 a
            $e
        }
    };
}

fn main() {
    let a = 10; // 外部的 a
    let result = using_a!(a + 1); // 使用外部的 a
    println!("{}", result); // 11, 而不是 43
}
```

### 打破衛生性

有時需要故意引入變量:

```rust
macro_rules! define_and_use {
    ($name:ident, $value:expr) => {
        let $name = $value; // 引入變量到調用作用域
    };
}

fn main() {
    define_and_use!(x, 42);
    println!("{}", x); // ✅ 可以使用 x
}
```

---

## 常用宏庫

### `paste` - 識別符拼接

```toml
[dependencies]
paste = "1.0"
```

```rust
use paste::paste;

macro_rules! make_methods {
    ($($name:ident),*) => {
        $(
            paste! {
                fn [<get_ $name>]() -> &'static str {
                    stringify!($name)
                }
            }
        )*
    };
}

make_methods!(foo, bar, baz);

fn main() {
    println!("{}", get_foo()); // "foo"
    println!("{}", get_bar()); // "bar"
}
```

### `quote` - 生成 Rust 代碼

```rust
use quote::quote;

fn generate_struct() {
    let name = syn::Ident::new("MyStruct", proc_macro2::Span::call_site());
    
    let tokens = quote! {
        struct #name {
            field: i32,
        }
    };
    
    println!("{}", tokens);
}
```

### `syn` - 解析 Rust 語法

```rust
use syn::{parse_str, Expr};

fn parse_expression() {
    let expr: Expr = parse_str("1 + 2").unwrap();
    println!("{:#?}", expr);
}
```

---

## 編譯期計算與 `const fn`

### 基本 `const fn`

```rust
const fn fibonacci(n: u32) -> u32 {
    match n {
        0 => 0,
        1 => 1,
        _ => fibonacci(n - 1) + fibonacci(n - 2),
    }
}

const FIB_10: u32 = fibonacci(10);

fn main() {
    println!("Fibonacci(10) = {}", FIB_10); // 編譯期計算
}
```

### `const fn` 的限制與演進

**Rust 1.90+ 支持**:
- 循環 (`loop`, `while`, `for`)
- 匹配 (`match`, `if let`)
- 解構賦值
- 基本運算符

```rust
const fn sum_array<const N: usize>(arr: &[i32; N]) -> i32 {
    let mut sum = 0;
    let mut i = 0;
    
    while i < N {
        sum += arr[i];
        i += 1;
    }
    
    sum
}

const TOTAL: i32 = sum_array(&[1, 2, 3, 4, 5]);

fn main() {
    println!("總和: {}", TOTAL); // 15
}
```

### Const Generics 結合

```rust
const fn create_array<const N: usize>() -> [usize; N] {
    let mut arr = [0; N];
    let mut i = 0;
    
    while i < N {
        arr[i] = i * i;
        i += 1;
    }
    
    arr
}

const SQUARES: [usize; 5] = create_array();

fn main() {
    println!("{:?}", SQUARES); // [0, 1, 4, 9, 16]
}
```

---

## Build Scripts (`build.rs`)

在編譯前執行的 Rust 腳本,用於代碼生成、編譯 C 代碼等。

### 基本結構

```rust
// build.rs
fn main() {
    println!("cargo:rerun-if-changed=build.rs");
    
    // 生成代碼
    generate_code();
    
    // 設置環境變量
    println!("cargo:rustc-env=BUILD_TIME={}", chrono::Utc::now());
}

fn generate_code() {
    use std::fs;
    use std::path::Path;
    
    let out_dir = std::env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("generated.rs");
    
    fs::write(
        dest_path,
        "pub const GENERATED_VALUE: i32 = 42;",
    ).unwrap();
}
```

### 在代碼中使用

```rust
// main.rs
include!(concat!(env!("OUT_DIR"), "/generated.rs"));

fn main() {
    println!("生成的值: {}", GENERATED_VALUE);
    println!("構建時間: {}", env!("BUILD_TIME"));
}
```

### 編譯 C 代碼

```toml
[build-dependencies]
cc = "1.0"
```

```rust
// build.rs
fn main() {
    cc::Build::new()
        .file("src/native/helper.c")
        .compile("helper");
}
```

---

## 實戰案例: 實現 Builder 派生宏

```rust
// proc_macro crate

use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, Data, Fields};

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let builder_name = syn::Ident::new(
        &format!("{}Builder", name),
        name.span()
    );
    
    let fields = match &input.data {
        Data::Struct(data) => match &data.fields {
            Fields::Named(fields) => &fields.named,
            _ => panic!("只支持具名字段"),
        },
        _ => panic!("只支持結構體"),
    };
    
    let builder_fields = fields.iter().map(|f| {
        let name = &f.ident;
        let ty = &f.ty;
        quote! {
            #name: Option<#ty>
        }
    });
    
    let builder_methods = fields.iter().map(|f| {
        let name = &f.ident;
        let ty = &f.ty;
        quote! {
            pub fn #name(mut self, #name: #ty) -> Self {
                self.#name = Some(#name);
                self
            }
        }
    });
    
    let build_fields = fields.iter().map(|f| {
        let name = &f.ident;
        quote! {
            #name: self.#name.ok_or(concat!(
                "字段 ",
                stringify!(#name),
                " 未設置"
            ))?
        }
    });
    
    let expanded = quote! {
        pub struct #builder_name {
            #(#builder_fields,)*
        }
        
        impl #builder_name {
            #(#builder_methods)*
            
            pub fn build(self) -> Result<#name, Box<dyn std::error::Error>> {
                Ok(#name {
                    #(#build_fields,)*
                })
            }
        }
        
        impl #name {
            pub fn builder() -> #builder_name {
                #builder_name {
                    #(#fields: None,)*
                }
            }
        }
    };
    
    TokenStream::from(expanded)
}

// 使用
// #[derive(Builder)]
// struct Config {
//     host: String,
//     port: u16,
// }
//
// fn main() {
//     let config = Config::builder()
//         .host("localhost".to_string())
//         .port(8080)
//         .build()
//         .unwrap();
// }
```

---

## 調試宏

### 使用 `cargo expand`

```bash
cargo install cargo-expand
cargo expand
```

查看宏展開後的代碼:

```rust
macro_rules! debug_print {
    ($x:expr) => {
        println!("{} = {:?}", stringify!($x), $x);
    };
}

fn main() {
    let value = 42;
    debug_print!(value);
}

// cargo expand 輸出:
// fn main() {
//     let value = 42;
//     {
//         println!("{} = {:?}", "value", value);
//     };
// }
```

### 使用 `trace_macros!`

```rust
#![feature(trace_macros)]

macro_rules! my_macro {
    ($x:expr) => { $x + 1 };
}

fn main() {
    trace_macros!(true);
    let x = my_macro!(5);
    trace_macros!(false);
}
```

---

## 宏的最佳實踐

### 1. 使用類型檢查而非字符串操作

```rust
// ❌ 不好: 容易出錯
macro_rules! bad_macro {
    ($x:expr) => {
        format!("value is {}", $x) // 運行時錯誤
    };
}

// ✅ 好: 編譯期檢查
macro_rules! good_macro {
    ($x:expr) => {
        {
            let val: i32 = $x; // 型別檢查
            format!("value is {}", val)
        }
    };
}
```

### 2. 提供清晰的錯誤訊息

```rust
macro_rules! assert_type {
    ($val:expr, $ty:ty) => {
        {
            let _: $ty = $val;
            // 編譯錯誤會清楚指出型別不匹配
        }
    };
}
```

### 3. 文檔化宏

```rust
/// 創建一個包含指定元素的向量
/// 
/// # 示例
/// 
/// ```
/// let v = my_vec![1, 2, 3];
/// assert_eq!(v, vec![1, 2, 3]);
/// ```
macro_rules! my_vec {
    // ...
}
```

### 4. 限制宏的作用域

```rust
// 模組內私有宏
mod internal {
    macro_rules! internal_macro {
        () => { /* ... */ };
    }
    
    pub(crate) use internal_macro;
}
```

---

## 性能考量

### 宏展開對編譯時間的影響

```rust
// 過度宏展開會增加編譯時間
macro_rules! repeat {
    ($($x:expr),*) => {
        $(
            $x;
            $x;
            $x;
        )*
    };
}

// 展開為大量重複代碼
repeat!(println!("a"), println!("b"));
```

### 建議

- 避免過度嵌套
- 考慮使用泛型而非宏
- 對頻繁調用的宏保持簡單

---

## 進階技巧

### TT Muncher 模式

逐個處理 token:

```rust
macro_rules! count_tts {
    () => { 0 };
    ($odd:tt $($a:tt $b:tt)*) => {
        (count_tts!($($a)*) << 1) | 1
    };
    ($($a:tt $even:tt)*) => {
        count_tts!($($a)*) << 1
    };
}

const COUNT: usize = count_tts!(a b c d e);
// COUNT = 5
```

### Internal Rules (內部規則)

```rust
macro_rules! foo {
    // 公開接口
    ($x:expr) => {
        foo!(@internal $x, 0)
    };
    
    // 內部規則
    (@internal $x:expr, $y:expr) => {
        $x + $y
    };
}
```

---

## 參考資料

1. [The Rust Programming Language - Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
2. [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
3. [Procedural Macros Workshop](https://github.com/dtolnay/proc-macro-workshop)
4. [syn Documentation](https://docs.rs/syn/)
5. [quote Documentation](https://docs.rs/quote/)
6. [Rust Reference - Macros](https://doc.rust-lang.org/reference/macros.html)
7. [Macros in Rust: A Tutorial with Examples](https://blog.logrocket.com/macros-in-rust-a-tutorial-with-examples/)

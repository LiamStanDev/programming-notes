# 02 - 生命期進階技巧

## 概述

生命期 (Lifetime) 是 Rust 所有權系統的核心組成部分,用於確保引用的有效性。生命期註解不會改變引用的實際生命週期,只是告訴編譯器引用之間的關係,讓編譯器驗證安全性。

### 核心概念

- **生命期是編譯期概念**: 不產生任何運行時開銷
- **借用檢查器**: Borrow Checker 使用生命期確保沒有懸垂引用
- **協變與逆變**: 生命期的子類型關係影響型別安全

---

## 生命期省略規則 (Elision Rules)

Rust 編譯器會在某些明確的情況下自動推導生命期,無需手動標註。

### 三條省略規則

#### 規則 1: 每個引用參數獲得獨立的生命期

```rust
// 編寫
fn foo(x: &i32) -> &i32 { x }

// 編譯器理解為
fn foo<'a>(x: &'a i32) -> &'a i32 { x }
```

#### 規則 2: 單一輸入生命期賦給所有輸出

```rust
// 編寫
fn first_word(s: &str) -> &str {
    s.split_whitespace().next().unwrap_or("")
}

// 編譯器理解為
fn first_word<'a>(s: &'a str) -> &'a str {
    s.split_whitespace().next().unwrap_or("")
}
```

#### 規則 3: 方法中,`&self` 的生命期賦給所有輸出

```rust
struct Context {
    data: String,
}

impl Context {
    // 編寫
    fn get_data(&self) -> &str {
        &self.data
    }
    
    // 編譯器理解為
    fn get_data_explicit<'a>(&'a self) -> &'a str {
        &self.data
    }
}
```

### 無法省略的情況

當有多個輸入生命期且輸出與哪個相關不明確時,必須手動標註。

```rust
// ❌ 編譯錯誤: 無法推導返回值的生命期
// fn longest(x: &str, y: &str) -> &str {
//     if x.len() > y.len() { x } else { y }
// }

// ✅ 正確: 手動標註
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}

fn main() {
    let s1 = String::from("long string");
    let s2 = String::from("short");
    
    let result = longest(&s1, &s2);
    println!("最長: {}", result);
}
```

---

## Higher-Rank Trait Bounds (HRTB)

HRTB 使用 `for<'a>` 語法,表示 trait 約束對所有可能的生命期都成立。

### 基本語法

```rust
// 普通 trait bound
fn foo<'a, T>(x: T)
where
    T: Fn(&'a i32),
{
}

// HRTB: T 必須對所有生命期都滿足
fn bar<T>(x: T)
where
    T: for<'a> Fn(&'a i32),
{
}
```

### 實際應用: 閉包與引用

```rust
fn apply_to_ref<F>(f: F)
where
    F: for<'a> Fn(&'a i32) -> &'a i32,
{
    let value = 42;
    let result = f(&value);
    println!("結果: {}", result);
}

fn main() {
    apply_to_ref(|x| x); // 閉包對任意生命期都有效
}
```

### 案例: Trait Object 與生命期

```rust
trait Processor {
    fn process<'a>(&self, data: &'a str) -> &'a str;
}

struct UpperCaseProcessor;

impl Processor for UpperCaseProcessor {
    fn process<'a>(&self, data: &'a str) -> &'a str {
        // 實際應該返回處理後的字符串,這裡簡化
        data
    }
}

// 使用 HRTB 確保 trait object 對所有生命期都有效
fn use_processor(p: &dyn for<'a> Fn(&'a str) -> &'a str) {
    let result = p("test");
    println!("{}", result);
}
```

### HRTB 與 `Fn` Traits

```rust
use std::fmt::Debug;

// 接受任意生命期的閉包
fn call_with_ref<F>(f: F)
where
    F: for<'a> Fn(&'a str) -> &'a str,
{
    let s = String::from("hello");
    let result = f(&s);
    println!("{}", result);
}

fn main() {
    call_with_ref(|x| {
        println!("處理: {}", x);
        x
    });
}
```

---

## `'static` 生命期深入理解

`'static` 是特殊的生命期,表示引用在整個程式執行期間都有效。

### 兩種 `'static` 含義

#### 1. 引用的生命期是 `'static`

引用指向的數據存活於整個程式執行期間。

```rust
// 字符串字面量具有 'static 生命期
let s: &'static str = "hello world";

// 常量也具有 'static 生命期
static CONSTANT: &str = "constant value";

fn main() {
    println!("{}", s);
    println!("{}", CONSTANT);
}
```

#### 2. Trait bound 是 `T: 'static`

表示類型 `T` 不包含任何非 `'static` 的引用 (可以是擁有的數據)。

```rust
use std::fmt::Display;

// T 必須不含非 'static 引用
fn print_forever<T: Display + 'static>(value: T) {
    println!("{}", value);
}

fn main() {
    let owned = String::from("owned");
    print_forever(owned); // ✅ String 是擁有的數據
    
    let static_ref: &'static str = "static";
    print_forever(static_ref); // ✅ 'static 引用
    
    let local = String::from("local");
    // print_forever(&local); // ❌ &String 不是 'static
}
```

### `'static` 在 Thread 中的應用

```rust
use std::thread;

fn main() {
    let static_str: &'static str = "hello";
    
    // ✅ 'static 引用可以安全地跨線程
    thread::spawn(move || {
        println!("{}", static_str);
    }).join().unwrap();
    
    let owned = String::from("owned");
    
    // ✅ 擁有的數據可以移動到線程
    thread::spawn(move || {
        println!("{}", owned);
    }).join().unwrap();
}
```

### Leaked 引用成為 `'static`

```rust
fn main() {
    let s = String::from("leaked");
    let static_ref: &'static str = Box::leak(s.into_boxed_str());
    
    println!("{}", static_ref);
    // 注意: 這會導致內存洩漏
}
```

---

## 生命期與閉包

### 閉包捕獲引用的生命期

```rust
fn main() {
    let data = String::from("data");
    
    // 閉包借用 data
    let closure = || {
        println!("{}", data);
    };
    
    closure();
    // data 的生命期必須涵蓋 closure 的使用
}
```

### 返回閉包需要明確生命期

```rust
// ❌ 錯誤: 返回的閉包生命期不明確
// fn make_closure() -> impl Fn(&str) {
//     |x| println!("{}", x)
// }

// ✅ 使用 HRTB
fn make_closure() -> impl for<'a> Fn(&'a str) {
    |x| println!("{}", x)
}

fn main() {
    let closure = make_closure();
    closure("test");
}
```

### 閉包與環境的生命期關係

```rust
fn call_with_data<'a, F>(data: &'a str, f: F)
where
    F: Fn(&'a str),
{
    f(data);
}

fn main() {
    let s = String::from("hello");
    call_with_data(&s, |x| {
        println!("{}", x);
    });
}
```

---

## 生命期與 Trait Objects

### Trait Object 的默認生命期

```rust
// 默認等價於 Box<dyn Trait + 'static>
fn create_box() -> Box<dyn std::fmt::Display> {
    Box::new(42)
}

// 明確指定生命期
fn create_box_with_lifetime<'a>(s: &'a str) -> Box<dyn std::fmt::Display + 'a> {
    Box::new(s)
}

fn main() {
    let s = String::from("test");
    let boxed = create_box_with_lifetime(&s);
    println!("{}", boxed);
}
```

### Trait Object 與引用

```rust
trait Drawable {
    fn draw(&self);
}

struct Circle;

impl Drawable for Circle {
    fn draw(&self) {
        println!("Drawing circle");
    }
}

// 接受任意生命期的 trait object
fn draw_all<'a>(items: &[&'a dyn Drawable]) {
    for item in items {
        item.draw();
    }
}

fn main() {
    let circle = Circle;
    let items: Vec<&dyn Drawable> = vec![&circle];
    draw_all(&items);
}
```

---

## Lifetime Variance (變異性)

Variance 描述生命期子類型關係如何影響包含它們的類型。

### 三種 Variance

#### 1. 協變 (Covariant)

如果 `'a: 'b` (即 `'a` 比 `'b` 長),則 `T<'a>` 可以當作 `T<'b>` 使用。

```rust
// &'a T 對 'a 是協變的
fn covariant_example() {
    let long_lived = String::from("long");
    let r: &'static str = "static";
    
    {
        let short_lived = String::from("short");
        // 'static 可以用在需要更短生命期的地方
        let x: &str = r; // ✅ 協變允許這樣做
    }
}
```

**協變類型**:
- `&'a T`
- `Box<T>`
- `Vec<T>`
- `fn() -> T`

#### 2. 逆變 (Contravariant)

如果 `'a: 'b`,則 `T<'b>` 可以當作 `T<'a>` 使用 (方向相反)。

```rust
// fn(&'a T) 對 'a 是逆變的
fn contravariant_example() {
    // 接受短生命期的函數可以用在需要長生命期的地方
    let f: fn(&'static str) = |x: &str| println!("{}", x);
    
    let s = String::from("temp");
    // f 可以接受更短的生命期
}
```

**逆變類型**:
- `fn(&'a T)`

#### 3. 不變 (Invariant)

沒有子類型關係,生命期必須精確匹配。

```rust
// &'a mut T 對 'a 是不變的
fn invariant_example() {
    let mut data = String::from("data");
    let r: &mut String = &mut data;
    
    // 不能將 &'static mut 賦值給更短的生命期
}
```

**不變類型**:
- `&'a mut T`
- `Cell<&'a T>`

### Variance 實戰案例

```rust
struct Container<'a, T> {
    data: &'a T,
}

// Container 對 'a 是協變的
fn use_container<'a>(c: Container<'a, i32>) {
    println!("Data: {}", c.data);
}

fn main() {
    static VALUE: i32 = 42;
    let container = Container { data: &VALUE };
    
    // 'static 可以縮短為任意生命期
    use_container(container);
}
```

---

## 常見生命期錯誤與解決方案

### 錯誤 1: 返回懸垂引用

```rust
// ❌ 錯誤: 返回局部變量的引用
// fn dangle() -> &str {
//     let s = String::from("hello");
//     &s // s 在函數結束時被銷毀
// }

// ✅ 解決方案 1: 返回擁有的數據
fn no_dangle_owned() -> String {
    String::from("hello")
}

// ✅ 解決方案 2: 接受外部引用
fn no_dangle_ref<'a>(s: &'a str) -> &'a str {
    s
}
```

### 錯誤 2: 生命期過長導致編譯失敗

```rust
// ❌ 錯誤: r 的生命期超過 x 的作用域
// fn main() {
//     let r;
//     {
//         let x = 5;
//         r = &x;
//     }
//     println!("{}", r);
// }

// ✅ 解決方案: 確保引用在被引用對象的作用域內
fn main() {
    let x = 5;
    let r = &x;
    println!("{}", r);
}
```

### 錯誤 3: 結構體字段生命期不明確

```rust
// ❌ 錯誤: 缺少生命期參數
// struct Context {
//     data: &str,
// }

// ✅ 解決方案: 添加生命期參數
struct Context<'a> {
    data: &'a str,
}

impl<'a> Context<'a> {
    fn new(data: &'a str) -> Self {
        Context { data }
    }
    
    fn get_data(&self) -> &str {
        self.data
    }
}

fn main() {
    let s = String::from("hello");
    let ctx = Context::new(&s);
    println!("{}", ctx.get_data());
}
```

### 錯誤 4: 可變引用與不可變引用同時存在

```rust
// ❌ 錯誤: 同時有可變和不可變引用
// fn main() {
//     let mut s = String::from("hello");
//     let r1 = &s;
//     let r2 = &mut s; // 錯誤!
//     println!("{}, {}", r1, r2);
// }

// ✅ 解決方案: 分離借用的作用域
fn main() {
    let mut s = String::from("hello");
    
    {
        let r1 = &s;
        println!("{}", r1);
    } // r1 作用域結束
    
    let r2 = &mut s;
    println!("{}", r2);
}
```

### 錯誤 5: 方法中的生命期衝突

```rust
struct Parser<'a> {
    source: &'a str,
}

impl<'a> Parser<'a> {
    // ❌ 錯誤: 返回值生命期與 self 衝突
    // fn parse(&mut self, default: &str) -> &str {
    //     self.source
    // }
    
    // ✅ 解決方案: 明確標註生命期關係
    fn parse(&mut self, default: &str) -> &'a str {
        if self.source.is_empty() {
            // default 的生命期不夠長,不能返回
            // default
            self.source
        } else {
            self.source
        }
    }
}
```

---

## 進階技巧與模式

### 1. 多個生命期參數

```rust
struct Context<'a, 'b> {
    part1: &'a str,
    part2: &'b str,
}

impl<'a, 'b> Context<'a, 'b> {
    // 返回值與兩個生命期都無關
    fn combined(&self) -> String {
        format!("{} {}", self.part1, self.part2)
    }
    
    // 返回值綁定到 'a
    fn get_part1(&self) -> &'a str {
        self.part1
    }
}
```

### 2. 生命期約束

```rust
// 'a 必須比 'b 長
struct Refs<'a, 'b: 'a> {
    long: &'a str,
    short: &'b str,
}

impl<'a, 'b: 'a> Refs<'a, 'b> {
    fn new(long: &'a str, short: &'b str) -> Self {
        Refs { long, short }
    }
}
```

### 3. 匿名生命期 `'_` (Rust 2018+)

```rust
struct StrWrapper<'a>(&'a str);

impl<'a> StrWrapper<'a> {
    // 舊寫法
    fn new_old(s: &'a str) -> StrWrapper<'a> {
        StrWrapper(s)
    }
    
    // 新寫法: 使用 '_' 省略生命期
    fn new(s: &str) -> StrWrapper<'_> {
        StrWrapper(s)
    }
}
```

### 4. 生命期與 Generic 結合

```rust
use std::fmt::Display;

fn longest_with_announcement<'a, T>(
    x: &'a str,
    y: &'a str,
    ann: T,
) -> &'a str
where
    T: Display,
{
    println!("公告: {}", ann);
    if x.len() > y.len() { x } else { y }
}
```

---

## 實戰案例: 實現一個安全的字符串切片器

```rust
pub struct Slicer<'a> {
    source: &'a str,
    position: usize,
}

impl<'a> Slicer<'a> {
    pub fn new(source: &'a str) -> Self {
        Slicer { source, position: 0 }
    }
    
    pub fn next(&mut self, len: usize) -> Option<&'a str> {
        if self.position + len > self.source.len() {
            return None;
        }
        
        let start = self.position;
        self.position += len;
        Some(&self.source[start..self.position])
    }
    
    pub fn remaining(&self) -> &'a str {
        &self.source[self.position..]
    }
    
    pub fn reset(&mut self) {
        self.position = 0;
    }
}

fn main() {
    let text = "Hello, World!";
    let mut slicer = Slicer::new(text);
    
    assert_eq!(slicer.next(5), Some("Hello"));
    assert_eq!(slicer.next(2), Some(", "));
    assert_eq!(slicer.remaining(), "World!");
    
    slicer.reset();
    assert_eq!(slicer.next(5), Some("Hello"));
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_slicer() {
        let text = "abcdef";
        let mut slicer = Slicer::new(text);
        
        assert_eq!(slicer.next(2), Some("ab"));
        assert_eq!(slicer.next(2), Some("cd"));
        assert_eq!(slicer.remaining(), "ef");
        assert_eq!(slicer.next(3), None); // 超出範圍
    }
}
```

---

## 調試技巧

### 使用 `rustc` 查看生命期推導

```bash
# 創建測試文件
cat > test.rs << 'EOF'
fn foo(x: &str) -> &str { x }
fn main() {}
EOF

# 查看編譯器的生命期推導
rustc --edition 2021 -Z unpretty=hir test.rs
```

### 使用 `cargo expand` 查看宏展開

```bash
cargo install cargo-expand
cargo expand
```

---

## 最佳實踐

### 1. 優先使用生命期省略

```rust
// ❌ 過度標註
fn get_first<'a>(s: &'a str) -> &'a str {
    s.split_whitespace().next().unwrap_or("")
}

// ✅ 利用省略規則
fn get_first(s: &str) -> &str {
    s.split_whitespace().next().unwrap_or("")
}
```

### 2. 結構體生命期儘量簡單

```rust
// ❌ 複雜的多生命期結構
struct Complex<'a, 'b, 'c> {
    a: &'a str,
    b: &'b str,
    c: &'c str,
}

// ✅ 統一生命期或使用擁有的數據
struct Simple<'a> {
    data: Vec<&'a str>,
}
```

### 3. 考慮使用擁有的數據避免生命期複雜性

```rust
// 生命期版本
struct ConfigRef<'a> {
    value: &'a str,
}

// 擁有版本 (更簡單)
struct Config {
    value: String,
}
```

---

## 參考資料

1. [The Rust Programming Language - Lifetime Syntax](https://doc.rust-lang.org/book/ch10-03-lifetime-syntax.html)
2. [Rust Reference - Lifetimes](https://doc.rust-lang.org/reference/lifetime-elision.html)
3. [Rustonomicon - Lifetimes](https://doc.rust-lang.org/nomicon/lifetimes.html)
4. [Variance in Rust](https://doc.rust-lang.org/nomicon/subtyping.html)
5. [Common Rust Lifetime Misconceptions](https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md)
6. [Higher-Rank Trait Bounds](https://doc.rust-lang.org/nomicon/hrtb.html)

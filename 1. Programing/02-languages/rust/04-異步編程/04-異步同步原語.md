# 異步同步原語

## 核心概念

### 同步 vs 異步原語

```rust
// 同步原語（std::sync）- 阻塞線程
use std::sync::{Mutex, RwLock};

let mutex = Mutex::new(0);
let guard = mutex.lock().unwrap();  // 阻塞當前線程

// 異步原語（tokio::sync）- 不阻塞執行器
use tokio::sync::Mutex as AsyncMutex;

let mutex = AsyncMutex::new(0);
let guard = mutex.lock().await;  // yield 當前任務，不阻塞線程
```

**關鍵差異**：

| 特性 | `std::sync` | `tokio::sync` |
|------|-------------|---------------|
| **阻塞行為** | 阻塞線程 | yield 任務 |
| **適用場景** | spawn_blocking | async 任務 |
| **開銷** | 低（無調度） | 中（需調度） |
| **死鎖風險** | 高 | 中 |

## Mutex

### 基本用法

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let data = Arc::new(Mutex::new(0));
    let mut handles = vec![];
    
    for _ in 0..10 {
        let data = data.clone();
        let handle = tokio::spawn(async move {
            let mut lock = data.lock().await;
            *lock += 1;
            // lock 在作用域結束時自動釋放
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("Result: {}", *data.lock().await);  // Output: 10
}
```

### try_lock 與 try_lock_owned

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let mutex = Arc::new(Mutex::new(42));
    
    // try_lock: 非阻塞嘗試獲取鎖
    match mutex.try_lock() {
        Ok(guard) => println!("Value: {}", *guard),
        Err(_) => println!("Lock is held"),
    }
    
    // lock_owned: 返回 OwnedMutexGuard，可移動到其他任務
    let mutex2 = mutex.clone();
    tokio::spawn(async move {
        let guard = mutex2.lock_owned().await;
        println!("Owned guard: {}", *guard);
    }).await.unwrap();
}
```

### 避免長時間持有鎖

```rust
use tokio::sync::Mutex;

// ❌ 錯誤：在 await 期間持有鎖
async fn bad_example(mutex: &Mutex<Vec<String>>) {
    let mut data = mutex.lock().await;
    data.push("item".to_string());
    
    // 危險！在持有鎖期間 await
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
}

// ✅ 正確：盡快釋放鎖
async fn good_example(mutex: &Mutex<Vec<String>>) {
    {
        let mut data = mutex.lock().await;
        data.push("item".to_string());
    }  // 鎖在此釋放
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
}
```

## RwLock

### 讀寫鎖用法

```rust
use tokio::sync::RwLock;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let data = Arc::new(RwLock::new(vec![1, 2, 3]));
    
    // 多個讀者可並發訪問
    let data1 = data.clone();
    let reader1 = tokio::spawn(async move {
        let read_guard = data1.read().await;
        println!("Reader 1: {:?}", *read_guard);
    });
    
    let data2 = data.clone();
    let reader2 = tokio::spawn(async move {
        let read_guard = data2.read().await;
        println!("Reader 2: {:?}", *read_guard);
    });
    
    // 寫者獨占訪問
    let data3 = data.clone();
    let writer = tokio::spawn(async move {
        let mut write_guard = data3.write().await;
        write_guard.push(4);
        println!("Writer: {:?}", *write_guard);
    });
    
    reader1.await.unwrap();
    reader2.await.unwrap();
    writer.await.unwrap();
}
```

### 降級與升級

```rust
use tokio::sync::RwLock;

#[tokio::main]
async fn main() {
    let lock = RwLock::new(5);
    
    // 寫鎖可以降級為讀鎖
    let write_guard = lock.write().await;
    let read_guard = write_guard.downgrade();
    println!("Value: {}", *read_guard);
    
    // 注意：讀鎖無法直接升級為寫鎖（會死鎖）
    // 需要釋放讀鎖後重新獲取寫鎖
}
```

### RwLock vs Mutex 選擇

```rust
// 適合使用 RwLock
// - 讀取頻繁，寫入少
// - 讀操作耗時長
struct Cache {
    data: RwLock<HashMap<String, String>>,
}

impl Cache {
    async fn get(&self, key: &str) -> Option<String> {
        self.data.read().await.get(key).cloned()
    }
    
    async fn insert(&self, key: String, value: String) {
        self.data.write().await.insert(key, value);
    }
}

// 適合使用 Mutex
// - 讀寫比例相近
// - 臨界區很小
struct Counter {
    value: Mutex<i32>,
}

impl Counter {
    async fn increment(&self) {
        let mut val = self.value.lock().await;
        *val += 1;
    }
}
```

## Semaphore

### 基本用法

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    // 最多 3 個並發任務
    let semaphore = Arc::new(Semaphore::new(3));
    let mut handles = vec![];
    
    for i in 0..10 {
        let permit = semaphore.clone().acquire_owned().await.unwrap();
        let handle = tokio::spawn(async move {
            println!("Task {} started", i);
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
            println!("Task {} finished", i);
            drop(permit);  // 釋放許可
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 限流器實現

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;
use std::time::Duration;

struct RateLimiter {
    semaphore: Arc<Semaphore>,
}

impl RateLimiter {
    fn new(max_concurrent: usize) -> Self {
        Self {
            semaphore: Arc::new(Semaphore::new(max_concurrent)),
        }
    }
    
    async fn acquire(&self) -> SemaphorePermit {
        self.semaphore.acquire_owned().await.unwrap()
    }
}

struct SemaphorePermit(tokio::sync::OwnedSemaphorePermit);

#[tokio::main]
async fn main() {
    let limiter = Arc::new(RateLimiter::new(5));
    
    for i in 0..20 {
        let limiter = limiter.clone();
        tokio::spawn(async move {
            let _permit = limiter.acquire().await;
            println!("Processing request {}", i);
            tokio::time::sleep(Duration::from_millis(500)).await;
        });
    }
    
    tokio::time::sleep(Duration::from_secs(10)).await;
}
```

### 資源池

```rust
use tokio::sync::Semaphore;
use std::sync::Arc;

struct ConnectionPool {
    connections: Vec<Connection>,
    semaphore: Arc<Semaphore>,
}

struct Connection {
    id: usize,
}

impl ConnectionPool {
    fn new(size: usize) -> Self {
        let connections = (0..size).map(|id| Connection { id }).collect();
        Self {
            connections,
            semaphore: Arc::new(Semaphore::new(size)),
        }
    }
    
    async fn acquire(&self) -> PooledConnection {
        let permit = self.semaphore.clone().acquire_owned().await.unwrap();
        // 實際應用中應從池中取出連接
        PooledConnection { _permit: permit }
    }
}

struct PooledConnection {
    _permit: tokio::sync::OwnedSemaphorePermit,
}

#[tokio::main]
async fn main() {
    let pool = Arc::new(ConnectionPool::new(5));
    
    let mut handles = vec![];
    for i in 0..10 {
        let pool = pool.clone();
        let handle = tokio::spawn(async move {
            let _conn = pool.acquire().await;
            println!("Task {} using connection", i);
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

## Notify

### 單播通知

```rust
use tokio::sync::Notify;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let notify = Arc::new(Notify::new());
    let notify2 = notify.clone();
    
    tokio::spawn(async move {
        notify2.notified().await;
        println!("Received notification!");
    });
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    notify.notify_one();  // 喚醒一個等待者
}
```

### 廣播通知

```rust
use tokio::sync::Notify;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let notify = Arc::new(Notify::new());
    let mut handles = vec![];
    
    for i in 0..5 {
        let notify = notify.clone();
        let handle = tokio::spawn(async move {
            notify.notified().await;
            println!("Task {} notified", i);
        });
        handles.push(handle);
    }
    
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    
    // 喚醒所有等待者
    notify.notify_waiters();
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 條件變量替代

```rust
use tokio::sync::Notify;
use std::sync::Arc;

struct Event {
    notify: Notify,
    flag: tokio::sync::Mutex<bool>,
}

impl Event {
    fn new() -> Self {
        Self {
            notify: Notify::new(),
            flag: tokio::sync::Mutex::new(false),
        }
    }
    
    async fn wait(&self) {
        loop {
            let notified = self.notify.notified();
            
            if *self.flag.lock().await {
                return;
            }
            
            notified.await;
        }
    }
    
    async fn set(&self) {
        *self.flag.lock().await = true;
        self.notify.notify_waiters();
    }
}

#[tokio::main]
async fn main() {
    let event = Arc::new(Event::new());
    
    let event2 = event.clone();
    tokio::spawn(async move {
        event2.wait().await;
        println!("Event triggered!");
    });
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    event.set().await;
    
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
}
```

## Barrier

### 同步多個任務

```rust
use tokio::sync::Barrier;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let barrier = Arc::new(Barrier::new(5));
    let mut handles = vec![];
    
    for i in 0..5 {
        let barrier = barrier.clone();
        let handle = tokio::spawn(async move {
            println!("Task {} preparing...", i);
            tokio::time::sleep(tokio::time::Duration::from_millis(i * 100)).await;
            
            println!("Task {} waiting at barrier", i);
            barrier.wait().await;
            
            println!("Task {} proceeding", i);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

### 多階段同步

```rust
use tokio::sync::Barrier;
use std::sync::Arc;

#[tokio::main]
async fn main() {
    let barrier = Arc::new(Barrier::new(3));
    
    let stages = vec!["Setup", "Process", "Cleanup"];
    
    for id in 0..3 {
        let barrier = barrier.clone();
        let stages = stages.clone();
        
        tokio::spawn(async move {
            for stage in stages {
                println!("Worker {} - {} phase", id, stage);
                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
                
                barrier.wait().await;  // 等待所有任務完成當前階段
                
                println!("Worker {} - {} phase complete", id, stage);
            }
        });
    }
    
    tokio::time::sleep(tokio::time::Duration::from_secs(2)).await;
}
```

## OnceCell / Lazy

### 延遲初始化

```rust
use tokio::sync::OnceCell;

static CONFIG: OnceCell<String> = OnceCell::const_new();

async fn get_config() -> &'static String {
    CONFIG.get_or_init(|| async {
        // 模擬從配置文件加載
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        "config_value".to_string()
    }).await
}

#[tokio::main]
async fn main() {
    println!("First call:");
    let config1 = get_config().await;
    println!("{}", config1);
    
    println!("Second call (cached):");
    let config2 = get_config().await;
    println!("{}", config2);
}
```

### 共享初始化

```rust
use tokio::sync::OnceCell;
use std::sync::Arc;

struct Database {
    connection: String,
}

impl Database {
    async fn init() -> Self {
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        Self {
            connection: "db_connection".to_string(),
        }
    }
}

struct App {
    db: Arc<OnceCell<Database>>,
}

impl App {
    fn new() -> Self {
        Self {
            db: Arc::new(OnceCell::new()),
        }
    }
    
    async fn get_db(&self) -> &Database {
        self.db.get_or_init(|| Database::init()).await
    }
}

#[tokio::main]
async fn main() {
    let app = Arc::new(App::new());
    
    // 多個任務並發訪問，但只初始化一次
    let mut handles = vec![];
    for i in 0..5 {
        let app = app.clone();
        let handle = tokio::spawn(async move {
            let db = app.get_db().await;
            println!("Task {}: {}", i, db.connection);
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
}
```

## Channel

### mpsc (多生產者單消費者)

```rust
use tokio::sync::mpsc;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = mpsc::channel(32);  // 緩衝區大小 32
    
    // 生產者
    for i in 0..10 {
        let tx = tx.clone();
        tokio::spawn(async move {
            tx.send(i).await.unwrap();
        });
    }
    
    drop(tx);  // 關閉發送端
    
    // 消費者
    while let Some(value) = rx.recv().await {
        println!("Received: {}", value);
    }
}
```

### broadcast (廣播)

```rust
use tokio::sync::broadcast;

#[tokio::main]
async fn main() {
    let (tx, _) = broadcast::channel(16);
    
    // 多個接收者
    let mut rx1 = tx.subscribe();
    let mut rx2 = tx.subscribe();
    let mut rx3 = tx.subscribe();
    
    tokio::spawn(async move {
        while let Ok(msg) = rx1.recv().await {
            println!("Receiver 1: {}", msg);
        }
    });
    
    tokio::spawn(async move {
        while let Ok(msg) = rx2.recv().await {
            println!("Receiver 2: {}", msg);
        }
    });
    
    tokio::spawn(async move {
        while let Ok(msg) = rx3.recv().await {
            println!("Receiver 3: {}", msg);
        }
    });
    
    // 廣播消息
    for i in 0..5 {
        tx.send(i).unwrap();
        tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    }
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
}
```

### watch (單一值監聽)

```rust
use tokio::sync::watch;

#[tokio::main]
async fn main() {
    let (tx, mut rx) = watch::channel("initial");
    
    // 監聽者
    tokio::spawn(async move {
        while rx.changed().await.is_ok() {
            println!("Value changed to: {}", *rx.borrow());
        }
    });
    
    // 發送者
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    tx.send("updated").unwrap();
    
    tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
    tx.send("final").unwrap();
    
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
}
```

### oneshot (一次性通道)

```rust
use tokio::sync::oneshot;

#[tokio::main]
async fn main() {
    let (tx, rx) = oneshot::channel();
    
    tokio::spawn(async move {
        tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        tx.send("result").unwrap();
    });
    
    match rx.await {
        Ok(value) => println!("Received: {}", value),
        Err(_) => println!("Sender dropped"),
    }
}
```

## 死鎖檢測與避免

### 死鎖範例

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

// ❌ 死鎖：循環等待
async fn deadlock_example() {
    let mutex1 = Arc::new(Mutex::new(1));
    let mutex2 = Arc::new(Mutex::new(2));
    
    let m1 = mutex1.clone();
    let m2 = mutex2.clone();
    
    let task1 = tokio::spawn(async move {
        let _g1 = m1.lock().await;
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
        let _g2 = m2.lock().await;  // 等待 mutex2
    });
    
    let task2 = tokio::spawn(async move {
        let _g2 = mutex2.lock().await;
        tokio::time::sleep(tokio::time::Duration::from_millis(10)).await;
        let _g1 = mutex1.lock().await;  // 等待 mutex1
    });
    
    task1.await.unwrap();
    task2.await.unwrap();
}
```

### 避免死鎖策略

```rust
use tokio::sync::Mutex;
use std::sync::Arc;

// ✅ 策略 1：鎖排序
async fn lock_ordering() {
    let mutex1 = Arc::new(Mutex::new(1));
    let mutex2 = Arc::new(Mutex::new(2));
    
    // 總是按相同順序獲取鎖
    let _g1 = mutex1.lock().await;
    let _g2 = mutex2.lock().await;
}

// ✅ 策略 2：try_lock
async fn try_lock_approach(mutex1: &Mutex<i32>, mutex2: &Mutex<i32>) {
    loop {
        let g1 = mutex1.lock().await;
        
        if let Ok(g2) = mutex2.try_lock() {
            // 成功獲取兩個鎖
            println!("{} {}", *g1, *g2);
            break;
        } else {
            // 釋放第一個鎖，重試
            drop(g1);
            tokio::task::yield_now().await;
        }
    }
}

// ✅ 策略 3：使用 RwLock
async fn use_rwlock() {
    let data = Arc::new(tokio::sync::RwLock::new(vec![1, 2, 3]));
    
    // 多個讀者不會死鎖
    let r1 = data.read().await;
    let r2 = data.read().await;
    println!("{:?} {:?}", *r1, *r2);
}
```

## 性能比較

### Mutex vs RwLock Benchmark

```rust
use tokio::sync::{Mutex, RwLock};
use std::sync::Arc;
use std::time::Instant;

async fn benchmark_mutex(iterations: usize) {
    let mutex = Arc::new(Mutex::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..10 {
        let mutex = mutex.clone();
        let handle = tokio::spawn(async move {
            for _ in 0..iterations {
                let mut val = mutex.lock().await;
                *val += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("Mutex: {:?}", start.elapsed());
}

async fn benchmark_rwlock(iterations: usize) {
    let rwlock = Arc::new(RwLock::new(0));
    let start = Instant::now();
    
    let mut handles = vec![];
    for _ in 0..10 {
        let rwlock = rwlock.clone();
        let handle = tokio::spawn(async move {
            for _ in 0..iterations {
                let mut val = rwlock.write().await;
                *val += 1;
            }
        });
        handles.push(handle);
    }
    
    for handle in handles {
        handle.await.unwrap();
    }
    
    println!("RwLock: {:?}", start.elapsed());
}

#[tokio::main]
async fn main() {
    benchmark_mutex(10000).await;
    benchmark_rwlock(10000).await;
}
```

---

## 參考資料

1. [Tokio Sync Documentation](https://docs.rs/tokio/latest/tokio/sync/)
2. [Tokio Tutorial - Shared State](https://tokio.rs/tokio/tutorial/shared-state)
3. [Async: What is blocking?](https://ryhl.io/blog/async-what-is-blocking/)
4. [Mutex vs RwLock in async Rust](https://morestina.net/blog/1482/rust-async-rwlock)
5. [The Rustonomicon - Concurrency](https://doc.rust-lang.org/nomicon/concurrency.html)
6. 《Rust Atomics and Locks》(Mara Bos, O'Reilly, 2023)

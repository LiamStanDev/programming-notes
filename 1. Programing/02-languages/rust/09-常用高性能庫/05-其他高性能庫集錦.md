# 其他高性能庫集錦 (Other High-Performance Libraries)

## 數據結構與算法

### ahash - 快速哈希

**概念**: 比標準庫 `DefaultHasher` 快 3-10x 的哈希函數

```toml
[dependencies]
ahash = "0.8"
```

```rust
use ahash::{AHasher, AHashMap, AHashSet};
use std::hash::{Hash, Hasher};

fn hash_performance() {
    // 方案 1: 使用 AHashMap (內建 AHash)
    let mut map = AHashMap::new();
    map.insert("key", "value");
    
    // 方案 2: 使用 AHashSet
    let mut set = AHashSet::new();
    set.insert(42);
    
    // 方案 3: 手動使用 AHasher
    let mut hasher = AHasher::default();
    "hello".hash(&mut hasher);
    let hash = hasher.finish();
    
    println!("Hash: {}", hash);
}

// 性能對比:
// std::HashMap:  ~50 ns/lookup
// ahash::AHashMap: ~15 ns/lookup (3x 快)
```

### dashmap - 併發哈希表

**概念**: 無鎖併發哈希表，比 `Mutex<HashMap>` 快 5-10x

```toml
[dependencies]
dashmap = "5.5"
```

```rust
use dashmap::DashMap;
use std::sync::Arc;
use std::thread;

fn concurrent_hashmap() {
    let map = Arc::new(DashMap::new());
    
    // 多個線程併發插入
    let mut handles = vec![];
    for i in 0..10 {
        let map = Arc::clone(&map);
        let handle = thread::spawn(move || {
            for j in 0..1000 {
                map.insert(i * 1000 + j, format!("value-{}", j));
            }
        });
        handles.push(handle);
    }
    
    for h in handles {
        h.join().unwrap();
    }
    
    println!("Map size: {}", map.len());
    
    // 讀取數據
    if let Some(entry) = map.get(&5000) {
        println!("Found: {}", entry.value());
    }
    
    // 迭代
    for entry in map.iter() {
        println!("{}: {}", entry.key(), entry.value());
    }
}
```

### smallvec - 小型向量優化

**概念**: 在棧上存儲小數組，避免堆分配

```toml
[dependencies]
smallvec = "1.11"
```

```rust
use smallvec::{SmallVec, smallvec};

fn small_vector() {
    // 最多 4 個元素在棧上，超過後分配到堆
    let mut vec: SmallVec<[i32; 4]> = smallvec![1, 2, 3];
    
    // 棧上分配 (快)
    vec.push(4);
    println!("On stack: {:?}", vec);
    
    // 超過容量，移到堆上
    vec.push(5);
    println!("On heap: {:?}", vec);
    
    // 性能提升: 小數組場景快 2-5x
}
```

---

## 序列化與反序列化

### serde + bincode - 二進制序列化

**概念**: 高性能二進制序列化，比 JSON 快 10-20x

```toml
[dependencies]
serde = { version = "1.0", features = ["derive"] }
bincode = "1.3"
```

```rust
use serde::{Serialize, Deserialize};

#[derive(Serialize, Deserialize, Debug)]
struct User {
    id: u64,
    name: String,
    age: u32,
}

fn binary_serialization() {
    let user = User {
        id: 1,
        name: "Alice".to_string(),
        age: 30,
    };
    
    // 序列化為二進制
    let encoded = bincode::serialize(&user).unwrap();
    println!("Encoded size: {} bytes", encoded.len());
    
    // 反序列化
    let decoded: User = bincode::deserialize(&encoded).unwrap();
    println!("Decoded: {:?}", decoded);
}

// 性能對比 (1000 次序列化):
// serde_json: ~5 ms
// bincode:    ~0.5 ms (10x 快)
```

### rmp-serde - MessagePack 序列化

```toml
[dependencies]
rmp-serde = "1.1"
```

```rust
use serde::{Serialize, Deserialize};
use rmp_serde::{Serializer, Deserializer};

#[derive(Serialize, Deserialize)]
struct Data {
    values: Vec<i32>,
}

fn messagepack_example() {
    let data = Data {
        values: vec![1, 2, 3, 4, 5],
    };
    
    // 序列化
    let mut buf = Vec::new();
    data.serialize(&mut Serializer::new(&mut buf)).unwrap();
    
    // 反序列化
    let mut de = Deserializer::new(&buf[..]);
    let decoded = Data::deserialize(&mut de).unwrap();
}
```

---

## 字符串處理

### bstr - 字節字符串

**概念**: 高性能字節字符串操作，支持非 UTF-8 數據

```toml
[dependencies]
bstr = "1.8"
```

```rust
use bstr::{ByteSlice, B};

fn byte_string() {
    let data = b"hello\xFFworld";  // 非 UTF-8 數據
    
    // 查找子串 (支持非 UTF-8)
    if let Some(pos) = data.find(B("\xFF")) {
        println!("Found at position: {}", pos);
    }
    
    // 分割
    let parts: Vec<_> = data.split_str("world").collect();
    
    // 替換
    let replaced = data.replace(B("\xFF"), B("_"));
}
```

### regex - 正則表達式

```toml
[dependencies]
regex = "1.10"
```

```rust
use regex::Regex;

fn regex_example() {
    // 編譯正則表達式 (只需一次)
    let re = Regex::new(r"(\d{4})-(\d{2})-(\d{2})").unwrap();
    
    // 查找匹配
    if let Some(caps) = re.captures("Today is 2024-01-15") {
        println!("Year: {}", &caps[1]);
        println!("Month: {}", &caps[2]);
        println!("Day: {}", &caps[3]);
    }
    
    // 替換
    let result = re.replace_all("2024-01-15", "$3/$2/$1");
    println!("Formatted: {}", result);  // 15/01/2024
}
```

---

## 內存管理

### bumpalo - 碰撞分配器

**概念**: 快速內存分配器，適合短生命週期對象

```toml
[dependencies]
bumpalo = "3.14"
```

```rust
use bumpalo::Bump;

fn bump_allocator() {
    // 創建 arena 分配器
    let bump = Bump::new();
    
    // 在 arena 中分配
    let x = bump.alloc(42);
    let y = bump.alloc(vec![1, 2, 3]);
    
    println!("x: {}, y: {:?}", x, y);
    
    // bump 離開作用域時，一次性釋放所有內存
}

// 性能: 比 Box::new 快 5-10x
```

### bytes - 零拷貝字節緩衝

```toml
[dependencies]
bytes = "1.5"
```

```rust
use bytes::{Bytes, BytesMut, Buf, BufMut};

fn zero_copy_buffers() {
    // 可變緩衝
    let mut buf = BytesMut::with_capacity(1024);
    buf.put(&b"hello "[..]);
    buf.put(&b"world"[..]);
    
    // 凍結為不可變 (零拷貝)
    let frozen = buf.freeze();
    
    // 克隆共享引用 (零拷貝)
    let clone1 = frozen.clone();
    let clone2 = frozen.clone();
    
    // 切片 (零拷貝)
    let slice = frozen.slice(0..5);
    println!("Slice: {:?}", slice);
}
```

---

## 數學與科學計算

### ndarray - 多維數組

```toml
[dependencies]
ndarray = "0.15"
```

```rust
use ndarray::{Array2, arr2};

fn ndarray_example() {
    // 創建 2D 數組
    let a = arr2(&[[1, 2, 3],
                   [4, 5, 6]]);
    
    let b = arr2(&[[1, 0, 1],
                   [0, 1, 0]]);
    
    // 矩陣運算
    let sum = &a + &b;
    let product = &a * &b;  // 逐元素乘法
    
    println!("Sum:\n{}", sum);
    println!("Product:\n{}", product);
    
    // 矩陣乘法
    let c = Array2::<f64>::zeros((2, 2));
    // let result = a.dot(&b.t());
}
```

### num - 數值類型擴展

```toml
[dependencies]
num = "0.4"
```

```rust
use num::{Complex, BigInt, rational::Ratio};

fn numeric_types() {
    // 複數
    let z = Complex::new(3.0, 4.0);
    println!("Magnitude: {}", z.norm());
    
    // 大整數
    let a: BigInt = "123456789012345678901234567890".parse().unwrap();
    let b: BigInt = "987654321098765432109876543210".parse().unwrap();
    println!("Sum: {}", a + b);
    
    // 有理數
    let r1 = Ratio::new(1, 3);  // 1/3
    let r2 = Ratio::new(1, 6);  // 1/6
    println!("Sum: {}", r1 + r2);  // 1/2
}
```

---

## 隨機數與加密

### rand - 隨機數生成

```toml
[dependencies]
rand = "0.8"
```

```rust
use rand::{Rng, thread_rng};
use rand::distributions::{Alphanumeric, Standard};

fn random_numbers() {
    let mut rng = thread_rng();
    
    // 隨機整數
    let x: i32 = rng.gen();
    let y: u32 = rng.gen_range(0..100);
    
    // 隨機浮點數
    let f: f64 = rng.gen();  // [0.0, 1.0)
    
    // 隨機字符串
    let s: String = (0..10)
        .map(|_| rng.sample(Alphanumeric) as char)
        .collect();
    
    println!("Random string: {}", s);
    
    // 隨機選擇
    let choices = vec!["A", "B", "C"];
    let choice = choices[rng.gen_range(0..choices.len())];
}
```

### sha2 - SHA-256 哈希

```toml
[dependencies]
sha2 = "0.10"
```

```rust
use sha2::{Sha256, Digest};

fn hash_example() {
    // 創建哈希器
    let mut hasher = Sha256::new();
    
    // 輸入數據
    hasher.update(b"hello world");
    
    // 計算哈希
    let result = hasher.finalize();
    
    // 轉為十六進制字符串
    let hex = format!("{:x}", result);
    println!("SHA-256: {}", hex);
}
```

---

## 壓縮與編碼

### flate2 - gzip/zlib 壓縮

```toml
[dependencies]
flate2 = "1.0"
```

```rust
use flate2::Compression;
use flate2::write::{GzEncoder, GzDecoder};
use std::io::Write;

fn compression_example() {
    let data = b"Hello, World!".repeat(100);
    
    // 壓縮
    let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
    encoder.write_all(&data).unwrap();
    let compressed = encoder.finish().unwrap();
    
    println!("Original: {} bytes", data.len());
    println!("Compressed: {} bytes", compressed.len());
    
    // 壓縮率
    let ratio = (1.0 - compressed.len() as f64 / data.len() as f64) * 100.0;
    println!("Compression ratio: {:.1}%", ratio);
}
```

### base64 - Base64 編碼

```toml
[dependencies]
base64 = "0.21"
```

```rust
use base64::{Engine as _, engine::general_purpose};

fn base64_example() {
    let data = b"Hello, World!";
    
    // 編碼
    let encoded = general_purpose::STANDARD.encode(data);
    println!("Encoded: {}", encoded);
    
    // 解碼
    let decoded = general_purpose::STANDARD.decode(&encoded).unwrap();
    println!("Decoded: {}", String::from_utf8(decoded).unwrap());
}
```

---

## 日期與時間

### chrono - 日期時間處理

```toml
[dependencies]
chrono = "0.4"
```

```rust
use chrono::{DateTime, Utc, Local, Duration, NaiveDate};

fn datetime_example() {
    // 當前時間
    let now = Utc::now();
    println!("UTC: {}", now);
    
    let local = Local::now();
    println!("Local: {}", local);
    
    // 解析字符串
    let dt = DateTime::parse_from_rfc3339("2024-01-15T12:30:00Z").unwrap();
    
    // 格式化
    let formatted = dt.format("%Y-%m-%d %H:%M:%S");
    println!("Formatted: {}", formatted);
    
    // 時間運算
    let tomorrow = now + Duration::days(1);
    let diff = tomorrow - now;
    println!("Difference: {} seconds", diff.num_seconds());
}
```

---

## 命令行工具

### clap - 命令行參數解析

```toml
[dependencies]
clap = { version = "4.4", features = ["derive"] }
```

```rust
use clap::Parser;

#[derive(Parser, Debug)]
#[command(author, version, about)]
struct Args {
    /// 輸入文件
    #[arg(short, long)]
    input: String,
    
    /// 輸出文件
    #[arg(short, long)]
    output: Option<String>,
    
    /// 詳細模式
    #[arg(short, long)]
    verbose: bool,
}

fn main() {
    let args = Args::parse();
    
    println!("Input: {}", args.input);
    if let Some(output) = args.output {
        println!("Output: {}", output);
    }
    if args.verbose {
        println!("Verbose mode enabled");
    }
}
```

### indicatif - 進度條

```toml
[dependencies]
indicatif = "0.17"
```

```rust
use indicatif::{ProgressBar, ProgressStyle};
use std::time::Duration;

fn progress_bar_example() {
    let pb = ProgressBar::new(100);
    
    // 設置樣式
    pb.set_style(
        ProgressStyle::default_bar()
            .template("[{elapsed_precise}] {bar:40.cyan/blue} {pos}/{len} {msg}")
            .unwrap()
            .progress_chars("##-")
    );
    
    for i in 0..100 {
        pb.set_position(i);
        pb.set_message(format!("Processing item {}", i));
        std::thread::sleep(Duration::from_millis(50));
    }
    
    pb.finish_with_message("Done!");
}
```

---

## 性能對比總結

| 庫 | 場景 | 性能提升 |
|----|------|---------|
| **ahash** | 哈希計算 | 3-10x |
| **dashmap** | 併發哈希表 | 5-10x |
| **smallvec** | 小數組 | 2-5x |
| **bincode** | 序列化 | 10-20x (vs JSON) |
| **bumpalo** | 內存分配 | 5-10x |
| **bytes** | 緩衝管理 | 零拷貝 |

---

## 最佳實踐

### 1. 選擇合適的庫

```rust
// 哈希表選擇
// - 單線程: std::HashMap 或 ahash::AHashMap
// - 多線程: dashmap::DashMap
// - 無鎖讀多寫少: evmap

// 序列化選擇
// - 人類可讀: serde_json
// - 高性能: bincode
// - 跨語言: protobuf (prost)
```

### 2. 基準測試驗證

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_hashmap(c: &mut Criterion) {
    let mut group = c.benchmark_group("hashmap");
    
    group.bench_function("std", |b| {
        let mut map = std::collections::HashMap::new();
        b.iter(|| {
            map.insert(black_box(42), black_box("value"));
        });
    });
    
    group.bench_function("ahash", |b| {
        let mut map = ahash::AHashMap::new();
        b.iter(|| {
            map.insert(black_box(42), black_box("value"));
        });
    });
    
    group.finish();
}

criterion_group!(benches, benchmark_hashmap);
criterion_main!(benches);
```

### 3. 性能分析

```bash
# 使用 cargo-flamegraph 生成火焰圖
cargo install flamegraph
cargo flamegraph --bin my_program

# 使用 perf 分析
perf record --call-graph dwarf ./my_program
perf report
```

---

## 參考資料 (References)

1. [Awesome Rust](https://github.com/rust-unofficial/awesome-rust) - Rust 庫精選
2. [crates.io](https://crates.io/) - Rust 包倉庫
3. [lib.rs](https://lib.rs/) - Rust 庫搜索引擎
4. [Are We Web Yet?](https://www.arewewebyet.org/) - Rust Web 生態
5. [Blessed.rs](https://blessed.rs/) - 官方推薦的 Rust 庫

# è²æ˜å¼å®æ·±åº¦è§£æ

> åŸºæ–¼ Rust 1.90+ (2025) | macro_rules! å®Œå…¨æŒ‡å—

## ğŸ“‹ æ¦‚è¿°

è²æ˜å¼å® (`macro_rules!`) æ˜¯ Rust æœ€å¸¸ç”¨çš„å®ç³»çµ±,é€šéæ¨¡å¼åŒ¹é…åœ¨ç·¨è­¯æœŸç”Ÿæˆä»£ç¢¼ã€‚æœ¬ç« æ·±å…¥æ¢è¨è²æ˜å¼å®çš„åŸç†ã€æŠ€å·§å’Œæœ€ä½³å¯¦è¸ã€‚

---

## ğŸ¯ å®çš„æœ¬è³ª

### å® vs å‡½æ•¸

```rust
// å‡½æ•¸: é‹è¡Œæ™‚åŸ·è¡Œ
fn add_function(a: i32, b: i32) -> i32 {
    a + b
}

// å®: ç·¨è­¯æœŸå±•é–‹
macro_rules! add_macro {
    ($a:expr, $b:expr) => {
        $a + $b
    };
}

fn main() {
    let x = add_function(2, 3);  // é‹è¡Œæ™‚èª¿ç”¨
    let y = add_macro!(2, 3);    // ç·¨è­¯æœŸå±•é–‹ç‚º 2 + 3
}
```

**å®çš„å„ªå‹¢**:
1. **ç·¨è­¯æœŸåŸ·è¡Œ**: é›¶é‹è¡Œæ™‚é–‹éŠ·
2. **å¯è®Šåƒæ•¸**: å¯æ¥å—ä»»æ„æ•¸é‡åƒæ•¸
3. **é¡å‹éˆæ´»**: å¯è™•ç†å¤šç¨®é¡å‹
4. **ç”Ÿæˆé‡è¤‡ä»£ç¢¼**: æ¸›å°‘æ¨£æ¿ä»£ç¢¼

---

## ğŸ”§ åŸºç¤èªæ³•

### æœ€ç°¡å–®çš„å®

```rust
macro_rules! say_hello {
    () => {
        println!("Hello, world!");
    };
}

fn main() {
    say_hello!();
    // å±•é–‹ç‚º:
    // println!("Hello, world!");
}
```

### å¸¶åƒæ•¸çš„å®

```rust
macro_rules! greet {
    ($name:expr) => {
        println!("Hello, {}!", $name);
    };
}

fn main() {
    greet!("Alice");  // Hello, Alice!
    greet!("Bob");    // Hello, Bob!
}
```

---

## ğŸ“ æŒ‡ç¤ºç¬¦ (Designators)

### å®Œæ•´æŒ‡ç¤ºç¬¦åˆ—è¡¨

```rust
macro_rules! test_designators {
    // ident - è­˜åˆ¥ç¬¦
    (ident $i:ident) => {
        let $i = 42;
    };
    
    // expr - è¡¨é”å¼
    (expr $e:expr) => {
        println!("{}", $e);
    };
    
    // ty - é¡å‹
    (ty $t:ty) => {
        let _: $t = Default::default();
    };
    
    // pat - æ¨¡å¼
    (pat $p:pat) => {
        let $p = 10;
    };
    
    // stmt - èªå¥
    (stmt $s:stmt) => {
        $s
    };
    
    // block - ä»£ç¢¼å¡Š
    (block $b:block) => {
        $b
    };
    
    // item - é …ç›®
    (item $i:item) => {
        $i
    };
    
    // literal - å­—é¢é‡
    (literal $l:literal) => {
        println!("{}", $l);
    };
    
    // path - è·¯å¾‘
    (path $p:path) => {
        use $p;
    };
    
    // tt - Token Tree
    (tt $t:tt) => {
        // åŒ¹é…ä»»ä½•å–®å€‹ token
    };
}

fn main() {
    test_designators!(ident x);
    test_designators!(expr 1 + 2);
    test_designators!(ty i32);
    test_designators!(literal "hello");
}
```

### æŒ‡ç¤ºç¬¦é¸æ“‡æŒ‡å—

| ç”¨é€” | ä½¿ç”¨æŒ‡ç¤ºç¬¦ | ç¯„ä¾‹ |
|------|-----------|------|
| è®Šé‡å | `ident` | `x`, `my_var` |
| è¨ˆç®—å¼ | `expr` | `1 + 2`, `foo()` |
| é¡å‹æ¨™è¨» | `ty` | `Vec<i32>`, `&str` |
| æ¨¡å¼åŒ¹é… | `pat` | `Some(x)`, `(a, b)` |
| ä»»æ„èªæ³• | `tt` | ä»»ä½• token |

---

## ğŸ” é‡è¤‡æ¨¡å¼

### åŸºæœ¬é‡è¤‡

```rust
macro_rules! create_array {
    ($($x:expr),*) => {
        {
            let array = [$($x),*];
            array
        }
    };
}

fn main() {
    let arr = create_array![1, 2, 3, 4, 5];
    println!("{:?}", arr);  // [1, 2, 3, 4, 5]
}
```

### é‡è¤‡èªæ³•

```rust
macro_rules! repeat_examples {
    // * - é›¶æ¬¡æˆ–å¤šæ¬¡
    (zero_or_more $($x:expr),*) => {
        vec![$($x),*]
    };
    
    // + - ä¸€æ¬¡æˆ–å¤šæ¬¡
    (one_or_more $($x:expr),+) => {
        vec![$($x),+]
    };
    
    // ? - é›¶æ¬¡æˆ–ä¸€æ¬¡
    (optional $($x:expr)?) => {
        {
            let mut v = Vec::new();
            $(v.push($x);)?
            v
        }
    };
}

fn main() {
    let v1 = repeat_examples!(zero_or_more);           // vec![]
    let v2 = repeat_examples!(zero_or_more 1, 2, 3);   // vec![1, 2, 3]
    let v3 = repeat_examples!(one_or_more 1);          // vec![1]
    let v4 = repeat_examples!(optional);               // vec![]
    let v5 = repeat_examples!(optional 42);            // vec![42]
}
```

### å¯é¸å°¾éš¨é€—è™Ÿ

```rust
macro_rules! vec_with_trailing {
    ($($x:expr),* $(,)?) => {
        vec![$($x),*]
    };
}

fn main() {
    let v1 = vec_with_trailing![1, 2, 3];   // OK
    let v2 = vec_with_trailing![1, 2, 3,];  // OK (å°¾éš¨é€—è™Ÿ)
}
```

---

## ğŸ¨ å¤šæ¨¡å¼åŒ¹é…

### åŸºæœ¬å¤šæ¨¡å¼

```rust
macro_rules! calculate {
    // åŠ æ³•
    (add $a:expr, $b:expr) => {
        $a + $b
    };
    
    // æ¸›æ³•
    (sub $a:expr, $b:expr) => {
        $a - $b
    };
    
    // ä¹˜æ³•
    (mul $a:expr, $b:expr) => {
        $a * $b
    };
    
    // é™¤æ³•
    (div $a:expr, $b:expr) => {
        $a / $b
    };
}

fn main() {
    assert_eq!(calculate!(add 10, 5), 15);
    assert_eq!(calculate!(sub 10, 5), 5);
    assert_eq!(calculate!(mul 10, 5), 50);
    assert_eq!(calculate!(div 10, 5), 2);
}
```

### éè¿´å®

```rust
macro_rules! sum {
    // åŸºç¤æƒ…æ³: å–®å€‹å…ƒç´ 
    ($x:expr) => {
        $x
    };
    
    // éè¿´æƒ…æ³: å¤šå€‹å…ƒç´ 
    ($x:expr, $($rest:expr),+) => {
        $x + sum!($($rest),+)
    };
}

fn main() {
    let result = sum!(1, 2, 3, 4, 5);
    println!("{}", result);  // 15
}
```

---

## ğŸš€ å¯¦æˆ°ç¯„ä¾‹

### ç¯„ä¾‹ 1: HashMap åˆå§‹åŒ–å®

```rust
macro_rules! hashmap {
    // ç©ºçš„ HashMap
    () => {
        std::collections::HashMap::new()
    };
    
    // å¸¶åˆå§‹å€¼
    ($($key:expr => $value:expr),* $(,)?) => {
        {
            let mut map = std::collections::HashMap::new();
            $(
                map.insert($key, $value);
            )*
            map
        }
    };
}

fn main() {
    let empty = hashmap!();
    
    let scores = hashmap! {
        "Alice" => 100,
        "Bob" => 85,
        "Charlie" => 92,
    };
    
    println!("{:?}", scores);
}
```

### ç¯„ä¾‹ 2: ç°¡åŒ–éŒ¯èª¤è™•ç†

```rust
macro_rules! try_or_return {
    ($expr:expr, $err:expr) => {
        match $expr {
            Ok(val) => val,
            Err(_) => return Err($err),
        }
    };
}

fn process_data(input: &str) -> Result<i32, String> {
    let trimmed = try_or_return!(
        Ok(input.trim()),
        "trim failed".to_string()
    );
    
    let number = try_or_return!(
        trimmed.parse::<i32>(),
        "parse failed".to_string()
    );
    
    Ok(number * 2)
}

fn main() {
    println!("{:?}", process_data("  42  "));  // Ok(84)
    println!("{:?}", process_data("abc"));     // Err("parse failed")
}
```

### ç¯„ä¾‹ 3: æšèˆ‰å­—ç¬¦ä¸²è½‰æ›

```rust
macro_rules! enum_str {
    (
        $(#[$meta:meta])*
        $vis:vis enum $name:ident {
            $($(#[$variant_meta:meta])* $variant:ident),* $(,)?
        }
    ) => {
        $(#[$meta])*
        $vis enum $name {
            $($(#[$variant_meta])* $variant),*
        }
        
        impl $name {
            pub fn as_str(&self) -> &'static str {
                match self {
                    $(Self::$variant => stringify!($variant)),*
                }
            }
            
            pub fn from_str(s: &str) -> Option<Self> {
                match s {
                    $(stringify!($variant) => Some(Self::$variant),)*
                    _ => None,
                }
            }
        }
    };
}

enum_str! {
    #[derive(Debug, Clone, Copy, PartialEq)]
    pub enum Color {
        Red,
        Green,
        Blue,
    }
}

fn main() {
    let color = Color::Red;
    assert_eq!(color.as_str(), "Red");
    
    let parsed = Color::from_str("Blue");
    assert_eq!(parsed, Some(Color::Blue));
}
```

### ç¯„ä¾‹ 4: æ¸¬è©¦ç”Ÿæˆå™¨

```rust
macro_rules! test_cases {
    (
        fn $test_name:ident($param:ident: $param_ty:ty) -> $ret:ty {
            $($input:expr => $expected:expr),* $(,)?
        }
    ) => {
        $(
            #[test]
            fn $test_name() {
                let $param: $param_ty = $input;
                let result: $ret = $test_name($param);
                assert_eq!(result, $expected);
            }
        )*
    };
}

fn double(x: i32) -> i32 {
    x * 2
}

// ç”Ÿæˆå¤šå€‹æ¸¬è©¦
test_cases! {
    fn double(x: i32) -> i32 {
        0 => 0,
        1 => 2,
        5 => 10,
        -3 => -6,
    }
}
```

---

## ğŸ” å®è¡›ç”Ÿ (Macro Hygiene)

### ä»€éº¼æ˜¯å®è¡›ç”Ÿ?

å®è¡›ç”Ÿç¢ºä¿å®å±•é–‹æ™‚ä¸æœƒæ„å¤–æ•ç²æˆ–è¦†è“‹è®Šé‡ã€‚

```rust
macro_rules! using_a {
    ($e:expr) => {
        {
            let a = 42;  // å®å…§éƒ¨çš„ a
            $e
        }
    };
}

fn main() {
    let a = 10;  // å¤–éƒ¨çš„ a
    
    // å®å…§çš„ a ä¸æœƒå½±éŸ¿å¤–éƒ¨çš„ a
    let result = using_a!(a + 1);
    println!("{}", result);  // 11 (ä½¿ç”¨å¤–éƒ¨çš„ a)
}
```

### æ•…æ„æ‰“ç ´è¡›ç”Ÿ

```rust
macro_rules! declare_and_use {
    ($name:ident, $val:expr) => {
        let $name = $val;
        println!("{}", $name);
    };
}

fn main() {
    declare_and_use!(x, 42);
    // x åœ¨é€™è£¡å¯ç”¨,å› ç‚º $name è¢«æ›¿æ›ç‚ºç”¨æˆ¶æä¾›çš„æ¨™è­˜ç¬¦
    println!("{}", x);  // 42
}
```

---

## ğŸ¯ é€²éšæŠ€å·§

### æŠ€å·§ 1: TT Muncher (Token Tree æ¶ˆè²»å™¨)

```rust
macro_rules! tt_muncher {
    // åŸºç¤æƒ…æ³
    () => {
        0
    };
    
    // æ¶ˆè²»ä¸€å€‹ token
    ($tt:tt $($rest:tt)*) => {
        1 + tt_muncher!($($rest)*)
    };
}

fn main() {
    let count = tt_muncher!(a b c d e);
    println!("Token count: {}", count);  // 5
}
```

### æŠ€å·§ 2: å…§éƒ¨è¦å‰‡

```rust
macro_rules! with_internal {
    // å…¬é–‹å…¥å£
    ($($x:expr),*) => {
        with_internal!(@internal $($x),*)
    };
    
    // å…§éƒ¨è¦å‰‡ (ä»¥ @ é–‹é ­)
    (@internal $($x:expr),*) => {
        vec![$($x),*]
    };
}

fn main() {
    let v = with_internal!(1, 2, 3);
    
    // ç„¡æ³•ç›´æ¥èª¿ç”¨å…§éƒ¨è¦å‰‡
    // let v = with_internal!(@internal 1, 2, 3);  // éŒ¯èª¤!
}
```

### æŠ€å·§ 3: å¢é‡ TT Muncher

```rust
macro_rules! parse_pairs {
    // ç´¯åŠ å™¨æ¨¡å¼
    (@acc [$($acc:tt)*]) => {
        vec![$($acc)*]
    };
    
    (@acc [$($acc:tt)*] $k:ident => $v:expr, $($rest:tt)*) => {
        parse_pairs!(@acc [$($acc)* ($k, $v),] $($rest)*)
    };
    
    (@acc [$($acc:tt)*] $k:ident => $v:expr) => {
        parse_pairs!(@acc [$($acc)* ($k, $v)])
    };
    
    // å…¥å£
    ($($tt:tt)*) => {
        parse_pairs!(@acc [] $($tt)*)
    };
}

fn main() {
    let pairs = parse_pairs! {
        name => "Alice",
        age => 30,
        city => "NYC"
    };
    
    println!("{:?}", pairs);
}
```

---

## ğŸ“Š å®Œæ•´ç¯„ä¾‹: DSL (é ˜åŸŸç‰¹å®šèªè¨€)

```rust
macro_rules! sql {
    // SELECT æŸ¥è©¢
    (SELECT $($field:ident),+ FROM $table:ident WHERE $cond:expr) => {
        {
            let fields = vec![$(stringify!($field)),+];
            let table = stringify!($table);
            let condition = stringify!($cond);
            
            format!(
                "SELECT {} FROM {} WHERE {}",
                fields.join(", "),
                table,
                condition
            )
        }
    };
    
    // INSERT èªå¥
    (INSERT INTO $table:ident ($($field:ident),+) VALUES ($($value:expr),+)) => {
        {
            let table = stringify!($table);
            let fields = vec![$(stringify!($field)),+];
            let values = vec![$(format!("{:?}", $value)),+];
            
            format!(
                "INSERT INTO {} ({}) VALUES ({})",
                table,
                fields.join(", "),
                values.join(", ")
            )
        }
    };
}

fn main() {
    let query1 = sql!(SELECT id, name, age FROM users WHERE age > 18);
    println!("{}", query1);
    // SELECT id, name, age FROM users WHERE age > 18
    
    let query2 = sql!(INSERT INTO users (name, age) VALUES ("Alice", 30));
    println!("{}", query2);
    // INSERT INTO users (name, age) VALUES ("Alice", 30)
}
```

---

## ğŸ”§ é™¤éŒ¯å®

### ä½¿ç”¨ cargo-expand

```bash
# å®‰è£
$ cargo install cargo-expand

# å±•é–‹å®
$ cargo expand

# å±•é–‹ç‰¹å®šæ¨¡çµ„
$ cargo expand module_name

# å±•é–‹ç‰¹å®šå‡½æ•¸
$ cargo expand function_name
```

### trace_macros (Nightly)

```rust
#![feature(trace_macros)]

macro_rules! my_macro {
    ($x:expr) => { $x + 1 };
}

fn main() {
    trace_macros!(true);
    let x = my_macro!(5);
    trace_macros!(false);
    
    println!("{}", x);
}

// è¼¸å‡ºå®å±•é–‹éç¨‹
```

### log_syntax (Nightly)

```rust
#![feature(log_syntax)]

macro_rules! debug_macro {
    ($($x:tt)*) => {
        log_syntax!($($x)*);
    };
}
```

---

## ğŸ“ æœ€ä½³å¯¦è¸

### 1. ä½¿ç”¨æ˜ç¢ºçš„æ¨¡å¼

```rust
// âŒ ä¸å¥½: éæ–¼å¯¬æ³›
macro_rules! bad {
    ($($x:tt)*) => { /* ... */ };
}

// âœ… å¥½: æ˜ç¢ºçš„æ¨¡å¼
macro_rules! good {
    ($name:ident, $value:expr) => { /* ... */ };
}
```

### 2. æä¾›å¤šå€‹å…¥å£é»

```rust
macro_rules! vec_from {
    // å–®å€‹å€¼
    ($val:expr) => {
        vec![$val]
    };
    
    // é‡è¤‡å€¼
    ($val:expr; $count:expr) => {
        vec![$val; $count]
    };
    
    // å¤šå€‹å€¼
    ($($val:expr),+ $(,)?) => {
        vec![$($val),+]
    };
}
```

### 3. æ–‡æª”åŒ–å®

```rust
/// å‰µå»ºä¸€å€‹åŒ…å«æŒ‡å®šå…ƒç´ çš„å‘é‡
///
/// # ç¯„ä¾‹
///
/// ```
/// let v = my_vec![1, 2, 3];
/// assert_eq!(v, vec![1, 2, 3]);
/// ```
#[macro_export]
macro_rules! my_vec {
    ($($x:expr),* $(,)?) => {
        vec![$($x),*]
    };
}
```

### 4. ä½¿ç”¨ #[macro_export]

```rust
// åœ¨ lib.rs ä¸­
#[macro_export]
macro_rules! public_macro {
    () => { /* ... */ };
}

// åœ¨å…¶ä»– crate ä¸­å¯ä»¥ä½¿ç”¨
// use my_crate::public_macro;
```

---

## ğŸ” å¸¸è¦‹é™·é˜±

### é™·é˜± 1: å¤šæ¬¡æ±‚å€¼

```rust
// âŒ å±éšª: åƒæ•¸å¯èƒ½è¢«æ±‚å€¼å¤šæ¬¡
macro_rules! bad_max {
    ($a:expr, $b:expr) => {
        if $a > $b { $a } else { $b }
    };
}

fn expensive() -> i32 {
    println!("Called!");
    42
}

fn main() {
    // expensive() è¢«èª¿ç”¨å…©æ¬¡!
    bad_max!(expensive(), 10);
}

// âœ… è§£æ±º: ä½¿ç”¨è‡¨æ™‚è®Šé‡
macro_rules! good_max {
    ($a:expr, $b:expr) => {
        {
            let a = $a;
            let b = $b;
            if a > b { a } else { b }
        }
    };
}
```

### é™·é˜± 2: é¡å‹æ¨æ–·å•é¡Œ

```rust
macro_rules! make_vec {
    () => { Vec::new() };  // é¡å‹ä¸æ˜ç¢º
}

fn main() {
    let v = make_vec!();
    // v.push(1);  // éŒ¯èª¤: ç„¡æ³•æ¨æ–·é¡å‹
    
    // éœ€è¦æ˜ç¢ºæŒ‡å®šé¡å‹
    let v: Vec<i32> = make_vec!();
    v.push(1);  // OK
}
```

---

## ğŸ“– åƒè€ƒè³‡æ–™

1. [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
2. [Rust Reference - Macros](https://doc.rust-lang.org/reference/macros.html)
3. [Rust By Example - Macros](https://doc.rust-lang.org/rust-by-example/macros.html)
4. [cargo-expand](https://github.com/dtolnay/cargo-expand)

---

*æœ€å¾Œæ›´æ–°: 2025-01-17*  
*Rust ç‰ˆæœ¬: 1.90+*

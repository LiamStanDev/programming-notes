# éç¨‹å®åŸºç¤

> åŸºæ–¼ Rust 1.90+ (2025) | Procedural Macros å…¥é–€

## ğŸ“‹ æ¦‚è¿°

éç¨‹å® (Procedural Macros) æ˜¯ Rust ä¸­æ›´å¼·å¤§çš„å®ç³»çµ±,å¯ä»¥ç›´æ¥æ“ä½œ Token Stream,å¯¦ç¾æ›´è¤‡é›œçš„ä»£ç¢¼ç”Ÿæˆã€‚èˆ‡è²æ˜å¼å®ä¸åŒ,éç¨‹å®æ˜¯çœŸæ­£çš„ Rust å‡½æ•¸ã€‚

---

## ğŸ¯ éç¨‹å®é¡å‹

### ä¸‰ç¨®éç¨‹å®

```mermaid
graph TD
    A["éç¨‹å®<br/>(Procedural Macros)"] --> B["Derive Macros<br/>æ´¾ç”Ÿå®"]
    A --> C["Attribute Macros<br/>å±¬æ€§å®"]
    A --> D["Function-like Macros<br/>å‡½æ•¸å¼å®"]
    
    B --> B1["#[derive(MyTrait)]<br/>è‡ªå‹•å¯¦ç¾ trait"]
    C --> C1["#[my_attr]<br/>ä¿®æ”¹é …ç›®"]
    D --> D1["my_macro!(...)<br/>é¡ä¼¼è²æ˜å¼å®"]
    
    style B fill:#51cf66
    style C fill:#4dabf7
    style D fill:#ffd93d
```

---

## ğŸš€ å‰µå»ºéç¨‹å® Crate

### é …ç›®çµæ§‹

```
my-macros/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â””â”€â”€ lib.rs
â””â”€â”€ tests/
    â””â”€â”€ test.rs
```

### Cargo.toml é…ç½®

```toml
[package]
name = "my-macros"
version = "0.1.0"
edition = "2021"

[lib]
proc-macro = true  # å¿…é ˆè¨­ç½®ç‚º true

[dependencies]
syn = { version = "2.0", features = ["full"] }
quote = "1.0"
proc-macro2 = "1.0"
```

**ä¾è³´èªªæ˜**:
- `syn`: è§£æ Rust èªæ³•
- `quote`: ç”Ÿæˆ Rust ä»£ç¢¼
- `proc-macro2`: proc-macro çš„å¯æ¸¬è©¦ç‰ˆæœ¬

---

## ğŸ“ Derive Macros (æ´¾ç”Ÿå®)

### åŸºæœ¬çµæ§‹

```rust
// src/lib.rs
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

#[proc_macro_derive(HelloMacro)]
pub fn hello_macro_derive(input: TokenStream) -> TokenStream {
    // è§£æè¼¸å…¥çš„ TokenStream
    let input = parse_macro_input!(input as DeriveInput);
    
    // ç²å–çµæ§‹é«”åç¨±
    let name = input.ident;
    
    // ç”Ÿæˆå¯¦ç¾ä»£ç¢¼
    let expanded = quote! {
        impl HelloMacro for #name {
            fn hello_macro() {
                println!("Hello, Macro! My name is {}!", stringify!(#name));
            }
        }
    };
    
    // è¿”å›ç”Ÿæˆçš„ä»£ç¢¼
    TokenStream::from(expanded)
}
```

### ä½¿ç”¨æ´¾ç”Ÿå®

```rust
// åœ¨å…¶ä»– crate ä¸­
use my_macros::HelloMacro;

trait HelloMacro {
    fn hello_macro();
}

#[derive(HelloMacro)]
struct Pancakes;

fn main() {
    Pancakes::hello_macro();
    // è¼¸å‡º: Hello, Macro! My name is Pancakes!
}
```

---

## ğŸ¨ å¯¦æˆ°ç¯„ä¾‹: Builder æ¨¡å¼

### å¯¦ç¾ Builder å®

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, Data, Fields};

#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    let builder_name = quote::format_ident!("{}Builder", name);
    
    // æå–å­—æ®µ
    let fields = match input.data {
        Data::Struct(data) => match data.fields {
            Fields::Named(fields) => fields.named,
            _ => panic!("Builder only works with named fields"),
        },
        _ => panic!("Builder only works with structs"),
    };
    
    // ç”Ÿæˆ Builder çµæ§‹é«”çš„å­—æ®µ
    let builder_fields = fields.iter().map(|f| {
        let name = &f.ident;
        let ty = &f.ty;
        quote! {
            #name: Option<#ty>
        }
    });
    
    // ç”Ÿæˆ setter æ–¹æ³•
    let setters = fields.iter().map(|f| {
        let name = &f.ident;
        let ty = &f.ty;
        quote! {
            pub fn #name(mut self, #name: #ty) -> Self {
                self.#name = Some(#name);
                self
            }
        }
    });
    
    // ç”Ÿæˆ build æ–¹æ³•
    let build_fields = fields.iter().map(|f| {
        let name = &f.ident;
        quote! {
            #name: self.#name.clone()
                .ok_or(concat!("Field ", stringify!(#name), " is not set"))?
        }
    });
    
    let field_names = fields.iter().map(|f| &f.ident);
    
    // ç”Ÿæˆå®Œæ•´ä»£ç¢¼
    let expanded = quote! {
        pub struct #builder_name {
            #(#builder_fields,)*
        }
        
        impl #builder_name {
            #(#setters)*
            
            pub fn build(self) -> Result<#name, String> {
                Ok(#name {
                    #(#build_fields,)*
                })
            }
        }
        
        impl #name {
            pub fn builder() -> #builder_name {
                #builder_name {
                    #(#field_names: None,)*
                }
            }
        }
    };
    
    TokenStream::from(expanded)
}
```

### ä½¿ç”¨ Builder

```rust
use my_macros::Builder;

#[derive(Builder, Debug)]
struct User {
    name: String,
    age: u32,
    email: String,
}

fn main() {
    let user = User::builder()
        .name("Alice".to_string())
        .age(30)
        .email("alice@example.com".to_string())
        .build()
        .unwrap();
    
    println!("{:?}", user);
}
```

---

## ğŸ¯ Attribute Macros (å±¬æ€§å®)

### åŸºæœ¬çµæ§‹

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn};

#[proc_macro_attribute]
pub fn log_function(_attr: TokenStream, item: TokenStream) -> TokenStream {
    let input = parse_macro_input!(item as ItemFn);
    let name = &input.sig.ident;
    let block = &input.block;
    let sig = &input.sig;
    let vis = &input.vis;
    
    let expanded = quote! {
        #vis #sig {
            println!("Entering function: {}", stringify!(#name));
            let result = #block;
            println!("Exiting function: {}", stringify!(#name));
            result
        }
    };
    
    TokenStream::from(expanded)
}
```

### ä½¿ç”¨å±¬æ€§å®

```rust
use my_macros::log_function;

#[log_function]
fn calculate(a: i32, b: i32) -> i32 {
    a + b
}

fn main() {
    let result = calculate(2, 3);
    // è¼¸å‡º:
    // Entering function: calculate
    // Exiting function: calculate
    
    println!("Result: {}", result);
}
```

### å¸¶åƒæ•¸çš„å±¬æ€§å®

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, ItemFn, LitStr};

#[proc_macro_attribute]
pub fn log_with_prefix(attr: TokenStream, item: TokenStream) -> TokenStream {
    let prefix = parse_macro_input!(attr as LitStr);
    let input = parse_macro_input!(item as ItemFn);
    let name = &input.sig.ident;
    let block = &input.block;
    let sig = &input.sig;
    
    let expanded = quote! {
        #sig {
            println!("{}: Entering {}", #prefix, stringify!(#name));
            let result = #block;
            println!("{}: Exiting {}", #prefix, stringify!(#name));
            result
        }
    };
    
    TokenStream::from(expanded)
}

// ä½¿ç”¨
#[log_with_prefix("DEBUG")]
fn my_function() {
    println!("Function body");
}
```

---

## ğŸ”§ Function-like Macros (å‡½æ•¸å¼å®)

### åŸºæœ¬çµæ§‹

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, LitStr};

#[proc_macro]
pub fn make_greeting(input: TokenStream) -> TokenStream {
    let name = parse_macro_input!(input as LitStr);
    
    let expanded = quote! {
        format!("Hello, {}! Welcome to Rust macros!", #name)
    };
    
    TokenStream::from(expanded)
}
```

### ä½¿ç”¨å‡½æ•¸å¼å®

```rust
use my_macros::make_greeting;

fn main() {
    let greeting = make_greeting!("Alice");
    println!("{}", greeting);
    // Hello, Alice! Welcome to Rust macros!
}
```

### è¤‡é›œçš„å‡½æ•¸å¼å®

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse::{Parse, ParseStream}, Token, Ident, LitStr};

// è‡ªå®šç¾©è§£æçµæ§‹
struct SqlQuery {
    table: Ident,
    _arrow: Token![=>],
    fields: Vec<Ident>,
}

impl Parse for SqlQuery {
    fn parse(input: ParseStream) -> syn::Result<Self> {
        let table = input.parse()?;
        let _arrow = input.parse()?;
        
        let mut fields = Vec::new();
        while !input.is_empty() {
            fields.push(input.parse()?);
            if input.peek(Token![,]) {
                input.parse::<Token![,]>()?;
            }
        }
        
        Ok(SqlQuery { table, _arrow, fields })
    }
}

#[proc_macro]
pub fn sql_select(input: TokenStream) -> TokenStream {
    let SqlQuery { table, fields, .. } = parse_macro_input!(input as SqlQuery);
    
    let field_names: Vec<_> = fields.iter()
        .map(|f| f.to_string())
        .collect();
    
    let field_list = field_names.join(", ");
    let table_name = table.to_string();
    
    let expanded = quote! {
        format!("SELECT {} FROM {}", #field_list, #table_name)
    };
    
    TokenStream::from(expanded)
}

// ä½¿ç”¨
let query = sql_select!(users => id, name, email);
println!("{}", query);
// SELECT id, name, email FROM users
```

---

## ğŸ“Š å®Œæ•´ç¯„ä¾‹: åºåˆ—åŒ–å®

```rust
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput, Data, Fields};

#[proc_macro_derive(Serialize)]
pub fn derive_serialize(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let name = &input.ident;
    
    let fields = match input.data {
        Data::Struct(data) => match data.fields {
            Fields::Named(fields) => fields.named,
            _ => panic!("Serialize only works with named fields"),
        },
        _ => panic!("Serialize only works with structs"),
    };
    
    // ç”Ÿæˆåºåˆ—åŒ–ä»£ç¢¼
    let serialize_fields = fields.iter().map(|f| {
        let field_name = &f.ident;
        let field_str = field_name.as_ref().unwrap().to_string();
        quote! {
            result.push_str(&format!(r#""{}": {},"#, #field_str, self.#field_name));
        }
    });
    
    let expanded = quote! {
        impl #name {
            pub fn to_json(&self) -> String {
                let mut result = String::from("{");
                #(#serialize_fields)*
                result.pop(); // ç§»é™¤æœ€å¾Œçš„é€—è™Ÿ
                result.push('}');
                result
            }
        }
    };
    
    TokenStream::from(expanded)
}

// ä½¿ç”¨
#[derive(Serialize)]
struct Person {
    name: String,
    age: u32,
}

fn main() {
    let person = Person {
        name: "Alice".to_string(),
        age: 30,
    };
    
    println!("{}", person.to_json());
    // {"name": Alice,"age": 30}
}
```

---

## ğŸ” syn åº«ä½¿ç”¨æŠ€å·§

### è§£æå¸¸è¦‹é¡å‹

```rust
use syn::{
    parse_macro_input,
    DeriveInput,    // ç”¨æ–¼ derive macros
    ItemFn,         // å‡½æ•¸
    ItemStruct,     // çµæ§‹é«”
    Expr,           // è¡¨é”å¼
    Type,           // é¡å‹
    Ident,          // è­˜åˆ¥ç¬¦
};

#[proc_macro]
pub fn parse_examples(input: TokenStream) -> TokenStream {
    // è§£æç‚ºè¡¨é”å¼
    let expr = parse_macro_input!(input as Expr);
    
    // è§£æç‚ºé¡å‹
    let ty = parse_macro_input!(input as Type);
    
    // è§£æç‚ºè­˜åˆ¥ç¬¦
    let ident = parse_macro_input!(input as Ident);
    
    // ...
}
```

### è¨ªå•çµæ§‹é«”å­—æ®µ

```rust
use syn::{Data, Fields};

#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    
    match input.data {
        Data::Struct(data) => {
            match data.fields {
                Fields::Named(fields) => {
                    // è™•ç†å‘½åå­—æ®µ
                    for field in fields.named.iter() {
                        let name = &field.ident;
                        let ty = &field.ty;
                        println!("Field: {:?}, Type: {:?}", name, ty);
                    }
                }
                Fields::Unnamed(fields) => {
                    // è™•ç†å…ƒçµ„å­—æ®µ
                    for (i, field) in fields.unnamed.iter().enumerate() {
                        println!("Field {}: {:?}", i, field.ty);
                    }
                }
                Fields::Unit => {
                    // å–®å…ƒçµæ§‹é«”
                }
            }
        }
        Data::Enum(_) => { /* è™•ç†æšèˆ‰ */ }
        Data::Union(_) => { /* è™•ç†è¯åˆé«” */ }
    }
    
    TokenStream::new()
}
```

---

## ğŸ¯ quote åº«ä½¿ç”¨æŠ€å·§

### åŸºæœ¬ç”¨æ³•

```rust
use quote::quote;

let name = "Alice";
let age = 30;

let tokens = quote! {
    struct Person {
        name: &'static str,
        age: u32,
    }
    
    let person = Person {
        name: #name,
        age: #age,
    };
};
```

### é‡è¤‡å±•é–‹

```rust
let names = vec!["Alice", "Bob", "Charlie"];

let tokens = quote! {
    let people = vec![
        #(#names),*
    ];
};
// å±•é–‹ç‚º: vec!["Alice", "Bob", "Charlie"]
```

### æ¢ä»¶ç”Ÿæˆ

```rust
let should_derive_debug = true;

let tokens = quote! {
    #(
        #[cfg(feature = "debug")]
        #[derive(Debug)]
    )?
    struct MyStruct;
};
```

---

## ğŸ”§ æ¸¬è©¦éç¨‹å®

### æ¸¬è©¦çµæ§‹

```rust
// tests/test.rs
use my_macros::Builder;

#[test]
fn test_builder() {
    #[derive(Builder)]
    struct TestStruct {
        field1: String,
        field2: i32,
    }
    
    let instance = TestStruct::builder()
        .field1("test".to_string())
        .field2(42)
        .build()
        .unwrap();
    
    assert_eq!(instance.field1, "test");
    assert_eq!(instance.field2, 42);
}
```

### ä½¿ç”¨ trybuild æ¸¬è©¦ç·¨è­¯éŒ¯èª¤

```toml
[dev-dependencies]
trybuild = "1.0"
```

```rust
#[test]
fn ui() {
    let t = trybuild::TestCases::new();
    t.pass("tests/pass/*.rs");
    t.compile_fail("tests/fail/*.rs");
}
```

---

## ğŸ“ æœ€ä½³å¯¦è¸

### 1. æä¾›æ¸…æ™°çš„éŒ¯èª¤ä¿¡æ¯

```rust
use syn::Error;

#[proc_macro_derive(MyMacro)]
pub fn my_macro(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    
    match input.data {
        Data::Struct(_) => { /* OK */ }
        _ => {
            let error = Error::new(
                input.ident.span(),
                "MyMacro can only be used with structs"
            );
            return error.to_compile_error().into();
        }
    }
    
    // ...
}
```

### 2. ä½¿ç”¨ span æä¾›æº–ç¢ºçš„éŒ¯èª¤ä½ç½®

```rust
use proc_macro2::Span;

let error = Error::new(
    field.span(),  // æŒ‡å‘ç‰¹å®šå­—æ®µ
    "This field must be a String"
);
```

### 3. æ–‡æª”åŒ–å®

```rust
/// A derive macro that implements the Builder pattern.
///
/// # Example
///
/// ```
/// use my_macros::Builder;
///
/// #[derive(Builder)]
/// struct User {
///     name: String,
///     age: u32,
/// }
///
/// let user = User::builder()
///     .name("Alice".to_string())
///     .age(30)
///     .build()
///     .unwrap();
/// ```
#[proc_macro_derive(Builder)]
pub fn derive_builder(input: TokenStream) -> TokenStream {
    // ...
}
```

---

## ğŸ“– åƒè€ƒè³‡æ–™

1. [The Rust Programming Language - Macros](https://doc.rust-lang.org/book/ch19-06-macros.html)
2. [syn Documentation](https://docs.rs/syn/)
3. [quote Documentation](https://docs.rs/quote/)
4. [proc-macro2 Documentation](https://docs.rs/proc-macro2/)
5. [Procedural Macros Workshop](https://github.com/dtolnay/proc-macro-workshop)

---

*æœ€å¾Œæ›´æ–°: 2025-01-17*  
*Rust ç‰ˆæœ¬: 1.90+*

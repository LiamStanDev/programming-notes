### Cooked Mode vs. Raw Mode
我們的終端默認是以 canonical mode (or cooked mode) 接收鍵盤的輸入，在這個模式下需要按下 Enter 才會傳輸到應用程式中

* crossbeam 提供方法可以讓應用程序進入 raw mode，會直接接收使用者的輸入
```rust
use crossterm::terminal::{disable_raw_mode, enable_raw_mode};
use std::io::{self, Read, Write};

fn main() {
    enable_raw_mode().unwrap(); // 進入 raw mode
    for b in io::stdin().bytes() {
        let c = b.unwrap() as char;
        print!("{}", c);
        io::stdout().flush().unwrap();

        if c == 'q' {
            disable_raw_mode().unwrap(); // 結束 raw mode
            break;
        }
    }
}
```


### Cargo.lock 的作用
* `cargo update`: 會自動將依賴更新至不包含 breaking change 的最新版。
* `cargo build --lock`: 會以 cargo.lock 進行構建，用於依賴更新完之後發生錯誤，可以回退使用 cargo.lock 進行構建。

### 打字機原理
古早的打字機會將紙張放在一個滾筒(drum)上來控制上下，滾筒放在滑架(carriage)上來控制左右，當按下按鍵，文字打印到紙上，滑架向左滑動，一直持續到紙張到最右邊，此時會發出聲響提醒你該拉把手將滾筒向上滾動，同時要將滑架向右滑動至最底，進行下一行的輸入。機算機設計時以這種方式設計的，故換行時有兩個關鍵的動作:
1. 拉把手將滾輪向上滾動: `\n` (return)
2. 將滑架向右滑動至最底: `\r` (cariage return)

### 使用 clippy 寫出更規範的代碼
```shell
cargo clippy -- -W clippy::all -W clippy::pedantic  -W clippy::nursery -W clippy::cargo -W clippy::restriction
```
* `all`: 包含正確性、可疑性、style、複雜度與性能等進行檢查
* `pedantic` (迂腐的): 對代碼風格和最佳實踐要求非常嚴格
* `nursery`: 用尚未穩定的規則進行檢查
* `cargo`: 對 cargo 配置正確性進行檢查
* `restriction`: 嚴格檢查
> 建議 all, pedantic 一定要開

### 好的錯誤處理
1. Handle locally: 若能夠在發生錯誤時解決，那就在當下解決
2. Pass upwards: 若發生錯誤無法直接修復，向上拋
3. Top-level handling: 錯誤拋到頂層時，要思考如何優雅的處理。


# Reference
---
課程鏈結: [hecto: Build Your Own Text Editor in Rust | philipp's blog](https://www.flenker.blog/hecto/)

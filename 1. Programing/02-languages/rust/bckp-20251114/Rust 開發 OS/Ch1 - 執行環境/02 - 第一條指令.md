# 計算機組成
---
* 電腦主要由處理器（Processor，也就是CPU），實體記憶體和 I/O 外設三個部分組成。
* CPU 唯一能夠直接存取的只有實體記憶體中的數據。
* 可以將實體記憶體看成一個大數組，而實體位址對應到元素的下標。該下標通常不以 0 開頭，而通常以一個常數，例如 0x80000000 開頭。 

#### 端序 (Endianness)
表示如何讀取多字節數據的數據。
* big-endian:  低位放在低地址，高位放在高地址
* little-endian: 低位放在高地址，高位放在低地址

#### 內存地址對齊
CPU 一般會要求存取記憶體資料的首地址的值為 4 或 8 的整數倍。
* 基本數據對齊:
	數據在記憶體中的偏移地址必須為一個字 (word)的整數倍
* 結構體數據對齊:
	上一個數據域結束和下一個數據域開始的地方填充一些無用的字節，以保證每個資料域（假定是基本數據）都能夠對齊（即按基本數據對齊）

# 內存佈局與編譯流程
---
#### 內存佈局
![[Pasted image 20240501125538.png]]
可執行文件中至少可以分為兩個部分，代碼與數據 (被 CPU 視作可讀寫的內存空間)，可以再進一步依功能劃分成更小的段 (section): 
* .text: 存放可執行的指令。
* .rodata: 只讀全局已經初始化數據。
* .data: 全局可修改以初始化數據。
* .bss: 全局未初始化數據，我們需要手動清零。
* heap: 存放運行動態分配的數據，由低往高。
* stack: 存放函數調用的上下文與函數的局部變量，由高往低。

#### 編譯流程
1. Compiler: 將每個源文件轉換成匯編語言，產出仍為文本文件。
2. Assembler: 將一個個匯編文件轉換成二進制文件稱為 Object File (目標文件)。
3. Linker: 將所有目標文件鏈接在一起形成完整的可執行文件。

目標文件有自己的內存佈局，透過 Linker 進行重組，並將預留的符號轉為實際的地址。
![[Pasted image 20240501130649.png]]

# 編寫第一條內核指令
---
### 匯編指令
```asm
# src/entry.s

.section .text.entry
.globl _start 

_start:
	li x1, 100
```
* `.globl` 指令可以將 _start 提供給外部做引用

### 在 Rust 中嵌入匯編
```rust
// src/main.rs

#![no_std]
#![no_main]

mod lang_items;

use core::arch::global_asm;
global_asm!(include_str!("entry.asm"));
```
* `global_asm!` 匯將字符串內聯到程序中
* `include_str!` 取得文件的字符串

### 調整內存佈局
因為我們要與 Qemu 對接，所以要求指令的第一個位置位於 `0x80200000`，我們需要手動實現鏈接腳本。
```toml
# .cargo/config.toml

[build]
 target = "riscv64gc-unknown-none-elf"

 [target.riscv64gc-unknown-none-elf]
 rustflags = [
     "-Clink-arg=-Tsrc/linker.ld", 
     "-Cforce-frame-pointers=yes" # 取消編譯器默認優化 frame pointer，方便之後 debug
 ]
```

##### 鏈接腳本
```c
OUTPUT_ARCH(riscv)
ENTRY(_start)
BASE_ADDRESS = 0x80200000; 

SECTIONS
{
    . = BASE_ADDRESS;
    skernel = .;

    stext = .;
    .text : {
        *(.text.entry)
        *(.text .text.*)
    }
    . = ALIGN(4K);
    etext = .;
    
    srodata = .;
    .rodata : {
        *(.rodata .rodata.*)
        *(.srodata .srodata.*)
    }
    . = ALIGN(4K);
    erodata = .;
    
    sdata = .;
    .data : {
        *(.data .data.*)
        *(.sdata .sdata.*)
    }
    . = ALIGN(4K);
    edata = .;
    
    .bss : {
        *(.bss.stack)
        sbss = .;
        *(.bss .bss.*)
        *(.sbss .sbss.*)
    }
    . = ALIGN(4K);
    ebss = .;
    
    ekernel = .;

    /DISCARD/ : {
        *(.eh_frame)
    }
}
```
* 開頭為 `s` 表示 start, 而 `e` 表示 end。
* `.` 表示當前位置
* 語法為 `<ObjectFile>(SectionName)`，都可以使用 wildcard
	e.g. `*(.bss .bss.*)` 表示所有目標文件，中的 `.bss` 與 `.bss.*` 都放在這裡
* `/DISCARD/` 中表示忽略
	* `*(.eh_frame)`: 包含異常處理的 section

> 絕對位置與相對位置
> 若程序中都使用相對位置，那程序就可以加載到內存中任意位置都可以運行，被稱為 (PIE, Position-independent Executable)，但我們的內核程序需要使用絕對位置，才能被 bootloader RustSBI 加載。

### 去掉元數據
![[Pasted image 20240501153949.png]]
我們透過 `rust-objcopy --strip-all output/binary -O binary output/binary.bin`，來生成去掉元數據的可執行文件`.bin`，這樣 `0x80200000` 才會是第一條指令。

### 執行調適
##### 編寫 just 腳本
```c
build: 
	cargo build --release
	rust-objcopy --strip-all output/binary -O binary output/binary.bin

run-debug: build
	qemu-system-riscv64 -machine virt -nographic -bios bootloader/rustsbi-qemu.bin -device loader,file=output/binary,addr=0x80200000 -s -S 

debug: 
	riscv64-unknown-elf-gdb -ex 'file output/binary' -ex 'set arch riscv:rv64' -ex 'target remote localhost:1234'
```

* 其中 qemu 的參數如下
```shell
qemu-system-riscv64 \ 
	-machine virt \ 
	-nographic \ 
	-bios bootloader/rustsbi-qemu.bin \ # 設定 bootloader
	-device loader,file=output/binary,addr=0x80200000 \ # 設定內核並指定加載位置
	-s -S # -s 表示在 1234 端口啟動 GDB 服務，-S 暫停等到 GDB 連接
```
> 退出 qemu
> 按下 `ctrl + a` 釋放後按下 `x` 

* gdb 參數解釋
	* `-ex`: 表示執行


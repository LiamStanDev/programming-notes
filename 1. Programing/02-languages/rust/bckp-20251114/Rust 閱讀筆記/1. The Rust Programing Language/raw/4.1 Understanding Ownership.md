##### Safety is the absence of undinfed behavior
* 比如使用未初始化變量，會導致未知的行為，這個行為無法預期，會使惡意人士藉由該錯誤入侵系統。
##### Ownership as a discipline for memeory safety

##### Variable live in the stack
* 變數是存活在 frames 裡，而 frame 被組織為 stack。![[Pasted image 20240320115442.png]]
* 當表達式讀取一個變量，變量的值會被 copy，如下![[Pasted image 20240320115800.png]]

##### Boxes live in the heap
* 為了避免傳遞變量導致的數據複製 (複製很消耗計算資源)，Rust 採用 pointer 指向 heap 上的數據，所以變量傳遞就能透過指針進行傳遞
	![[Pasted image 20240320121511.png]]
	* 註: **Heap** is separate region of memory where data can **live indefinitely**.
##### Stack vs. Heap
The stack holds data associated with a specific function, while the heap holds data that can outlive a function.
##### Rust Does Not Permit Manual Memory Management
* **Stack frames are automatically managed by Rust**
	* When a function is called, Rust allocates a stack frame for the called function. When the call ends, Rust deallocates the stack frame.
* **Box's owner manages dealloction**
	* **If a variable owns a box** (持有 box 的 ownership 的變量), when Rust deallocates the variable's frame, then Rust deallocates the box's heap memory.
	* a 與 b 變量在離開 stack frame 時都被 drop 掉，這樣會導致 double free 的 undefined behavior，故 `let b = a` 在 Rust 中採用 move 讓 a 失效，將所有權轉移給 b。

##### Collection use boxes
Rust 使用 Boxes 於類型如 `Vec`, `String` 與 `HashMap` 等來持有元素的集合，如下圖所示
![[Pasted image 20240320122720.png]]
###### 註: String 內部結構
![[Pasted image 20240320122753.png | 600]]
* first 為 `String` 類型，`String` 類型中有 field 為 vec，而 vec 為 `Vec` 類型，而 Vec 類型中包含兩個 fields 分別為 buf 與 len，而 buf 裡面包含是 `RawVec` 類型，裡面有  `ptr`  與 `cap`。
* `RawVec` 雖然不是 `Box` 但他也是與 `Box` 一樣擁有 heap 中的所有權，但多了一個 capacity 字段。

##### Variables cannot be used after being moved
與其他底層語言不同 Rust 直接不允許你操作被移動的值，若使用過 C++ 的移動語意就知道，原本的變量中指向的位置會變成 `nullptr`，若操作他會導致 segment fault。

> **Moved heap data principle**
  若變量將 heap data 的所有權移動給另一個變量，則原變量無法再被使用

##### 錯題回顧
![[Pasted image 20240320124404.png | 500]]
這題是會通過編譯的，我一開始認為 s 為 immutable，但是因為所有權已經轉移給 `add_suffix` 的 `mut s` 上，所以原本的 `s` 已經不能使用，**故 `immutable` 是作用在變量本身，而不是作用在數據上**。


##### 總結
**Ownership is primarily a discipline of heap management**.
- All heap data must be owned by exactly one variable.
- Rust deallocates heap data once its owner goes out of scope.
- Ownership can be transferred by moves, which happen on assignments and function calls.
- Heap data can only be accessed through its current owner, not a previous owner.


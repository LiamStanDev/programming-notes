若只使用能使用所有權系統，我們每調用一個函數所有權就會被移出，使我們設計時都要將未來繼續使用的變量作為返回值以便後續再次使用 (quit verbose)，故 Rust provides a concise style of **reading and writing without moves through references**.
##### References Are Non-Owning Pointers
* A reference is a kind of **pointer**.
```rust
fn main() {
		let m1 = String::from("Hello");
		let m2 = String::from("world");
		greet(&m1, &m2); // &m1: means create a reference to m1.
}

fn greet(g1: &String, g2: &String) {
		println!("{} {}!", g1, g2);
}
```
* `&m1`: create the reference to m1.

##### Dereferencing a Pointer Accesses It's Data
![[Pasted image 20240321143007.png|600]]
* calling method implicitly inserts derederences and references
```rust
let x: Box<i32> = Box::new(-1);
let x_abs1 = i32::abs(*x); // explicit dereference
let x_abs2 = x.abs(); // implicity dereference

let r: &Box<i32> = &x;
let r_abs1 = i32::abs(**r); // explicit dereference
let r_abs2 = r.abs(); // implicit dereference

let s = String::from("Hello");
let s_len1 = str::len(&s); // explicit reference
let s_len2 = s.len(); // implicit dereference
```

##### Rust avoiding simultaneous aliasing and mutation
###### 什麼是 alias ?
alias (別名) 表示獲取同一個 data 使用不同的變量。
指針是一個強大而危險的功能，因為它們會導致別名。別名本身是無害的，但結合 mutation 就會導致災難，如下:
1. 釋放 aliased 的 data，讓其他 Pointer 指向已被釋放的內存。
2. 修改 aliased data，導致在運行時其他變量有問題。
3. 在多線程會導致競爭條件。

###### 案例: 使用上述第二點舉例
```rust
let mut v: Vec<i32> = vec![1,2,3]; // len is 3, and capacity is 3
let num: &i32 = &v[2];
v.push(4); // will allocate larger capacity and copy whole array to new location.
println!("Third element is {}", *num);
```
以上程式碼會導致因為 push 後建立一個更大的 array 在 heap，原本的 heap 內存空間被釋放，但是 num 使用指針指向原數組最後一個位置，導致運行時的 undefined behavior。本質原因在於 v 的數據同時被錯作為別名 (`num`)，且又被改變 (`v.push(4)`)。

###### Data should never be aliased and mutated ant the same time
這是 Rust 的 Pointer Safety Principle，表示不允許別名與可變同時存在。
對於 Box 類型 Rust 只允許單一個所有者，來保護指針安全，但是 reference 這個指針並不會獲得所有權，所以需要新的規則也就是 borrow checker。


##### References Change Permissions on Path
###### Path 是什麼 ? 
Path 表示任何可以被放在賦值左側的都稱之，如:
```rust
let a = Box::new(3); // a is path
*r = 33; // *r is path
arr[2] = 5; // arr[5] is path
t.0 = "Hello"; // s.0 is path
s.age = 38; // s.age is path
// 任何上面的結合都是 path
```

###### Permission 有哪些 ?
* Read: 數據可以被複製到別 location，也就是讀出數據但原本 location 上的數據完全不會改變，**取數據本質是 copy 一份出來給你用**。
* Write: in-place 修改數據。
* Own: 數據可以 moved 與 dropped。

###### Permission 是基於 Path
對於數據的能執行的操作並不只看變數，而是看 Path:
* 默認變量是會獲得其變量的 read + Own Permission。
* 而 `let mut` 會額外獲得 Write

###### Reference 可以改變 Permissions
使用 reference 會改變 Path 的 Permission，


##### Mutable References Provide Unique and Non-Owning Access to Data


##### Permissions Are Returned at the End of a Reference's Lifetime
##### Data Must Outlive All of It's References

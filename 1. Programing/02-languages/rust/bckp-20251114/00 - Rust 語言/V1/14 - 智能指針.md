### 簡介
指針是一個地址的變量，該地址指向另外的數據，在 rust 最常用的指針就是引用，他不會帶來任何的性能損耗，功能僅僅是借用。rust 中的各種指針如下:

| 類型           | 含意                                                                                                                             |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------ |
| `&T`         | 可以借用數據，但不允许修改。                                                                                                                 |
| `&mut T`     | 可借用數據，但允許修改。                                                                                                                   |
| `*const T`   | 原始不可變裸指針，不受借用規則限制。                                                                                                             |
| `*mut T`     | 原始可變裸指針，不受借用規則限制。                                                                                                              |
| `Box<T>`     | 標準庫提供的智能指針，在堆上為數據分配空間，擁有該數據的**唯一所有權**，並指向它                                                                                     |
| `Rc<T>`      | 標準庫提供的智能指針，可以多個指針指向相同的變量但不可變，實現多**所有權**，共同管理數據的生命週期，採用引用計數實現。                                                                  |
| `Arc<T>`     | 標準庫提供的智能指針，與 `Rc<T>` 不同，`Arc<T>` 有實現 `Send` 特徵是多線程安全的，為**多線程下安全的多所有權**實現。                                                      |
| `Cell<T>`    | 提供編譯時期內部可變性，改變不可變數值內部的值，但類型需要實現 Copy trai。                                                                                     |
| `RefCell<T>` | 提供運行時期內部可變性，改變不可變數值內部的值，類型沒有限制，但有運行時性能開銷，且在運行時違反借用檢查會導致 panic。準確來說他返回的 `Ref` 與 `RefMut` 是智能指針                                  |
| `Ref<T>`     | 對 `RefCell<T>` 使用 `borrow()` 方法的返回值，為對 `RefCell` 內部數據的不可變引用。                                                                   |
| `RefMut<T>`  | 對 `RefCell<T>` 使用 `borrow_mut()` 方法的返回值，為對 `RefCell` 內部數據的可變引用。                                                                |
| `Mutex<T>`   | 提供互斥鎖，用於多線程中對共享數據的訪問，只保證同時只有一個線程能訪問，提供內部可變性，與 `RefCell` 類似本身不是智能指針 ，但使用 `lock()` 處裡錯誤之後，可得到 `MutexGuard` 為對 `Mutex` 內部數據的可變引用。 |
| `RWLock<T>`  | 提供讀寫鎖，用於多個線程讀取數據，但只允許一個線程寫入數據，提供內部可變性。                                                                                         |


### 內部可變性模式(Interior mutability)
內部可變性讓我們**修改改不可變數值內部的值**，即使 RefCell 本身是不可變的。

> `RefCell` 是使用安全的 API 來包裹 unsafe 的操作才能做到，所以編譯能夠成功，但要注意因為 `RefCell` **返回的是借用**，所以**還是需要遵守借用規則**，但借用檢查不在編譯時執行而是到運行時執行。

```rust
fn main() {
	let x = 5; // 不可變變量
	let y = &mut x; // 可變借用
}
```
我們可以得知你無法對不可變變量生成可變引用，但是可以透過 ReffCell 達成
```rust
fn main() {
    let x = 5; // 不可變變量
    let c = RefCell::new(x); // 使用 RefCell 包裹
    let mut y = c.borrow_mut(); // 取得可變引用
    *y = 10; // 修改值
    println!("y: {}", y); // 返回 y: 10
}
```


### Rc + RefCell 組合
我們知道 Rc 能用於多所有權，但只能獲得不可變的所有權，我們可以透過與 RefCell 配合來生成可變的多所有權。
```rust
fn main() {
    let s = Rc::new(RefCell::new("Hello".to_string()));

    let s1 = Rc::clone(&s); // 所有者 1
    let s2 = Rc::clone(&s); // 所有者 2

    s2.borrow_mut().push_str(", world"); // 取得可變引用

    println!("s1: {:?}", s1.borrow());
}
```
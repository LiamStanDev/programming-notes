### Rust 泛型原理


# 特徵
---
#### 定義與使用
```rust
pub trait Summary {
    fn summarize(&self) -> String;
}

pub struct Post {
    pub title: String,
    pub author: String,
    pub content: String,
}

impl Summary for Post {
    fn summarize(&self) -> String {
        format!("title: {}, author: {}", self.title, self.author)
    }
}

fn main() {
    let post = Post {
        title: "Good travel in Tauyuan.".to_string(),
        author: "Liam".to_string(),
        content: "Goooooood".to_string(),
    };

    println!("{}", post.summarize());
}
```

#### 關聯類型
我們常在 trait 中看到 `type` 關鍵字，他用於定義類型的別名，有助於更快的理解特徵的含意，常用於定義特徵函數 or 方法的返回值類型，以下以 `String` 實作 `Add` trait 案例: 

```rust
// 特徵定義
pub trait Add<Rhs = Self> {
    type Output;

    fn add(self, rhs: Rhs) -> Self::Output;
}

// 使用特徵
impl Add<&str> for String {
    type Output = String; // 指定返回值為 String

    fn add(mut self, other: &str) -> Self::Output { // 使用類型別名
        self.push_str(other);
        self
    }
}
```
> 泛型常用來表達特徵函數/方法的參數，而特徵類型用來表達返回值類型
#### 孤兒原則
表示**實現類型與特徵至少要有一個是在當前的 crate 中**，你可以引入外部的 trait 實現在自己的類型，或者定義 trait 使用在外部的類型。


#### 特徵作為函數參數
有兩種方式:
1. **impl trait**: 用於簡單情況，他為特徵約束的語法糖。
2. **特徵約束(trait bound)**: 基於泛行約束的基礎上，使用 trait 對類型約束。

* 單約束
```rust
// 1. impl trait
pub fn notify(item: &impl Summary) {
    println!("Breaking news! {}", item.summarize());
}

// 2. trait bound
pub fn notify<T>(item: &T) 
	where T: Summary
{
    println!("Breaking news! {}", item.summarize());
}


// 多個參數，相同特徵
// 1. impl trait
pub fn notify(item1: &impl Summary, item2: &impl Summary) {
	// ...
}

// 2. trait bound
pub fn notify(item1: &T, item2: &T) 
	where T: Summary
{
	// ...
}
```

* 多重約束
```rust
// 1. impl trait
pub fn notify(item: &(impl Summary + Display)) {}

// 2. trait bound
fn some_function<T, U>(t: &T, u: &U) -> i32 
	where T: Display + Clone, U: Clone + Debug 
{}
```
# 字符串字面值
---
Rust 的字符串字面值是採用 UTF-8 編碼，為 Unicode 的一種編碼方式，採用變動大小方式，所以不同字符採用可能會有不同大小，如英文為 1 byte，中文為 3 bytes。**字符串字面值是會直接寫入到二進制文件中**，所以其本身是無法修改，在 Rust 中字符串字面值是使用切片的方式來訪問的。

註: `&str` 不是引用而是切片。


# String 類型
---
`String` 也是採用 UTF-8 編碼，除了 `String` 類型外標準庫還有提供 `OsString` 與 `OsStr` (用於不同 OS 自動轉換的編碼)、`CString`, `CsStr` (用於與 C 語言交互，以 null 結尾) 等，String 結尾表示能動態修改 (再堆上分配)，Str 結尾表示字面值 (只能使用切片訪問)。

### 操作
#### String 的切片
切片可以在不獲得所有權的情況下，獲得集合中部份的連續序列，故我們也可以取 String 集合的切片。
```rust
let s = String::from("Hello, Liam");

let slice = &[..]; // 取得全部
let slice = &[1..2]; // 取得部分
```

* 注意上述為切片，以下為 String 的引用
```rust
let ref_str = &s; // 類型為 &String
```

> 切片可用於所有連續集合，雖然都是 `&str` 類型，但字符串字面值是指向二進制文件中，而 String 切片是指向堆上的動態數組。


#### String 與 &str 轉換
###### &str 轉換為 String
```rust
String::from("Hello, Liam"); // 方式一
"hello, world".to_string(); // 方式二

// 當然也可以
let s = String::from("Hello, Liam");
let ref_str = &s[1..2];
let ss = ref_str.to_string();
```

###### String 轉換為 &str
* 簡單方式
```rust
// 1. 直接切片
let s = String::from("Hello, Liam");
let slice = &s[..]; 

// 2. 轉換方法
let slice = s.as_str();
```

* `deref` 隱式強制轉換
```rust
fn main() {
    let s = String::from("Hello, Liam");
    say_hello(&s);
}

fn say_hello(s: &str) {
    println!("{}", s);
}
```
首先函數接收參數為字符串切片 `&str`，我們傳入類型為 `&String`，正常來說是報類型錯誤，但是因為 `String` 實現 `Deref` 特徵，所以在方法或函數中傳入引用 `&String` 會自動解引用直到類型匹配。

> 註: `deref` 強制轉換必須滿足以下條件
> 	1. 該類型實現 `deref` trait
> 	2. 接收者為函數參數或方法參數
> 	3. 實參為引用才會觸發

#### 索引與遍歷
Rust 中的 `String` 類型是無法進行索引的，(雖然 `&str` 可以進行索引，但很不安全)，若要遍歷可以使用如下兩種方式: 
```rust
let s = String::from("Hello, Liam 林大中");

// 採用字符遍歷
for c in s.chars() {
		println!("{}", c);
}

// 採用字節遍歷
for b in s.bytes() {
		println!("{}", b);
}
```

#### 其他重要操作
##### 追加
* `fn push(&mut self, ch: char)`: 追加字符
* `fn push_str(&mut self, string: &str)`: 追加字符串

##### 插入
* `fn insert(&mut self, idx: usize, ch: char)`: 插入字符
* `fn insert_str(&mut self, idx: usize, string: &str)`: 插入字符串
###### 替換
替換有三個方法，前兩個可以用於 `String` 與 `&str`，因為他不會修改原有字串，而是會返回新的 `String`。
* `fn replace<'a, P: Pattern<'a>>(&'a self, from: P, to: &str) -> String`: 替換所有匹配
* `fn replacen<'a, P: Pattern<'a>>(&'a self, pat: P, to: &str, count: usize) -> String `: 替換遇到的 n 個匹配
* `fn replace_range<R>(&mut self, range: R, replace_with: &str)`: 唯獨這個會修改原本字串，但需要指定索引所以若剛好切割到字中間會 panic。
##### 刪除
* `fn pop(&mut self) -> Option<char>`: 刪除最後，返回刪除的字符 Option，因為可能字串為空。
* `fn remove(&mut self, idx: usize) -> char`: 刪除指定索引，同樣切割到字中間會 panic。
* `fn truncate(&mut self, new_len: usize)`: 指定索引後面(含)都刪除，與上面同樣問題。
* `fn clear(&mut self)`: 清空字符串。

##### 連接
###### 1. 使用 `add` trait
* 簽名
```rust
impl Add<&str> for String {
    type Output = String;

    #[inline]
    fn add(mut self, other: &str) -> String { // 是使用 mut self, 所以會 move
        self.push_str(other);
        self
    }
}
```
* 操作
```rust
fn main() {
    let s1 = String::from("Hello");
    let s2 = String::from(", world");

    let s3 = s1 + &s2; // s1 is moved

    println!("{} + {} = {}", s1, s2, s3);  // panic 
}
```
###### 2. 使用 format! 宏
使用 format! 就不用擔心所有權會轉移，他會返回一個新的 `String`。
```rust
fn main() {
    let s1 = String::from("Hello");
    let s2 = String::from(", world");

    let s3 = format!("{} {}!", &s1, &s2);

    println!("{} + {} = {}", s1, s2, s3);
}
```

##### 若真的需要索引來操作 utf-8 字符串
1. 可以將它轉為 `Vec<char>` 後來操作，如下:
```rust
fn main() {
    let s1 = String::from("Hello, 林大中");
    let v: Vec<char> = s1.chars().collect(); // 不會取得 s1 所有權
    
    for i in 0..v.len() {
        if v[i] == '林' {
            continue;
        }
        println!("{}", v[i]);
    }
}
```
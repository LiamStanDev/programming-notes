### 介紹 
Rust 的方法可以將行為綁定在數據上，可以在結構體、枚舉、特徵一起使用。

### 使用
#### 定義方法
```rust
struct Circle {
    x: f64,
    y: f64,
    radius: f64,
}

impl Circle {
		// 關聯函數
    fn new(x: f64, y: f64, radius: f64) -> Circle {
        Circle { x, y, radius }
    }
		// 方法
    fn area(&self) -> f64 {
        std::f64::consts::PI * self.radius.powi(2)
    }
}

fn main() {
    let c1 = Circle::new(22.3, -28.73, 22.3);

    println!("radius: {}", c1.area())
}
```


#### self, &self, &mut self ?!
##### Self 與 self
* Self 為 impl 塊所綁定的**類型**
* self 為 impl 所綁定類型的**實例**

> `&self` 是方法參數中 `self: &Self` 的縮寫

##### 所有權與借用
* self: 會取得所有權，這種形式用的很少
* &self: 取的不可變引用
* &mut self: 取得可變引用

#### 方法的自動引用與解引用
當我們在操作方法時，Rust 會自動的添加 `&`、`&mut` 或者 `*` 來自動飲用或解引用來匹配方法參數。如下
```rust
impl Circle {
    fn distance(&self, other: &Self) -> f64 {
        let dx = (self.x - other.x).abs();
        let dy = (self.y - other.y).abs();

        (dx.powi(2) + dy.powi(2)).sqrt()
    }
}

fn main() {
	p1.distance(&p2); // 正常使用
	(&p1).distance(&p2); // 編譯器做的事情
}
```
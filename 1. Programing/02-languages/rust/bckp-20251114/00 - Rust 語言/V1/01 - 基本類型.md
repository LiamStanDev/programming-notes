# 數值類型
---
### 整數
| 長度    | 有符號類型   | 无符號類型   |
| ----- | ------- | ------- |
| 8 位   | `i8`    | `u8`    |
| 16 位  | `i16`   | `u16`   |
| 32 位  | `i32`   | `u32`   |
| 64 位  | `i64`   | `u64`   |
| 128 位 | `i128`  | `u128`  |
| 視架構而定 | `isize` | `usize` |
整數可以使用不同的表達方式進行書寫，如下

| 數字字面量         | 示例            |
| ------------- | ------------- |
| 十進制           | `98_222`      |
| 十六進制          | `0xff`        |
| 八進制           | `0o77`        |
| 二進制           | `0b1111_0000` |
| 字節 (僅限于 `u8`) | `b'A'`        |

##### Range
Range 可以用於生成連續的整型數值。
```rust
let x: std::ops::Range<i32> = 1..5; // 1~4

for i in -10..=20 {
	println!("i: {}", i);
}
```

### 浮點數
| 長度   | 類型    |
| ---- | ----- |
| 32 位 | `f32` |
| 64 位 | `f64` |

Rust 的浮點數實現 `std::cmp::PartialEq` 特徵，也就是只能進行 `>`, `>=` 等比較，而不是像其他類型一樣實現 `std::cmp::Eq` 特徵，因為浮點數有精度誤差問題，故使用 `==` 比較兩個浮點數是危險且無意義的。
```rust
assert!(0.1 + 0.2 == 0.3); // panic
```
* HashMap 無法使用浮點數作為 Key

##### NaN
數學上未定義的結果在 Rust 中使用 NaN 來表示，所有與 NaN 的操作都會返回 NaN。故浮點數提供了`is_nan()` 方法
```rust
fn main() {
	let x = (-42.0_f32).squr();
	if x.is_nan() {
		println!("Undefined");
	}
}
```

### 基本類型轉換
Rust 中只有相同類型才能進行比較與運算，所以在進行運算之前需要進行轉換可以使用 `as` 操作符來完成。
```rust
fn main() {
	let a: i32 = 10;
	let b: u16 = 100;
	if a < (b as i32) { // 使用 as 
		println!("Ten is less than one hundred.");
	}
}
```

 
# 字符類型
---
Rust 中的字符使用 Unicode 編碼，而不是 ASCII 編碼，故可以容納所有字符，每個字符都占用 4 bytes。
```rust
fn main() {
	let x = '中';
	println!("{} use {} bytes", x, std::mem::size_of_val(&x));
}
```

# 布爾類型
---
只有 true 與 false，占用 1 byte。

# 單元類型
---
單元類型就是 `()`。
# 枚舉
---
### 介紹
枚舉的概念同其他程式與言的概念，但不同的是 Rust 中的枚舉可以協帶數據而不單單只是整型，提高枚舉與數據的內聚性，所以較其他程式與言更強大。

#### 概念推導
##### Stage1: 枚舉沒有協帶數據
```rust
enum PokerSuit {
    Clubs,
    Spades,
    Diamons,
    Hearts,
}

struct PokerCard {
    suit: PokerSuit,
    value: u8,
}

fn main() {
    let c1 = PokerCard {
        suit: PokerSuit::Clubs,
        value: 1,
    };
}
```
* 我們發現 `PokerSuit` 與 `PokerCard` 是具有高內聚性，但我們卻將它們分開了 (ps 其他語言只能這麼做)

##### Stage2: 讓枚舉協帶數據
```rust
enum PokerCard {
    Clubs(u8),
    Spades(u8),
    Diamonds(u8),
    Hearts(u8),
}
fn main() {
    let c1 = PokerCard::Clubs(9);
}
```


### 枚舉的內存結構
枚舉是可以不同列舉都為不同類型，如下所示
```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangColor(i32, i32, i32),
}

fn main() {
    let m1 = Message::Quit;
    let m2 = Message::ChangColor(2, 3, 33);
    let m3 = Message::Move { x: 22, y: -2 };
}
```

那枚舉的內存是怎麼布局呢?
枚舉與 C 中的 Union 一樣採用類似的方式，所有列舉都存放在相同的內存空間，占用空間最大的那個做為該枚舉的內存大小。


# 常用的枚舉 - `Option<T>`
---
Option 是 Rust 用來解決操作空指針問題 (Segment fault)，而提出的解決方案，拋棄 `null` 使用 Option 可以讓編譯器提醒你一它可能沒有值，二是你**一定要顯示處理為空值狀態**。
> `Option`, `None` 與 `Some` 因為太常使用，已經放到 prelude 中，所以不用寫類似 `use Option::Some` 語句了。

##### 簽名
```rust
pub enum Option<T> {
    /// No value.
    None,
    /// Some value of type `T`.
    Some(T),
}
```
* `None`: 表示沒有值
* `Some(T)`: 表示有值，類型為 T。

##### 基本使用
1. 想要操作好 Option 要多查看 [Option 的 API 文檔](https://doc.rust-lang.org/std/option/enum.Option.html)
2. 使用 `match` 或者 `if let` 來處理

```rust
fn main() {
    let five = Some(5);

    let six = plus_one(five);
    let none = plus_one(None);
}

// 方法一: 
fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

// 方法二:
fn plus_one(x: Option<i32>) -> Option<i32> {
    if let Some(i) = x {
        Some(i + 1)
    } else {
        None
    }
}
```

# 常用的枚舉 - `Result<T, E>`
---



# 函數調用與棧
---
函數調用為一種較為複雜的控制流，CPU 原本是按照物理地址序列執行程式，但函數會跳轉到函數開始的地址，又函數完成之會返回執行函數指令的下一條指令，所以在跳轉函數時需要儲存返回要執行的指令位置，通常使用 `ra` (return address) 寄存器，我們使用 `call` 偽指令在跳轉時會將返回地址保存到 `ra` 中，使用 `ret` 偽指令會自動返回到 `ra` 地址。

##### 函數嵌套
嵌套子函數調用時，要確保返回時 `ra` 不會變動，實際上不僅限於 `ra`　寄存器，而是所有通用寄存器，所以控制流轉移前後需要保持不變的寄存器集合稱為**函數調用上下文 (Function Call Context)**。

每個 CPU 只有一套寄存器，要保持函數調用上下文不變，需要使用物理內存，調用函數前要在內存中**保存**寄存器的值; 執行完畢後需要重內存讀取**恢復**寄存器的值。分為:
* Callee-Saved 寄存器: 被調用函數可能覆蓋這些寄存器，由被調用者來保證調用前後上下文不變。
* Caller-Saved 寄存器: 被調用函數可能覆蓋這些寄存器，由調用者保證調用前後上下文不變。

### Calling Convention
RISC-V 的調用規範，

| registers        | 保存者    | 功能                                                        |
| ---------------- | ------ | --------------------------------------------------------- |
| a0~a7            | Caller | 參數傳遞                                                      |
| t0~t6            | Caller | 臨時寄存器，可給 Callee 隨意使用                                      |
| s0~s11           | Callee | 臨時寄存器，Callee 自己保存後才能使用                                    |
| zero (x0)        | None   | 恆為零，對他操作不會有任何結果                                           |
| ra (x1)          | Callee | 保存函數返回地址，Callee 也可能再調用子函數，所以由自己保存，因為 Caller 並不知道你有沒有嵌套調用。 |
| sp (x2)          | Callee | Stack Pointer，指向下一個函數調用棧的起始位置，也就是現在函數所占用的棧頂。              |
| fp (s0)          | Callee | Frame Pointer，表示當前棧底位置，也就是當前函數棧的起始位置。                     |
| gp (x3), tp (x4) | None   | 運行期間都不會變化，不是函數調用上下文，功能後續會提到。                              |
> **記憶麵包**
> s 表示 save，所以當前函數需要先 save 再使用。
> a 表示 argument，傳參數的 Caller 需要自己記得傳入的值呀。
> t 表示 temporary，Callee 隨便使用當然是由 Caller 幫你擦屁股。
> sp, fp，是調用棧空間，只有自己才知道多大，自己管理而且只有當前有用，函數返回就沒用了。
> ra 表示 return address，子函數自己保存結束要返回哪裡。

###### 調用棧與 stack pointer
![[Pasted image 20240502091756.png]]
> **stack frame**
> 這個寄存器，常會被編譯器優化掉，因為我們並不需要紀錄調用棧的起始位置，這個信息是用來在當下區分 Caller 與 Callee 分別使用棧的哪個部分，但在 backtrace 或 debug 時候就會非常有用。

##### 案例
```c
# Prologue
# 分配 64 bytes 的棧
addi sp, sp, -64
# 保存 ra, fp
sd ra, 56(sp)
sd fp, 48(sp)
# 更新 stack frame
addi fp, sp, 64 

# 函數執行
# ...

# Epilogue
# 恢復 ra, fp
ld ra, 56(sp)
ld fp, 48(sp)
addi sp, sp, 64
ret
```

# 分配啟動棧
---
```c
# src/entry.s

	.section .text.entry
	.global _start
_start: 
	la, sp, boot_stack_top
	call rust_main
	
	.section .bss.stack
	.global boot_stack_lower_bound
boot_stack_lower_bound:
	.space 4096 * 16
	
	.global boot_stack_top
boot_stack_top:
```
內存佈局如下，
![[Pasted image 20240502114400.png]]
我們希望做到以下的棧空間操作，
![[Pasted image 20240502112635.png]]
> **棧溢出**
> 目前這樣設計若 rust_main 調用過多的函數，可能會導致 overlap 其他部分，目前只能小心，之後會進行處理。

> **使用 .bss 原因**
> .bss 使用前需要先清零的，但是 stack 不用，我們應該直接使用 .data，但是失敗了，故放在 .bss.stack 中。

##### 轉移控制權給 Rust
我們首先需要將 .bss 清零。
```rust
// src/main.rs

#[no_mangle]
pub rust_main() -> ! {
	clear_bss();
	loop {}
}

fn clear_bss() {
	extern "C" {
		// 這兩個是由鏈接交本定義的全局符號
		static sbss: usize;
		static ebss: usize;
	}

	unsafe {
		(sbss..ebss).for_each(|b| {
			(b as *mut).write_volatile(0); 
		})
	}
}
```
* `write_volatile`: 其中的 volatile 編譯器不會優化，導致執行順序改變。
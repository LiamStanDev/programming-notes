TODO
* 協程與事件循環

# 概念
---
### 異步高併發模式
##### Coroutine
Muti-threading 的方式切換的是 Thread，而異步切換的是 Coroutine，Coroutine 是用戶態的線程，他不由 OS 來進行管理，他能夠進行掛起與恢復，但切換時間均為 nano seconds 級別 (p.s. Thread 切換為 micro seconds)。

##### Event Loop
異步的技術是透過在事件循環上註冊 Coroutine 來管理多任務的切換，註冊的 Coroutine 發生等待會立刻停止後返回，之後事件循環會輪詢 (poll) Coroutine 查看狀態，若 Coroutine 狀態可執行，就會恢復然後執行，[[04 - Multiplexing#使用 select 建立服務端|詳情請見 Mutiplexing]]。
###### 事件循環圖
![[Pasted image 20240318094718.png]]
目前事件循環有三個協程，執行方式如下:
A-1 → ... → A-5 → B-1 → ... → B-3 → C-1 → ... → C-4

##### async 
線程為一個函數，協程也是一個函數，我們**在函數前面標記 `async` 將其標示為一個協程** (這是透過程式語言層面的支持)，受到 `async` 標記的函數代表他能夠擁有掛起與恢復的功能，這個函數變成可以透過輪巡返回狀態的狀態機，當我們將 **async function 註冊到事件循環中就會長出新的箭頭**。

##### await 
目前我們的協程都沒有實現停止與恢復的功能，只能依順序執行完整個協程，我們可以使用 `await` 來等待一件事情，故請掛起這個協程，然後 Event loop 可以跳去下一個 Coroutine 執行，而 `await` 後面的代碼會等到等待的事情結束後在執行。同 async 一樣 await 是編程語言層面的支持。
![[Pasted image 20240318095850.png]]
A-1 → ... → A-3 → B-1 → ... → B-3 → C-1 → ... → C-4 -> (某輪 A3 等待事件發生) → A-3 → ... → A -5 

##### 在沒有 async await 之前是怎麼實現異步? 
使用**回調函數**，我們會向 Event loop 註冊函數，並讓要停止的地方註冊監聽事件，然後在註冊後續任務讓他在監聽事件發生之後在執行，這樣就會發生 Callback haul。

# Rust 異步使用
---
### 什麼是 async/.await?
* 為 Rust 的特殊語法，**在發生阻塞時，讓他放棄當前線程的控制權**，允許在等待操作完成的時候其他代碼能取得進展。

### async 的使用方法
##### async fn
```rust
async foo() -> u8 {5}
```
##### async block
```rust
fn bar() -> impl Future<Output = u8> {
		async {
				let x: u8 = foo().await;
				x + 5;
		}
}
```
##### 重點
* 兩者的返回值都實現了 Future trait。
* async 體與其他 Future 都是惰性的，在運行之前甚麼都不做。
* 運行方式:
	* `.await`
	* 自行編寫運行時: Executor
	* 使用 tokio, async-std 等第三方運行時
* 若 Future 被阻塞，會放棄當前線程的控制權，當可以取得更多進展時，執行器會撿起這個 Future 並會負執行，最終由 .await 完成解析。

#### 案例: 
```rust
use async_std::{
    io::{ReadExt, WriteExt},
    net, task,
};

async fn cheapo_request(host: &str, port: u16, path: &str) -> std::io::Result<String> {
    let mut socket = net::TcpStream::connect((host, port)).await?;

    let request = format!("GET {} HTTP/1.1\r\nHost: {}\r\n\r\n", path, host);
    socket.write_all(request.as_bytes()).await?;

    socket.shutdown(net::Shutdown::Write)?;
    let mut response = String::new();

    socket.read_to_string(&mut response).await?;
    Ok(response)
}
fn main() -> std::io::Result<()> {
    let response = task::block_on(cheapo_request("example.com", 80, "/"))?;

    println!("{}", response);
    Ok(())
}
```
###### 重點
1. `task::block_on` 為執行器
2. `cheapo_request` 為異步函數，裡面有三個異步函數 `connect`、 `write_all` 與 `read_to_string`。
3. `.await` 會等待，直到 Future 變成 ready，`.await` 最終會解析出 Future 的值。
4. `cheap_request` 的返回類型會被編譯器轉換為 Future 類型，裡面包含函數參數、本地變量空間等恢復所需的信息。
	* Futre 具體類型會由編譯器基於函數體與參數自動生成，為匿名類型實現了 `Future<Output = R>`
5. 第一次對 `cheapo_request` 進行 `poll` 時，會從函數頂部開始執行，直到第一個 `.await`，然後 `.await` 表達式對 `connect` 的 Future 進行 `poll`，若沒有完成: 返回 `Pending`，針對 `cheapo_request` 的 poll 也無法繼續直到 `connect` 的 Future 返回 `Ready`W
6. `.await` 可以獲得 Future 的所有權，並對其進行 `poll`，若 Future 返回 Ready，最終值就是 `.await` 表達式的值，此時執行就能夠繼續，否則返回 `Pending` 給調用者。
7. 下一次對 `cheapo_request` 進行 `poll` 時，並不會在函數頂部開始執行，會在 `connect` Future 進行 `poll` 的地方繼續執行，直到整個 `connect` 返回 Ready 時 (因為 `connect` 裡面也可能會嵌套 `.await`)，才會繼續在 `cheapo_request` 的函數體往下進行。
8. `cheapo_request` 會不斷被 `poll`，每次執行就是從一個 `.await` 到下一個 `.await`，而且只有在子 Future 的 `.await` 變成 `Ready` 之後才繼續。
9. `cheapo_request` 的 Future 會追蹤:
	1. 下一次 `poll` 應該恢復的位置
	2. 所需的本地狀態: 變量、參數、臨時變量等



### async 的生命週期
async 函數若使用引用或其他非 `'static` 生命週期的，其產生的 Future 之生命周期為輸入的參數的生命周期，是為了保證 在 `.await` 的同時輸入參數是有效的
```rust
async fn foo(x: &u8) -> u8 { *x }
// 會被解釋成以下
fn foo_expaned<'a>(x: &'a u8) -> impl Future<Output = u8> + 'a {
		async move { *x } // 這個 async move 捕獲的是 x 的引用本身，而不是 x 
}
```

##### 傳遞 Future
當我們在調用 async 函數時我們並未調用 `.await` ，而是相將其作為 Future 進行傳遞，這時會導致生命週期不匹配，如下所示:
```rust
fn bad() -> impl Future<Output = u8> {
		let x = 5;
		// 假設這個 borrow_x 為異步函數。
		// 此時這個異步函數的 Future 的生命週期綁定在局部變量 x
		// 所以我們若返回 borrow_x(&x) 的 Future 會導致未來使用他時
		// 他已經超過生命週期了，也就是 x 已經 drop 了。
		borrow_x(&x); 
}
```
解決方案為使用 async block 將其包裹，因為 async 函數與 block 會保存當前運行環境，所以可以保存 x 到下次使用 Future 的時候，如下所示:
```rust
fn good() -> impl Future<Output = u8> {
		async {
				let x = 5;
				borrow_x(&x).await // 這邊必須使用 .await，因為我們只希望包一層 Future。
		}
}
```

##### async move
async move block 與 closure 都支持 move 語法，可以捕獲外部變量的所有權，與閉包相同所以跳過 skip...

### Pin






# Rust 異步底層
---
### Future 特徵
Future 特徵是 Rust 異步的核心，他表示的是異步函數的返回值，也就是**在未來某個時點可用的值**，我們可以鑑驗他是否已經完成，簡單結構如下:
```rust
trait MyFuture {
		type Output;
		fn poll(&mut self, wake: fn()) -> Poll<Self::Output>
}

enum Poll<T> {
	Ready(T),
	Pending,
}
```
##### 細節
* poll 方法: 會輪詢 Future，取得目前狀態，也就是檢驗 Future 實例
	* Future 完成: 返回 `Poll::Ready(result)`，而 `result` 就是最終結果
	* Future 無法完成: 返回 `Poll::Pending`，並當 Future 準備好時 (發生了一個事件)，調用 `wake()` 回調函數。
> 對於 Future 只能使用 poll 函數敲它，直到吐出一個值。
> 
> 源代碼的對 `poll` 的解釋: 
> Attempt to resolve the future to a final value, registering the current task for wakeup if the value is not yet available.
> poll 可以取得 future 的最終結果，若不行尚未完成會註冊到 wakeup 中。

* wake 回調函數: (運行時會傳入)
	* 調用時: 執行器將再次對 Future 調用 poll，來使其繼續執行。
	* 若沒有 wake 函數，就只能在事件循環中不斷地 poll 該 Future，故效率低。

> wake() 就是 coroutine 的恢復操作。

##### 案例: 實現 Future
實現一個 SocketRead Future，他用來表是 Socket 讀取的結果。
```rust
struct SocketRead<'a> {
    socket: &'a Socket,
}

impl MyFuture for SocketRead<'_> {
    type Output = Vec<u8>;

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
		    // 當 socket 可以讀了
        if self.socket.can_read() {
            Poll::Ready(self.socket.read_but()) // 返回數據
        // socket 還不能讀
        } else {
            self.socket.set_readable_callback(wake); // 讓 wake 監聽 socket 可讀事件
            Poll::Pending
        }
    }
}
```
##### 案例: 併發執行多個 Future
實現一個 Join Future 用來表是併發運行兩個 SocketRead 的運行結果。
```rust
// Join Futre 有兩個 Future
// 註1: 我不在這邊寫 trait boud，因為反正 MyFuture 都要寫所以無所謂。
// 註2: Option 是因為若是 None 就不要 poll 了，不然每次都要 poll。
struct JoinFut<FutureA, FutureB> {
    a: Option<FutureA>,
    b: Option<FutureB>,
}

// 實現 Future trait
impl<FutureA, FutureB> MyFuture for JoinFut<FutureA, FutureB>
where // a, b 必須是 Future
    FutureA: MyFuture<Output = ()>,
    FutureB: MyFuture<Output = ()>,
{
    type Output = ();

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if let Some(a) = &mut self.a { // 表示 a 還沒有完成過
            if let Poll::Ready(()) = a.poll(wake) {
                self.a.take(); // 取出值並將 Option 設定為 None
            }
        }

        if let Some(b) = &mut self.b { // 表示 a 還沒有完成過
            if let Poll::Ready(()) = b.poll(wake) {
                self.b.take(); // 取出值並將 Option 設定為 None
            }
        }

        if self.a.is_none() && self.b.is_none() { // 都完成兩者為 None
            Poll::Ready(()) 
        } else { // 至少有一個沒有完成
            Poll::Pending 
        }
    }
}
```

##### 案例: 串聯多個 Future
```rust
// 我們需要知道 a 是否已經完成，所以使用 Option，但 b 是接續任務所以不用。
struct AndThenFut<FutureA, FutureB> {
    a: Option<FutureA>,
    b: FutureB,
}

impl<FutureA, FutureB> MyFuture for AndThenFut<FutureA, FutureB>
where
    FutureA: MyFuture<Output = ()>,
    FutureB: MyFuture<Output = ()>,
{
    type Output = ();

    fn poll(&mut self, wake: fn()) -> Poll<Self::Output> {
        if let Some(a) = &mut self.a {
            match a.poll(wake) {
                Poll::Ready(()) => self.a.take(),
                Poll::Pending => return Poll::Pending,
            };
        }

        self.b.poll(wake)
    }
}
```

#### 真實的 Future
```rust
trait Future {
		type Output;

		// 源代碼的文檔有很多資訊
		/// Attempt to resolve the future to a final value, registering
    /// the current task for wakeup if the value is not yet available.
    ///
    /// # Return value
    ///
    /// This function returns:
    ///
    /// - [`Poll::Pending`] if the future is not ready yet
    /// - [`Poll::Ready(val)`] with the result `val` of this future if it
    ///   finished successfully.
    ///
    /// Once a future has finished, clients should not `poll` it again.
    ///
    /// When a future is not ready yet, `poll` returns `Poll::Pending` and
    /// stores a clone of the [`Waker`] copied from the current [`Context`].
    /// This [`Waker`] is then woken once the future can make progress.
    /// For example, a future waiting for a socket to become
    /// readable would call `.clone()` on the [`Waker`] and store it.
    /// When a signal arrives elsewhere indicating that the socket is readable,
    /// [`Waker::wake`] is called and the socket future's task is awoken.
    /// Once a task has been woken up, it should attempt to `poll` the future
    /// again, which may or may not produce a final value.
    ///
    /// Note that on multiple calls to `poll`, only the [`Waker`] from the
    /// [`Context`] passed to the most recent call should be scheduled to
    /// receive a wakeup.
    ///
    /// # Runtime characteristics
    ///
    /// Futures alone are *inert*; they must be *actively* `poll`ed to make
    /// progress, meaning that each time the current task is woken up, it should
    /// actively re-`poll` pending futures that it still has an interest in.
    ///
    /// The `poll` function is not called repeatedly in a tight loop -- instead,
    /// it should only be called when the future indicates that it is ready to
    /// make progress (by calling `wake()`). If you're familiar with the
    /// `poll(2)` or `select(2)` syscalls on Unix it's worth noting that futures
    /// typically do *not* suffer the same problems of "all wakeups must poll
    /// all events"; they are more like `epoll(4)`.
    ///
    /// An implementation of `poll` should strive to return quickly, and should
    /// not block. Returning quickly prevents unnecessarily clogging up
    /// threads or event loops. If it is known ahead of time that a call to
    /// `poll` may end up taking awhile, the work should be offloaded to a
    /// thread pool (or something similar) to ensure that `poll` can return
    /// quickly.
    ///
    /// # Panics
    ///
    /// Once a future has completed (returned `Ready` from `poll`), calling its
    /// `poll` method again may panic, block forever, or cause other kinds of
    /// problems; the `Future` trait places no requirements on the effects of
    /// such a call. However, as the `poll` method is not marked `unsafe`,
    /// Rust's usual rules apply: calls must never cause undefined behavior
    /// (memory corruption, incorrect use of `unsafe` functions, or the like),
    /// regardless of the future's state.
    ///
    /// [`Poll::Ready(val)`]: Poll::Ready
    /// [`Waker`]: crate::task::Waker
    /// [`Waker::wake`]: crate::task::Waker::wake
		fn poll(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Self::Output>;
}
```

##### 差異
* `self` 不是 `&mut Self` 而是 `Pin<&mut Self>`
	* 他允許我們創建不可移動的 Future，
* `wake: fn()` 變成 `cx: &mut Context<'_>`
	* wake: 可以通知執行器應該來 Poll 這個 Future 了，但只是函數指針，不能知道調用 wake 是哪個 Future。
	* cx: 改善函數指針的缺陷，傳遞了 Waker 的資訊(上下文資訊)，以方便外部統一喚醒的管理者知道該 poll 哪個 Future。

### 喚醒者 Waker
`Future` 第一次 `poll` 時，基本上是無法完成任務的，所以 Future 需要保證在準備好繼續進行時，可以再次被 `poll`，`Future` 每次被 `poll`，都會執行整個任務的一部分。

##### 任務 Task
Task 是被執行者執行的 `Future` (該 `Future` 裡面可能包含很多接續或者併發的 `Future`)，也就是頂層 Future。

##### Waker 
`Waker` 提供了 `wake()` 方法，他可以被用來告訴執行者，Waker 關聯的任務應該被喚醒，執行者就知道 Waker 所關聯的任務已經準備好繼續執行，`Future` 就該再次被 `poll`。
* `Waker` 實現 `clone()`，可以被複製與儲存。


#### 案例: 定時器
建立一個定時器 Future，這個定時器創建時會啟動一個線程睡眠指定秒數，結束後喚醒 Future，然後 Future 就完成任務。
```rust
struct SharedState {
		completed: bool,
		waker: Option<Waker>, // 當線程完成喚醒 Future
}

struct TimerFutuer {
		// 為 Future 與等待的線程間共享的狀態。
		shared_state: Arc<Mutex<SharedState>>
}

impl TimerFutuer {
		// 創建一個 TimeFuture 任務
		fn new() -> Self {
				let shared_state = Arc::new(Mutex::new(SharedState {
						completed: false,
						waker: None,
				}));

				
		}
}


```


### 執行者 Executer
---
因為 Future 是惰性的，所以建立的 Future 沒有 poll 來驅動，會甚麼都不做，一種驅動方式就是在 async 函數中使用 `.await` 來達成，但這只是把問題推到上一層，則最終我們會有一個頂層的 async 函數返回的 Future，我們需要由執行者來驅動。

> 由執行者來執行最頂層 async 函數的 Future。

##### 流程
1. Future 的執行者會獲取一系列頂層的 Future。
2. 執行者 poll 一個 Future 一次，作為起始驅動，但不一定能執行完成。
3. 當 Future 被調用 `wake()`，表示已經準備好取得進展時，他們就會被放回到一個隊列裡，然後 poll 再次被調用。
4. 一直重複到 Future 完成。

#### 案例: 建構執行者
構建簡單的執行者，可以運行大量的頂層 Future 來併發的完成。


# 多線程基本
---
### 單核心併發
單核心還是可以處裡多任務，這是因為 OS 提供的多線程，讓 CPU 將時間分片依據調度器分配每一個線程，從整體上來看就像是多個任務在一起執行。
#### OS 線程
我們的程序不與 CPU 打交道，OS 會替我們做，我們只與 OS 提供的內核線程打交道，一個線程管理一個任務對列，OS 中的調度器會依照算法來選擇讓 CPU 執行某個線程與某個線程的哪個任務，**透過快速輪換處理不同的任務**。

### 併發模型
1. **1 比 1 模型**: 如 Rust 語言，他會透過 OS 提供的 API 創建線程，能創建最大的線程數量與 OS 能建立的線程數量一致。
2. **M:N**: 透過語言本身建立一個調度器，由調度器分配執行某個協程，所以在單個線程上，也能執行多個任務。


### 線程重要細節
* Rust 使用的是 1:1 模型，為的是最小化運行時，使用的是 OS 的 API 建立線程。
* `thread::spawn()` 可以建立線程，會返回一個 `JoinHandler` 句柄，可以透過句炳的 `join` 讓主線程等待
* 線程因為啟動與結束時間無法確定，所以閉包只能透過 `move` 來捕獲所有權。
* 線程結束的時間不是看父線程，而是看線程自己是否運行結束或者 main 線程結束。

# 線程同步
---
## 消息傳遞
### channel
由標準提供 `std::sync::mpsc`，提供的 `channel` 作為消息傳輸管道，該管道為 multiple producer, single consumer。
```rust
use std::{sync::mpsc, thread, time::Duration};

#[derive(Debug)]
struct Message {
    data: String,
}

fn main() {
    let (sender1, receiver) = mpsc::channel();
    let sender2 = sender1.clone(); 

    thread::spawn(move || {
        let msg = Message {
            data: "Hello main thread.".to_string(),
        };

        sender1.send(msg).unwrap();
    });

    thread::spawn(move || {
        let msg = Message {
            data: "Hello main thread.".to_string(),
        };

        sender2.send(msg).unwrap();
    });
    // 方式1: 直接 recv (阻塞)
		println!("Received: P{:?}", receiver.recv().unwarp());
		
		// 方式2: 使用迭代器
		for msg in receiver.iter() {
        println!("Received: {:#?}", msg);
    }
}
```
> 1. recv 返回錯誤來自於對方已經中斷連接，也就是所有 sender 都被 `drop`。
> 2. send 返回錯誤表示 sender 被 `drop`。

##### 使用 try_recv() 接收
這個方法不會阻塞會立刻返回 `Result<T, TryRecvError>`，當有消息時會返回 `Ok`，沒有消息時返回 `Err`，錯誤來自於沒有消息，或者中斷連接。
##### 消息類型
一個通道只能傳輸一種類型，可以顯示的指定，如下:
```rust
let (tx, rx): (Sender<Fruit>, Receiver<Fruit>) = mpsc::channel();
```

##### 消息緩存
channel 默認是異步通道，也就是說不用管對方是否正在接收就能發送，所以 sender 可以不斷的 send 不會阻塞，這會導致消息沒被消耗積壓在 channel 中導致內存占用過大，可以設定緩存消息數量，達到上限 send 就會阻塞等到緩存中的數量小於設定值。
```rust
let (sender1, receiver) = mpsc::channel(20); // 裡面只能有 20 筆消息
```

###### 同步通道
channel 默認是異步通道，也就是說不用管對方是否正在接收就能發送，所以 sender 可以不斷的 send 不會阻塞，而同步通道需要對方在 recv 下才能 send，故 send 會阻塞等待對方。
```rust
let (sender1, receiver) = mpsc::channel(1); // 裡面只能有 1 筆消息
```


## 共享內存
共享內存是同步的靈魂，其實消息通道也是基於共享內存。與消息傳遞的不同如下:
1. 消息傳遞中，發送者與接收者在不同的空間，所以要將數據拷貝到共享空間再到接收者的空間，產生拷貝成本。
2. 共享內存更簡潔。
3. 共享內存會有更多鎖競爭。

### 互斥鎖 Mutex - 安全的資源訪問
互斥鎖讓多線程同時訪問變成排隊訪問，同一時間只允許一個線程訪問該值，其他線程需要等待訪問的線程釋放鎖。
```rust
fn main() {
    let counter = Arc::new(Mutex::new(0));
    let mut handles = Vec::new();

    for _ in 0..10 {
        let counter = Arc::clone(&counter);

        let handle = std::thread::spawn(move || {
            let mut counter = counter.lock().unwrap();

            *counter += 1;
        });

        handles.push(handle);
    }

    for handle in handles {
        handle.join().unwrap();
    }

    println!("{}", counter.lock().unwrap())
}
```
##### 為什麼 lock() 返回 Result?
因為可能持有鎖的線程 panic 導致鎖永遠不會釋放，這時候就會返回 Err。

##### 為甚麼 counter 不用標記 mut
因為內部可變性，Mutex 與 RefCell 提供內部可變性，我們可以取得他的可變引用 `MutexGuard` (智能指針)，來對內部進行修改，所以不用標記 mut。

##### try_lock() 不阻塞
使用 `lock()` 若不能獲取鎖線程會阻塞等待鎖釋放，而 `try_lock` 會立刻返回，若沒有取得鎖會返回 `Err("WouldBlock")` 變體，可用來阻止死鎖的發生。

### 讀寫鎖 RwLock - 高併發讀的資源訪問
若我們需要高併發的讀取，非常少量的修改，使用 `Mutex` 就會無法滿足需求，使用 `read()` 會返回不可變引用 `RwLockReadGuard` (智能指針)，使用 `write()` 會返回可變引用 `RwLockWriteGuard` (智能指針)。
```rust
fn main() {
    let data = Arc::new(RwLock::new(5));

    for i in 0..50 {
        let data = Arc::clone(&data);
        if i == 10 {
            thread::spawn(move || {
                let mut r = data.write().unwrap(); // 寫
                *r += 1;
            });
        } else {
            thread::spawn(move || {
                let r = data.read().unwrap(); // 讀
                println!("{}: {}", i, *r);
            });
        }
    }
}
```
> 多個讀不會阻塞，而寫存在時新的讀與寫會阻塞。

##### Mutex vs. RwLock
RwLock 的問題:
1. 寫鎖可能會一直獲取不到鎖。
2. RwLock 實現原理遠比 Mutex 複雜，單論性能而言比不上 Mutex。

使用場景:
1. 追求高併發讀取時使用 `RwLock`，但還是需要做 bechmark 確認是否真的比較優，考慮點為:
	*  對讀取數據操作時間非常短，使用 `Mutex` 在性能上可能優於 `RwLock`。 e.g. HashMap 讀取很快應該使用 `Mutex` 而不是 `RwLock`
	*  對讀取數據作長時間操作，使用 RwLock 併發讀取才有優勢。
2. 除此之外一律選擇 `Mutex`。


### 條件變量 Condvar 
與鎖不同條件變量解決的是資源訪問順序問題，Rust 提供條件變量，達成某些條件後使用條件變量 notify 系列方法，可以**通知**使用條件變量的 wait 在等待的線程繼續執行。

##### 案例
主線程作為一些事情之後通知，子線程能繼續做事情。

```rust
fn main() {
		// Mutex 包裹的是條件，Condvar 用來等待條件，他們必須一起用。
    let pair = Arc::new((Mutex::new(false), Condvar::new()));

    let mut handles = Vec::new();

    for i in 1..=10 {
        let pair = Arc::clone(&pair);

        handles.push(thread::spawn(move || {
            let (flag, cvar) = &*pair;
            let mut done = flag.lock().unwrap(); // 注意這邊要取得鎖

            while !*done { // 這邊使用循環是避免假喚醒，但條件沒達成
                println!("Thread: {} Waiting for notification...", i);
                done = cvar.wait(done).unwrap(); // 會等待條通知，並返回條件的值
            }

            println!("Thread: {} Notification received!", i);
            cvar.notify_all();
        }));
    }

    println!("Main thread doing some work...");
    thread::sleep(Duration::from_secs(1));

		// 為何這邊需要獨立一個 block?
		// 因為主線程使用 lock 取得鎖，修改條件完通知後，子線程也得獲得鎖，所以這邊要釋放鎖。
    {
        let (flag, cvar) = &*pair;
        let mut done = flag.lock().unwrap();
        *done = true;
        cvar.notify_all();
    }

    for handle in handles {
        handle.join().unwrap();
    }
}
```


### 信號量 Semaphore - 控制最大併發數
標準庫已經標記 Deprecated 主要原因是因為容易與 OS 提供的 Semaphore 混淆概念，另外使用者非常少所以已經棄用了，取而代之的是 tokio 的 Semaphore，到異步章節再進行說明。

### 原子類型 Atomic
這個先跳過，我想不到哪裡會使用他。

# 線程安全 
---
Send 與 Sync 這兩個特徵為標記特徵，並沒有定義任何行為。

##### Send 特徵
Send 表示該類型可以在線程間**安全傳遞其所有權**。

##### Sync 特徵
Sync 表示該類型可以**使所有引用同步**，使得在線程間安全共享類型。

> 幾乎所有的類型都默認實現了 Send + Sync，這兩個特徵都是可以自動派生的，也就是說複合類型只要內部成員都實現了 Send 或 Sync，該類型就會自動實現 Send 或 Sync。

##### 沒有實現 Send 與 Sync 的類型
1. 裸指針兩者都沒實現，因為其本真沒有任何安全保證。
2. `Cell` 與 `RefCell` 沒有實現 `Sync`。
3. `Rc` 兩者都沒實現

> 手動實現 Send 與 Sync 是不安全的，所以要使用 unsafe 關鍵字

#### 案例
###### Why Rc 不能在線程中使用但 Arc 可以?
```rust
// Rc
impl<T: ?Sized, A: Allocator> !Send for Rc<T, A> {}
impl<T: ?Sized, A: Allocator> !Sync for Rc<T, A> {}
// Arc
unsafe impl<T: ?Sized + Sync + Send, A: Allocator + Send> Send for Arc<T, A> {}
unsafe impl<T: ?Sized + Sync + Send, A: Allocator + Sync> Sync for Arc<T, A> {}
```
> `!` 表示移除默認自動實現

###### RwLock
RwLock 可以在多線程中取得所有權與共享，那肯定實現 `Send` + `Sync`。且他的數據能被併發的讀表示 `T` 需要實現 `Sync` 
```rust
unsafe impl<T: ?Sized + Send> Send for RwLock<T> {}
unsafe impl<T: ?Sized + Send + Sync> Sync for RwLock<T> {}
```

###### Mutex
Mutex 無法同時有多個線程訪問內部數據，所以 `T` 一定沒有實現 `Sync`
```rust
unsafe impl<T: ?Sized + Send> Send for Mutex<T> {}
unsafe impl<T: ?Sized + Send> Sync for Mutex<T> {}
```
* `T` 並沒有實現 `Sync`
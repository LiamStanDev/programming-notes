# 內聯彙編與底層控制 (Inline Assembly & Low-Level Control)

## 核心概念

### 內聯彙編簡介

**內聯彙編 (Inline Assembly)**: 在 Rust 代碼中直接嵌入 CPU 彙編指令，用於：
1. **性能優化**: 使用特定 CPU 指令
2. **硬件訪問**: 訪問特殊寄存器 (如 `CPUID`, `RDTSC`)
3. **底層操作**: 實現操作系統內核、驅動程序
4. **無法通過 Rust 表達的操作**: 原子操作、內存屏障

**語法**: `asm!()` 宏 (穩定版 Rust 1.59+)

```rust
use std::arch::asm;

unsafe {
    asm!(
        "mov {tmp}, {x}",
        "add {tmp}, {y}",
        "mov {x}, {tmp}",
        x = inout(reg) x,  // 輸入輸出操作數
        y = in(reg) y,     // 輸入操作數
        tmp = out(reg) _, // 臨時寄存器
    );
}
```

---

## 基本語法

### 操作數類型

```rust
use std::arch::asm;

unsafe {
    let mut x: u64 = 10;
    let y: u64 = 20;
    
    // in: 輸入操作數 (只讀)
    asm!("add {0}, {1}", in(reg) x, in(reg) y);
    
    // out: 輸出操作數 (只寫)
    let mut result: u64;
    asm!("mov {}, 42", out(reg) result);
    
    // inout: 輸入輸出操作數 (讀寫)
    asm!("shl {0}, 2", inout(reg) x);
    
    // lateout: 延遲輸出 (在所有輸入讀取後才寫入)
    let mut z: u64;
    asm!(
        "add {tmp}, {x}, {y}",
        x = in(reg) x,
        y = in(reg) y,
        tmp = lateout(reg) z,
    );
}
```

### 寄存器約束

```rust
use std::arch::asm;

unsafe {
    let mut a: u64;
    
    // 通用寄存器
    asm!("mov {}, 1", out(reg) a);
    
    // 特定寄存器 (x86_64)
    asm!("mov rax, 1", out("rax") a);
    
    // SIMD 寄存器
    asm!("movq {}, xmm0", out(xmm_reg) a);
    
    // 常量操作數
    asm!("add {}, {}", inout(reg) a, const 42);
}
```

---

## 實戰案例

### 案例 1：RDTSC - 讀取 CPU 時鐘週期

```rust
use std::arch::asm;

/// 讀取 CPU 時間戳計數器 (Time Stamp Counter)
#[inline]
pub fn rdtsc() -> u64 {
    let lo: u32;
    let hi: u32;
    
    unsafe {
        asm!(
            "rdtsc",
            out("eax") lo,
            out("edx") hi,
            options(nomem, nostack, preserves_flags)
        );
    }
    
    ((hi as u64) << 32) | (lo as u64)
}

// 使用範例：測量函數執行時間
fn measure_cycles<F: FnOnce()>(f: F) -> u64 {
    let start = rdtsc();
    f();
    let end = rdtsc();
    end - start
}

// 測試
fn main() {
    let cycles = measure_cycles(|| {
        let mut sum = 0;
        for i in 0..1000 {
            sum += i;
        }
    });
    println!("Took {} cycles", cycles);
}
```

### 案例 2：CPUID - 查詢 CPU 特性

```rust
use std::arch::asm;

/// 執行 CPUID 指令
#[inline]
pub fn cpuid(leaf: u32) -> (u32, u32, u32, u32) {
    let mut eax: u32;
    let mut ebx: u32;
    let mut ecx: u32 = 0;
    let mut edx: u32;
    
    unsafe {
        asm!(
            "cpuid",
            inout("eax") leaf => eax,
            inout("ebx") ebx,
            inout("ecx") ecx,
            inout("edx") edx,
        );
    }
    
    (eax, ebx, ecx, edx)
}

/// 檢查 CPU 是否支持 AVX2
pub fn has_avx2() -> bool {
    let (_, ebx, _, _) = cpuid(7);
    (ebx & (1 << 5)) != 0
}

/// 獲取 CPU 廠商字符串
pub fn cpu_vendor() -> String {
    let (_, ebx, ecx, edx) = cpuid(0);
    
    let mut vendor = [0u8; 12];
    vendor[0..4].copy_from_slice(&ebx.to_le_bytes());
    vendor[4..8].copy_from_slice(&edx.to_le_bytes());
    vendor[8..12].copy_from_slice(&ecx.to_le_bytes());
    
    String::from_utf8_lossy(&vendor).to_string()
}
```

### 案例 3：原子操作 - 實現自旋鎖

```rust
use std::arch::asm;
use std::sync::atomic::{AtomicBool, Ordering};

pub struct SpinLock {
    locked: AtomicBool,
}

impl SpinLock {
    pub const fn new() -> Self {
        Self { locked: AtomicBool::new(false) }
    }
    
    #[inline]
    pub fn lock(&self) {
        while self.locked.swap(true, Ordering::Acquire) {
            // 使用 PAUSE 指令減少功耗和內存總線競爭
            while self.locked.load(Ordering::Relaxed) {
                spin_loop_hint();
            }
        }
    }
    
    #[inline]
    pub fn unlock(&self) {
        self.locked.store(false, Ordering::Release);
    }
}

/// CPU 自旋循環提示 (x86: PAUSE, ARM: YIELD)
#[inline]
fn spin_loop_hint() {
    #[cfg(target_arch = "x86_64")]
    unsafe {
        asm!("pause", options(nomem, nostack, preserves_flags));
    }
    
    #[cfg(target_arch = "aarch64")]
    unsafe {
        asm!("yield", options(nomem, nostack, preserves_flags));
    }
}
```

### 案例 4：內存屏障與緩存控制

```rust
use std::arch::asm;

/// 完整內存屏障 (Memory Fence)
#[inline]
pub fn memory_fence() {
    #[cfg(target_arch = "x86_64")]
    unsafe {
        asm!("mfence", options(nostack, preserves_flags));
    }
    
    #[cfg(target_arch = "aarch64")]
    unsafe {
        asm!("dmb sy", options(nostack, preserves_flags));
    }
}

/// 清空特定緩存行 (Cache Line Flush)
#[inline]
pub fn clflush(addr: *const u8) {
    #[cfg(target_arch = "x86_64")]
    unsafe {
        asm!(
            "clflush [{}]",
            in(reg) addr,
            options(nostack, preserves_flags)
        );
    }
}

/// 預取數據到緩存 (Prefetch)
#[inline]
pub fn prefetch<T>(addr: *const T) {
    #[cfg(target_arch = "x86_64")]
    unsafe {
        asm!(
            "prefetcht0 [{}]",
            in(reg) addr,
            options(nostack, preserves_flags, readonly)
        );
    }
}
```

### 案例 5：快速整數運算

```rust
use std::arch::asm;

/// 計算前導零數量 (Leading Zeros)
#[inline]
pub fn leading_zeros(x: u64) -> u32 {
    if x == 0 {
        return 64;
    }
    
    let result: u64;
    
    #[cfg(target_arch = "x86_64")]
    unsafe {
        asm!(
            "lzcnt {}, {}",
            out(reg) result,
            in(reg) x,
            options(nomem, nostack, pure)
        );
    }
    
    result as u32
}

/// 計算尾隨零數量 (Trailing Zeros)
#[inline]
pub fn trailing_zeros(x: u64) -> u32 {
    if x == 0 {
        return 64;
    }
    
    let result: u64;
    
    #[cfg(target_arch = "x86_64")]
    unsafe {
        asm!(
            "tzcnt {}, {}",
            out(reg) result,
            in(reg) x,
            options(nomem, nostack, pure)
        );
    }
    
    result as u32
}

/// 計算置位比特數量 (Population Count)
#[inline]
pub fn popcnt(x: u64) -> u32 {
    let result: u64;
    
    #[cfg(target_arch = "x86_64")]
    unsafe {
        asm!(
            "popcnt {}, {}",
            out(reg) result,
            in(reg) x,
            options(nomem, nostack, pure)
        );
    }
    
    result as u32
}
```

---

## 選項標記 (Options)

### 常用選項

```rust
use std::arch::asm;

unsafe {
    // pure: 函數無副作用，可被優化掉
    asm!("nop", options(pure));
    
    // nomem: 不訪問內存
    asm!("mov {}, {}", out(reg) _, in(reg) 42, options(nomem));
    
    // nostack: 不訪問棧
    asm!("rdtsc", out("eax") _, out("edx") _, options(nostack));
    
    // preserves_flags: 不修改 CPU 標誌位
    asm!("pause", options(preserves_flags));
    
    // readonly: 只讀內存
    asm!("prefetch [{}]", in(reg) 0x1000usize, options(readonly));
    
    // noreturn: 不返回 (用於 panic/abort)
    asm!("ud2", options(noreturn));
}
```

---

## AT&T vs Intel 語法

### Intel 語法 (默認)

```rust
use std::arch::asm;

unsafe {
    // Intel: dest, src
    asm!("mov rax, rbx");  // rax = rbx
    asm!("add rax, 1");    // rax += 1
}
```

### AT&T 語法

```rust
use std::arch::asm;

unsafe {
    // AT&T: src, dest (加 % 前綴)
    asm!("movq %rbx, %rax", options(att_syntax));  // rax = rbx
    asm!("addq $1, %rax", options(att_syntax));    // rax += 1
}
```

---

## 安全性考慮

### 1. 未定義行為風險

```rust
// ❌ 不好：破壞 Rust 的別名規則
unsafe {
    let mut x = 5;
    asm!("mov dword ptr [{}], 0", in(reg) &x);
    // x 可能不是 0，因為編譯器可能緩存了 x 的值
}

// ✅ 好：使用 volatile 操作
unsafe {
    let mut x = 5;
    let ptr = &mut x as *mut i32;
    asm!(
        "mov dword ptr [{}], 0",
        in(reg) ptr,
        options(nostack)
    );
    std::ptr::write_volatile(ptr, 0);
}
```

### 2. 寄存器破壞

```rust
// ❌ 不好：未聲明破壞的寄存器
unsafe {
    asm!("xor rax, rax");  // 破壞了 rax，但未聲明
}

// ✅ 好：聲明所有使用的寄存器
unsafe {
    asm!("xor rax, rax", out("rax") _);
}
```

### 3. 內存排序

```rust
// ❌ 不好：缺少內存屏障
static mut READY: bool = false;
static mut DATA: i32 = 0;

unsafe {
    DATA = 42;
    READY = true;  // 可能被重排序到 DATA 之前
}

// ✅ 好：使用內存屏障
unsafe {
    std::ptr::write_volatile(&mut DATA, 42);
    std::sync::atomic::fence(std::sync::atomic::Ordering::Release);
    std::ptr::write_volatile(&mut READY, true);
}
```

---

## 性能測試

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn benchmark_assembly(c: &mut Criterion) {
    c.bench_function("rdtsc_asm", |b| {
        b.iter(|| black_box(rdtsc()))
    });
    
    c.bench_function("leading_zeros_asm", |b| {
        b.iter(|| black_box(leading_zeros(black_box(0x1234_5678_9ABC_DEF0))))
    });
    
    c.bench_function("leading_zeros_std", |b| {
        b.iter(|| black_box(0x1234_5678_9ABC_DEF0u64.leading_zeros()))
    });
}

criterion_group!(benches, benchmark_assembly);
criterion_main!(benches);
```

---

## 最佳實踐

### 1. 優先使用標準庫

```rust
// ❌ 避免不必要的內聯彙編
#[inline]
fn swap(a: &mut i32, b: &mut i32) {
    unsafe {
        asm!(
            "mov {tmp}, [{a}]",
            "mov {tmp2}, [{b}]",
            "mov [{a}], {tmp2}",
            "mov [{b}], {tmp}",
            a = in(reg) a,
            b = in(reg) b,
            tmp = out(reg) _,
            tmp2 = out(reg) _,
        );
    }
}

// ✅ 使用標準庫
fn swap(a: &mut i32, b: &mut i32) {
    std::mem::swap(a, b);
}
```

### 2. 使用 Intrinsics 代替彙編

```rust
// ❌ 手寫彙編
unsafe fn bswap32_asm(x: u32) -> u32 {
    let result: u32;
    asm!("bswap {}", inout(reg) x => result);
    result
}

// ✅ 使用 intrinsic
fn bswap32(x: u32) -> u32 {
    x.swap_bytes()  // 編譯為 bswap 指令
}
```

### 3. 文檔與測試

```rust
/// 讀取 CPU 時間戳計數器
///
/// # Safety
/// 此函數是 unsafe 的，因為：
/// - 依賴特定 CPU 架構 (x86/x86_64)
/// - TSC 可能不穩定 (多核系統、變頻 CPU)
///
/// # Example
/// ```
/// let cycles = unsafe { rdtsc() };
/// ```
#[inline]
pub unsafe fn rdtsc() -> u64 {
    // 實現...
    0
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_rdtsc_monotonic() {
        unsafe {
            let t1 = rdtsc();
            let t2 = rdtsc();
            assert!(t2 >= t1, "TSC should be monotonic");
        }
    }
}
```

---

## 跨平台抽象

```rust
/// 原子加法 (跨平台)
#[inline]
pub fn atomic_add(ptr: *mut u64, value: u64) -> u64 {
    #[cfg(target_arch = "x86_64")]
    unsafe {
        let result: u64;
        asm!(
            "lock xadd [{ptr}], {value}",
            ptr = in(reg) ptr,
            value = inout(reg) value => result,
        );
        result
    }
    
    #[cfg(target_arch = "aarch64")]
    unsafe {
        use std::sync::atomic::{AtomicU64, Ordering};
        let atomic = &*(ptr as *const AtomicU64);
        atomic.fetch_add(value, Ordering::SeqCst)
    }
}
```

---

## 參考資料 (References)

1. [Rust Inline Assembly RFC](https://rust-lang.github.io/rfcs/2873-inline-asm.html)
2. [Rust asm! Documentation](https://doc.rust-lang.org/reference/inline-assembly.html)
3. [Intel® 64 and IA-32 Architectures Software Developer Manuals](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)
4. [ARM Architecture Reference Manual](https://developer.arm.com/documentation/)
5. [Agner Fog's Optimization Manuals](https://www.agner.org/optimize/)

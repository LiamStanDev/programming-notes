# 零成本抽象與內聯優化 (Zero-Cost Abstractions & Inlining)

## 核心概念

### 零成本抽象 (Zero-Cost Abstractions)

**定義**: Rust 的抽象在運行時不會引入額外性能開銷，編譯器優化後的代碼等同於手寫的低級代碼。

**核心原則**:
1. **靜態分派 (Static Dispatch)**: 泛型在編譯期單態化 (Monomorphization)
2. **內聯展開 (Inlining)**: 函數調用在編譯期被替換為函數體
3. **消除抽象 (Abstraction Elimination)**: 迭代器等高級抽象被優化為等效的循環

```rust
// 高級抽象寫法
let sum: i32 = (1..=100).filter(|x| x % 2 == 0).sum();

// 編譯後等效於
let mut sum = 0;
for x in 1..=101 {
    if x % 2 == 0 {
        sum += x;
    }
}
```

---

## 內聯優化 (Inlining)

### 內聯屬性

**`#[inline]` 系列屬性**:

```rust
// 建議內聯 (編譯器可忽略)
#[inline]
fn add(a: i32, b: i32) -> i32 {
    a + b
}

// 強制內聯 (除非無法內聯)
#[inline(always)]
fn critical_path(x: u64) -> u64 {
    x.wrapping_mul(0x517cc1b727220a95)
}

// 禁止內聯
#[inline(never)]
fn slow_function() {
    // 用於性能分析時保留調用棧
}
```

**內聯決策因素**:
1. **函數大小**: 小函數更容易被內聯
2. **調用頻率**: 熱路徑函數優先內聯
3. **跨 crate**: 默認不內聯，需 `#[inline]` 或 LTO

### 跨 crate 內聯

```rust
// lib.rs
#[inline]  // 允許其他 crate 內聯此函數
pub fn hash_combine(seed: u64, v: u64) -> u64 {
    seed ^ (v.wrapping_add(0x9e3779b9).wrapping_add(seed << 6).wrapping_add(seed >> 2))
}

// 使用 LTO (Link-Time Optimization) 自動跨 crate 內聯
// Cargo.toml:
// [profile.release]
// lto = "thin"  # 或 "fat" 獲得更激進的優化
```

---

## 單態化與代碼膨脹 (Monomorphization)

### 泛型單態化

**工作原理**: 為每個具體類型生成專門的函數副本

```rust
fn max<T: Ord>(a: T, b: T) -> T {
    if a > b { a } else { b }
}

// 調用
let x = max(1, 2);      // 生成 max::<i32>
let y = max(1.0, 2.0);  // 生成 max::<f64>
```

**代碼膨脹問題**:

```rust
// 不好：每個類型都生成一份代碼
fn process<T: Clone + Debug>(items: Vec<T>) {
    // 100 行處理邏輯...
}

// 好：提取類型無關的部分
fn process_impl(items: &[u8], item_size: usize) {
    // 100 行處理邏輯...
}

fn process<T: Clone + Debug>(items: Vec<T>) {
    let bytes = unsafe {
        std::slice::from_raw_parts(
            items.as_ptr() as *const u8,
            items.len() * std::mem::size_of::<T>()
        )
    };
    process_impl(bytes, std::mem::size_of::<T>());
}
```

### 動態分派替代方案

```rust
use std::fmt::Debug;

// 靜態分派：代碼膨脹
fn log_static<T: Debug>(value: &T) {
    println!("{:?}", value);
}

// 動態分派：單一函數，運行時虛表調用
fn log_dynamic(value: &dyn Debug) {
    println!("{:?}", value);
}

// 性能對比
// 靜態分派：無運行時開銷，但二進制體積大
// 動態分派：虛表間接調用 (~2-5ns 開銷)，二進制體積小
```

---

## 編譯器優化技巧

### 常量折疊與傳播 (Constant Folding)

```rust
// 編譯期計算
const SIZE: usize = 1024 * 1024;  // 直接變為 1048576

fn compute() -> i32 {
    let x = 10;
    let y = 20;
    x * y + 5  // 編譯為 return 205;
}
```

### 死碼消除 (Dead Code Elimination)

```rust
fn process(flag: bool) -> i32 {
    if flag {
        expensive_computation()
    } else {
        0
    }
}

// 調用 process(false) 時，expensive_computation 被完全消除
let result = process(false);
```

### 循環展開 (Loop Unrolling)

```rust
// 原始代碼
for i in 0..4 {
    array[i] *= 2;
}

// 編譯器可能展開為
array[0] *= 2;
array[1] *= 2;
array[2] *= 2;
array[3] *= 2;
```

**手動展開** (適用於固定小循環):

```rust
// 不好
for i in 0..8 {
    hash = hash.rotate_left(5) ^ data[i];
}

// 好：手動展開 + SIMD
hash = hash.rotate_left(5) ^ data[0];
hash = hash.rotate_left(5) ^ data[1];
hash = hash.rotate_left(5) ^ data[2];
hash = hash.rotate_left(5) ^ data[3];
// ...
```

---

## 實戰案例

### 案例 1：高性能哈希函數

```rust
#[inline(always)]
fn hash_bytes(mut hash: u64, bytes: &[u8]) -> u64 {
    // 使用 chunks_exact 避免邊界檢查
    let (chunks, remainder) = bytes.as_chunks::<8>();
    
    for chunk in chunks {
        let v = u64::from_le_bytes(*chunk);
        hash = hash.rotate_left(5).wrapping_add(v);
    }
    
    // 處理剩餘字節
    for &byte in remainder {
        hash = hash.rotate_left(5).wrapping_add(byte as u64);
    }
    
    hash
}
```

### 案例 2：零開銷迭代器鏈

```rust
// 這段代碼編譯後與手寫循環性能相同
fn process_data(data: &[i32]) -> i32 {
    data.iter()
        .filter(|&&x| x > 0)
        .map(|&x| x * 2)
        .sum()
}

// 編譯後等效於
fn process_data_manual(data: &[i32]) -> i32 {
    let mut sum = 0;
    for &x in data {
        if x > 0 {
            sum += x * 2;
        }
    }
    sum
}
```

### 案例 3：避免不必要的分配

```rust
// 不好：多次分配
fn format_message(name: &str, count: usize) -> String {
    let mut msg = String::new();
    msg.push_str("User ");
    msg.push_str(name);
    msg.push_str(" has ");
    msg.push_str(&count.to_string());
    msg.push_str(" items");
    msg
}

// 好：預分配容量
fn format_message_optimized(name: &str, count: usize) -> String {
    let mut msg = String::with_capacity(name.len() + 30);
    use std::fmt::Write;
    write!(msg, "User {} has {} items", name, count).unwrap();
    msg
}
```

---

## 性能驗證

### 使用 cargo-asm 查看生成代碼

```bash
# 安裝工具
cargo install cargo-show-asm

# 查看函數的彙編代碼
cargo asm --release my_crate::my_function

# 查看 LLVM IR
cargo llvm-ir --release my_crate::my_function
```

### Benchmark 對比

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};

fn bench_abstraction(c: &mut Criterion) {
    let data: Vec<i32> = (0..1000).collect();
    
    c.bench_function("iterator chain", |b| {
        b.iter(|| {
            black_box(&data).iter().filter(|&&x| x % 2 == 0).sum::<i32>()
        })
    });
    
    c.bench_function("manual loop", |b| {
        b.iter(|| {
            let mut sum = 0;
            for &x in black_box(&data) {
                if x % 2 == 0 { sum += x; }
            }
            sum
        })
    });
}

criterion_group!(benches, bench_abstraction);
criterion_main!(benches);
```

---

## 最佳實踐

### 1. 內聯策略

```rust
// ✅ 對小型熱路徑函數使用 #[inline]
#[inline]
pub fn is_aligned(ptr: usize, align: usize) -> bool {
    ptr & (align - 1) == 0
}

// ✅ 對跨 crate 調用的公共函數標記 #[inline]
#[inline]
pub fn compute_hash(data: &[u8]) -> u64 { /* ... */ }

// ❌ 避免對大函數使用 #[inline(always)]
#[inline(always)]  // 不好：函數太大
fn large_function() {
    // 200 行代碼...
}
```

### 2. 泛型使用

```rust
// ✅ 對性能關鍵路徑使用泛型
fn sort_optimized<T: Ord>(slice: &mut [T]) {
    // 為每個類型生成優化的排序代碼
}

// ✅ 對非關鍵路徑使用 trait object
fn log_debug(value: &dyn Debug) {
    // 減少代碼膨脹
}
```

### 3. 編譯器提示

```rust
// 使用 likely/unlikely (nightly)
#![feature(core_intrinsics)]

use std::intrinsics::{likely, unlikely};

fn process(value: i32) -> i32 {
    if unsafe { unlikely(value < 0) } {
        panic!("Negative value");
    }
    value * 2
}
```

### 4. Profile-Guided Optimization (PGO)

```toml
# Cargo.toml
[profile.release]
lto = "thin"
codegen-units = 1  # 單個代碼生成單元，更好的優化

# 使用 PGO
# 1. 構建帶插樁的版本
# RUSTFLAGS="-Cprofile-generate=/tmp/pgo-data" cargo build --release
# 2. 運行典型工作負載
# ./target/release/myapp
# 3. 使用收集的數據重新編譯
# RUSTFLAGS="-Cprofile-use=/tmp/pgo-data/merged.profdata" cargo build --release
```

---

## 常見陷阱

### 1. 過度內聯

```rust
// ❌ 不好：強制內聯大函數導致代碼緩存未命中
#[inline(always)]
fn large_complex_function() {
    // 500 行代碼...
}
```

### 2. 忽略泛型代碼膨脹

```rust
// ❌ 不好：為每個類型生成龐大的代碼
fn process_all<T: Clone>(data: Vec<Vec<Vec<T>>>) {
    // 嵌套泛型容器導致指數級代碼膨脹
}
```

### 3. 假設編譯器總是優化

```rust
// 在 debug 模式下，零成本抽象可能有開銷
// 始終在 release 模式下測試性能

// 使用 #[cfg] 提供 debug 優化的版本
#[cfg(debug_assertions)]
fn debug_fast_path() { /* 簡化版本 */ }

#[cfg(not(debug_assertions))]
fn debug_fast_path() { /* 完整優化版本 */ }
```

---

## 參考資料 (References)

1. [The Rust Performance Book](https://nnethercote.github.io/perf-book/)
2. [Rust RFC 1210 - Specialization](https://rust-lang.github.io/rfcs/1210-impl-specialization.html)
3. [LLVM Optimization Documentation](https://llvm.org/docs/Passes.html)
4. [Godbolt Compiler Explorer](https://godbolt.org/) - 查看編譯器生成的彙編代碼
5. 《Systems Performance》 (Brendan Gregg, 2020)

# æ¸¬è©¦è¦†è“‹ç‡èˆ‡å“è³ªåº¦é‡

> åŸºæ–¼ Rust 1.90+ (2025) | é‡åŒ–ä»£ç¢¼å“è³ªèˆ‡æ¸¬è©¦å®Œæ•´æ€§

## ğŸ“‹ æ¦‚è¿°

æ¸¬è©¦è¦†è“‹ç‡æ˜¯è¡¡é‡æ¸¬è©¦å®Œæ•´æ€§çš„é‡è¦æŒ‡æ¨™ã€‚æœ¬ç« ä»‹ç´¹å¦‚ä½•æ¸¬é‡å’Œæå‡ Rust é …ç›®çš„æ¸¬è©¦è¦†è“‹ç‡,ä»¥åŠå…¶ä»–ä»£ç¢¼å“è³ªåº¦é‡å·¥å…·ã€‚

---

## ğŸ¯ ä»€éº¼æ˜¯æ¸¬è©¦è¦†è“‹ç‡?

### è¦†è“‹ç‡é¡å‹

```mermaid
graph TD
    A["æ¸¬è©¦è¦†è“‹ç‡"] --> B["è¡Œè¦†è“‹ç‡<br/>(Line Coverage)"]
    A --> C["åˆ†æ”¯è¦†è“‹ç‡<br/>(Branch Coverage)"]
    A --> D["å‡½æ•¸è¦†è“‹ç‡<br/>(Function Coverage)"]
    A --> E["æ¢ä»¶è¦†è“‹ç‡<br/>(Condition Coverage)"]
    
    B --> B1["åŸ·è¡Œçš„ä»£ç¢¼è¡Œ / ç¸½ä»£ç¢¼è¡Œ"]
    C --> C1["åŸ·è¡Œçš„åˆ†æ”¯ / ç¸½åˆ†æ”¯"]
    D --> D1["èª¿ç”¨çš„å‡½æ•¸ / ç¸½å‡½æ•¸"]
    E --> E1["æ¸¬è©¦çš„æ¢ä»¶çµ„åˆ"]
    
    style B fill:#51cf66
    style C fill:#4dabf7
    style D fill:#ffd93d
    style E fill:#ff6b6b
```

### ç¯„ä¾‹èªªæ˜

```rust
fn classify_number(n: i32) -> &'static str {
    if n > 0 {          // åˆ†æ”¯ 1
        "positive"
    } else if n < 0 {   // åˆ†æ”¯ 2
        "negative"
    } else {            // åˆ†æ”¯ 3
        "zero"
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    // âŒ è¦†è“‹ç‡ 33% (åªæ¸¬è©¦ä¸€å€‹åˆ†æ”¯)
    #[test]
    fn test_positive() {
        assert_eq!(classify_number(5), "positive");
    }
    
    // âœ… è¦†è“‹ç‡ 100% (æ¸¬è©¦æ‰€æœ‰åˆ†æ”¯)
    #[test]
    fn test_all_cases() {
        assert_eq!(classify_number(5), "positive");
        assert_eq!(classify_number(-5), "negative");
        assert_eq!(classify_number(0), "zero");
    }
}
```

---

## ğŸ› ï¸ ä½¿ç”¨ cargo-tarpaulin

### å®‰è£

```bash
$ cargo install cargo-tarpaulin
```

### åŸºæœ¬ä½¿ç”¨

```bash
# é‹è¡Œè¦†è“‹ç‡æ¸¬è©¦
$ cargo tarpaulin

# è¼¸å‡º HTML å ±å‘Š
$ cargo tarpaulin --out Html

# è¼¸å‡º Lcov æ ¼å¼ (å¯ç”¨æ–¼ CI)
$ cargo tarpaulin --out Lcov

# å¿½ç•¥æ¸¬è©¦ä»£ç¢¼
$ cargo tarpaulin --ignore-tests

# è¨­ç½®è¶…æ™‚
$ cargo tarpaulin --timeout 120
```

### è¼¸å‡ºç¯„ä¾‹

```
|| Tested/Total Lines:
|| src/lib.rs: 45/50 (90.00%)
|| src/utils.rs: 30/35 (85.71%)
|| 
|| Total Coverage: 88.24%
```

### é…ç½®æ–‡ä»¶

**tarpaulin.toml**:
```toml
[config]
# æ’é™¤çš„æ–‡ä»¶
exclude_files = [
    "src/generated/*",
    "tests/*"
]

# è¦†è“‹ç‡é–¾å€¼
fail-under = 80.0

# è¼¸å‡ºæ ¼å¼
output-formats = ["Html", "Lcov"]

# å¿½ç•¥ panic ä»£ç¢¼
ignore-panics = true

# è¶…æ™‚è¨­ç½® (ç§’)
timeout = 300
```

---

## ğŸ”§ ä½¿ç”¨ cargo-llvm-cov

### å®‰è£

```bash
$ cargo install cargo-llvm-cov
```

### åŸºæœ¬ä½¿ç”¨

```bash
# é‹è¡Œè¦†è“‹ç‡æ¸¬è©¦
$ cargo llvm-cov

# ç”Ÿæˆ HTML å ±å‘Š
$ cargo llvm-cov --html
$ open target/llvm-cov/html/index.html

# ç”Ÿæˆ JSON å ±å‘Š
$ cargo llvm-cov --json --output-path coverage.json

# åƒ…é¡¯ç¤ºæ‘˜è¦
$ cargo llvm-cov --summary-only

# æ¸¬è©¦ç‰¹å®šåŒ…
$ cargo llvm-cov --package my-package
```

### è¼¸å‡ºç¯„ä¾‹

```
Filename                      Regions    Missed Regions     Cover   Functions  Missed Functions  Executed
----------------------------------------------------------------------------------------------------------
src/lib.rs                         24                 2    91.67%          10                 1    90.00%
src/utils.rs                       15                 3    80.00%           5                 0   100.00%
----------------------------------------------------------------------------------------------------------
TOTAL                              39                 5    87.18%          15                 1    93.33%
```

---

## ğŸ“Š æŒçºŒé›†æˆä¸­çš„è¦†è“‹ç‡

### GitHub Actions é…ç½®

**.github/workflows/coverage.yml**:
```yaml
name: Code Coverage

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  coverage:
    runs-on: ubuntu-latest
    
    steps:
    - uses: actions/checkout@v3
    
    - name: Install Rust
      uses: actions-rs/toolchain@v1
      with:
        toolchain: stable
        override: true
    
    - name: Install tarpaulin
      run: cargo install cargo-tarpaulin
    
    - name: Run coverage
      run: cargo tarpaulin --out Xml --output-dir coverage
    
    - name: Upload to Codecov
      uses: codecov/codecov-action@v3
      with:
        files: ./coverage/cobertura.xml
        fail_ci_if_error: true
```

### ä½¿ç”¨ Codecov

```yaml
# .codecov.yml
coverage:
  status:
    project:
      default:
        target: 80%      # ç›®æ¨™è¦†è“‹ç‡
        threshold: 1%    # å…è¨±çš„ä¸‹é™å¹…åº¦
    patch:
      default:
        target: 85%      # PR çš„ç›®æ¨™è¦†è“‹ç‡

ignore:
  - "tests/**/*"
  - "examples/**/*"
```

### ä½¿ç”¨ Coveralls

```yaml
- name: Upload to Coveralls
  uses: coverallsapp/github-action@master
  with:
    github-token: ${{ secrets.GITHUB_TOKEN }}
    path-to-lcov: ./coverage/lcov.info
```

---

## ğŸ¨ å¯¦æˆ°ç¯„ä¾‹: æå‡è¦†è“‹ç‡

### ç¯„ä¾‹ 1: è­˜åˆ¥æœªæ¸¬è©¦çš„ä»£ç¢¼

```rust
// src/lib.rs
pub fn process_request(request: &str) -> Result<String, String> {
    if request.is_empty() {
        return Err("empty request".to_string());  // åˆ†æ”¯ 1
    }
    
    if request.starts_with("GET") {
        Ok("GET request processed".to_string())   // åˆ†æ”¯ 2
    } else if request.starts_with("POST") {
        Ok("POST request processed".to_string())  // åˆ†æ”¯ 3
    } else {
        Err("unknown method".to_string())          // åˆ†æ”¯ 4
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    // åˆå§‹æ¸¬è©¦ - è¦†è“‹ç‡ 50%
    #[test]
    fn test_get_request() {
        assert!(process_request("GET /").is_ok());
    }
    
    #[test]
    fn test_post_request() {
        assert!(process_request("POST /").is_ok());
    }
    
    // é‹è¡Œ cargo tarpaulin ç™¼ç¾æœªè¦†è“‹çš„åˆ†æ”¯
    
    // æ·»åŠ æ¸¬è©¦æå‡è¦†è“‹ç‡åˆ° 100%
    #[test]
    fn test_empty_request() {
        assert!(process_request("").is_err());
    }
    
    #[test]
    fn test_unknown_method() {
        assert!(process_request("DELETE /").is_err());
    }
}
```

### ç¯„ä¾‹ 2: æ¸¬è©¦éŒ¯èª¤è·¯å¾‘

```rust
use std::fs::File;
use std::io::Read;

pub fn read_config(path: &str) -> Result<String, std::io::Error> {
    let mut file = File::open(path)?;  // å¯èƒ½å¤±æ•—
    let mut content = String::new();
    file.read_to_string(&mut content)?;  // å¯èƒ½å¤±æ•—
    Ok(content)
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::io::Write;
    use tempfile::NamedTempFile;
    
    #[test]
    fn test_read_config_success() {
        let mut temp = NamedTempFile::new().unwrap();
        write!(temp, "test content").unwrap();
        
        let result = read_config(temp.path().to_str().unwrap());
        assert!(result.is_ok());
        assert_eq!(result.unwrap(), "test content");
    }
    
    #[test]
    fn test_read_config_file_not_found() {
        let result = read_config("/nonexistent/path");
        assert!(result.is_err());
        
        // é©—è­‰éŒ¯èª¤é¡å‹
        assert_eq!(result.unwrap_err().kind(), std::io::ErrorKind::NotFound);
    }
    
    #[test]
    fn test_read_config_permission_denied() {
        // åœ¨ Unix ç³»çµ±ä¸Šæ¸¬è©¦æ¬Šé™éŒ¯èª¤
        #[cfg(unix)]
        {
            use std::fs;
            use std::os::unix::fs::PermissionsExt;
            
            let temp = NamedTempFile::new().unwrap();
            let path = temp.path();
            
            // ç§»é™¤è®€å–æ¬Šé™
            let mut perms = fs::metadata(path).unwrap().permissions();
            perms.set_mode(0o000);
            fs::set_permissions(path, perms).unwrap();
            
            let result = read_config(path.to_str().unwrap());
            assert!(result.is_err());
        }
    }
}
```

---

## ğŸ“ˆ è¦†è“‹ç‡å ±å‘Šè§£è®€

### HTML å ±å‘Šçµæ§‹

```
target/coverage/
â”œâ”€â”€ index.html              # ä¸»é é¢
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs.html        # å¸¶é«˜äº®çš„æºä»£ç¢¼
â”‚   â””â”€â”€ utils.rs.html
â””â”€â”€ coverage.json          # è©³ç´°æ•¸æ“š
```

### é¡è‰²æ¨™è¨˜

- ğŸŸ¢ **ç¶ è‰²**: å·²åŸ·è¡Œçš„ä»£ç¢¼
- ğŸ”´ **ç´…è‰²**: æœªåŸ·è¡Œçš„ä»£ç¢¼
- ğŸŸ¡ **é»ƒè‰²**: éƒ¨åˆ†åŸ·è¡Œçš„ä»£ç¢¼ (å¦‚åªæ¸¬è©¦äº† if è€Œæœªæ¸¬è©¦ else)

### ç¯„ä¾‹å ±å‘Š

```html
<!-- æœªè¦†è“‹çš„ä»£ç¢¼æœƒä»¥ç´…è‰²æ¨™è¨˜ -->
<span class="uncovered">if condition {</span>
    <span class="covered">println!("covered");</span>
<span class="uncovered">}</span>
```

---

## ğŸ¯ è¦†è“‹ç‡ç›®æ¨™è¨­ç½®

### ä¸åŒé …ç›®é¡å‹çš„å»ºè­°

| é …ç›®é¡å‹ | å»ºè­°è¦†è“‹ç‡ | èªªæ˜ |
|---------|-----------|------|
| é—œéµç³»çµ± | 90-100% | é‡‘èã€é†«ç™‚ç­‰ |
| ç”Ÿç”¢åº« | 80-90% | ä¾›ä»–äººä½¿ç”¨çš„åº« |
| æ‡‰ç”¨ç¨‹å¼ | 70-80% | ä¸€èˆ¬æ‡‰ç”¨ |
| åŸå‹/å·¥å…· | 50-70% | å¿«é€Ÿè¿­ä»£é …ç›® |

### Cargo.toml é…ç½®

```toml
[package.metadata.tarpaulin]
# æœ€ä½è¦†è“‹ç‡è¦æ±‚
minimum-coverage = 80.0

# æ’é™¤çš„æ–‡ä»¶
exclude-files = [
    "src/generated.rs",
    "build.rs"
]
```

---

## ğŸ” å…¶ä»–å“è³ªåº¦é‡å·¥å…·

### cargo-audit - å®‰å…¨å¯©è¨ˆ

```bash
# å®‰è£
$ cargo install cargo-audit

# æª¢æŸ¥ä¾è³´çš„å®‰å…¨æ¼æ´
$ cargo audit

# è¼¸å‡º JSON
$ cargo audit --json
```

### cargo-outdated - ä¾è³´æ›´æ–°

```bash
# å®‰è£
$ cargo install cargo-outdated

# æª¢æŸ¥éæ™‚çš„ä¾è³´
$ cargo outdated

# æª¢æŸ¥ç‰¹å®šæ·±åº¦
$ cargo outdated --depth 1
```

### cargo-deny - ä¾è³´æ”¿ç­–

**deny.toml**:
```toml
[advisories]
vulnerability = "deny"
unmaintained = "warn"

[licenses]
unlicensed = "deny"
allow = ["MIT", "Apache-2.0", "BSD-3-Clause"]
deny = ["GPL-3.0"]

[bans]
multiple-versions = "warn"
```

```bash
$ cargo install cargo-deny
$ cargo deny check
```

### cargo-geiger - ä¸å®‰å…¨ä»£ç¢¼æª¢æ¸¬

```bash
# å®‰è£
$ cargo install cargo-geiger

# æª¢æ¸¬ä¸å®‰å…¨ä»£ç¢¼
$ cargo geiger

# è¼¸å‡ºç¯„ä¾‹
# Metric output format: x/y
#   x = unsafe code used by the build
#   y = total unsafe code found in the crate
#
# Functions  Expressions  Impls  Traits  Methods  Dependency
# 0/0        0/0          0/0    0/0     0/0      my-crate
# 2/5        8/15         0/1    0/0     1/3      â”œâ”€â”€ dependency-a
# 0/2        0/4          0/0    0/0     0/0      â””â”€â”€ dependency-b
```

---

## ğŸ“Š å®Œæ•´ç¯„ä¾‹: è¦†è“‹ç‡é©…å‹•é–‹ç™¼

### æ­¥é©Ÿ 1: ç·¨å¯«åˆå§‹ä»£ç¢¼

```rust
// src/calculator.rs
pub struct Calculator;

impl Calculator {
    pub fn add(a: i32, b: i32) -> i32 {
        a + b
    }
    
    pub fn subtract(a: i32, b: i32) -> i32 {
        a - b
    }
    
    pub fn multiply(a: i32, b: i32) -> i32 {
        a * b
    }
    
    pub fn divide(a: i32, b: i32) -> Result<i32, String> {
        if b == 0 {
            Err("division by zero".to_string())
        } else {
            Ok(a / b)
        }
    }
    
    pub fn power(base: i32, exp: u32) -> i32 {
        if exp == 0 {
            1
        } else {
            base * Self::power(base, exp - 1)
        }
    }
}
```

### æ­¥é©Ÿ 2: ç·¨å¯«åŸºæœ¬æ¸¬è©¦

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_add() {
        assert_eq!(Calculator::add(2, 3), 5);
    }
    
    #[test]
    fn test_divide() {
        assert_eq!(Calculator::divide(10, 2).unwrap(), 5);
    }
}
```

### æ­¥é©Ÿ 3: é‹è¡Œè¦†è“‹ç‡åˆ†æ

```bash
$ cargo tarpaulin --out Html
```

**çµæœ**:
```
|| src/calculator.rs: 6/12 (50.00%)
|| Total Coverage: 50.00%
```

### æ­¥é©Ÿ 4: æ ¹æ“šå ±å‘Šæ·»åŠ æ¸¬è©¦

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    // åŸæœ‰æ¸¬è©¦...
    
    // æ–°å¢æ¸¬è©¦æå‡è¦†è“‹ç‡
    #[test]
    fn test_subtract() {
        assert_eq!(Calculator::subtract(5, 3), 2);
    }
    
    #[test]
    fn test_multiply() {
        assert_eq!(Calculator::multiply(3, 4), 12);
    }
    
    #[test]
    fn test_divide_by_zero() {
        assert!(Calculator::divide(10, 0).is_err());
    }
    
    #[test]
    fn test_power_zero() {
        assert_eq!(Calculator::power(5, 0), 1);
    }
    
    #[test]
    fn test_power_positive() {
        assert_eq!(Calculator::power(2, 3), 8);
    }
}
```

### æ­¥é©Ÿ 5: å†æ¬¡æª¢æŸ¥

```bash
$ cargo tarpaulin --out Html
```

**çµæœ**:
```
|| src/calculator.rs: 12/12 (100.00%)
|| Total Coverage: 100.00%
```

---

## ğŸ“ æœ€ä½³å¯¦è¸

### 1. ä¸è¦ç›²ç›®è¿½æ±‚ 100%

```rust
// âŒ éåº¦æ¸¬è©¦
#[test]
fn test_getter() {
    let user = User { name: "Alice".to_string() };
    assert_eq!(user.name, "Alice");  // æ²’æœ‰æ„ç¾©çš„æ¸¬è©¦
}

// âœ… æ¸¬è©¦æœ‰åƒ¹å€¼çš„é‚è¼¯
#[test]
fn test_validation() {
    assert!(validate_email("test@example.com"));
    assert!(!validate_email("invalid"));
}
```

### 2. é—œæ³¨æœªæ¸¬è©¦çš„éŒ¯èª¤è·¯å¾‘

```rust
pub fn process(input: &str) -> Result<String, Error> {
    let parsed = parse(input)?;       // éŒ¯èª¤è·¯å¾‘ 1
    let validated = validate(parsed)?;  // éŒ¯èª¤è·¯å¾‘ 2
    let result = transform(validated)?; // éŒ¯èª¤è·¯å¾‘ 3
    Ok(result)
}

// ç¢ºä¿æ¸¬è©¦æ‰€æœ‰éŒ¯èª¤è·¯å¾‘
#[cfg(test)]
mod tests {
    #[test]
    fn test_parse_error() { /* ... */ }
    
    #[test]
    fn test_validation_error() { /* ... */ }
    
    #[test]
    fn test_transform_error() { /* ... */ }
}
```

### 3. ä½¿ç”¨è¦†è“‹ç‡ä½œç‚ºæŒ‡æ¨™è€Œéç›®æ¨™

```rust
// è¦†è“‹ç‡æ˜¯ç™¼ç¾éºæ¼æ¸¬è©¦çš„å·¥å…·
// ä¸æ˜¯ç‚ºäº†é”åˆ°æ•¸å­—è€Œå¯«æ¸¬è©¦

// âŒ ç‚ºè¦†è“‹ç‡è€Œæ¸¬è©¦
#[test]
fn test_unreachable_code() {
    // æ¸¬è©¦æ°¸é ä¸æœƒåŸ·è¡Œçš„ä»£ç¢¼
}

// âœ… ç§»é™¤æ­»ä»£ç¢¼
// å¦‚æœä»£ç¢¼ä¸å¯é”,æ‡‰è©²åˆªé™¤è€Œéæ¸¬è©¦
```

### 4. æ’é™¤ä¸éœ€è¦æ¸¬è©¦çš„ä»£ç¢¼

```rust
// è‡ªå‹•ç”Ÿæˆçš„ä»£ç¢¼
#[cfg(not(tarpaulin_include))]
mod generated {
    // ...
}

// ç°¡å–®çš„ getter/setter
#[derive(Debug)]
pub struct Config {
    pub host: String,  // ç°¡å–®å­—æ®µç„¡éœ€æ¸¬è©¦
}
```

---

## ğŸ”§ æ•…éšœæ’é™¤

### å•é¡Œ 1: è¦†è“‹ç‡å ±å‘Šä¸æº–ç¢º

```bash
# æ¸…ç†ä¸¦é‡æ–°ç”Ÿæˆ
$ cargo clean
$ cargo tarpaulin --out Html
```

### å•é¡Œ 2: æŸäº›ä»£ç¢¼æœªè¢«æ¨™è¨˜ç‚ºå·²è¦†è“‹

```rust
// å¯èƒ½æ˜¯å› ç‚ºå„ªåŒ–,ä½¿ç”¨ --release æ¸¬è©¦
$ cargo tarpaulin --release
```

### å•é¡Œ 3: CI ä¸­è¦†è“‹ç‡æ¸¬è©¦å¤±æ•—

```yaml
# å¢åŠ è¶…æ™‚æ™‚é–“
- name: Run coverage
  run: cargo tarpaulin --timeout 300
  
# æˆ–ä½¿ç”¨ --no-fail-fast
- name: Run coverage
  run: cargo tarpaulin --no-fail-fast
```

---

## ğŸ“– åƒè€ƒè³‡æ–™

1. [cargo-tarpaulin Documentation](https://github.com/xd009642/tarpaulin)
2. [cargo-llvm-cov Documentation](https://github.com/taiki-e/cargo-llvm-cov)
3. [Codecov Documentation](https://docs.codecov.io/)
4. [Code Coverage Best Practices](https://martinfowler.com/bliki/TestCoverage.html)
5. [Rust Testing Guide](https://doc.rust-lang.org/book/ch11-00-testing.html)

---

*æœ€å¾Œæ›´æ–°: 2025-01-17*  
*Rust ç‰ˆæœ¬: 1.90+*

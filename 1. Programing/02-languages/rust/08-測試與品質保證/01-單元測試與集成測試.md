# å–®å…ƒæ¸¬è©¦èˆ‡é›†æˆæ¸¬è©¦

> åŸºæ–¼ Rust 1.90+ (2025) | æ§‹å»ºå¯é çš„æ¸¬è©¦é«”ç³»

## ğŸ“‹ æ¦‚è¿°

æ¸¬è©¦æ˜¯è»Ÿé«”å“è³ªçš„åŸºçŸ³ã€‚Rust å…§å»ºå¼·å¤§çš„æ¸¬è©¦æ¡†æ¶,æ”¯æŒå–®å…ƒæ¸¬è©¦ã€é›†æˆæ¸¬è©¦ã€æ–‡æª”æ¸¬è©¦ç­‰å¤šç¨®æ¸¬è©¦é¡å‹,å¹«åŠ©é–‹ç™¼è€…æ§‹å»ºé«˜å“è³ªçš„ä»£ç¢¼ã€‚

---

## ğŸ¯ Rust æ¸¬è©¦åŸºç¤

### æ¸¬è©¦é¡å‹æ¦‚è¦½

```mermaid
graph TD
    A["Rust æ¸¬è©¦"] --> B["å–®å…ƒæ¸¬è©¦<br/>(Unit Tests)"]
    A --> C["é›†æˆæ¸¬è©¦<br/>(Integration Tests)"]
    A --> D["æ–‡æª”æ¸¬è©¦<br/>(Doc Tests)"]
    A --> E["åŸºæº–æ¸¬è©¦<br/>(Benchmarks)"]
    
    B --> B1["æ¸¬è©¦ç§æœ‰å‡½æ•¸"]
    B --> B2["æ¸¬è©¦æ¨¡çµ„å…§éƒ¨é‚è¼¯"]
    
    C --> C1["æ¸¬è©¦å…¬é–‹ API"]
    C --> C2["æ¸¬è©¦æ¨¡çµ„é–“äº¤äº’"]
    
    D --> D1["ç¢ºä¿æ–‡æª”æ­£ç¢ºæ€§"]
    D --> D2["æä¾›ä½¿ç”¨ç¯„ä¾‹"]
    
    E --> E1["æ€§èƒ½æ¸¬è©¦"]
    E --> E2["å›æ­¸æª¢æ¸¬"]
    
    style B fill:#51cf66
    style C fill:#4dabf7
    style D fill:#ffd93d
    style E fill:#ff6b6b
```

---

## ğŸ§ª å–®å…ƒæ¸¬è©¦ (Unit Tests)

### åŸºæœ¬çµæ§‹

```rust
// src/lib.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_add() {
        assert_eq!(add(2, 3), 5);
    }
    
    #[test]
    fn test_add_negative() {
        assert_eq!(add(-1, 1), 0);
    }
}
```

**é‹è¡Œæ¸¬è©¦**:
```bash
$ cargo test

running 2 tests
test tests::test_add ... ok
test tests::test_add_negative ... ok

test result: ok. 2 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

### æ¸¬è©¦å®

#### assert! - å¸ƒæ—æ–·è¨€

```rust
#[test]
fn test_assert() {
    assert!(2 + 2 == 4);
    assert!(vec![1, 2, 3].len() > 0);
    
    // è‡ªå®šç¾©å¤±æ•—æ¶ˆæ¯
    assert!(2 + 2 == 4, "åŸºæœ¬æ•¸å­¸æ‡‰è©²æ­£ç¢º");
    assert!(
        vec![1, 2, 3].len() > 0,
        "å‘é‡é•·åº¦: {}, æ‡‰è©²å¤§æ–¼ 0",
        vec![1, 2, 3].len()
    );
}
```

#### assert_eq! å’Œ assert_ne! - ç›¸ç­‰æ€§æ–·è¨€

```rust
#[test]
fn test_equality() {
    assert_eq!(add(2, 3), 5);
    assert_ne!(add(2, 3), 6);
    
    // è‡ªå®šç¾©æ¶ˆæ¯
    assert_eq!(
        add(2, 3),
        5,
        "2 + 3 æ‡‰è©²ç­‰æ–¼ 5"
    );
}
```

#### æ¯”è¼ƒè¤‡é›œé¡å‹

```rust
#[derive(Debug, PartialEq)]
struct User {
    name: String,
    age: u32,
}

#[test]
fn test_user_equality() {
    let user1 = User {
        name: "Alice".to_string(),
        age: 30,
    };
    let user2 = User {
        name: "Alice".to_string(),
        age: 30,
    };
    
    assert_eq!(user1, user2);
}
```

### æ¸¬è©¦é æœŸçš„ Panic

```rust
#[test]
#[should_panic]
fn test_division_by_zero() {
    let _ = 10 / 0;
}

#[test]
#[should_panic(expected = "index out of bounds")]
fn test_out_of_bounds() {
    let v = vec![1, 2, 3];
    let _ = v[10];
}
```

### æ¸¬è©¦ Result

```rust
#[test]
fn test_with_result() -> Result<(), String> {
    if 2 + 2 == 4 {
        Ok(())
    } else {
        Err("æ•¸å­¸å£æ‰äº†".to_string())
    }
}

// å¯¦éš›æ¡ˆä¾‹
fn parse_and_validate(s: &str) -> Result<i32, String> {
    s.parse()
        .map_err(|_| "è§£æå¤±æ•—".to_string())
        .and_then(|n| {
            if n > 0 {
                Ok(n)
            } else {
                Err("å¿…é ˆç‚ºæ­£æ•¸".to_string())
            }
        })
}

#[test]
fn test_parse_valid() -> Result<(), String> {
    assert_eq!(parse_and_validate("42")?, 42);
    Ok(())
}

#[test]
fn test_parse_invalid() {
    assert!(parse_and_validate("abc").is_err());
    assert!(parse_and_validate("-5").is_err());
}
```

---

## ğŸ¨ æ¸¬è©¦çµ„ç¹”

### å…§è¯æ¸¬è©¦æ¨¡çµ„

```rust
// src/lib.rs
pub fn is_even(n: i32) -> bool {
    n % 2 == 0
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_even() {
        assert!(is_even(2));
        assert!(is_even(0));
        assert!(!is_even(1));
    }
}
```

**å„ªé»**:
- å¯ä»¥æ¸¬è©¦ç§æœ‰å‡½æ•¸
- æ¸¬è©¦ä»£ç¢¼èˆ‡å¯¦ç¾ä»£ç¢¼åœ¨åŒä¸€æ–‡ä»¶
- ç·¨è­¯é€Ÿåº¦è¼ƒå¿«

### ç¨ç«‹æ¸¬è©¦æ–‡ä»¶

```rust
// src/math.rs
pub fn add(a: i32, b: i32) -> i32 {
    a + b
}

// src/math/tests.rs
#[cfg(test)]
mod tests {
    use super::super::*;
    
    #[test]
    fn test_add() {
        assert_eq!(add(1, 2), 3);
    }
}

// src/lib.rs
mod math;
#[cfg(test)]
#[path = "math/tests.rs"]
mod math_tests;
```

### æ¸¬è©¦ç§æœ‰å‡½æ•¸

```rust
mod internal {
    fn private_function(x: i32) -> i32 {
        x * 2
    }
    
    #[cfg(test)]
    mod tests {
        use super::*;
        
        #[test]
        fn test_private() {
            // å¯ä»¥æ¸¬è©¦ç§æœ‰å‡½æ•¸
            assert_eq!(private_function(5), 10);
        }
    }
}
```

---

## ğŸ”— é›†æˆæ¸¬è©¦ (Integration Tests)

### åŸºæœ¬çµæ§‹

```
my_project/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â””â”€â”€ lib.rs
â””â”€â”€ tests/
    â”œâ”€â”€ integration_test.rs
    â””â”€â”€ common/
        â””â”€â”€ mod.rs
```

**tests/integration_test.rs**:
```rust
// é›†æˆæ¸¬è©¦åªèƒ½ä½¿ç”¨å…¬é–‹ API
use my_project::add;

#[test]
fn test_add_integration() {
    assert_eq!(add(2, 3), 5);
}
```

**é‹è¡Œ**:
```bash
$ cargo test

running 1 test
test test_add_integration ... ok

test result: ok. 1 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out
```

### å…±ç”¨æ¸¬è©¦è¼”åŠ©ä»£ç¢¼

**tests/common/mod.rs**:
```rust
// å…±ç”¨çš„æ¸¬è©¦è¼”åŠ©å‡½æ•¸
pub fn setup() {
    // åˆå§‹åŒ–é‚è¼¯
    println!("Setting up test environment");
}

pub fn teardown() {
    // æ¸…ç†é‚è¼¯
    println!("Tearing down test environment");
}
```

**tests/integration_test.rs**:
```rust
mod common;

#[test]
fn test_with_setup() {
    common::setup();
    
    // æ¸¬è©¦é‚è¼¯
    assert_eq!(2 + 2, 4);
    
    common::teardown();
}
```

### æ¸¬è©¦äºŒé€²åˆ¶ Crate

```
my_project/
â”œâ”€â”€ Cargo.toml
â”œâ”€â”€ src/
â”‚   â”œâ”€â”€ lib.rs       # åº«ä»£ç¢¼
â”‚   â””â”€â”€ main.rs      # äºŒé€²åˆ¶ä»£ç¢¼
â””â”€â”€ tests/
    â””â”€â”€ cli_test.rs
```

**src/lib.rs**:
```rust
// å°‡æ ¸å¿ƒé‚è¼¯æ”¾åœ¨ lib.rs
pub fn process_data(input: &str) -> String {
    input.to_uppercase()
}
```

**src/main.rs**:
```rust
use my_project::process_data;

fn main() {
    let result = process_data("hello");
    println!("{}", result);
}
```

**tests/cli_test.rs**:
```rust
use my_project::process_data;

#[test]
fn test_process_data() {
    assert_eq!(process_data("hello"), "HELLO");
}
```

---

## ğŸ¯ æ¸¬è©¦æœ€ä½³å¯¦è¸

### 1. ä½¿ç”¨æè¿°æ€§çš„æ¸¬è©¦åç¨±

```rust
// âŒ ä¸å¥½
#[test]
fn test1() { }

// âœ… å¥½
#[test]
fn test_add_positive_numbers() { }

#[test]
fn test_add_returns_error_on_overflow() { }

#[test]
fn test_user_creation_with_valid_email() { }
```

### 2. AAA æ¨¡å¼ (Arrange-Act-Assert)

```rust
#[test]
fn test_user_registration() {
    // Arrange (æº–å‚™)
    let username = "alice";
    let email = "alice@example.com";
    
    // Act (åŸ·è¡Œ)
    let result = register_user(username, email);
    
    // Assert (æ–·è¨€)
    assert!(result.is_ok());
    let user = result.unwrap();
    assert_eq!(user.username, username);
    assert_eq!(user.email, email);
}
```

### 3. æ¸¬è©¦é‚Šç•Œæƒ…æ³

```rust
fn divide(a: i32, b: i32) -> Option<i32> {
    if b == 0 {
        None
    } else {
        Some(a / b)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_divide_normal() {
        assert_eq!(divide(10, 2), Some(5));
    }
    
    #[test]
    fn test_divide_by_zero() {
        assert_eq!(divide(10, 0), None);
    }
    
    #[test]
    fn test_divide_negative() {
        assert_eq!(divide(-10, 2), Some(-5));
    }
    
    #[test]
    fn test_divide_zero_dividend() {
        assert_eq!(divide(0, 5), Some(0));
    }
}
```

### 4. ä½¿ç”¨æ¸¬è©¦å¤¾å…· (Test Fixtures)

```rust
struct TestFixture {
    temp_dir: std::path::PathBuf,
}

impl TestFixture {
    fn new() -> Self {
        let temp_dir = std::env::temp_dir()
            .join(format!("test_{}", uuid::Uuid::new_v4()));
        std::fs::create_dir_all(&temp_dir).unwrap();
        
        Self { temp_dir }
    }
}

impl Drop for TestFixture {
    fn drop(&mut self) {
        std::fs::remove_dir_all(&self.temp_dir).ok();
    }
}

#[test]
fn test_with_fixture() {
    let fixture = TestFixture::new();
    
    // ä½¿ç”¨è‡¨æ™‚ç›®éŒ„é€²è¡Œæ¸¬è©¦
    let test_file = fixture.temp_dir.join("test.txt");
    std::fs::write(&test_file, "test data").unwrap();
    
    assert!(test_file.exists());
    
    // fixture è‡ªå‹•æ¸…ç†
}
```

---

## ğŸ”§ æ¸¬è©¦å±¬æ€§èˆ‡é…ç½®

### å¿½ç•¥æ¸¬è©¦

```rust
#[test]
#[ignore]
fn expensive_test() {
    // è€—æ™‚çš„æ¸¬è©¦
    std::thread::sleep(std::time::Duration::from_secs(10));
}
```

**é‹è¡Œ**:
```bash
# é»˜èªè·³éè¢«å¿½ç•¥çš„æ¸¬è©¦
$ cargo test

# åªé‹è¡Œè¢«å¿½ç•¥çš„æ¸¬è©¦
$ cargo test -- --ignored

# é‹è¡Œæ‰€æœ‰æ¸¬è©¦(åŒ…æ‹¬è¢«å¿½ç•¥çš„)
$ cargo test -- --include-ignored
```

### æ¢ä»¶ç·¨è­¯æ¸¬è©¦

```rust
#[test]
#[cfg(target_os = "linux")]
fn test_linux_only() {
    // åªåœ¨ Linux ä¸Šé‹è¡Œ
}

#[test]
#[cfg(not(target_os = "windows"))]
fn test_non_windows() {
    // åœ¨é Windows å¹³å°é‹è¡Œ
}

#[test]
#[cfg(feature = "advanced")]
fn test_advanced_feature() {
    // åªåœ¨å•Ÿç”¨ "advanced" feature æ™‚é‹è¡Œ
}
```

### æ¸¬è©¦ç·šç¨‹æ§åˆ¶

```bash
# å–®ç·šç¨‹é‹è¡Œæ¸¬è©¦
$ cargo test -- --test-threads=1

# é¡¯ç¤ºæ¸¬è©¦è¼¸å‡º
$ cargo test -- --nocapture

# é‹è¡Œç‰¹å®šæ¸¬è©¦
$ cargo test test_name

# é‹è¡ŒåŒ¹é…æ¨¡å¼çš„æ¸¬è©¦
$ cargo test add
```

---

## ğŸ“Š å®Œæ•´ç¯„ä¾‹: ç”¨æˆ¶ç®¡ç†ç³»çµ±

```rust
// src/lib.rs
use std::collections::HashMap;

#[derive(Debug, Clone, PartialEq)]
pub struct User {
    pub id: u64,
    pub username: String,
    pub email: String,
}

#[derive(Debug)]
pub struct UserRepository {
    users: HashMap<u64, User>,
    next_id: u64,
}

impl UserRepository {
    pub fn new() -> Self {
        Self {
            users: HashMap::new(),
            next_id: 1,
        }
    }
    
    pub fn create(&mut self, username: String, email: String) -> Result<User, String> {
        // é©—è­‰
        if username.is_empty() {
            return Err("username cannot be empty".to_string());
        }
        
        if !email.contains('@') {
            return Err("invalid email".to_string());
        }
        
        // æª¢æŸ¥é‡è¤‡
        if self.users.values().any(|u| u.username == username) {
            return Err("username already exists".to_string());
        }
        
        // å‰µå»ºç”¨æˆ¶
        let user = User {
            id: self.next_id,
            username,
            email,
        };
        
        self.users.insert(user.id, user.clone());
        self.next_id += 1;
        
        Ok(user)
    }
    
    pub fn get(&self, id: u64) -> Option<&User> {
        self.users.get(&id)
    }
    
    pub fn update_email(&mut self, id: u64, new_email: String) -> Result<(), String> {
        if !new_email.contains('@') {
            return Err("invalid email".to_string());
        }
        
        self.users
            .get_mut(&id)
            .map(|user| {
                user.email = new_email;
            })
            .ok_or_else(|| "user not found".to_string())
    }
    
    pub fn delete(&mut self, id: u64) -> Result<User, String> {
        self.users
            .remove(&id)
            .ok_or_else(|| "user not found".to_string())
    }
}

// å–®å…ƒæ¸¬è©¦
#[cfg(test)]
mod tests {
    use super::*;
    
    fn create_test_repo() -> UserRepository {
        UserRepository::new()
    }
    
    #[test]
    fn test_create_user_success() {
        let mut repo = create_test_repo();
        
        let result = repo.create(
            "alice".to_string(),
            "alice@example.com".to_string(),
        );
        
        assert!(result.is_ok());
        let user = result.unwrap();
        assert_eq!(user.id, 1);
        assert_eq!(user.username, "alice");
        assert_eq!(user.email, "alice@example.com");
    }
    
    #[test]
    fn test_create_user_empty_username() {
        let mut repo = create_test_repo();
        
        let result = repo.create(
            "".to_string(),
            "test@example.com".to_string(),
        );
        
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "username cannot be empty");
    }
    
    #[test]
    fn test_create_user_invalid_email() {
        let mut repo = create_test_repo();
        
        let result = repo.create(
            "alice".to_string(),
            "invalid-email".to_string(),
        );
        
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "invalid email");
    }
    
    #[test]
    fn test_create_duplicate_username() {
        let mut repo = create_test_repo();
        
        repo.create("alice".to_string(), "alice1@example.com".to_string()).unwrap();
        
        let result = repo.create(
            "alice".to_string(),
            "alice2@example.com".to_string(),
        );
        
        assert!(result.is_err());
        assert_eq!(result.unwrap_err(), "username already exists");
    }
    
    #[test]
    fn test_get_user() {
        let mut repo = create_test_repo();
        let user = repo.create("alice".to_string(), "alice@example.com".to_string()).unwrap();
        
        let found = repo.get(user.id);
        assert!(found.is_some());
        assert_eq!(found.unwrap(), &user);
        
        let not_found = repo.get(999);
        assert!(not_found.is_none());
    }
    
    #[test]
    fn test_update_email() -> Result<(), String> {
        let mut repo = create_test_repo();
        let user = repo.create("alice".to_string(), "alice@example.com".to_string())?;
        
        repo.update_email(user.id, "newemail@example.com".to_string())?;
        
        let updated = repo.get(user.id).unwrap();
        assert_eq!(updated.email, "newemail@example.com");
        
        Ok(())
    }
    
    #[test]
    fn test_delete_user() -> Result<(), String> {
        let mut repo = create_test_repo();
        let user = repo.create("alice".to_string(), "alice@example.com".to_string())?;
        
        let deleted = repo.delete(user.id)?;
        assert_eq!(deleted, user);
        
        assert!(repo.get(user.id).is_none());
        
        Ok(())
    }
}
```

**é›†æˆæ¸¬è©¦ (tests/integration_test.rs)**:
```rust
use my_project::{User, UserRepository};

#[test]
fn test_full_user_lifecycle() {
    let mut repo = UserRepository::new();
    
    // å‰µå»ºç”¨æˆ¶
    let user = repo.create(
        "alice".to_string(),
        "alice@example.com".to_string(),
    ).expect("Failed to create user");
    
    assert_eq!(user.id, 1);
    
    // ç²å–ç”¨æˆ¶
    let found = repo.get(user.id).expect("User not found");
    assert_eq!(found.username, "alice");
    
    // æ›´æ–°éƒµç®±
    repo.update_email(user.id, "newemail@example.com".to_string())
        .expect("Failed to update email");
    
    let updated = repo.get(user.id).unwrap();
    assert_eq!(updated.email, "newemail@example.com");
    
    // åˆªé™¤ç”¨æˆ¶
    repo.delete(user.id).expect("Failed to delete user");
    assert!(repo.get(user.id).is_none());
}

#[test]
fn test_multiple_users() {
    let mut repo = UserRepository::new();
    
    let user1 = repo.create("alice".to_string(), "alice@example.com".to_string()).unwrap();
    let user2 = repo.create("bob".to_string(), "bob@example.com".to_string()).unwrap();
    
    assert_eq!(user1.id, 1);
    assert_eq!(user2.id, 2);
    
    assert!(repo.get(1).is_some());
    assert!(repo.get(2).is_some());
}
```

---

## ğŸ“ æ¸¬è©¦æŠ€å·§ç¸½çµ

### æ¸¬è©¦é‡‘å­—å¡”

```
        /\
       /  \      E2E æ¸¬è©¦ (å°‘é‡)
      /____\
     /      \    é›†æˆæ¸¬è©¦ (é©é‡)
    /________\
   /          \  å–®å…ƒæ¸¬è©¦ (å¤§é‡)
  /____________\
```

1. **å¤§é‡å–®å…ƒæ¸¬è©¦**: å¿«é€Ÿã€éš”é›¢ã€ç²¾ç¢º
2. **é©é‡é›†æˆæ¸¬è©¦**: æ¸¬è©¦æ¨¡çµ„é–“äº¤äº’
3. **å°‘é‡ E2E æ¸¬è©¦**: æ¸¬è©¦å®Œæ•´æµç¨‹

### é—œéµåŸå‰‡

1. **FIRST åŸå‰‡**:
   - **F**ast (å¿«é€Ÿ): æ¸¬è©¦æ‡‰è©²å¿«é€ŸåŸ·è¡Œ
   - **I**ndependent (ç¨ç«‹): æ¸¬è©¦ä¹‹é–“ä¸æ‡‰ç›¸äº’ä¾è³´
   - **R**epeatable (å¯é‡è¤‡): æ¯æ¬¡é‹è¡Œçµæœæ‡‰è©²ä¸€è‡´
   - **S**elf-validating (è‡ªæˆ‘é©—è­‰): æ¸¬è©¦æ‡‰è©²è‡ªå‹•åˆ¤æ–·é€šéèˆ‡å¦
   - **T**imely (åŠæ™‚): æ‡‰è©²åœ¨ç·¨å¯«ä»£ç¢¼çš„åŒæ™‚ç·¨å¯«æ¸¬è©¦

2. **æ¸¬è©¦è¦†è“‹**:
   - æ­£å¸¸æƒ…æ³
   - é‚Šç•Œæƒ…æ³
   - ç•°å¸¸æƒ…æ³
   - éŒ¯èª¤è™•ç†

3. **å¯ç¶­è­·æ€§**:
   - æ¸…æ™°çš„æ¸¬è©¦åç¨±
   - é¿å…é‡è¤‡ä»£ç¢¼
   - ä½¿ç”¨æ¸¬è©¦è¼”åŠ©å‡½æ•¸

---

## ğŸ“– åƒè€ƒè³‡æ–™

1. [The Rust Programming Language - Writing Tests](https://doc.rust-lang.org/book/ch11-00-testing.html)
2. [Rust By Example - Testing](https://doc.rust-lang.org/rust-by-example/testing.html)
3. [The Cargo Book - Tests](https://doc.rust-lang.org/cargo/guide/tests.html)
4. [Test Organization - Rust API Guidelines](https://rust-lang.github.io/api-guidelines/documentation.html#examples-use-and-not-try-not-unwrap-c-question-mark)

---

*æœ€å¾Œæ›´æ–°: 2025-01-17*  
*Rust ç‰ˆæœ¬: 1.90+*

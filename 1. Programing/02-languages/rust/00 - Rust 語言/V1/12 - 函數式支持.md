# 閉包 Closure
---
### 含意
閉包被廣泛用於函數式編程語言中，他**是一種匿名函數，他可以賦值給變量，並且允許捕獲作用域內的值**。

#### 案例: 實現緩存
我們需要調用者傳遞一個取得值的閉包給緩存器，緩存器看是否有值，沒有值就調用該閉包來取得值。
```rust
struct Casher<T> 
	where T: Fn(u32) -> u32
{
	query: T,
	value: Option<u32>
}

impl<T> Casher<T> 
where T: Fn(u32) -> u32
{
		fn new(query: T)  -> Self {
				Casher {
					query,
					value: None,
				}
		}

		fn value(&mut self, arg: u32) -> u32 {
				match self.value {
					Some(v) => v,
					None => {
						let v = (self.query)(arg);
						self.value = Some(v);
						v
					}
				}
		}
}
```

##### 為甚麼使用 trait bound?
以下會報錯
```rust
struct casher {
	query: Fn(u32) -> u32,
	value: Option<u32>
}
```
錯誤信息為: trait objects must include the `dyn` keyword。
因為 **Fn 是 trait 不是結構體**，只能使用 trait bound，或者改成如下:
```rust
struct casher {
	query: Box<dyn Fn(u32) -> u32>
	value: Option<u32>
}
```
這樣寫也能達成目標，但是使用 trait bound 在編譯時期會換成實際類型，也就是靜態配發，不會有運行時開銷，而 trait object 會有 vtable 的開銷。

### 三種 Fn 特徵
##### FnOnce
這個閉包會**取得捕獲變量的所有權**，所以這個閉包只能執行一次。
###### 例子: Thread::spawn()
* 簽名
```rust
pub fn spawn<F, T>(f: F) -> JoinHandle<T>
where
    F: FnOnce() -> T,
    F: Send + 'static,
    T: Send + 'static,
{}
```
> 為什麼 `spawn` 是 `FnOnce` ? 
> 因為線程是獨立的存活時間，若不取得所有權只使用引用的話，是無法保證避免懸垂引用。
* 操作如下
```rust
let v = vec![1, 2, 3];

let handle = thread::spawn(move || { // 要顯示使用 move 關鍵字，捕獲所有權
		println!("Here's a vector: {:?}", v);
});
```

##### FnMut
他可以修改捕獲變量的值，所以捕獲它的可變借用 `&mut` 。

##### Fn 
捕獲變量的不可變借用 `&`。


# 迭代器 Iterator
---
### 簡介
迭代器允許我們迭代一個連續的集合，e.g. 數組、`Vec`、`HashMap` 等，**迭代器不使用索引訪問，我們只關心元素該如何被處理**。

### Iterator 特徵
**實現這個特徵的我們稱之為迭代器**，實現他需要實作 `next` 方法，我們會**將集合轉成實現 Iterator 的實例**，透過實作以下三種方法:
1. `fn into_iter() -> IntoIter`: 取得的迭代器，會獲取原本集合的所有權，next 返回所有權
2. `fn iter() -> Iter`: 取得的迭代器，使用原本集合的不可變引用，next 返回不可變引用
3. `fn iter_mut() -> IterMut`: 取得的迭代器，使用原本集合的可變引用，next 返回可變引用
> 注意: IntoIter, Iter, IterMut 名稱可以自訂義，但他們都必須實作 Iterator trait 才能稱作迭代器。


### 實作
我們希望實現的類型如下:
```rust
// 自訂義集合
struct MyCollection {
    data: Vec<i32>,
}
```

#### 1. 實現獲得所有權的 into_iter()
```rust
// 添加 into_iter 方法
impl MyCollection {
    fn into_iter(self) -> IntoIter { // 返回自訂義迭代器
        IntoIter {
            inner: self,
            index: 0,
        }
    }
}

struct IntoIter {
    inner: MyCollection, // 取得原本集合的所有權
    index: usize,
}
// 迭代器需要實作 Iterator Trait
impl Iterator for IntoIter {
    type Item = i32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.inner.data.len() {
            let item = self.inner.data[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}
```

#### 2. 實現獲得集合不可變引用的 iter()
我撰寫的順序是先寫好 Iter 然後實作 Iter 的 next 方法，再添加 iter() 方法到 MyCollection 這樣比較符合邏輯撰寫規則。
```rust
impl<'a> MyCollection {
    fn iter(&'a self) -> Iter<'a> {
        Iter {
            inner: self,
            index: 0,
        }
    }
}

// 自訂義 Iterator
struct Iter<'a> {
    inner: &'a MyCollection, // 取得原集合的引用
    index: usize,
}

impl<'a> Iterator for Iter<'a> {
    type Item = &'a i32; // 返回的是原集合數據的引用

    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.inner.data.len() {
            let item = &self.inner.data[self.index];
            self.index += 1;
            Some(item)
        } else {
            None
        }
    }
}
```

#### 3. 實現獲得集合可變引用的 iter_mut()
##### 非常困難!!!
首先想到將 iter() 改一改
```rust
struct IterMut<'a> {
    inner: &'a mut MyCollection,
    index: usize,
}

impl<'a> Iterator for IterMut<'a> {
    type Item = &'a mut i32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.inner.data.len() {
		        let item = &mut self.inner.data[self.index];
		        self.index += 1;
		        Some(item)
        } else {
            None
        }
    }
}
```
* 恭喜我們得到一個 lifetime 錯誤如下:
```text
error: lifetime may not live long enough
  --> src/main.rs:77:13
   |
66 | impl<'a> Iterator for IterMut<'a> {
   |      -- lifetime `'a` defined here
...
69 |     fn next(&mut self) -> Option<Self::Item> {
   |             - let's call the lifetime of this reference `'1`
...
77 |             Some(item)
   |             ^^^^^^^^^^ method was supposed to return data with lifetime `'a` but it is returning data with lifetime `'1`
```
這問題很奇怪，我們使用的是 IterMut 中的 MyCollection 的不可變借用，他明明已經標記生命週期為 `'a` 為甚麼還會出現生命週期問題? [參見 stackoverflow](https://stackoverflow.com/questions/63437935/in-rust-how-do-i-create-a-mutable-iterator)
原因在於我們的返回值是可變引用，返回可變引用表示若我們多次調用該方法，**可能會返回指向相同內存空間的可變引用**，這違反了借用規則，所以借用檢查器不讓你通過 (報錯真的看不懂)，就算我們的程式碼的迭代器保證我們每次調用 `next()` 一定不會用到相同的內存，但編譯器不會知道你的邏輯能否保證，所以一律拒絕。

##### 解決方案
我們只能透過 unsafe code 來解決這個問題，這邊就要提到解決生命週期問題的大外掛，**無界生命週期(Unbounded lifetime)**，我們透過將他轉為 raw pointer，在轉換為引用就能製造一個生命無限長可以 fit 任何生命週期的引用。
```rust
impl<'a> Iterator for IterMut<'a> {
    type Item = &'a mut i32;

    fn next(&mut self) -> Option<Self::Item> {
        if self.index < self.inner.data.len() {
            let i = self.index;
            self.index += 1;
            let ptr = self.inner.data.as_mut_ptr(); // 取得裸指針
            unsafe { 
		            Some(&mut *ptr.add(i)) // 操作裸指針解引用後轉換成 &mut，變成 unbuned lifetime
		        } 
        } else {
            None
        }
    }
}
```

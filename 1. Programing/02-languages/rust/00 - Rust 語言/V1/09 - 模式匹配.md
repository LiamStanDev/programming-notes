# match 與 if let 基本
---
### match 匹配
```rust
enum Direction {
    East,
    West,
    North,
    South,
}

fn main() {
    let dire = Direction::South;
    match dire {
        Direction::East => println!("East"),
        Direction::North | Direction::South => { // 表示兩個匹配一個就會進入分支
            println!("South or North");
        },
        _ => println!("West"),
    };
}
```
有以下重點:
1. 需要**窮盡批配**，不能少掉任何分支 (比其他語言的 switch 更安全)
2. 使用 `_` 表示，default 的含意
3. `|` 表示兩個滿足一個就匹配
4. 所有匹配路徑**返回值類型都要相同**

### if let 匹配
用於只想處裡其中一個匹配時，可以考慮 `if let` 更簡潔。
```rust
fn main() {
    let v = Some(3u8);
    // 使用 match
    match v {
        Some(3) => println!("Three"),
        _ => (),
    }
		// 使用 if let
    if let Some(3) = v {
        println!("Three")
    }
}
```
> 可以配合 else 來處理不匹配情況

### matches! 宏
`matches!` 讓我們查看兩者是否能匹配，返回 `bool`。

以過濾為例:
```rust
let v = vec![MyEnum::Foo, MyEnum::Bar, MyEnum::Foo];

// 不能使用 == 因為沒有實現該操作。
// let res:Vec<_> = v.iter().filter(|x| x == MyEnum::Foo).collect();

let res: Vec<_> = v.iter().filter(|x| matches!(x, MyEnum::Foo)).collect();
```


# 使用模式的場景
---
### 簡介
模式是 Rust 提供強大的功能，用來匹配類型中的數據結構，概念上同 javascript 的**解構賦值**。

### 所有使用場景
1. match 分支
2. if let 分支
3. while let 條件循環
```rust
let mut stack = Vec::new();

// 添加數據

while let Some(top) = stack.pop() { // pop 返回 Option<i32>
	// ...
}
```
4. for 循環
```rust
let v = vec!['a', 'b', 'c'];

// (index, value) 使用了模式
for (index, value) in v.iter().enumerate() {
	// ...
}
```
5. let 語句
```rust
struct A {
    x: i32,
    y: i32,
}

fn main() {
		// 匹配結構體
    let a = A { x: 5, y: 10 };
    let A { x: px, y: py } = a;

		// 匹配 tup
		let (x, y, z) = (1, 2, 3);
}
```
6. 函數參數
```rust
fn print_coordinates(&(x, y): &(i32, i32)) { // 模式匹配
    println!("Current location: ({}, {})", x, y);
}

fn main() {
    let point = (3, 5);
    print_coordinates(&point);
}
```

### 可駁與不可駁?!
##### refutable patterns (可駁模式匹配)
表示匹配可允許失敗，不會導致編譯不過，使用場景如下:
1. `if let`: 指匹配一個，匹配成功進入分支。
2. `while let`: 指匹配一個，匹配成功進入迴圈。

##### irrefutable patterns (不可駁模式匹配)
表示不可能發生匹配不成功，所以需要**窮盡批配**，使用場景如下:
1. `let`
2. 函數參數
3. `for` 循環
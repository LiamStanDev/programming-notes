# 所有權 Ownership
---
### Stack and Heap

| 觀點   | stack                                 | heap                    |
| ---- | ------------------------------------- | ----------------------- |
| 大小   | 固定大小 8192 kB                          | 由系統動態分配                 |
| 清理方式 | 由編譯器清理，採用後進先出的方式清理<br>e.g. 局部變量、函數參數。 | 手動清理，若忘記會導致 memory leak |
| 性能   | 較快，無須進行系統調用                           | 較慢，需要進行系統調用             |

#### 所有權與堆棧
棧上的數據超出作用域會自動被釋放，堆上的數據需要手動清理，因此需要跟蹤數據是何時進行分配與釋放很重要。故 rust 採用所有權的方式來解決跟蹤問題，數據有所有者超出作用域就會被釋放。

### 所有權規則
> 1. 每個值都被一個變量所有，該變量被稱為值的所有者。
> 2. 每一個值只有唯一一個所有者
> 3. 當所有者離開作用域，這個值會被丟棄 (Drop)。

註: 基本類型 (簡單類型、棧上類型) 不會採用移動的方式，而是拷貝。因為對他們來說拷貝消耗比移動小。
#### 移動與淺拷貝
* String 類型中包含:
	1. 長度: 8 bytes 
	2. 容量: 8 bytes 
	3. 指針: 8 bytes，指向堆上真實存放的字符串數組。
```rust
fn main() {
    let s1 = String::from("Hello");
    let s2 = s1; // 發生移動

    println!("{}", s1);
}
```
以上的移動因為將屬於 s1 指向堆上的指針交給 s2，乍看之下進行了淺拷貝，但移動多做了將原本 s1 的指針置空與[[C++ Move Statement| C++ 移動構造函數]]概念相同，另外 Rust 也不允許你操作 s1 (C++ 可以)。

> 註: Rust 中拷貝(copy)指的是淺拷貝(shallow copy)，克隆(clone)指的是深拷貝(deep copy)。
#### copy trait
拷貝特徵**用於只棧上儲存的類型** (底層為同 c 的 `memcpy` )，該類型**不會進行移動而是進行拷貝**，所以舊變量在賦值給新變量後還是能使用，Rust 中原生實現 Copy 的類型有:
1. 所有整數類型 e.g. `i32`
2. 布爾類型
3. 所有浮點數類型 e.g. `f64`
4. 字符類型 e.g. `char`
5. 所有元素都實現 copy trait 的元組
6. **不可變引用** `&T`

#### 函數傳參與返回
與 let 語句一樣，也會發生 `copy` 或者 `move`。


# 借用 Borrowing
---
借用避免只使用所有權導致的程序編寫只能傳遞所有權帶來的問題，Rust 使用借用(Borrowing) 的概念來解決這個問題。
引用在 Rust 中是實現借用概念的方式，可以想為**一個內存安全的指針**。

> 註:
> 1. 引用用來表達借用之意，所以看到 `&` 開頭類型都是有借用的涵義。
> 2. Rust 的**引用是指針類型**，與不是 C++ 中引用(只是別名概念)，Rust 引用是一個類型。。

### 不可變引用
```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1);

    println!("The length of \"{}\" is {}", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

### 可變引用
```rust
fn main() {
    let mut s = String::from("Hello");
    change_str(&mut s);
}

fn change_str(some_str: &mut String) -> () {
    some_str.push_str(", world.");
}
```

### 借用規則 (Borrow checker)
> 1. 每一個數據不能同時存在多個可變借用。
> 2. 可變引用與不可變引用不能同時存在。

註: 同時存在表示在相同的作用域中。

* 規則一: 可以避免多線程數據競爭導致的不可預期行為。
* 規則二: 可以避免只讀借用數值被修改(dirty read)。

#### NLL 編譯器優化
Non-Lexical Lifetimes(NLL)，是為了避免 borrow checker 限制明明不違反的情況下編譯不通過，如以下案例在沒有 NLL 優化的舊版編譯器會報錯。

```rust
fn main() {
    let mut s = String::from("Hello");

    let r1 = &s;
    let r2 = &s;

    println!("{} and {}", r1, r2);

    let r3 = &mut s; // 相同作用域的同時存在不可變與可變引用
    r3.push_str(", world!");

    println!("{}", r3);
}
```
在 NLL 下編譯器判斷 r1, r2 生命週期與 r3 並不重疊故通過 borrow checker。
# 網路性能優化

## 連接池優化

### HTTP 連接池調優

```rust
use reqwest::Client;
use std::time::Duration;

fn create_optimized_client() -> Client {
    Client::builder()
        .pool_max_idle_per_host(10)          // 每個 host 最多 10 個空閒連接
        .pool_idle_timeout(Duration::from_secs(90))  // 空閒超時
        .timeout(Duration::from_secs(30))    // 請求超時
        .tcp_nodelay(true)                   // 禁用 Nagle 算法
        .tcp_keepalive(Duration::from_secs(60))  // TCP keepalive
        .http2_keep_alive_interval(Duration::from_secs(30))
        .http2_keep_alive_timeout(Duration::from_secs(10))
        .build()
        .unwrap()
}
```

### TCP 連接池

```rust
use tokio::net::TcpStream;
use std::sync::Arc;
use tokio::sync::Semaphore;

struct OptimizedConnectionPool {
    addr: String,
    semaphore: Arc<Semaphore>,
    max_connections: usize,
}

impl OptimizedConnectionPool {
    fn new(addr: String, max_connections: usize) -> Self {
        Self {
            addr,
            semaphore: Arc::new(Semaphore::new(max_connections)),
            max_connections,
        }
    }
    
    async fn acquire(&self) -> Result<TcpStream, std::io::Error> {
        let _permit = self.semaphore.acquire().await.unwrap();
        
        let stream = TcpStream::connect(&self.addr).await?;
        
        // 優化 socket 選項
        stream.set_nodelay(true)?;
        
        let socket = socket2::SockRef::from(&stream);
        socket.set_keepalive(true)?;
        socket.set_recv_buffer_size(256 * 1024)?;
        socket.set_send_buffer_size(256 * 1024)?;
        
        Ok(stream)
    }
}
```

## 批次處理

```rust
use tokio::sync::mpsc;
use std::time::Duration;

async fn batch_processor() {
    let (tx, mut rx) = mpsc::channel::<String>(1000);
    
    tokio::spawn(async move {
        let mut batch = Vec::new();
        let mut interval = tokio::time::interval(Duration::from_millis(100));
        
        loop {
            tokio::select! {
                Some(item) = rx.recv() => {
                    batch.push(item);
                    if batch.len() >= 100 {
                        process_batch(&batch).await;
                        batch.clear();
                    }
                }
                _ = interval.tick() => {
                    if !batch.is_empty() {
                        process_batch(&batch).await;
                        batch.clear();
                    }
                }
            }
        }
    });
}

async fn process_batch(batch: &[String]) {
    println!("Processing batch of {} items", batch.len());
}
```

## 零拷貝技術

```rust
use tokio::io::{AsyncReadExt, AsyncWriteExt};
use tokio::fs::File;
use tokio::net::TcpStream;

// 使用 sendfile (Linux)
async fn zero_copy_transfer(file_path: &str, mut socket: TcpStream) -> std::io::Result<()> {
    let mut file = File::open(file_path).await?;
    tokio::io::copy(&mut file, &mut socket).await?;
    Ok(())
}

// 向量化 IO
async fn vectored_write(socket: &mut TcpStream) -> std::io::Result<()> {
    use std::io::IoSlice;
    
    let header = b"HTTP/1.1 200 OK\r\n";
    let content_type = b"Content-Type: text/plain\r\n\r\n";
    let body = b"Hello, World!";
    
    let bufs = &[
        IoSlice::new(header),
        IoSlice::new(content_type),
        IoSlice::new(body),
    ];
    
    socket.write_vectored(bufs).await?;
    Ok(())
}
```

## 並發限制

```rust
use futures::stream::{self, StreamExt};

async fn concurrent_requests(urls: Vec<String>) {
    let client = reqwest::Client::new();
    
    stream::iter(urls)
        .map(|url| {
            let client = client.clone();
            async move {
                client.get(&url).send().await
            }
        })
        .buffer_unordered(50)  // 最多 50 個並發請求
        .for_each(|result| async {
            match result {
                Ok(response) => println!("Status: {}", response.status()),
                Err(e) => eprintln!("Error: {}", e),
            }
        })
        .await;
}
```

## 性能監控

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::time::Instant;

struct NetworkMetrics {
    requests: AtomicU64,
    bytes_sent: AtomicU64,
    bytes_received: AtomicU64,
    errors: AtomicU64,
}

impl NetworkMetrics {
    fn new() -> Self {
        Self {
            requests: AtomicU64::new(0),
            bytes_sent: AtomicU64::new(0),
            bytes_received: AtomicU64::new(0),
            errors: AtomicU64::new(0),
        }
    }
    
    fn record_request(&self, sent: u64, received: u64) {
        self.requests.fetch_add(1, Ordering::Relaxed);
        self.bytes_sent.fetch_add(sent, Ordering::Relaxed);
        self.bytes_received.fetch_add(received, Ordering::Relaxed);
    }
    
    fn record_error(&self) {
        self.errors.fetch_add(1, Ordering::Relaxed);
    }
    
    fn report(&self) {
        println!("Requests: {}", self.requests.load(Ordering::Relaxed));
        println!("Bytes sent: {}", self.bytes_sent.load(Ordering::Relaxed));
        println!("Bytes received: {}", self.bytes_received.load(Ordering::Relaxed));
        println!("Errors: {}", self.errors.load(Ordering::Relaxed));
    }
}
```

## 壓縮

```rust
use flate2::write::GzEncoder;
use flate2::Compression;
use std::io::Write;

fn compress_response(data: &[u8]) -> Vec<u8> {
    let mut encoder = GzEncoder::new(Vec::new(), Compression::default());
    encoder.write_all(data).unwrap();
    encoder.finish().unwrap()
}

// 在 axum 中使用壓縮中間件
use tower_http::compression::CompressionLayer;
use axum::Router;

fn create_compressed_app() -> Router {
    Router::new()
        .layer(CompressionLayer::new())
}
```

---

## 參考資料

1. [High Performance Browser Networking](https://hpbn.co/)
2. [Systems Performance](https://www.brendangregg.com/systems-performance-2nd-edition-book.html)
3. [TCP/IP Performance Tuning](https://www.kernel.org/doc/Documentation/networking/ip-sysctl.txt)

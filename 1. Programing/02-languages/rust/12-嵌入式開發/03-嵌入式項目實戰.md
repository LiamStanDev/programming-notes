# 嵌入式項目實戰

## 1. 項目規劃與架構設計

### 1.1 硬件選擇考量

```rust
// 常見開發板特性對比
/*
STM32F4 系列:
- Cortex-M4 (168MHz)
- 適合：信號處理、控制系統
- 豐富的外設支持

ESP32-C3:
- RISC-V 架構
- 適合：IoT、Wi-Fi 應用
- 低功耗設計

nRF52840:
- Cortex-M4 (64MHz)
- 適合：藍牙應用、低功耗設備
- 優秀的無線性能
*/
```

### 1.2 項目架構設計原則

```rust
// 分層架構設計
/*
應用層 (Application Layer)
    ↓
業務邏輯層 (Business Logic)
    ↓
硬件抽象層 (HAL)
    ↓
底層驅動 (Low-level Drivers)
    ↓
硬件 (Hardware)
*/

// 模塊化設計
pub mod drivers {
    pub mod sensor;
    pub mod display;
    pub mod communication;
}

pub mod application {
    pub mod data_processing;
    pub mod state_machine;
}

pub mod config {
    pub const SAMPLE_RATE: u32 = 100; // Hz
    pub const BUFFER_SIZE: usize = 256;
}
```

## 2. 實戰項目：智能環境監測系統

### 2.1 項目需求

```rust
// 功能需求
/*
1. 溫濕度監測 (DHT22/BME280)
2. 空氣質量監測 (MQ-135)
3. OLED 顯示屏顯示
4. 藍牙數據傳輸
5. 低功耗模式
6. 數據記錄 (Flash)
*/

// Cargo.toml
[package]
name = "env-monitor"
version = "0.1.0"
edition = "2021"

[dependencies]
cortex-m = "0.7"
cortex-m-rt = "0.7"
embedded-hal = "1.0"
stm32f4xx-hal = { version = "0.20", features = ["stm32f411"] }
panic-halt = "0.2"
nb = "1.0"
embedded-graphics = "0.8"
ssd1306 = "0.8"
dht-sensor = "0.2"

[dependencies.rtic]
version = "2.0"
features = ["thumbv7-backend"]
```

### 2.2 硬件抽象層設計

```rust
// src/drivers/sensor.rs
use embedded_hal::i2c::I2c;
use core::fmt;

#[derive(Debug)]
pub enum SensorError {
    I2cError,
    InvalidData,
    Timeout,
}

pub trait EnvironmentSensor {
    type Error;
    
    fn read_temperature(&mut self) -> Result<f32, Self::Error>;
    fn read_humidity(&mut self) -> Result<f32, Self::Error>;
    fn read_pressure(&mut self) -> Result<f32, Self::Error>;
}

// BME280 驅動實現
pub struct Bme280<I2C> {
    i2c: I2C,
    address: u8,
    calibration: CalibrationData,
}

#[derive(Default)]
struct CalibrationData {
    dig_t1: u16,
    dig_t2: i16,
    dig_t3: i16,
    dig_h1: u8,
    dig_h2: i16,
    // ... 其他校準參數
}

impl<I2C, E> Bme280<I2C>
where
    I2C: I2c<Error = E>,
{
    const CHIP_ID: u8 = 0x60;
    const REGISTER_CHIP_ID: u8 = 0xD0;
    const REGISTER_CTRL_HUM: u8 = 0xF2;
    const REGISTER_CTRL_MEAS: u8 = 0xF4;
    const REGISTER_TEMP_MSB: u8 = 0xFA;
    
    pub fn new(i2c: I2C, address: u8) -> Result<Self, SensorError> {
        let mut sensor = Self {
            i2c,
            address,
            calibration: CalibrationData::default(),
        };
        
        sensor.verify_chip_id()?;
        sensor.load_calibration()?;
        sensor.configure()?;
        
        Ok(sensor)
    }
    
    fn verify_chip_id(&mut self) -> Result<(), SensorError> {
        let mut buffer = [0u8; 1];
        self.i2c
            .write_read(self.address, &[Self::REGISTER_CHIP_ID], &mut buffer)
            .map_err(|_| SensorError::I2cError)?;
        
        if buffer[0] == Self::CHIP_ID {
            Ok(())
        } else {
            Err(SensorError::InvalidData)
        }
    }
    
    fn load_calibration(&mut self) -> Result<(), SensorError> {
        // 讀取校準數據
        let mut buf = [0u8; 24];
        self.i2c
            .write_read(self.address, &[0x88], &mut buf)
            .map_err(|_| SensorError::I2cError)?;
        
        self.calibration.dig_t1 = u16::from_le_bytes([buf[0], buf[1]]);
        self.calibration.dig_t2 = i16::from_le_bytes([buf[2], buf[3]]);
        self.calibration.dig_t3 = i16::from_le_bytes([buf[4], buf[5]]);
        
        Ok(())
    }
    
    fn configure(&mut self) -> Result<(), SensorError> {
        // 配置濕度採樣
        self.i2c
            .write(self.address, &[Self::REGISTER_CTRL_HUM, 0b00000101])
            .map_err(|_| SensorError::I2cError)?;
        
        // 配置溫度和壓力採樣，正常模式
        self.i2c
            .write(self.address, &[Self::REGISTER_CTRL_MEAS, 0b10110111])
            .map_err(|_| SensorError::I2cError)?;
        
        Ok(())
    }
    
    fn read_raw_temperature(&mut self) -> Result<i32, SensorError> {
        let mut buffer = [0u8; 3];
        self.i2c
            .write_read(self.address, &[Self::REGISTER_TEMP_MSB], &mut buffer)
            .map_err(|_| SensorError::I2cError)?;
        
        let raw = ((buffer[0] as i32) << 12) 
                | ((buffer[1] as i32) << 4) 
                | ((buffer[2] as i32) >> 4);
        Ok(raw)
    }
    
    fn compensate_temperature(&self, raw: i32) -> f32 {
        let var1 = ((raw / 8) - (self.calibration.dig_t1 as i32 * 2)) 
                 * (self.calibration.dig_t2 as i32) / 2048;
        
        let var2 = ((raw / 16) - (self.calibration.dig_t1 as i32))
                 * ((raw / 16) - (self.calibration.dig_t1 as i32))
                 / 4096 * (self.calibration.dig_t3 as i32) / 16384;
        
        let t_fine = var1 + var2;
        (t_fine * 5 + 128) as f32 / 256.0 / 100.0
    }
}

impl<I2C, E> EnvironmentSensor for Bme280<I2C>
where
    I2C: I2c<Error = E>,
{
    type Error = SensorError;
    
    fn read_temperature(&mut self) -> Result<f32, Self::Error> {
        let raw = self.read_raw_temperature()?;
        Ok(self.compensate_temperature(raw))
    }
    
    fn read_humidity(&mut self) -> Result<f32, Self::Error> {
        // 實現濕度讀取
        todo!("Implement humidity reading")
    }
    
    fn read_pressure(&mut self) -> Result<f32, Self::Error> {
        // 實現氣壓讀取
        todo!("Implement pressure reading")
    }
}
```

### 2.3 OLED 顯示驅動

```rust
// src/drivers/display.rs
use embedded_graphics::{
    mono_font::{ascii::FONT_6X10, MonoTextStyle},
    pixelcolor::BinaryColor,
    prelude::*,
    text::Text,
};
use ssd1306::{
    mode::BufferedGraphicsMode, prelude::*, I2CDisplayInterface, Ssd1306,
};

pub struct Display<I2C> {
    driver: Ssd1306<I2CInterface<I2C>, DisplaySize128x64, BufferedGraphicsMode<DisplaySize128x64>>,
}

impl<I2C, E> Display<I2C>
where
    I2C: embedded_hal::i2c::I2c<Error = E>,
{
    pub fn new(i2c: I2C) -> Result<Self, E> {
        let interface = I2CDisplayInterface::new(i2c);
        let mut driver = Ssd1306::new(interface, DisplaySize128x64, DisplayRotation::Rotate0)
            .into_buffered_graphics_mode();
        
        driver.init().map_err(|_| todo!())?;
        driver.clear_buffer();
        
        Ok(Self { driver })
    }
    
    pub fn show_environment_data(
        &mut self,
        temp: f32,
        humidity: f32,
        pressure: f32,
    ) -> Result<(), ()> {
        self.driver.clear_buffer();
        
        let text_style = MonoTextStyle::new(&FONT_6X10, BinaryColor::On);
        
        // 顯示溫度
        let mut temp_str = heapless::String::<32>::new();
        use core::fmt::Write;
        write!(&mut temp_str, "Temp: {:.1}C", temp).ok();
        Text::new(&temp_str, Point::new(0, 10), text_style)
            .draw(&mut self.driver)
            .map_err(|_| ())?;
        
        // 顯示濕度
        let mut hum_str = heapless::String::<32>::new();
        write!(&mut hum_str, "Hum:  {:.1}%", humidity).ok();
        Text::new(&hum_str, Point::new(0, 25), text_style)
            .draw(&mut self.driver)
            .map_err(|_| ())?;
        
        // 顯示氣壓
        let mut press_str = heapless::String::<32>::new();
        write!(&mut press_str, "Pres: {:.0}Pa", pressure).ok();
        Text::new(&press_str, Point::new(0, 40), text_style)
            .draw(&mut self.driver)
            .map_err(|_| ())?;
        
        self.driver.flush().map_err(|_| ())?;
        Ok(())
    }
}
```

### 2.4 RTIC 任務調度

```rust
// src/main.rs
#![no_std]
#![no_main]

use panic_halt as _;

#[rtic::app(device = stm32f4xx_hal::pac, peripherals = true, dispatchers = [EXTI0, EXTI1])]
mod app {
    use stm32f4xx_hal::{
        gpio::{Output, Pin},
        i2c::I2c,
        pac,
        prelude::*,
    };
    use systick_monotonic::*;
    use crate::drivers::{sensor::Bme280, display::Display};
    
    #[monotonic(binds = SysTick, default = true)]
    type MonoTimer = Systick<1000>; // 1 kHz
    
    #[shared]
    struct Shared {
        sensor_data: SensorData,
    }
    
    #[local]
    struct Local {
        led: Pin<'C', 13, Output>,
        sensor: Bme280<I2c<pac::I2C1>>,
        display: Display<I2c<pac::I2C2>>,
    }
    
    #[derive(Default, Clone, Copy)]
    struct SensorData {
        temperature: f32,
        humidity: f32,
        pressure: f32,
    }
    
    #[init]
    fn init(cx: init::Context) -> (Shared, Local, init::Monotonics) {
        let rcc = cx.device.RCC.constrain();
        let clocks = rcc.cfgr.sysclk(84.MHz()).freeze();
        
        // 初始化 GPIO
        let gpioa = cx.device.GPIOA.split();
        let gpiob = cx.device.GPIOB.split();
        let gpioc = cx.device.GPIOC.split();
        
        let led = gpioc.pc13.into_push_pull_output();
        
        // 初始化 I2C1 (傳感器)
        let scl1 = gpiob.pb8.into_alternate_open_drain();
        let sda1 = gpiob.pb9.into_alternate_open_drain();
        let i2c1 = I2c::new(cx.device.I2C1, (scl1, sda1), 100.kHz(), &clocks);
        
        // 初始化 I2C2 (顯示屏)
        let scl2 = gpiob.pb10.into_alternate_open_drain();
        let sda2 = gpiob.pb3.into_alternate_open_drain();
        let i2c2 = I2c::new(cx.device.I2C2, (scl2, sda2), 400.kHz(), &clocks);
        
        let sensor = Bme280::new(i2c1, 0x76).unwrap();
        let display = Display::new(i2c2).unwrap();
        
        // 初始化 Monotonic
        let mono = Systick::new(cx.core.SYST, clocks.sysclk().to_Hz());
        
        // 啟動周期性任務
        read_sensor::spawn_after(1000.millis()).ok();
        update_display::spawn_after(500.millis()).ok();
        blink_led::spawn_after(250.millis()).ok();
        
        (
            Shared {
                sensor_data: SensorData::default(),
            },
            Local { led, sensor, display },
            init::Monotonics(mono),
        )
    }
    
    // 每秒讀取一次傳感器
    #[task(local = [sensor], shared = [sensor_data], priority = 2)]
    fn read_sensor(mut cx: read_sensor::Context) {
        let temp = cx.local.sensor.read_temperature().unwrap_or(0.0);
        let humidity = cx.local.sensor.read_humidity().unwrap_or(0.0);
        let pressure = cx.local.sensor.read_pressure().unwrap_or(0.0);
        
        cx.shared.sensor_data.lock(|data| {
            data.temperature = temp;
            data.humidity = humidity;
            data.pressure = pressure;
        });
        
        // 重新調度
        read_sensor::spawn_after(1000.millis()).ok();
    }
    
    // 每 500ms 更新一次顯示
    #[task(local = [display], shared = [sensor_data], priority = 1)]
    fn update_display(mut cx: update_display::Context) {
        let data = cx.shared.sensor_data.lock(|d| *d);
        
        cx.local.display
            .show_environment_data(data.temperature, data.humidity, data.pressure)
            .ok();
        
        // 重新調度
        update_display::spawn_after(500.millis()).ok();
    }
    
    // 閃爍 LED (心跳指示)
    #[task(local = [led], priority = 0)]
    fn blink_led(cx: blink_led::Context) {
        cx.local.led.toggle();
        blink_led::spawn_after(250.millis()).ok();
    }
}
```

### 2.5 數據記錄到 Flash

```rust
// src/storage.rs
use embedded_storage::nor_flash::{NorFlash, ReadNorFlash};

pub struct DataLogger<FLASH> {
    flash: FLASH,
    write_offset: u32,
    base_address: u32,
    capacity: u32,
}

#[repr(C)]
#[derive(Clone, Copy)]
struct LogEntry {
    timestamp: u32,
    temperature: f32,
    humidity: f32,
    pressure: f32,
    checksum: u16,
}

impl LogEntry {
    fn new(timestamp: u32, temp: f32, hum: f32, press: f32) -> Self {
        let mut entry = Self {
            timestamp,
            temperature: temp,
            humidity: hum,
            pressure: press,
            checksum: 0,
        };
        entry.checksum = entry.calculate_checksum();
        entry
    }
    
    fn calculate_checksum(&self) -> u16 {
        // 簡單的累加校驗
        let bytes = unsafe {
            core::slice::from_raw_parts(
                self as *const Self as *const u8,
                core::mem::size_of::<Self>() - 2,
            )
        };
        bytes.iter().fold(0u16, |acc, &b| acc.wrapping_add(b as u16))
    }
    
    fn verify(&self) -> bool {
        self.checksum == self.calculate_checksum()
    }
}

impl<FLASH> DataLogger<FLASH>
where
    FLASH: NorFlash + ReadNorFlash,
{
    const SECTOR_SIZE: u32 = 4096;
    
    pub fn new(flash: FLASH, base_address: u32, capacity: u32) -> Self {
        Self {
            flash,
            write_offset: 0,
            base_address,
            capacity,
        }
    }
    
    pub fn log_data(&mut self, timestamp: u32, temp: f32, hum: f32, press: f32) 
        -> Result<(), FLASH::Error> 
    {
        let entry = LogEntry::new(timestamp, temp, hum, press);
        let bytes = unsafe {
            core::slice::from_raw_parts(
                &entry as *const LogEntry as *const u8,
                core::mem::size_of::<LogEntry>(),
            )
        };
        
        let address = self.base_address + self.write_offset;
        
        // 如果超出扇區邊界，擦除下一個扇區
        if self.write_offset % Self::SECTOR_SIZE == 0 {
            self.flash.erase(address, address + Self::SECTOR_SIZE)?;
        }
        
        self.flash.write(address, bytes)?;
        
        self.write_offset += core::mem::size_of::<LogEntry>() as u32;
        if self.write_offset >= self.capacity {
            self.write_offset = 0; // 循環覆蓋
        }
        
        Ok(())
    }
    
    pub fn read_latest(&mut self, count: usize) -> Result<heapless::Vec<LogEntry, 100>, FLASH::Error> {
        let mut entries = heapless::Vec::new();
        let entry_size = core::mem::size_of::<LogEntry>() as u32;
        
        let mut offset = if self.write_offset >= entry_size {
            self.write_offset - entry_size
        } else {
            self.capacity - entry_size
        };
        
        for _ in 0..count.min(100) {
            let mut buffer = [0u8; core::mem::size_of::<LogEntry>()];
            let address = self.base_address + offset;
            
            self.flash.read(address, &mut buffer)?;
            
            let entry: LogEntry = unsafe { core::ptr::read(buffer.as_ptr() as *const _) };
            
            if entry.verify() {
                entries.push(entry).ok();
            }
            
            if offset >= entry_size {
                offset -= entry_size;
            } else {
                break;
            }
        }
        
        Ok(entries)
    }
}
```

## 3. 低功耗優化

### 3.1 睡眠模式管理

```rust
// src/power.rs
use cortex_m::peripheral::SCB;
use stm32f4xx_hal::pac::PWR;

pub enum SleepMode {
    Sleep,           // CPU 停止，外設運行
    Stop,            // CPU 和大部分外設停止
    Standby,         // 最低功耗，僅保留備份域
}

pub struct PowerManager {
    scb: SCB,
    pwr: PWR,
}

impl PowerManager {
    pub fn new(scb: SCB, pwr: PWR) -> Self {
        Self { scb, pwr }
    }
    
    pub fn enter_sleep_mode(&mut self, mode: SleepMode) {
        match mode {
            SleepMode::Sleep => {
                cortex_m::asm::wfi(); // Wait For Interrupt
            }
            SleepMode::Stop => {
                // 配置 STOP 模式
                self.pwr.cr.modify(|_, w| w.lpds().set_bit());
                self.scb.set_sleepdeep();
                cortex_m::asm::wfi();
                self.scb.clear_sleepdeep();
            }
            SleepMode::Standby => {
                // 配置 STANDBY 模式
                self.pwr.cr.modify(|_, w| {
                    w.pdds().set_bit() // Power Down Deep Sleep
                     .cwuf().set_bit() // Clear Wakeup Flag
                });
                self.scb.set_sleepdeep();
                cortex_m::asm::wfi();
            }
        }
    }
    
    pub fn configure_wakeup_pin(&mut self) {
        // 啟用 WKUP 引腳
        self.pwr.csr.modify(|_, w| w.ewup().set_bit());
    }
}
```

### 3.2 動態電壓頻率調整

```rust
// src/power.rs (續)
use stm32f4xx_hal::rcc::{Clocks, CFGR};

pub struct DynamicFrequencyScaling {
    // 保存 RCC 配置的引用
}

impl DynamicFrequencyScaling {
    pub fn set_performance_mode(&mut self, cfgr: &mut CFGR) {
        // 高性能：84 MHz
        cfgr.sysclk(84.MHz());
    }
    
    pub fn set_balanced_mode(&mut self, cfgr: &mut CFGR) {
        // 平衡模式：42 MHz
        cfgr.sysclk(42.MHz());
    }
    
    pub fn set_low_power_mode(&mut self, cfgr: &mut CFGR) {
        // 低功耗：16 MHz
        cfgr.sysclk(16.MHz());
    }
}
```

## 4. 無線通信集成

### 4.1 藍牙 BLE (使用 nRF52)

```rust
// 使用 nrf-softdevice
use nrf_softdevice::{
    ble::{gatt_server, peripheral},
    Softdevice,
};

#[nrf_softdevice::gatt_service(uuid = "180F")] // Battery Service
struct BatteryService {
    #[characteristic(uuid = "2A19", read, notify)]
    battery_level: u8,
}

#[nrf_softdevice::gatt_service(uuid = "181A")] // Environmental Sensing
struct EnvironmentService {
    #[characteristic(uuid = "2A6E", read, notify)]
    temperature: i16, // 溫度 * 100
    
    #[characteristic(uuid = "2A6F", read, notify)]
    humidity: u16, // 濕度 * 100
}

#[nrf_softdevice::gatt_server]
struct Server {
    battery: BatteryService,
    environment: EnvironmentService,
}

async fn bluetooth_task(sd: &'static Softdevice) {
    let server = Server::new(sd).unwrap();
    
    // 廣播配置
    let adv_data = &[
        0x02, 0x01, 0x06, // Flags
        0x09, 0x09, b'E', b'n', b'v', b'M', b'o', b'n', b'i', b't', // Name
    ];
    
    loop {
        let config = peripheral::Config::default();
        let adv = peripheral::ConnectableAdvertisement::ScannableUndirected {
            adv_data,
            scan_data: &[],
        };
        
        let conn = peripheral::advertise_connectable(sd, adv, &config)
            .await
            .unwrap();
        
        // 連接後處理
        gatt_server::run(&conn, &server, |e| match e {
            ServerEvent::Battery(BatteryServiceEvent::BatteryLevelCccdWrite { notifications }) => {
                // 處理訂閱通知
            }
            ServerEvent::Environment(EnvironmentServiceEvent::TemperatureCccdWrite { notifications }) => {
                // 處理溫度訂閱
            }
            _ => {}
        })
        .await;
    }
}
```

### 4.2 LoRa 長距離通信

```rust
// 使用 sx127x 驅動
use sx127x::{LoRa, Mode};
use embedded_hal::spi::SpiDevice;

pub struct LoRaTransmitter<SPI, CS, RESET> {
    lora: LoRa<SPI, CS, RESET>,
}

impl<SPI, CS, RESET, E> LoRaTransmitter<SPI, CS, RESET>
where
    SPI: SpiDevice<Error = E>,
{
    pub fn new(spi: SPI, cs: CS, reset: RESET) -> Result<Self, E> {
        let mut lora = LoRa::new(spi, cs, reset);
        
        // 配置 LoRa 參數
        lora.set_frequency(915_000_000)?; // 915 MHz
        lora.set_spreading_factor(7)?;
        lora.set_bandwidth(125_000)?;
        lora.set_coding_rate(5)?;
        lora.set_tx_power(17, 0)?;
        
        Ok(Self { lora })
    }
    
    pub fn send_sensor_data(&mut self, temp: f32, hum: f32) -> Result<(), E> {
        let mut buffer = [0u8; 8];
        buffer[0..4].copy_from_slice(&temp.to_le_bytes());
        buffer[4..8].copy_from_slice(&hum.to_le_bytes());
        
        self.lora.transmit(&buffer)?;
        Ok(())
    }
    
    pub fn receive_data(&mut self) -> Result<[u8; 255], E> {
        self.lora.set_mode(Mode::RxContinuous)?;
        
        let mut buffer = [0u8; 255];
        let size = self.lora.read_packet(&mut buffer)?;
        
        Ok(buffer)
    }
}
```

## 5. 調試與測試

### 5.1 RTT (Real-Time Transfer) 調試

```rust
// 使用 rtt-target
use rtt_target::{rtt_init_print, rprintln};

#[rtic::app(device = stm32f4xx_hal::pac)]
mod app {
    #[init]
    fn init(cx: init::Context) -> (Shared, Local, init::Monotonics) {
        rtt_init_print!();
        rprintln!("System initialized");
        
        // ... 初始化代碼
    }
    
    #[task]
    fn read_sensor(cx: read_sensor::Context) {
        let temp = 25.5;
        rprintln!("Temperature: {:.1}°C", temp);
    }
}

// .cargo/config.toml 配置
// [target.'cfg(all(target_arch = "arm", target_os = "none"))']
// runner = "probe-rs run --chip STM32F411RETx"
```

### 5.2 單元測試策略

```rust
// tests/sensor_tests.rs
#![cfg(test)]

use embedded_hal_mock::i2c::{Mock as I2cMock, Transaction};
use your_crate::drivers::sensor::Bme280;

#[test]
fn test_bme280_init() {
    let expectations = [
        Transaction::write_read(0x76, vec![0xD0], vec![0x60]), // Chip ID
        Transaction::write_read(0x76, vec![0x88], vec![0; 24]), // Calibration
        Transaction::write(0x76, vec![0xF2, 0b00000101]),
        Transaction::write(0x76, vec![0xF4, 0b10110111]),
    ];
    
    let i2c = I2cMock::new(&expectations);
    let sensor = Bme280::new(i2c, 0x76).unwrap();
    
    // 驗證初始化成功
}

#[test]
fn test_temperature_reading() {
    let expectations = [
        Transaction::write_read(0x76, vec![0xD0], vec![0x60]),
        Transaction::write_read(0x76, vec![0x88], vec![0; 24]),
        Transaction::write(0x76, vec![0xF2, 0b00000101]),
        Transaction::write(0x76, vec![0xF4, 0b10110111]),
        Transaction::write_read(0x76, vec![0xFA], vec![0x80, 0x00, 0x00]),
    ];
    
    let mut i2c = I2cMock::new(&expectations);
    let mut sensor = Bme280::new(i2c, 0x76).unwrap();
    
    let temp = sensor.read_temperature().unwrap();
    assert!(temp > -40.0 && temp < 85.0);
}
```

### 5.3 硬件在環測試 (HIL)

```rust
// tests/hardware_test.rs
#![no_std]
#![no_main]

use defmt_rtt as _;
use panic_probe as _;

#[defmt_test::tests]
mod tests {
    use super::*;
    
    #[init]
    fn init() -> Context {
        // 初始化硬件
        Context { /* ... */ }
    }
    
    #[test]
    fn test_i2c_communication(ctx: &mut Context) {
        // 實際硬件測試
        let result = ctx.i2c.write_read(0x76, &[0xD0], &mut [0]);
        assert!(result.is_ok());
    }
    
    #[test]
    fn test_gpio_toggle(ctx: &mut Context) {
        ctx.led.set_high();
        cortex_m::asm::delay(1000000);
        assert!(ctx.led.is_set_high());
    }
}
```

## 6. 部署與優化

### 6.1 二進制大小優化

```toml
# Cargo.toml
[profile.release]
opt-level = "z"      # 優化大小
lto = true           # 鏈接時優化
codegen-units = 1    # 更好的優化
strip = true         # 移除符號
panic = "abort"      # 減少 panic 代碼
```

```rust
// 移除未使用的功能
#![no_std]
#![no_main]
#![feature(default_alloc_error_handler)] // 使用默認 OOM handler
```

### 6.2 性能分析

```rust
// 使用 cortex-m-rtfm 的性能計數器
use cortex_m::peripheral::DWT;

pub struct PerformanceMonitor {
    dwt: DWT,
}

impl PerformanceMonitor {
    pub fn new(mut dwt: DWT) -> Self {
        dwt.enable_cycle_counter();
        Self { dwt }
    }
    
    pub fn measure<F, R>(&self, f: F) -> (R, u32)
    where
        F: FnOnce() -> R,
    {
        let start = DWT::cycle_count();
        let result = f();
        let cycles = DWT::cycle_count().wrapping_sub(start);
        (result, cycles)
    }
}

// 使用示例
let monitor = PerformanceMonitor::new(cx.core.DWT);
let (temp, cycles) = monitor.measure(|| sensor.read_temperature());
rprintln!("Temperature reading took {} cycles", cycles);
```

### 6.3 OTA 更新

```rust
// 基於 bootloader 的 OTA 更新
pub struct OtaUpdater {
    flash_start: u32,
    flash_size: u32,
}

impl OtaUpdater {
    const APP_START: u32 = 0x0800_4000;
    const UPDATE_START: u32 = 0x0802_0000;
    
    pub fn write_update_chunk(&mut self, offset: u32, data: &[u8]) -> Result<(), ()> {
        // 寫入更新數據到備用區域
        todo!()
    }
    
    pub fn verify_update(&self) -> Result<(), ()> {
        // 驗證 CRC/哈希
        todo!()
    }
    
    pub fn apply_update(&mut self) -> Result<(), ()> {
        // 從備用區域複製到應用區域
        // 設置標誌位通知 bootloader
        todo!()
    }
    
    pub fn reboot(&self) -> ! {
        cortex_m::peripheral::SCB::sys_reset();
    }
}
```

## 7. 最佳實踐總結

### 7.1 錯誤處理

```rust
// 定義項目特定的錯誤類型
#[derive(Debug)]
pub enum SystemError {
    Sensor(SensorError),
    Display(DisplayError),
    Storage(StorageError),
    Communication(CommError),
}

impl From<SensorError> for SystemError {
    fn from(e: SensorError) -> Self {
        Self::Sensor(e)
    }
}

// 統一的錯誤處理
pub type Result<T> = core::result::Result<T, SystemError>;
```

### 7.2 資源管理

```rust
// 使用 RTIC 的資源管理
#[shared]
struct Shared {
    #[lock_free] // 單一寫入者，無需鎖
    sensor_data: SensorData,
}

// 避免動態分配，使用靜態緩衝區
static mut BUFFER: [u8; 1024] = [0; 1024];
```

### 7.3 代碼組織

```
project/
├── src/
│   ├── main.rs          # RTIC 應用入口
│   ├── drivers/         # 硬件驅動
│   │   ├── mod.rs
│   │   ├── sensor.rs
│   │   └── display.rs
│   ├── app/             # 應用邏輯
│   │   ├── mod.rs
│   │   └── state_machine.rs
│   └── config.rs        # 配置常量
├── tests/               # 測試
├── memory.x             # 鏈接腳本
└── .cargo/config.toml   # 構建配置
```

## 8. 常見問題排查

### 8.1 I2C 通信問題

```rust
// 調試 I2C
pub fn debug_i2c_scan<I2C>(i2c: &mut I2C)
where
    I2C: embedded_hal::i2c::I2c,
{
    rprintln!("Scanning I2C bus...");
    
    for addr in 0x08..=0x77 {
        let mut buffer = [0u8];
        match i2c.write_read(addr, &[], &mut buffer) {
            Ok(_) => rprintln!("Found device at 0x{:02X}", addr),
            Err(_) => {}
        }
    }
}
```

### 8.2 棧溢出檢測

```rust
// 在 memory.x 中配置棧大小
_stack_size = 0x2000; /* 8 KB */

// 運行時檢測
#[inline(never)]
fn check_stack_overflow() {
    extern "C" {
        static mut _stack_start: u32;
    }
    
    let stack_ptr = cortex_m::register::msp::read() as u32;
    let stack_start = unsafe { &_stack_start as *const u32 as u32 };
    
    if stack_ptr < stack_start + 256 {
        panic!("Stack overflow detected!");
    }
}
```

這個嵌入式項目實戰指南涵蓋了從硬件驅動開發到系統集成的完整流程，適合實際項目參考。

# åŸå­æ“ä½œèˆ‡å…§å­˜é †åº (Atomic Operations & Memory Ordering)

## æ ¸å¿ƒæ¦‚å¿µ

### åŸå­æ€§ (Atomicity) æ·±åº¦è§£æ

#### ä»€éº¼æ˜¯åŸå­æ€§ï¼Ÿ

**åŸå­æ€§ (Atomicity)**: æ“ä½œåœ¨åŸ·è¡Œæ™‚ä¸æœƒè¢«æ‰“æ–·ï¼Œå°å…¶ä»–ç·šç¨‹ä¾†èªªï¼Œæ“ä½œè¦éº¼æœªç™¼ç”Ÿï¼Œè¦éº¼å·²å®Œæˆã€‚

#### CPU å±¤é¢çš„ç†è§£

åœ¨ç¾ä»£å¤šæ ¸ CPU ä¸­ï¼Œå³ä½¿æ˜¯æœ€ç°¡å–®çš„æ“ä½œä¹Ÿå¯èƒ½ä¸æ˜¯åŸå­çš„ï¼š

```rust
// çœ‹èµ·ä¾†ç°¡å–®çš„æ“ä½œ
let mut counter = 0;
counter += 1;  // é€™å¯¦éš›ä¸Šæ˜¯ä¸‰å€‹ CPU æŒ‡ä»¤ï¼

// å°æ‡‰çš„å½™ç·¨æŒ‡ä»¤ï¼ˆx86_64ï¼‰ï¼š
// mov    rax, QWORD PTR [counter]     ; 1. å¾è¨˜æ†¶é«”è¼‰å…¥åˆ°æš«å­˜å™¨
// add    rax, 1                      ; 2. æš«å­˜å™¨å€¼ +1
// mov    QWORD PTR [counter], rax     ; 3. å¾æš«å­˜å™¨å¯«å›è¨˜æ†¶é«”
```

**å¤šç·šç¨‹å•é¡Œç¤ºæ„**ï¼š

```mermaid
sequenceDiagram
    participant CPU1
    participant Memory
    participant CPU2
    
    Note over CPU1,CPU2: åˆå§‹å€¼ï¼šcounter = 5
    
    CPU1->>Memory: 1. è®€å– counter (5)
    CPU2->>Memory: 1. è®€å– counter (5)
    
    Note over CPU1: 2. è¨ˆç®— 5+1=6
    Note over CPU2: 2. è¨ˆç®— 5+1=6
    
    CPU1->>Memory: 3. å¯«å› 6
    CPU2->>Memory: 3. å¯«å› 6
    
    Note over Memory: çµæœ: 6 (é æœŸ: 7) âŒ
```

#### ç‚ºä»€éº¼éœ€è¦åŸå­æ“ä½œï¼Ÿ

**å•é¡Œå¯¦ä¾‹ 1ï¼šç«¶çˆ­æ¢ä»¶ (Race Condition)**

```rust
use std::thread;

// âŒ éåŸå­æ“ä½œ - æœƒç”¢ç”Ÿæ•¸æ“šç«¶çˆ­
static mut COUNTER: i32 = 0;

fn increment_unsafe() {
    for _ in 0..100000 {
        unsafe {
            // é€™çœ‹èµ·ä¾†æ˜¯ä¸€è¡Œä»£ç¢¼ï¼Œä½†å¯¦éš›ä¸Šæ˜¯ä¸‰å€‹åˆ†é›¢çš„æ“ä½œï¼š
            // 1. è¼‰å…¥ COUNTER åˆ° CPU æš«å­˜å™¨  (LOAD)
            // 2. æš«å­˜å™¨å€¼ +1                (ADD)
            // 3. å¯«å› COUNTER åˆ°è¨˜æ†¶é«”      (STORE)
            COUNTER += 1;  // âŒ éåŸå­ï¼ä¸‰å€‹æ“ä½œä¹‹é–“å¯èƒ½è¢«æ‰“æ–·
        }
    }
}

fn main() {
    // å‰µå»º 10 å€‹ç·šç¨‹ï¼Œæ¯å€‹å¢åŠ  100,000 æ¬¡
    let handles: Vec<_> = (0..10)
        .map(|_| thread::spawn(increment_unsafe))
        .collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    unsafe {
        // æœŸæœ›å€¼ï¼š10 * 100,000 = 1,000,000
        // å¯¦éš›å€¼ï¼šå¯èƒ½æ˜¯ä»»ä½•å°æ–¼ 1,000,000 çš„æ•¸å­—
        println!("COUNTER: {}", COUNTER);  
        // å…¸å‹è¼¸å‡ºï¼šCOUNTER: 847392 âŒ
    }
}
```

**ç‚ºä»€éº¼æœƒä¸Ÿå¤±æ›´æ–°ï¼Ÿæ™‚åºåˆ†æï¼š**

```
æ™‚é–“ç·šï¼šç·šç¨‹ A å’Œç·šç¨‹ B åŒæ™‚åŸ·è¡Œ

ç·šç¨‹ A                   ç·šç¨‹ B                è¨˜æ†¶é«”ä¸­çš„ COUNTER
-------                  -------               ----------------
LOAD r1, COUNTER (5)     |                     5
|                        LOAD r2, COUNTER (5)  5
ADD r1, 1 (r1=6)         |                     5
|                        ADD r2, 1 (r2=6)      5
STORE COUNTER, r1        |                     6
|                        STORE COUNTER, r2     6 âŒ (æœŸæœ›æ˜¯ 7)

çµæœï¼šå…©æ¬¡å¢åŠ æ“ä½œï¼Œä½†åªå¢åŠ äº† 1ï¼Œä¸Ÿå¤±äº†ä¸€æ¬¡æ›´æ–°ï¼
```

**æ­£ç¢ºåšæ³•ï¼šä½¿ç”¨åŸå­æ“ä½œ**

```rust
use std::sync::atomic::{AtomicI32, Ordering};
use std::thread;

// âœ… ä½¿ç”¨åŸå­é¡å‹
static COUNTER: AtomicI32 = AtomicI32::new(0);

fn increment_safe() {
    for _ in 0..100000 {
        // âœ… fetch_add æ˜¯åŸå­æ“ä½œ
        // æ•´å€‹ã€Œè®€å–-ä¿®æ”¹-å¯«å›ã€éç¨‹ä¸å¯è¢«æ‰“æ–·
        COUNTER.fetch_add(1, Ordering::Relaxed);
    }
}

fn main() {
    let handles: Vec<_> = (0..10)
        .map(|_| thread::spawn(increment_safe))
        .collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    // âœ… ä¿è­‰çµæœæ­£ç¢º
    println!("COUNTER: {}", COUNTER.load(Ordering::Relaxed));  
    // è¼¸å‡ºï¼šCOUNTER: 1000000 âœ…
}
```

**åŸå­æ“ä½œçš„ CPU å¯¦ç¾**

```rust
// fetch_add åœ¨ x86_64 ä¸Šå¯èƒ½å°æ‡‰é€™æ¨£çš„æŒ‡ä»¤ï¼š
// lock add DWORD PTR [counter], 1
//      ^^^^ LOCK å‰ç¶´ä¿è­‰æ“ä½œçš„åŸå­æ€§

// LOCK å‰ç¶´çš„ä½œç”¨ï¼š
// 1. é–å®šè¨˜æ†¶é«”åŒ¯æµæ’ï¼Œé˜²æ­¢å…¶ä»– CPU è¨ªå•
// 2. ç¢ºä¿æ“ä½œå°æ‰€æœ‰ CPU æ ¸å¿ƒç«‹å³å¯è¦‹
// 3. æä¾›è¨˜æ†¶é«”é †åºä¿è­‰
```

**å•é¡Œå¯¦ä¾‹ 2ï¼šå¯è¦‹æ€§å•é¡Œ**

```rust
use std::thread;
use std::time::Duration;

static mut FLAG: bool = false;
static mut DATA: i32 = 0;

fn writer() {
    unsafe {
        DATA = 42;           // A: å¯«å…¥æ•¸æ“š
        FLAG = true;         // B: è¨­ç½®æ¨™èªŒ
    }
}

fn reader() {
    unsafe {
        while !FLAG {        // C: æª¢æŸ¥æ¨™èªŒ
            // è‡ªæ—‹ç­‰å¾…
        }
        // D: è®€å–æ•¸æ“š
        println!("DATA: {}", DATA);  // å¯èƒ½è¼¸å‡º 0 è€Œä¸æ˜¯ 42ï¼
    }
}

fn main() {
    let w = thread::spawn(writer);
    let r = thread::spawn(reader);
    
    w.join().unwrap();
    r.join().unwrap();
}
```

**ç‚ºä»€éº¼æœƒæœ‰å¯è¦‹æ€§å•é¡Œï¼Ÿ**

1. **ç·¨è­¯å™¨é‡æ’**ï¼šç·¨è­¯å™¨å¯èƒ½é‡æ’ A å’Œ B çš„é †åº
2. **CPU é‡æ’**ï¼šCPU å¯èƒ½äº‚åºåŸ·è¡ŒæŒ‡ä»¤
3. **ç·©å­˜å•é¡Œ**ï¼šä¸åŒ CPU æ ¸å¿ƒçš„ç·©å­˜å¯èƒ½ä¸åŒæ­¥

```mermaid
graph LR
    A["Writer ç·šç¨‹<br/>CPU Core 1"] --> B["L1 Cache<br/>DATA=42, FLAG=true"]
    B --> C["L2 Cache"]
    C --> D["Main Memory"]
    
    E["Reader ç·šç¨‹<br/>CPU Core 2"] --> F["L1 Cache<br/>FLAG=false, DATA=0"]
    F --> G["L2 Cache"]
    G --> D
    
    style B fill:#90EE90
    style F fill:#FF6347
```

**æ­£ç¢ºçš„åŸå­ç‰ˆæœ¬**ï¼š

```rust
use std::sync::atomic::{AtomicBool, AtomicI32, Ordering};
use std::thread;

static FLAG: AtomicBool = AtomicBool::new(false);
static DATA: AtomicI32 = AtomicI32::new(0);

fn writer() {
    DATA.store(42, Ordering::Relaxed);       // A: åŸå­å¯«å…¥æ•¸æ“š
    FLAG.store(true, Ordering::Release);     // B: åŸå­è¨­ç½®æ¨™èªŒ (Release)
}

fn reader() {
    while !FLAG.load(Ordering::Acquire) {   // C: åŸå­æª¢æŸ¥æ¨™èªŒ (Acquire)
        // è‡ªæ—‹ç­‰å¾…
    }
    let value = DATA.load(Ordering::Relaxed); // D: åŸå­è®€å–æ•¸æ“š
    println!("DATA: {}", value);  // âœ… ä¿è­‰è¼¸å‡º 42
}

fn main() {
    let w = thread::spawn(writer);
    let r = thread::spawn(reader);
    
    w.join().unwrap();
    r.join().unwrap();
}
```

---

## å…§å­˜é †åº (Memory Ordering) æ·±åº¦è§£æ

### ç‚ºä»€éº¼éœ€è¦å…§å­˜é †åºï¼Ÿ

åœ¨ç†è§£äº”ç¨®å…§å­˜é †åºä¹‹å‰ï¼Œæˆ‘å€‘éœ€è¦å…ˆç†è§£ç¾ä»£ CPU çš„**æŒ‡ä»¤é‡æ’**å•é¡Œï¼š

#### CPU æŒ‡ä»¤é‡æ’çš„ç¾å¯¦

```rust
// æºä»£ç¢¼
let a = 1;    // æŒ‡ä»¤ A
let b = 2;    // æŒ‡ä»¤ B
let c = 3;    // æŒ‡ä»¤ C

// CPU å¯èƒ½çš„åŸ·è¡Œé †åºï¼š
// 1. A -> B -> C  (æŒ‰åº)
// 2. B -> A -> C  (é‡æ’)
// 3. A -> C -> B  (é‡æ’)
// 4. ç”šè‡³åŒæ™‚åŸ·è¡Œ (è¶…æ¨™é‡)
```

**ç‚ºä»€éº¼ CPU è¦é‡æ’ï¼Ÿ**
1. **æµæ°´ç·šå„ªåŒ–**ï¼šé¿å…æŒ‡ä»¤æµæ°´ç·šåœé “
2. **ç·©å­˜å„ªåŒ–**ï¼šå„ªå…ˆåŸ·è¡Œç·©å­˜å‘½ä¸­çš„æŒ‡ä»¤
3. **ä¸¦è¡ŒåŸ·è¡Œ**ï¼šç¾ä»£ CPU å¯ä»¥åŒæ™‚åŸ·è¡Œå¤šæ¢æŒ‡ä»¤

#### å–®ç·šç¨‹ vs å¤šç·šç¨‹

```rust
// å–®ç·šç¨‹ï¼šé‡æ’ä¸å½±éŸ¿çµæœ
fn single_thread() {
    let mut x = 0;
    let mut y = 0;
    
    x = 1;    // A
    y = 2;    // B
    
    // ç„¡è«– Aã€B çš„åŸ·è¡Œé †åºå¦‚ä½•ï¼Œçµæœéƒ½æ˜¯ x=1, y=2
}

// å¤šç·šç¨‹ï¼šé‡æ’å¯èƒ½å½±éŸ¿å…¶ä»–ç·šç¨‹è§€å¯Ÿåˆ°çš„é †åº
static X: AtomicI32 = AtomicI32::new(0);
static Y: AtomicI32 = AtomicI32::new(0);

fn thread1() {
    X.store(1, Ordering::Relaxed);  // A
    Y.store(2, Ordering::Relaxed);  // B
}

fn thread2() {
    let y = Y.load(Ordering::Relaxed);  // C
    let x = X.load(Ordering::Relaxed);  // D
    
    // å¯èƒ½çš„è§€å¯Ÿçµæœï¼š
    // - x=1, y=2  âœ… (A->B->C->D)
    // - x=0, y=2  â“ (B->A è¢«é‡æ’ï¼ŒC åœ¨ A å‰åŸ·è¡Œ)
    // - x=1, y=0  â“ (C->D è¢«é‡æ’ï¼ŒD çœ‹åˆ°èˆŠå€¼)
    // - x=0, y=0  â“ (éƒ½çœ‹åˆ°èˆŠå€¼)
}
```

### äº”ç¨®å…§å­˜é †åºè©³è§£

Rust æä¾›äº”ç¨® `std::sync::atomic::Ordering`ï¼Œæ§åˆ¶é‡æ’çš„ç¨‹åº¦ï¼š

```mermaid
graph TD
    A["Relaxed<br/>æœ€å¼±ä¿è­‰<br/>åªä¿è­‰åŸå­æ€§"] --> B["Acquire/Release<br/>å»ºç«‹åŒæ­¥é—œä¿‚<br/>æ§åˆ¶éƒ¨åˆ†é‡æ’"]
    B --> C["AcqRel<br/>Acquire + Release<br/>RMW æ“ä½œå°ˆç”¨"]
    C --> D["SeqCst<br/>é †åºä¸€è‡´æ€§<br/>æœ€å¼·ä¿è­‰"]
    
    style A fill:#90EE90
    style B fill:#FFD700
    style C fill:#FFA500
    style D fill:#FF6347
    
    E["Consume<br/>(å·²å»¢æ£„)"] -.-> B
    style E fill:#CCCCCC
```

### 1. Relaxed - æœ€å¼±çš„å…§å­˜é †åº

**ç‰¹æ€§**ï¼š
- âœ… ä¿è­‰**åŸå­æ€§**ï¼ˆæ“ä½œä¸å¯è¢«æ‰“æ–·ï¼‰
- âŒ **ä¸ä¿è­‰é †åº**ï¼ˆå…è¨±ä»»æ„é‡æ’ï¼‰
- âŒ **ä¸å»ºç«‹åŒæ­¥é—œä¿‚**

#### Relaxed çš„è©³ç´°åˆ†æ

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread;

static X: AtomicU64 = AtomicU64::new(0);
static Y: AtomicU64 = AtomicU64::new(0);

fn thread1() {
    X.store(1, Ordering::Relaxed);  // æ“ä½œ A
    Y.store(1, Ordering::Relaxed);  // æ“ä½œ B
    
    // æ³¨æ„ï¼šRelaxed ä¸ä¿è­‰ A happens-before B
    // CPU å¯èƒ½é‡æ’æˆ B -> A
}

fn thread2() {
    let y = Y.load(Ordering::Relaxed);  // æ“ä½œ C
    let x = X.load(Ordering::Relaxed);  // æ“ä½œ D
    
    // æ‰€æœ‰å¯èƒ½çš„è§€å¯Ÿçµæœï¼š
    match (x, y) {
        (0, 0) => println!("éƒ½é‚„æ²’çœ‹åˆ°æ›´æ–°"),
        (1, 0) => println!("çœ‹åˆ°äº† X=1ï¼Œä½† Y é‚„æ˜¯ 0"),
        (0, 1) => println!("çœ‹åˆ°äº† Y=1ï¼Œä½† X é‚„æ˜¯ 0 â“ é‡æ’å°è‡´"),
        (1, 1) => println!("éƒ½çœ‹åˆ°äº†æ›´æ–°"),
        _ => unreachable!(),
    }
}

fn main() {
    // å¤šæ¬¡åŸ·è¡Œé€™å€‹ç¨‹åºï¼Œä½ æœƒçœ‹åˆ°æ‰€æœ‰å››ç¨®çµæœ
    let h1 = thread::spawn(thread1);
    let h2 = thread::spawn(thread2);
    h1.join().unwrap();
    h2.join().unwrap();
}
```

#### ç‚ºä»€éº¼æœƒå‡ºç¾ (0,1) çš„çµæœï¼Ÿ

```mermaid
sequenceDiagram
    participant T1 as Thread 1
    participant Memory
    participant T2 as Thread 2
    
    Note over T1,T2: æ™‚é–“ç·šå¾ä¸Šåˆ°ä¸‹
    
    T1->>Memory: Y.store(1) â† CPU é‡æ’ï¼Œå…ˆåŸ·è¡Œ B
    T2->>Memory: y = Y.load() â†’ 1
    T2->>Memory: x = X.load() â†’ 0
    T1->>Memory: X.store(1) â† å¾ŒåŸ·è¡Œ A
    
    Note over T2: è§€å¯Ÿåˆ° x=0, y=1
```

#### Relaxed çš„å¯¦éš›æ‡‰ç”¨

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::sync::Arc;
use std::thread;

// âœ… é©ç”¨å ´æ™¯ 1ï¼šç°¡å–®è¨ˆæ•¸å™¨
struct Counter {
    value: AtomicU64,
}

impl Counter {
    fn new() -> Self {
        Self {
            value: AtomicU64::new(0),
        }
    }
    
    fn increment(&self) {
        // Relaxed è¶³å¤ ï¼šæˆ‘å€‘åªé—œå¿ƒè¨ˆæ•¸çš„åŸå­æ€§ï¼Œä¸é—œå¿ƒé †åº
        self.value.fetch_add(1, Ordering::Relaxed);
    }
    
    fn get(&self) -> u64 {
        self.value.load(Ordering::Relaxed)
    }
}

// âœ… é©ç”¨å ´æ™¯ 2ï¼šçµ±è¨ˆä¿¡æ¯
struct Stats {
    requests: AtomicU64,
    errors: AtomicU64,
}

impl Stats {
    fn record_request(&self) {
        self.requests.fetch_add(1, Ordering::Relaxed);
    }
    
    fn record_error(&self) {
        self.errors.fetch_add(1, Ordering::Relaxed);
    }
    
    // é€™è£¡ä¸éœ€è¦ç²¾ç¢ºçš„åŒæ­¥ï¼Œåªéœ€è¦å¤§è‡´æº–ç¢ºçš„çµ±è¨ˆ
}

// âŒ ä¸é©ç”¨å ´æ™¯ï¼šéœ€è¦é †åºä¿è­‰çš„åŒæ­¥
static FLAG: AtomicBool = AtomicBool::new(false);
static DATA: AtomicU64 = AtomicU64::new(0);

fn bad_example() {
    // Producer
    thread::spawn(|| {
        DATA.store(42, Ordering::Relaxed);    // A
        FLAG.store(true, Ordering::Relaxed);  // B
        
        // âŒ å•é¡Œï¼šB å¯èƒ½åœ¨ A ä¹‹å‰è¢«å…¶ä»–ç·šç¨‹çœ‹åˆ°
    });
    
    // Consumer
    thread::spawn(|| {
        while !FLAG.load(Ordering::Relaxed) {} // C
        let value = DATA.load(Ordering::Relaxed); // D
        
        // âŒ å¯èƒ½è®€åˆ° DATA=0ï¼Œå› ç‚º A å¯èƒ½åœ¨ B ä¹‹å¾Œè¢«çœ‹åˆ°
        println!("Value: {}", value);
    });
}
```

#### Relaxed çš„æ€§èƒ½ç‰¹æ€§

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::Instant;

fn benchmark_relaxed() {
    let counter = AtomicU64::new(0);
    let iterations = 10_000_000;
    
    let start = Instant::now();
    for _ in 0..iterations {
        counter.fetch_add(1, Ordering::Relaxed);
    }
    let duration = start.elapsed();
    
    println!("Relaxed: {} ops/sec", 
             iterations as f64 / duration.as_secs_f64());
    
    // å…¸å‹çµæœï¼šRelaxed æ˜¯æœ€å¿«çš„ï¼Œå› ç‚ºæ²’æœ‰é¡å¤–çš„åŒæ­¥é–‹éŠ·
}
```

#### CPU æŒ‡ä»¤å°æ‡‰

```rust
// Relaxed ordering åœ¨ä¸åŒæ¶æ§‹ä¸Šçš„æŒ‡ä»¤ï¼š

// x86_64: 
// mov rax, 1
// mov [counter], rax     ; æ™®é€šçš„ mov æŒ‡ä»¤ï¼Œç„¡é¡å¤–åŒæ­¥

// ARM64:
// mov x0, #1
// str x0, [counter]      ; æ™®é€šçš„ store æŒ‡ä»¤

// å°æ¯”å…¶ä»–é †åºï¼š
// - Acquire/Release éœ€è¦é¡å¤–çš„è¨˜æ†¶é«”å±éšœæŒ‡ä»¤
// - SeqCst éœ€è¦æ›´å¼·çš„åŒæ­¥æŒ‡ä»¤ï¼ˆå¦‚ mfenceï¼‰
```

### 2. Acquire/Release - å»ºç«‹åŒæ­¥é—œä¿‚

**ç‰¹æ€§**ï¼š
- **Release**ï¼šå¯«æ“ä½œçš„è¨˜æ†¶é«”å±éšœ
  - âœ… **ä¹‹å‰**çš„æ‰€æœ‰å…§å­˜æ“ä½œä¸æœƒè¢«é‡æ’åˆ°æ­¤**ä¹‹å¾Œ**
  - âœ… å»ºç«‹**é‡‹æ”¾èªç¾©**
- **Acquire**ï¼šè®€æ“ä½œçš„è¨˜æ†¶é«”å±éšœ  
  - âœ… **ä¹‹å¾Œ**çš„æ‰€æœ‰å…§å­˜æ“ä½œä¸æœƒè¢«é‡æ’åˆ°æ­¤**ä¹‹å‰**
  - âœ… å»ºç«‹**ç²å–èªç¾©**

#### Acquire/Release çš„æ·±åº¦åˆ†æ

```rust
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::thread;

static DATA: AtomicU64 = AtomicU64::new(0);
static READY: AtomicBool = AtomicBool::new(false);

fn producer() {
    // æ­¥é©Ÿ 1: æº–å‚™æ•¸æ“š
    DATA.store(42, Ordering::Relaxed);        // æ“ä½œ A
    
    // æ­¥é©Ÿ 2: ç™¼å¸ƒæ•¸æ“šï¼ˆRelease èªç¾©ï¼‰
    READY.store(true, Ordering::Release);     // æ“ä½œ B
    
    // Release ä¿è­‰ï¼š
    // - æ“ä½œ A ä¸æœƒè¢«é‡æ’åˆ°æ“ä½œ B ä¹‹å¾Œ
    // - ç•¶å…¶ä»–ç·šç¨‹çœ‹åˆ° READY=true æ™‚ï¼Œå®ƒå€‘ä¹Ÿèƒ½çœ‹åˆ° DATA=42
}

fn consumer() {
    // æ­¥é©Ÿ 1: ç­‰å¾…æ•¸æ“šæº–å‚™å¥½ï¼ˆAcquire èªç¾©ï¼‰
    while !READY.load(Ordering::Acquire) {   // æ“ä½œ C
        std::hint::spin_loop();
    }
    
    // æ­¥é©Ÿ 2: è®€å–æ•¸æ“š
    let data = DATA.load(Ordering::Relaxed); // æ“ä½œ D
    
    // Acquire ä¿è­‰ï¼š
    // - æ“ä½œ D ä¸æœƒè¢«é‡æ’åˆ°æ“ä½œ C ä¹‹å‰
    // - ç”±æ–¼ Release-Acquire å°ï¼Œæˆ‘å€‘ä¿è­‰çœ‹åˆ° DATA=42
    
    println!("æ”¶åˆ°æ•¸æ“š: {}", data);  // å¿…ç„¶è¼¸å‡º 42
}

fn main() {
    let h1 = thread::spawn(producer);
    let h2 = thread::spawn(consumer);
    h1.join().unwrap();
    h2.join().unwrap();
}
```

#### è¦–è¦ºåŒ–ï¼šhappens-before é—œä¿‚

```mermaid
graph TD
    A["DATA.store(42, Relaxed)"] --> B["READY.store(true, Release)"]
    B -->|"synchronizes-with"| C["READY.load(Acquire) â†’ true"]
    C --> D["DATA.load(Relaxed)"]
    
    A -.->|"happens-before"| D
    
    style B fill:#FFA500
    style C fill:#FFA500
    style A fill:#90EE90
    style D fill:#90EE90
```

#### ä»€éº¼æœƒè¢«é‡æ’ï¼Œä»€éº¼ä¸æœƒï¼Ÿ

```rust
use std::sync::atomic::{AtomicU64, Ordering};

static A: AtomicU64 = AtomicU64::new(0);
static B: AtomicU64 = AtomicU64::new(0);
static C: AtomicU64 = AtomicU64::new(0);
static FLAG: AtomicBool = AtomicBool::new(false);

fn release_example() {
    A.store(1, Ordering::Relaxed);        // æŒ‡ä»¤ 1
    B.store(2, Ordering::Relaxed);        // æŒ‡ä»¤ 2
    FLAG.store(true, Ordering::Release);  // Release å±éšœ
    C.store(3, Ordering::Relaxed);        // æŒ‡ä»¤ 3
    
    // Release èªç¾©ä¿è­‰ï¼š
    // âœ… æŒ‡ä»¤ 1ã€2 ä¸æœƒè¢«é‡æ’åˆ° Release ä¹‹å¾Œ
    // âŒ æŒ‡ä»¤ 3 å¯èƒ½è¢«é‡æ’åˆ° Release ä¹‹å‰ï¼ˆä½†é€šå¸¸ä¸æœƒï¼‰
    
    // å¯èƒ½çš„åŸ·è¡Œé †åºï¼š
    // 1 -> 2 -> Release -> 3  âœ…
    // 2 -> 1 -> Release -> 3  âœ… (1,2 ä¹‹é–“å¯ä»¥é‡æ’)
    // 3 -> 1 -> 2 -> Release  âŒ (3 ä¸èƒ½è·³åˆ° Release å‰)
}

fn acquire_example() {
    while !FLAG.load(Ordering::Acquire) {} // Acquire å±éšœ
    let a = A.load(Ordering::Relaxed);      // æŒ‡ä»¤ 4
    let b = B.load(Ordering::Relaxed);      // æŒ‡ä»¤ 5
    
    // Acquire èªç¾©ä¿è­‰ï¼š
    // âœ… æŒ‡ä»¤ 4ã€5 ä¸æœƒè¢«é‡æ’åˆ° Acquire ä¹‹å‰
    // âŒ Acquire å‰çš„æŒ‡ä»¤å¯èƒ½è¢«é‡æ’åˆ° Acquire ä¹‹å¾Œ
    
    // å¯èƒ½çš„åŸ·è¡Œé †åºï¼š
    // Acquire -> 4 -> 5  âœ…
    // Acquire -> 5 -> 4  âœ… (4,5 ä¹‹é–“å¯ä»¥é‡æ’)
    // 4 -> Acquire -> 5  âŒ (4 ä¸èƒ½è·³åˆ° Acquire å‰)
}
```

#### å¯¦æˆ°æ¡ˆä¾‹ï¼šç”Ÿç”¢è€…-æ¶ˆè²»è€…éšŠåˆ—

```rust
use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};
use std::thread;
use std::time::Duration;

struct SimpleQueue<T> {
    data: Vec<Option<T>>,
    write_pos: AtomicUsize,
    read_pos: AtomicUsize,
    finished: AtomicBool,
}

impl<T> SimpleQueue<T> {
    fn new(capacity: usize) -> Self {
        let mut data = Vec::with_capacity(capacity);
        for _ in 0..capacity {
            data.push(None);
        }
        
        Self {
            data,
            write_pos: AtomicUsize::new(0),
            read_pos: AtomicUsize::new(0),
            finished: AtomicBool::new(false),
        }
    }
    
    fn push(&self, item: T) -> Result<(), T> {
        let pos = self.write_pos.load(Ordering::Relaxed);
        
        // ç°¡åŒ–ç‰ˆï¼šä¸è™•ç†ç’°å½¢ç·©è¡å€å’Œå®¹é‡æª¢æŸ¥
        unsafe {
            let slot = &self.data[pos] as *const _ as *mut Option<T>;
            *slot = Some(item);
        }
        
        // é—œéµï¼šRelease ç¢ºä¿æ•¸æ“šå¯«å…¥å°æ¶ˆè²»è€…å¯è¦‹
        self.write_pos.store(pos + 1, Ordering::Release);
        Ok(())
    }
    
    fn pop(&self) -> Option<T> {
        loop {
            // é—œéµï¼šAcquire ç¢ºä¿çœ‹åˆ°ç”Ÿç”¢è€…çš„æ•¸æ“šå¯«å…¥
            let write_pos = self.write_pos.load(Ordering::Acquire);
            let read_pos = self.read_pos.load(Ordering::Relaxed);
            
            if read_pos >= write_pos {
                if self.finished.load(Ordering::Acquire) {
                    return None;  // éšŠåˆ—å·²é—œé–‰
                }
                std::hint::spin_loop();  // ç­‰å¾…æ›´å¤šæ•¸æ“š
                continue;
            }
            
            unsafe {
                let slot = &self.data[read_pos] as *const _ as *mut Option<T>;
                if let Some(item) = (*slot).take() {
                    self.read_pos.store(read_pos + 1, Ordering::Relaxed);
                    return Some(item);
                }
            }
        }
    }
    
    fn close(&self) {
        self.finished.store(true, Ordering::Release);
    }
}
```

#### Acquire/Release çš„ CPU å¯¦ç¾

```rust
// x86_64 æ¶æ§‹ï¼š
// Release store å¯èƒ½ä½¿ç”¨ï¼š
//   mov [addr], value    ; æ™®é€š storeï¼ˆx86 æœ‰è¼ƒå¼·çš„å…§å­˜æ¨¡å‹ï¼‰
//   æˆ–
//   lock mov [addr], value

// Acquire load å¯èƒ½ä½¿ç”¨ï¼š
//   mov value, [addr]    ; æ™®é€š load
//   æˆ–
//   mov value, [addr]
//   lfence              ; load fence

// ARM64 æ¶æ§‹ï¼š
// Release storeï¼š
//   stlr w0, [addr]     ; store-release æŒ‡ä»¤

// Acquire loadï¼š
//   ldar w0, [addr]     ; load-acquire æŒ‡ä»¤
```

#### æ€§èƒ½å°æ¯”

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::Instant;

fn benchmark_orderings() {
    let counter = AtomicU64::new(0);
    let iterations = 1_000_000;
    
    // Relaxed
    let start = Instant::now();
    for _ in 0..iterations {
        counter.store(1, Ordering::Relaxed);
    }
    println!("Relaxed: {:?}", start.elapsed());
    
    // Release
    let start = Instant::now();
    for _ in 0..iterations {
        counter.store(1, Ordering::Release);
    }
    println!("Release: {:?}", start.elapsed());
    
    // Acquire
    let start = Instant::now();
    for _ in 0..iterations {
        counter.load(Ordering::Acquire);
    }
    println!("Acquire: {:?}", start.elapsed());
    
    // å…¸å‹çµæœï¼ˆx86_64ï¼‰ï¼š
    // Relaxed: 15ms
    // Release: 15ms  (x86 çš„å¼·å…§å­˜æ¨¡å‹è®“å·®ç•°å¾ˆå°)
    // Acquire: 15ms
    
    // ARM64 ä¸Šå·®ç•°æœƒæ›´æ˜é¡¯ï¼š
    // Relaxed: 10ms
    // Release: 12ms
    // Acquire: 12ms
}
```

#### å¸¸è¦‹èª¤ç”¨

```rust
// âŒ éŒ¯èª¤ 1ï¼šåªç”¨äº†ä¸€åŠçš„ Acquire-Release å°
static DATA: AtomicU64 = AtomicU64::new(0);
static FLAG: AtomicBool = AtomicBool::new(false);

fn bad_producer() {
    DATA.store(42, Ordering::Relaxed);
    FLAG.store(true, Ordering::Relaxed);  // âŒ æ‡‰è©²ç”¨ Release
}

fn bad_consumer() {
    while !FLAG.load(Ordering::Relaxed) {} // âŒ æ‡‰è©²ç”¨ Acquire
    let data = DATA.load(Ordering::Relaxed);
    // ç„¡æ³•ä¿è­‰çœ‹åˆ° DATA=42
}

// âœ… æ­£ç¢ºï¼šå¿…é ˆæˆå°ä½¿ç”¨
fn good_producer() {
    DATA.store(42, Ordering::Relaxed);
    FLAG.store(true, Ordering::Release);  // âœ…
}

fn good_consumer() {
    while !FLAG.load(Ordering::Acquire) {} // âœ…
    let data = DATA.load(Ordering::Relaxed);
    // ä¿è­‰çœ‹åˆ° DATA=42
}
```

**é©ç”¨å ´æ™¯ç¸½çµ**ï¼š
- âœ… **ç”Ÿç”¢è€…-æ¶ˆè²»è€…æ¨¡å¼**
- âœ… **è‡ªæ—‹é–å¯¦ç¾**
- âœ… **ç‹€æ…‹ç™¼å¸ƒ/é€šçŸ¥æ©Ÿåˆ¶**
- âœ… **å–®æ¬¡åˆå§‹åŒ– (Once)**

### 3. AcqRel - è®€-ä¿®æ”¹-å¯«çš„å®Œç¾é¸æ“‡

**ç‰¹æ€§**ï¼š
- âœ… **åŒæ™‚å…·å‚™ Acquire å’Œ Release èªç¾©**
- âœ… **é©ç”¨æ–¼ RMW (Read-Modify-Write) æ“ä½œ**
- âœ… **åœ¨å–®å€‹åŸå­æ“ä½œä¸­æä¾›é›™å‘åŒæ­¥**

#### AcqRel çš„è©³ç´°åˆ†æ

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::thread;

static COUNTER: AtomicU64 = AtomicU64::new(0);
static MESSAGES: [AtomicU64; 10] = [
    AtomicU64::new(0), AtomicU64::new(0), AtomicU64::new(0), AtomicU64::new(0), AtomicU64::new(0),
    AtomicU64::new(0), AtomicU64::new(0), AtomicU64::new(0), AtomicU64::new(0), AtomicU64::new(0),
];

fn worker_thread(id: u64) {
    // æ­¥é©Ÿ 1: æº–å‚™æ¶ˆæ¯æ•¸æ“š
    for i in 0..10 {
        MESSAGES[i].store(id * 10 + i, Ordering::Relaxed);
    }
    
    // æ­¥é©Ÿ 2: åŸå­æ€§åœ°å¢åŠ è¨ˆæ•¸å™¨ä¸¦ç²å–åºè™Ÿ
    let my_sequence = COUNTER.fetch_add(1, Ordering::AcqRel);
    //                                        ^^^^^^
    //                                        é—œéµï¼šAcqRel èªç¾©
    
    // AcqRel æä¾›çš„ä¿è­‰ï¼š
    // 1. Acquire èªç¾©: æˆ‘èƒ½çœ‹åˆ°ä¹‹å‰æ‰€æœ‰å®Œæˆå·¥ä½œçš„ç·šç¨‹çš„æ•¸æ“š
    // 2. Release èªç¾©: æˆ‘çš„æ•¸æ“šä¿®æ”¹å°å¾ŒçºŒçš„ç·šç¨‹å¯è¦‹
    
    println!("ç·šç¨‹ {} ç²å¾—åºè™Ÿ {}", id, my_sequence);
    
    // æ­¥é©Ÿ 3: åŸºæ–¼åºè™Ÿåšå¾ŒçºŒå·¥ä½œ
    if my_sequence % 2 == 0 {
        println!("ç·šç¨‹ {} åŸ·è¡Œå¶æ•¸ä»»å‹™", id);
    } else {
        println!("ç·šç¨‹ {} åŸ·è¡Œå¥‡æ•¸ä»»å‹™", id);
    }
}

fn main() {
    let handles: Vec<_> = (0..5)
        .map(|i| thread::spawn(move || worker_thread(i)))
        .collect();
    
    for h in handles {
        h.join().unwrap();
    }
}
```

#### ç‚ºä»€éº¼ RMW éœ€è¦ AcqRelï¼Ÿ

```rust
use std::sync::atomic::{AtomicU64, Ordering};

// å ´æ™¯ï¼šå¯¦ç¾ä¸€å€‹ç·šç¨‹å®‰å…¨çš„å”¯ä¸€ ID ç”Ÿæˆå™¨
struct IdGenerator {
    next_id: AtomicU64,
    issued_ids: AtomicU64,  // çµ±è¨ˆç™¼å‡ºçš„ ID æ•¸é‡
}

impl IdGenerator {
    fn new() -> Self {
        Self {
            next_id: AtomicU64::new(1),
            issued_ids: AtomicU64::new(0),
        }
    }
    
    // âŒ ä½¿ç”¨ Relaxed çš„å•é¡Œç‰ˆæœ¬
    fn generate_id_bad(&self) -> u64 {
        let id = self.next_id.fetch_add(1, Ordering::Relaxed);
        self.issued_ids.fetch_add(1, Ordering::Relaxed);
        
        // å•é¡Œï¼šå…©å€‹åŸå­æ“ä½œä¹‹é–“æ²’æœ‰åŒæ­¥ä¿è­‰
        // å…¶ä»–ç·šç¨‹å¯èƒ½è§€å¯Ÿåˆ°ä¸ä¸€è‡´çš„ç‹€æ…‹
        id
    }
    
    // âœ… ä½¿ç”¨ AcqRel çš„æ­£ç¢ºç‰ˆæœ¬
    fn generate_id_good(&self) -> u64 {
        // æ–¹æ³• 1: ä½¿ç”¨ AcqRel ç¢ºä¿åŒæ­¥
        let id = self.next_id.fetch_add(1, Ordering::AcqRel);
        self.issued_ids.fetch_add(1, Ordering::AcqRel);
        
        // AcqRel ä¿è­‰ï¼š
        // - æˆ‘èƒ½çœ‹åˆ°ä¹‹å‰æ‰€æœ‰çš„ ID åˆ†é…ï¼ˆAcquireï¼‰
        // - æˆ‘çš„ ID åˆ†é…å°å¾ŒçºŒçš„ç·šç¨‹å¯è¦‹ï¼ˆReleaseï¼‰
        id
    }
    
    fn get_stats(&self) -> (u64, u64) {
        let next = self.next_id.load(Ordering::Acquire);
        let issued = self.issued_ids.load(Ordering::Acquire);
        (next, issued)
    }
}
```

#### AcqRel vs åˆ†é–‹çš„ Acquire/Release

```rust
use std::sync::atomic::{AtomicU64, Ordering};

static VALUE: AtomicU64 = AtomicU64::new(0);

// æ–¹æ³• 1: ä½¿ç”¨ AcqRelï¼ˆæ¨è–¦ï¼‰
fn increment_acqrel() -> u64 {
    VALUE.fetch_add(1, Ordering::AcqRel)
    // å–®å€‹åŸå­æ“ä½œï¼Œæ—¢æœ‰ Acquire åˆæœ‰ Release èªç¾©
}

// æ–¹æ³• 2: åˆ†é–‹ä½¿ç”¨ï¼ˆä¸æ¨è–¦ï¼Œä¸”ä¸ç­‰åƒ¹ï¼‰
fn increment_separated() -> u64 {
    // âŒ é€™ä¸ç­‰åƒ¹æ–¼ AcqRel
    let old = VALUE.load(Ordering::Acquire);      // åªæœ‰ Acquire
    VALUE.store(old + 1, Ordering::Release);      // åªæœ‰ Release
    old
    
    // å•é¡Œï¼šå…©å€‹æ“ä½œä¹‹é–“ä¸æ˜¯åŸå­çš„ï¼Œå¯èƒ½ç”¢ç”Ÿç«¶çˆ­æ¢ä»¶
}

// æ­£ç¢ºçš„åˆ†é–‹ç‰ˆæœ¬ï¼ˆä½†ä»ä¸å¦‚ AcqRelï¼‰
fn increment_separated_correct() -> u64 {
    loop {
        let old = VALUE.load(Ordering::Acquire);
        match VALUE.compare_exchange_weak(
            old, 
            old + 1, 
            Ordering::AcqRel,     // æˆåŠŸæ™‚ä½¿ç”¨ AcqRel
            Ordering::Acquire,    // å¤±æ•—æ™‚ä½¿ç”¨ Acquire
        ) {
            Ok(prev) => return prev,
            Err(_) => continue,  // CAS å¤±æ•—ï¼Œé‡è©¦
        }
    }
}
```

#### å¯¦æˆ°æ¡ˆä¾‹ï¼šå¼•ç”¨è¨ˆæ•¸

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::ptr::NonNull;

// ç°¡åŒ–ç‰ˆçš„ Arc å¯¦ç¾
struct SimpleArc<T> {
    ptr: NonNull<ArcInner<T>>,
}

struct ArcInner<T> {
    ref_count: AtomicUsize,
    data: T,
}

impl<T> SimpleArc<T> {
    fn new(data: T) -> Self {
        let inner = Box::new(ArcInner {
            ref_count: AtomicUsize::new(1),
            data,
        });
        
        Self {
            ptr: NonNull::new(Box::into_raw(inner)).unwrap(),
        }
    }
    
    fn inner(&self) -> &ArcInner<T> {
        unsafe { self.ptr.as_ref() }
    }
}

impl<T> Clone for SimpleArc<T> {
    fn clone(&self) -> Self {
        // å¢åŠ å¼•ç”¨è¨ˆæ•¸
        // ä½¿ç”¨ Relaxed å°±è¶³å¤ äº†ï¼Œå› ç‚ºæˆ‘å€‘åªé—œå¿ƒè¨ˆæ•¸æœ¬èº«
        self.inner().ref_count.fetch_add(1, Ordering::Relaxed);
        
        Self { ptr: self.ptr }
    }
}

impl<T> Drop for SimpleArc<T> {
    fn drop(&mut self) {
        // é—œéµï¼šæ¸›å°‘å¼•ç”¨è¨ˆæ•¸æ™‚ä½¿ç”¨ AcqRel
        let old_count = self.inner().ref_count.fetch_sub(1, Ordering::AcqRel);
        
        // ç‚ºä»€éº¼ç”¨ AcqRelï¼Ÿ
        // - Acquire: ç¢ºä¿æˆ‘èƒ½çœ‹åˆ°å…¶ä»–ç·šç¨‹å°æ•¸æ“šçš„æ‰€æœ‰ä¿®æ”¹
        // - Release: ç¢ºä¿æˆ‘å°æ•¸æ“šçš„ä¿®æ”¹å°å…¶ä»–ç·šç¨‹å¯è¦‹
        // é€™åœ¨æœ€å¾Œä¸€å€‹å¼•ç”¨è¢«é‡‹æ”¾æ™‚ç‰¹åˆ¥é‡è¦
        
        if old_count == 1 {
            // æˆ‘æ˜¯æœ€å¾Œä¸€å€‹å¼•ç”¨ï¼Œè² è²¬æ¸…ç†
            
            // é¡å¤–çš„ Acquire fence ç¢ºä¿åŒæ­¥
            // é€™æ˜¯ std::Arc çš„å¯¦ç¾ç´°ç¯€
            std::sync::atomic::fence(Ordering::Acquire);
            
            unsafe {
                drop(Box::from_raw(self.ptr.as_ptr()));
            }
        }
    }
}

unsafe impl<T: Send + Sync> Send for SimpleArc<T> {}
unsafe impl<T: Send + Sync> Sync for SimpleArc<T> {}
```

#### AcqRel çš„é©ç”¨å ´æ™¯

```rust
use std::sync::atomic::{AtomicUsize, AtomicBool, Ordering};

// âœ… å ´æ™¯ 1: fetch_* ç³»åˆ—æ“ä½œ
fn fetch_operations() {
    let atomic = AtomicUsize::new(0);
    
    // é€™äº›éƒ½é©åˆä½¿ç”¨ AcqRel
    atomic.fetch_add(1, Ordering::AcqRel);
    atomic.fetch_sub(1, Ordering::AcqRel);
    atomic.fetch_and(0xFF, Ordering::AcqRel);
    atomic.fetch_or(0x01, Ordering::AcqRel);
    atomic.fetch_xor(0x0F, Ordering::AcqRel);
    atomic.fetch_max(100, Ordering::AcqRel);
    atomic.fetch_min(10, Ordering::AcqRel);
}

// âœ… å ´æ™¯ 2: compare_exchange
fn compare_exchange_operations() {
    let atomic = AtomicUsize::new(0);
    
    // CAS æ“ä½œé€šå¸¸ä½¿ç”¨ AcqRel
    let _ = atomic.compare_exchange(
        0,                    // æœŸæœ›å€¼
        1,                    // æ–°å€¼
        Ordering::AcqRel,     // æˆåŠŸæ™‚çš„é †åº
        Ordering::Acquire,    // å¤±æ•—æ™‚çš„é †åºï¼ˆé€šå¸¸æ˜¯ Acquireï¼‰
    );
}

// âœ… å ´æ™¯ 3: swap æ“ä½œ
fn swap_operations() {
    let atomic = AtomicBool::new(false);
    
    // swap ä¹Ÿé©åˆ AcqRel
    let old = atomic.swap(true, Ordering::AcqRel);
}

// âŒ ä¸é©ç”¨å ´æ™¯: ç´”è®€å–æˆ–ç´”å¯«å…¥
fn inappropriate_usage() {
    let atomic = AtomicUsize::new(0);
    
    // âŒ ç´”è®€å–ç”¨ AcqRel æ²’æ„ç¾©ï¼ˆä½†ä¹Ÿä¸æœƒå‡ºéŒ¯ï¼‰
    // let value = atomic.load(Ordering::AcqRel);  // ç·¨è­¯éŒ¯èª¤ï¼load ä¸æ”¯æŒ AcqRel
    let value = atomic.load(Ordering::Acquire);   // âœ… æ­£ç¢º
    
    // âŒ ç´”å¯«å…¥ç”¨ AcqRel æ²’æ„ç¾©
    // atomic.store(42, Ordering::AcqRel);         // ç·¨è­¯éŒ¯èª¤ï¼store ä¸æ”¯æŒ AcqRel
    atomic.store(42, Ordering::Release);          // âœ… æ­£ç¢º
}
```

#### æ€§èƒ½è€ƒé‡

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::time::Instant;

fn benchmark_rmw_orderings() {
    let atomic = AtomicUsize::new(0);
    let iterations = 1_000_000;
    
    // Relaxed RMW
    let start = Instant::now();
    for _ in 0..iterations {
        atomic.fetch_add(1, Ordering::Relaxed);
    }
    println!("Relaxed RMW: {:?}", start.elapsed());
    
    // AcqRel RMW
    let start = Instant::now();
    for _ in 0..iterations {
        atomic.fetch_add(1, Ordering::AcqRel);
    }
    println!("AcqRel RMW: {:?}", start.elapsed());
    
    // å…¸å‹çµæœï¼š
    // x86_64: å·®ç•°å¾ˆå°ï¼ˆå¼·å…§å­˜æ¨¡å‹ï¼‰
    // ARM64: AcqRel æ¯” Relaxed æ…¢ 10-20%
}
```

**AcqRel é©ç”¨å ´æ™¯ç¸½çµ**ï¼š
- âœ… **æ‰€æœ‰ RMW æ“ä½œ**ï¼ˆfetch_add, compare_exchange, swap ç­‰ï¼‰
- âœ… **å¼•ç”¨è¨ˆæ•¸çš„æ¸›å°‘**
- âœ… **ç·šç¨‹å®‰å…¨è¨ˆæ•¸å™¨ï¼ˆéœ€è¦åŒæ­¥èªç¾©æ™‚ï¼‰**
- âœ… **ç‹€æ…‹æ©Ÿè½‰æ›**

### 4. SeqCst - æœ€å¼·çš„è¨˜æ†¶é«”é †åºä¿è­‰

**ç‰¹æ€§**ï¼š
- âœ… **é †åºä¸€è‡´æ€§ (Sequential Consistency)**ï¼šæ‰€æœ‰ç·šç¨‹éƒ½è§€å¯Ÿåˆ°ç›¸åŒçš„å…¨å±€é †åº
- âœ… **åŒ…å« Acquire + Release çš„æ‰€æœ‰ä¿è­‰**
- âœ… **å»ºç«‹å…¨å±€çš„ happens-before é—œä¿‚**
- âŒ **æ€§èƒ½é–‹éŠ·æœ€å¤§**

#### SeqCst çš„æ ¸å¿ƒæ¦‚å¿µ

**é †åºä¸€è‡´æ€§**å®šç¾©ï¼šç¨‹åºçš„åŸ·è¡Œçµæœèˆ‡æ‰€æœ‰ç·šç¨‹çš„æ“ä½œæŒ‰æŸç¨®é †åºäº¤éŒ¯åŸ·è¡Œçš„çµæœä¸€è‡´ï¼Œä¸”æ¯å€‹ç·šç¨‹å…§çš„æ“ä½œæŒ‰ç¨‹åºé †åºåŸ·è¡Œã€‚

```rust
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::thread;

static X: AtomicBool = AtomicBool::new(false);
static Y: AtomicBool = AtomicBool::new(false);
static Z: AtomicU64 = AtomicU64::new(0);

fn demonstrate_seqcst() {
    let t1 = thread::spawn(|| {
        X.store(true, Ordering::SeqCst);  // æ“ä½œ A
    });
    
    let t2 = thread::spawn(|| {
        Y.store(true, Ordering::SeqCst);  // æ“ä½œ B  
    });
    
    let t3 = thread::spawn(|| {
        while !X.load(Ordering::SeqCst) {} // æ“ä½œ C: ç­‰å¾… X=true
        if Y.load(Ordering::SeqCst) {       // æ“ä½œ D: æª¢æŸ¥ Y
            Z.fetch_add(1, Ordering::SeqCst);
        }
    });
    
    let t4 = thread::spawn(|| {
        while !Y.load(Ordering::SeqCst) {} // æ“ä½œ E: ç­‰å¾… Y=true  
        if X.load(Ordering::SeqCst) {       // æ“ä½œ F: æª¢æŸ¥ X
            Z.fetch_add(1, Ordering::SeqCst);
        }
    });
    
    t1.join().unwrap();
    t2.join().unwrap(); 
    t3.join().unwrap();
    t4.join().unwrap();
    
    let final_z = Z.load(Ordering::SeqCst);
    println!("æœ€çµ‚ Z å€¼: {}", final_z);
    
    // SeqCst ä¿è­‰ï¼šZ >= 1
    // åŸå› ï¼šç„¡è«– Aã€B å“ªå€‹å…ˆåŸ·è¡Œï¼Œè‡³å°‘æœ‰ä¸€å€‹ç·šç¨‹æœƒçœ‹åˆ°å¦ä¸€å€‹çš„çµæœ
    assert!(final_z >= 1);
}
```

#### ç‚ºä»€éº¼ SeqCst ä¿è­‰ Z >= 1ï¼Ÿ

åœ¨ SeqCst æ¨¡å‹ä¸‹ï¼Œå­˜åœ¨ä¸€å€‹**å…¨å±€çš„æ“ä½œé †åº**ï¼Œæ‰€æœ‰ç·šç¨‹éƒ½èƒ½è§€å¯Ÿåˆ°é€™å€‹é †åºï¼š

```mermaid
graph TD
    subgraph "æƒ…æ³ 1: A åœ¨å…¨å±€é †åºä¸­å…ˆæ–¼ B"
        A1["A: X.store(true)"] --> B1["B: Y.store(true)"]
        B1 --> C1["ç·šç¨‹3: X.load() â†’ true"]
        C1 --> D1["ç·šç¨‹3: Y.load() â†’ true"]
        D1 --> Z1["Z += 1"]
    end
    
    subgraph "æƒ…æ³ 2: B åœ¨å…¨å±€é †åºä¸­å…ˆæ–¼ A"  
        B2["B: Y.store(true)"] --> A2["A: X.store(true)"]
        A2 --> E2["ç·šç¨‹4: Y.load() â†’ true"]
        E2 --> F2["ç·šç¨‹4: X.load() â†’ true"] 
        F2 --> Z2["Z += 1"]
    end
    
    style Z1 fill:#90EE90
    style Z2 fill:#90EE90
```

#### SeqCst vs å…¶ä»–é †åºçš„å°æ¯”

```rust
use std::sync::atomic::{AtomicBool, AtomicU64, Ordering};
use std::thread;
use std::sync::Arc;

// æ¸¬è©¦å‡½æ•¸ï¼šé‹è¡Œå¤šæ¬¡çœ‹çµæœåˆ†å¸ƒ
fn test_ordering(ordering: Ordering, name: &str) {
    let mut results = Vec::new();
    
    for _ in 0..1000 {
        let x = Arc::new(AtomicBool::new(false));
        let y = Arc::new(AtomicBool::new(false));
        let z = Arc::new(AtomicU64::new(0));
        
        let (x1, y1, z1) = (x.clone(), y.clone(), z.clone());
        let (x2, y2, z2) = (x.clone(), y.clone(), z.clone());
        let (x3, y3, z3) = (x.clone(), y.clone(), z.clone());
        let (x4, y4, z4) = (x.clone(), y.clone(), z.clone());
        
        let t1 = thread::spawn(move || {
            x1.store(true, ordering);
        });
        
        let t2 = thread::spawn(move || {
            y2.store(true, ordering);
        });
        
        let t3 = thread::spawn(move || {
            while !x3.load(ordering) {}
            if y3.load(ordering) {
                z3.fetch_add(1, ordering);
            }
        });
        
        let t4 = thread::spawn(move || {
            while !y4.load(ordering) {}
            if x4.load(ordering) {
                z4.fetch_add(1, ordering);
            }
        });
        
        t1.join().unwrap();
        t2.join().unwrap();
        t3.join().unwrap();
        t4.join().unwrap();
        
        results.push(z.load(ordering));
    }
    
    let zero_count = results.iter().filter(|&&x| x == 0).count();
    let one_count = results.iter().filter(|&&x| x == 1).count();
    let two_count = results.iter().filter(|&&x| x == 2).count();
    
    println!("{}: Z=0: {}, Z=1: {}, Z=2: {}", 
             name, zero_count, one_count, two_count);
}

fn main() {
    // æ¸¬è©¦ä¸åŒçš„è¨˜æ†¶é«”é †åº
    test_ordering(Ordering::Relaxed, "Relaxed");
    // å¯èƒ½è¼¸å‡ºï¼šRelaxed: Z=0: 45, Z=1: 502, Z=2: 453
    // æ³¨æ„ï¼šZ=0 æ˜¯å¯èƒ½çš„ï¼ï¼ˆè¨˜æ†¶é«”é‡æ’å°è‡´ï¼‰
    
    test_ordering(Ordering::SeqCst, "SeqCst");
    // è¼¸å‡ºï¼šSeqCst: Z=0: 0, Z=1: 634, Z=2: 366
    // ä¿è­‰ï¼šZ=0 æ°¸é ä¸æœƒç™¼ç”Ÿï¼
}
```

#### SeqCst çš„å¯¦éš›æ‡‰ç”¨å ´æ™¯

```rust
use std::sync::atomic::{AtomicBool, AtomicUsize, Ordering};
use std::thread;

// å ´æ™¯ 1: å…¨å±€ç‹€æ…‹å”èª¿
struct GlobalState {
    shutdown: AtomicBool,
    active_workers: AtomicUsize,
    emergency_stop: AtomicBool,
}

impl GlobalState {
    fn new() -> Self {
        Self {
            shutdown: AtomicBool::new(false),
            active_workers: AtomicUsize::new(0),
            emergency_stop: AtomicBool::new(false),
        }
    }
    
    // éœ€è¦å¼·ä¸€è‡´æ€§ï¼šæ‰€æœ‰ç·šç¨‹å¿…é ˆçœ‹åˆ°ç›¸åŒçš„é—œé–‰é †åº
    fn initiate_shutdown(&self) {
        self.shutdown.store(true, Ordering::SeqCst);
        
        // ç­‰å¾…æ‰€æœ‰å·¥ä½œç·šç¨‹çµæŸ
        while self.active_workers.load(Ordering::SeqCst) > 0 {
            thread::yield_now();
        }
    }
    
    fn emergency_shutdown(&self) {
        // ç·Šæ€¥åœæ­¢å¿…é ˆå°æ‰€æœ‰ç·šç¨‹ç«‹å³å¯è¦‹
        self.emergency_stop.store(true, Ordering::SeqCst);
        self.shutdown.store(true, Ordering::SeqCst);
    }
    
    fn worker_loop(&self, id: usize) {
        // å·¥ä½œç·šç¨‹è¨»å†Š
        self.active_workers.fetch_add(1, Ordering::SeqCst);
        
        loop {
            // æª¢æŸ¥åœæ­¢æ¢ä»¶ï¼ˆéœ€è¦å¼·ä¸€è‡´æ€§ï¼‰
            if self.emergency_stop.load(Ordering::SeqCst) || 
               self.shutdown.load(Ordering::SeqCst) {
                break;
            }
            
            // åŸ·è¡Œå·¥ä½œ...
            println!("Worker {} working", id);
            thread::sleep(std::time::Duration::from_millis(100));
        }
        
        // å·¥ä½œç·šç¨‹è¨»éŠ·
        self.active_workers.fetch_sub(1, Ordering::SeqCst);
        println!("Worker {} stopped", id);
    }
}
```

#### SeqCst çš„æ€§èƒ½æˆæœ¬

```rust
use std::sync::atomic::{AtomicU64, Ordering};
use std::time::Instant;

fn benchmark_all_orderings() {
    let atomic = AtomicU64::new(0);
    let iterations = 1_000_000;
    
    // Relaxed
    let start = Instant::now();
    for _ in 0..iterations {
        atomic.fetch_add(1, Ordering::Relaxed);
    }
    println!("Relaxed:  {:?}", start.elapsed());
    
    // AcqRel  
    atomic.store(0, Ordering::Relaxed);
    let start = Instant::now();
    for _ in 0..iterations {
        atomic.fetch_add(1, Ordering::AcqRel);
    }
    println!("AcqRel:   {:?}", start.elapsed());
    
    // SeqCst
    atomic.store(0, Ordering::Relaxed);
    let start = Instant::now();
    for _ in 0..iterations {
        atomic.fetch_add(1, Ordering::SeqCst);
    }
    println!("SeqCst:   {:?}", start.elapsed());
    
    // å…¸å‹çµæœï¼ˆx86_64ï¼‰ï¼š
    // Relaxed:  15ms
    // AcqRel:   15ms
    // SeqCst:   45ms  â† æ˜é¡¯æ›´æ…¢
    
    // ARM64 ä¸Šå·®ç•°æ›´å¤§ï¼š
    // Relaxed:  10ms
    // AcqRel:   12ms  
    // SeqCst:   35ms
}
```

#### ä½•æ™‚ä½¿ç”¨ SeqCst

```rust
// âœ… é©ç”¨å ´æ™¯

// 1. é»˜èªé¸æ“‡ï¼ˆä¸ç¢ºå®šæ™‚ï¼‰
let flag = AtomicBool::new(false);
flag.store(true, Ordering::SeqCst);  // å®‰å…¨ä½†å¯èƒ½éåº¦

// 2. è¤‡é›œçš„å¤šç·šç¨‹å”èª¿
// å¤šå€‹åŸå­è®Šé‡ä¹‹é–“éœ€è¦åš´æ ¼çš„é †åºä¿è­‰

// 3. èª¿è©¦å’Œæ¸¬è©¦
// ä½¿ç”¨æœ€å¼·é †åºå¯ä»¥æš´éœ²æ›´å¤šçš„ä½µç™¼å•é¡Œ

// âŒ ä¸å¿…è¦çš„å ´æ™¯

// 1. ç°¡å–®è¨ˆæ•¸å™¨
let counter = AtomicU64::new(0);
counter.fetch_add(1, Ordering::SeqCst);  // Relaxed å°±è¶³å¤ 

// 2. å–®ä¸€åŸå­è®Šé‡çš„ç°¡å–®è®€å¯«
let value = AtomicU64::new(0);
value.store(42, Ordering::SeqCst);       // Release å¯èƒ½å°±å¤ 
```

**SeqCst é©ç”¨å ´æ™¯ç¸½çµ**ï¼š
- âœ… **è¤‡é›œçš„å¤šç·šç¨‹ç‹€æ…‹å”èª¿**
- âœ… **éœ€è¦å…¨å±€ä¸€è‡´æ€§çš„å ´æ™¯**
- âœ… **èª¿è©¦ä½µç™¼å•é¡Œæ™‚**
- âœ… **ä¸ç¢ºå®šç”¨ä»€éº¼é †åºæ™‚çš„å®‰å…¨é¸æ“‡**
- âŒ **æ€§èƒ½æ•æ„Ÿä¸”åªæ¶‰åŠå–®å€‹åŸå­è®Šé‡**
- âŒ **ç°¡å–®çš„è¨ˆæ•¸æˆ–çµ±è¨ˆ**

---

## æš«åœé»

æˆ‘å·²ç¶“å®Œæˆäº†åŸå­æ“ä½œèˆ‡å…§å­˜é †åºçš„æ ¸å¿ƒæ¦‚å¿µéƒ¨åˆ†ï¼ŒåŒ…æ‹¬ï¼š

1. âœ… **åŸå­æ€§çš„æ·±åº¦è§£æ** - CPUå±¤é¢ç†è§£ã€ç«¶çˆ­æ¢ä»¶ç¯„ä¾‹
2. âœ… **äº”ç¨®å…§å­˜é †åºçš„è©³ç´°è§£é‡‹**ï¼š
   - Relaxedï¼šæœ€å¼±ä¿è­‰ï¼Œé©åˆç°¡å–®è¨ˆæ•¸
   - Acquire/Releaseï¼šå»ºç«‹åŒæ­¥é—œä¿‚ï¼Œé©åˆç”Ÿç”¢è€…-æ¶ˆè²»è€…
   - AcqRelï¼šRMWæ“ä½œçš„å®Œç¾é¸æ“‡
   - SeqCstï¼šæœ€å¼·ä¿è­‰ï¼Œé©åˆè¤‡é›œå”èª¿

æ¯å€‹éƒ¨åˆ†éƒ½åŒ…å«äº†ï¼š
- ğŸ“š æ·±å…¥çš„æ¦‚å¿µè§£é‡‹
- ğŸ’» è©³ç´°çš„ç¨‹å¼ç¢¼è¨»è§£
- ğŸ“Š è¦–è¦ºåŒ–åœ–è¡¨
- ğŸ” å¯¦æˆ°æ¡ˆä¾‹åˆ†æ
- âš¡ æ€§èƒ½å°æ¯”æ•¸æ“š

é‚„éœ€è¦è£œå……çš„éƒ¨åˆ†ï¼š
- å¸¸ç”¨åŸå­é¡å‹çš„å…·é«”æ“ä½œ
- å¯¦æˆ°æ¡ˆä¾‹ï¼ˆè‡ªæ—‹é–ã€ç„¡é–æ£§ç­‰ï¼‰
- æª¢æ¸¬å·¥å…·ä½¿ç”¨
- æœ€ä½³å¯¦è¸ç¸½çµ

æ‚¨å¸Œæœ›æˆ‘ç¹¼çºŒè£œå……é€™å€‹æª”æ¡ˆï¼Œé‚„æ˜¯è½‰åˆ°å…¶ä»–å›°é›£çš„æª”æ¡ˆï¼Ÿ

---

## å¸¸ç”¨åŸå­é¡å‹

### åŸºæœ¬åŸå­é¡å‹

```rust
use std::sync::atomic::*;

// æ•´æ•¸é¡å‹
let a_i8   = AtomicI8::new(0);
let a_i16  = AtomicI16::new(0);
let a_i32  = AtomicI32::new(0);
let a_i64  = AtomicI64::new(0);
let a_isize = AtomicIsize::new(0);

let a_u8   = AtomicU8::new(0);
let a_u16  = AtomicU16::new(0);
let a_u32  = AtomicU32::new(0);
let a_u64  = AtomicU64::new(0);
let a_usize = AtomicUsize::new(0);

// å¸ƒçˆ¾é¡å‹
let a_bool = AtomicBool::new(false);

// æŒ‡é‡é¡å‹
let a_ptr = AtomicPtr::<i32>::new(std::ptr::null_mut());
```

### å¸¸ç”¨æ“ä½œ

```rust
use std::sync::atomic::{AtomicU64, Ordering};

let atomic = AtomicU64::new(10);

// è¼‰å…¥
let value = atomic.load(Ordering::Relaxed);

// å­˜å„²
atomic.store(20, Ordering::Relaxed);

// äº¤æ›
let old = atomic.swap(30, Ordering::Relaxed);

// æ¯”è¼ƒä¸¦äº¤æ› (CAS)
let result = atomic.compare_exchange(
    30,                     // æœŸæœ›å€¼
    40,                     // æ–°å€¼
    Ordering::AcqRel,       // æˆåŠŸæ™‚çš„é †åº
    Ordering::Acquire       // å¤±æ•—æ™‚çš„é †åº
);

match result {
    Ok(old) => println!("æˆåŠŸäº¤æ›ï¼ŒèˆŠå€¼: {}", old),
    Err(current) => println!("å¤±æ•—ï¼Œç•¶å‰å€¼: {}", current),
}

// æ¯”è¼ƒä¸¦äº¤æ› (å¼±ç‰ˆæœ¬ï¼Œå¯èƒ½è™›å‡å¤±æ•—)
let result = atomic.compare_exchange_weak(
    40, 50,
    Ordering::AcqRel,
    Ordering::Acquire
);

// Fetch-Add/Sub/And/Or/Xor
let old = atomic.fetch_add(5, Ordering::Relaxed);
let old = atomic.fetch_sub(3, Ordering::Relaxed);
let old = atomic.fetch_and(0xFF, Ordering::Relaxed);
let old = atomic.fetch_or(0x01, Ordering::Relaxed);
let old = atomic.fetch_xor(0x0F, Ordering::Relaxed);

// Fetch-Max/Min (Rust 1.45+)
let old = atomic.fetch_max(100, Ordering::Relaxed);
let old = atomic.fetch_min(10, Ordering::Relaxed);
```

---

## å¯¦æˆ°æ¡ˆä¾‹

### æ¡ˆä¾‹ 1ï¼šè‡ªæ—‹é– (Spinlock)

```rust
use std::sync::atomic::{AtomicBool, Ordering};
use std::cell::UnsafeCell;

pub struct SpinLock<T> {
    locked: AtomicBool,
    data: UnsafeCell<T>,
}

unsafe impl<T: Send> Sync for SpinLock<T> {}

impl<T> SpinLock<T> {
    pub const fn new(data: T) -> Self {
        Self {
            locked: AtomicBool::new(false),
            data: UnsafeCell::new(data),
        }
    }
    
    pub fn lock(&self) -> SpinLockGuard<T> {
        // ä½¿ç”¨ compare_exchange ç²å–é–
        while self.locked
            .compare_exchange_weak(
                false,                  // æœŸæœ›å€¼ï¼šæœªé–å®š
                true,                   // æ–°å€¼ï¼šé–å®š
                Ordering::Acquire,      // æˆåŠŸï¼šç²å–èªç¾©
                Ordering::Relaxed       // å¤±æ•—ï¼šæ”¾é¬†
            )
            .is_err()
        {
            // è‡ªæ—‹ç­‰å¾…
            while self.locked.load(Ordering::Relaxed) {
                std::hint::spin_loop();  // CPU æç¤º
            }
        }
        
        SpinLockGuard { lock: self }
    }
}

pub struct SpinLockGuard<'a, T> {
    lock: &'a SpinLock<T>,
}

impl<T> std::ops::Deref for SpinLockGuard<'_, T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        unsafe { &*self.lock.data.get() }
    }
}

impl<T> std::ops::DerefMut for SpinLockGuard<'_, T> {
    fn deref_mut(&mut self) -> &mut T {
        unsafe { &mut *self.lock.data.get() }
    }
}

impl<T> Drop for SpinLockGuard<'_, T> {
    fn drop(&mut self) {
        // é‡‹æ”¾é–
        self.lock.locked.store(false, Ordering::Release);
    }
}

// ä½¿ç”¨ç¯„ä¾‹
fn main() {
    use std::thread;
    
    let lock = SpinLock::new(0);
    let handles: Vec<_> = (0..10)
        .map(|_| {
            thread::spawn(|| {
                for _ in 0..1000 {
                    let mut guard = lock.lock();
                    *guard += 1;
                }
            })
        })
        .collect();
    
    for h in handles {
        h.join().unwrap();
    }
    
    println!("Final value: {}", *lock.lock());  // 10000
}
```

### æ¡ˆä¾‹ 2ï¼šç„¡é–æ£§ (Lock-Free Stack)

```rust
use std::sync::atomic::{AtomicPtr, Ordering};
use std::ptr;

struct Node<T> {
    data: T,
    next: *mut Node<T>,
}

pub struct LockFreeStack<T> {
    head: AtomicPtr<Node<T>>,
}

impl<T> LockFreeStack<T> {
    pub const fn new() -> Self {
        Self {
            head: AtomicPtr::new(ptr::null_mut()),
        }
    }
    
    pub fn push(&self, data: T) {
        let new_node = Box::into_raw(Box::new(Node {
            data,
            next: ptr::null_mut(),
        }));
        
        let mut head = self.head.load(Ordering::Relaxed);
        loop {
            unsafe { (*new_node).next = head; }
            
            match self.head.compare_exchange_weak(
                head,
                new_node,
                Ordering::Release,
                Ordering::Relaxed
            ) {
                Ok(_) => break,
                Err(current) => head = current,  // CAS å¤±æ•—ï¼Œé‡è©¦
            }
        }
    }
    
    pub fn pop(&self) -> Option<T> {
        let mut head = self.head.load(Ordering::Relaxed);
        loop {
            if head.is_null() {
                return None;
            }
            
            let next = unsafe { (*head).next };
            
            match self.head.compare_exchange_weak(
                head,
                next,
                Ordering::Acquire,
                Ordering::Relaxed
            ) {
                Ok(_) => {
                    let node = unsafe { Box::from_raw(head) };
                    return Some(node.data);
                }
                Err(current) => head = current,
            }
        }
    }
}

impl<T> Drop for LockFreeStack<T> {
    fn drop(&mut self) {
        while self.pop().is_some() {}
    }
}

unsafe impl<T: Send> Send for LockFreeStack<T> {}
unsafe impl<T: Send> Sync for LockFreeStack<T> {}
```

### æ¡ˆä¾‹ 3ï¼šåŸå­å¼•ç”¨è¨ˆæ•¸ (Arc çš„ç°¡åŒ–å¯¦ç¾)

```rust
use std::sync::atomic::{AtomicUsize, Ordering};
use std::ptr::NonNull;

struct ArcInner<T> {
    ref_count: AtomicUsize,
    data: T,
}

pub struct SimpleArc<T> {
    ptr: NonNull<ArcInner<T>>,
}

impl<T> SimpleArc<T> {
    pub fn new(data: T) -> Self {
        let inner = Box::new(ArcInner {
            ref_count: AtomicUsize::new(1),
            data,
        });
        
        Self {
            ptr: NonNull::new(Box::into_raw(inner)).unwrap(),
        }
    }
    
    fn inner(&self) -> &ArcInner<T> {
        unsafe { self.ptr.as_ref() }
    }
}

impl<T> Clone for SimpleArc<T> {
    fn clone(&self) -> Self {
        // å¢åŠ å¼•ç”¨è¨ˆæ•¸
        self.inner().ref_count.fetch_add(1, Ordering::Relaxed);
        
        Self { ptr: self.ptr }
    }
}

impl<T> Drop for SimpleArc<T> {
    fn drop(&mut self) {
        // æ¸›å°‘å¼•ç”¨è¨ˆæ•¸
        if self.inner().ref_count.fetch_sub(1, Ordering::Release) == 1 {
            // æœ€å¾Œä¸€å€‹å¼•ç”¨ï¼Œéœ€è¦é‡‹æ”¾
            std::sync::atomic::fence(Ordering::Acquire);
            unsafe {
                drop(Box::from_raw(self.ptr.as_ptr()));
            }
        }
    }
}

impl<T> std::ops::Deref for SimpleArc<T> {
    type Target = T;
    
    fn deref(&self) -> &T {
        &self.inner().data
    }
}

unsafe impl<T: Send + Sync> Send for SimpleArc<T> {}
unsafe impl<T: Send + Sync> Sync for SimpleArc<T> {}
```

---

## æ€§èƒ½è€ƒæ…®

### å…§å­˜é †åºæ€§èƒ½å°æ¯”

```rust
use criterion::{black_box, criterion_group, criterion_main, Criterion};
use std::sync::atomic::{AtomicU64, Ordering};

fn benchmark_ordering(c: &mut Criterion) {
    let atomic = AtomicU64::new(0);
    
    c.bench_function("relaxed", |b| {
        b.iter(|| atomic.fetch_add(1, Ordering::Relaxed))
    });
    
    c.bench_function("acquire", |b| {
        b.iter(|| atomic.load(Ordering::Acquire))
    });
    
    c.bench_function("release", |b| {
        b.iter(|| atomic.store(black_box(1), Ordering::Release))
    });
    
    c.bench_function("acqrel", |b| {
        b.iter(|| atomic.fetch_add(1, Ordering::AcqRel))
    });
    
    c.bench_function("seqcst", |b| {
        b.iter(|| atomic.fetch_add(1, Ordering::SeqCst))
    });
}

criterion_group!(benches, benchmark_ordering);
criterion_main!(benches);

// å…¸å‹çµæœ (x86_64):
// relaxed: ~1 ns
// acquire: ~1 ns
// release: ~1 ns
// acqrel:  ~1 ns
// seqcst:  ~3 ns (éœ€è¦å…§å­˜æŸµæ¬„)
```

---

## æœ€ä½³å¯¦è¸

### 1. é¸æ“‡åˆé©çš„å…§å­˜é †åº

```rust
// âœ… ç°¡å–®è¨ˆæ•¸å™¨ï¼šRelaxed
static COUNTER: AtomicU64 = AtomicU64::new(0);
COUNTER.fetch_add(1, Ordering::Relaxed);

// âœ… åŒæ­¥æ¨™èªŒï¼šAcquire/Release
static READY: AtomicBool = AtomicBool::new(false);
READY.store(true, Ordering::Release);
while !READY.load(Ordering::Acquire) {}

// âœ… éœ€è¦å…¨å±€é †åºï¼šSeqCst
static FLAG1: AtomicBool = AtomicBool::new(false);
static FLAG2: AtomicBool = AtomicBool::new(false);
FLAG1.store(true, Ordering::SeqCst);
FLAG2.store(true, Ordering::SeqCst);
```

### 2. é¿å… ABA å•é¡Œ

```rust
// âŒ ABA å•é¡Œç¯„ä¾‹
// ç·šç¨‹ A: è®€å– head (æŒ‡å‘ node1)
// ç·šç¨‹ B: pop node1, pop node2, push node1 (head åˆæŒ‡å‘ node1)
// ç·šç¨‹ A: CAS æˆåŠŸ (ä½† node1 å·²è¢«é‡ç”¨)

// âœ… è§£æ±ºæ–¹æ¡ˆï¼šä½¿ç”¨ç‰ˆæœ¬è™Ÿ
struct VersionedPtr<T> {
    ptr: *mut T,
    version: usize,
}

let versioned = AtomicU128::new(pack_versioned_ptr(ptr, 0));

// æˆ–ä½¿ç”¨ epoch-based reclamation (å¦‚ crossbeam-epoch)
```

### 3. æ€§èƒ½æç¤º

```rust
// âœ… åœ¨è‡ªæ—‹å¾ªç’°ä¸­ä½¿ç”¨ spin_loop
while locked.load(Ordering::Relaxed) {
    std::hint::spin_loop();  // å‘Šè¨´ CPU é€™æ˜¯è‡ªæ—‹ï¼Œé™ä½åŠŸè€—
}

// âœ… ä½¿ç”¨ compare_exchange_weak åœ¨å¾ªç’°ä¸­
loop {
    match atomic.compare_exchange_weak(old, new, Ordering::AcqRel, Ordering::Acquire) {
        Ok(_) => break,
        Err(current) => old = current,
    }
}
```

---

## åƒè€ƒè³‡æ–™ (References)

1. [Rust Atomics and Locks](https://marabos.nl/atomics/) (Mara Bos, 2023)
2. [C++ Memory Model](https://en.cppreference.com/w/cpp/atomic/memory_order)
3. [The Rustonomicon - Atomics](https://doc.rust-lang.org/nomicon/atomics.html)
4. [Linux Kernel Memory Barriers](https://www.kernel.org/doc/Documentation/memory-barriers.txt)
5. ã€ŠThe Art of Multiprocessor Programmingã€‹ (Herlihy & Shavit, 2020)

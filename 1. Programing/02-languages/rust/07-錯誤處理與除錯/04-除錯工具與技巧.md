# é™¤éŒ¯å·¥å…·èˆ‡æŠ€å·§

> åŸºæ–¼ Rust 1.90+ (2025) | é«˜æ•ˆå®šä½å’Œè§£æ±ºå•é¡Œ

## ğŸ“‹ æ¦‚è¿°

è‰¯å¥½çš„é™¤éŒ¯èƒ½åŠ›æ˜¯é–‹ç™¼è€…çš„æ ¸å¿ƒæŠ€èƒ½ã€‚æœ¬ç« ä»‹ç´¹ Rust ç”Ÿæ…‹ä¸­çš„å„ç¨®é™¤éŒ¯å·¥å…·ã€æŠ€å·§å’Œæœ€ä½³å¯¦è¸,å¹«åŠ©ä½ å¿«é€Ÿå®šä½å’Œè§£æ±ºå•é¡Œã€‚

---

## ğŸ” åŸºç¤é™¤éŒ¯æŠ€å·§

### ä½¿ç”¨ println! å’Œ dbg! å®

#### println! - åŸºæœ¬è¼¸å‡º

```rust
fn calculate(a: i32, b: i32) -> i32 {
    println!("calculate called with a={}, b={}", a, b);
    let result = a + b;
    println!("result: {}", result);
    result
}

fn main() {
    let x = 10;
    let y = 20;
    println!("x = {}, y = {}", x, y);
    
    let sum = calculate(x, y);
    println!("sum = {}", sum);
}
```

#### dbg! - é™¤éŒ¯è¼¸å‡º (Rust 1.32+)

```rust
fn main() {
    let x = 10;
    let y = 20;
    
    // dbg! æœƒæ‰“å°è¡¨é”å¼å’Œå€¼,ä¸¦è¿”å›å€¼çš„æ‰€æœ‰æ¬Š
    let sum = dbg!(x + y);
    // è¼¸å‡º: [src/main.rs:5] x + y = 30
    
    // å¯ä»¥ç”¨æ–¼è¡¨é”å¼ä¸­é–“
    let result = dbg!(x) + dbg!(y);
    // è¼¸å‡º:
    // [src/main.rs:9] x = 10
    // [src/main.rs:9] y = 20
    
    // æŸ¥çœ‹è¤‡é›œè¡¨é”å¼
    let data = vec![1, 2, 3];
    dbg!(&data);
    // è¼¸å‡º: [src/main.rs:15] &data = [1, 2, 3]
    
    // éˆå¼èª¿ç”¨
    let result = some_value
        .map(|x| dbg!(x * 2))  // æ‰“å°ä¸­é–“å€¼
        .filter(|x| dbg!(*x > 10));
}
```

**dbg! vs println!**:

| ç‰¹æ€§ | println! | dbg! |
|------|----------|------|
| è¼¸å‡ºä½ç½® | stdout | stderr |
| é¡¯ç¤ºæ–‡ä»¶/è¡Œè™Ÿ | âŒ | âœ… |
| é¡¯ç¤ºè¡¨é”å¼ | âŒ | âœ… |
| è¿”å›å€¼ | ç„¡ | è¿”å›è¡¨é”å¼çš„å€¼ |
| ä½¿ç”¨å ´æ™¯ | ç”¨æˆ¶è¼¸å‡º | é™¤éŒ¯è¼¸å‡º |

### ä½¿ç”¨ eprintln! éŒ¯èª¤è¼¸å‡º

```rust
fn process_file(path: &str) -> Result<(), String> {
    eprintln!("Processing file: {}", path);  // éŒ¯èª¤æµè¼¸å‡º
    
    if !std::path::Path::new(path).exists() {
        eprintln!("Error: file not found: {}", path);
        return Err("file not found".to_string());
    }
    
    Ok(())
}

// ä½¿ç”¨
// $ cargo run 2> errors.log  # é‡å®šå‘éŒ¯èª¤è¼¸å‡º
```

---

## ğŸ¯ RUST_BACKTRACE å †ç–Šè¿½è¹¤

### å•Ÿç”¨å †ç–Šè¿½è¹¤

```rust
fn level_3() {
    panic!("Something went wrong!");
}

fn level_2() {
    level_3();
}

fn level_1() {
    level_2();
}

fn main() {
    level_1();
}
```

**é‹è¡Œ**:
```bash
# ç°¡çŸ­å †ç–Šè¿½è¹¤
$ RUST_BACKTRACE=1 cargo run

# å®Œæ•´å †ç–Šè¿½è¹¤
$ RUST_BACKTRACE=full cargo run
```

**è¼¸å‡ºç¯„ä¾‹**:
```
thread 'main' panicked at 'Something went wrong!', src/main.rs:2:5
stack backtrace:
   0: rust_begin_unwind
   1: core::panicking::panic_fmt
   2: demo::level_3
             at ./src/main.rs:2:5
   3: demo::level_2
             at ./src/main.rs:6:5
   4: demo::level_1
             at ./src/main.rs:10:5
   5: demo::main
             at ./src/main.rs:14:5
```

### ç¨‹å¼åŒ–æ•ç²å †ç–Šè¿½è¹¤

```rust
use std::backtrace::Backtrace;

fn capture_trace() {
    let trace = Backtrace::capture();
    println!("Backtrace:\n{}", trace);
}

fn main() {
    capture_trace();
}
```

### è‡ªå®šç¾© Panic Hook

```rust
use std::panic;

fn main() {
    // è¨­ç½®è‡ªå®šç¾© panic hook
    panic::set_hook(Box::new(|panic_info| {
        eprintln!("========== PANIC ==========");
        
        if let Some(location) = panic_info.location() {
            eprintln!("Panic occurred in file '{}' at line {}",
                     location.file(),
                     location.line());
        }
        
        if let Some(message) = panic_info.payload().downcast_ref::<&str>() {
            eprintln!("Panic message: {}", message);
        }
        
        eprintln!("==========================");
    }));
    
    panic!("Test panic");
}
```

---

## ğŸ› ï¸ ä½¿ç”¨é™¤éŒ¯å™¨

### rust-gdb (Linux/macOS)

#### å®‰è£èˆ‡åŸºæœ¬ä½¿ç”¨

```bash
# ç·¨è­¯ç‚º debug æ¨¡å¼
$ cargo build

# å•Ÿå‹• gdb
$ rust-gdb target/debug/my_program

# å¸¸ç”¨å‘½ä»¤
(gdb) break main              # åœ¨ main è¨­ç½®æ–·é»
(gdb) break file.rs:42        # åœ¨ç‰¹å®šè¡Œè¨­ç½®æ–·é»
(gdb) run                     # é‹è¡Œç¨‹åº
(gdb) next                    # ä¸‹ä¸€è¡Œ (ä¸é€²å…¥å‡½æ•¸)
(gdb) step                    # ä¸‹ä¸€æ­¥ (é€²å…¥å‡½æ•¸)
(gdb) continue                # ç¹¼çºŒåŸ·è¡Œ
(gdb) print variable_name     # æ‰“å°è®Šé‡å€¼
(gdb) backtrace              # æŸ¥çœ‹å †ç–Š
(gdb) quit                    # é€€å‡º
```

#### å¯¦æˆ°ç¯„ä¾‹

```rust
// src/main.rs
fn factorial(n: u64) -> u64 {
    if n == 0 {
        1
    } else {
        n * factorial(n - 1)
    }
}

fn main() {
    let result = factorial(5);
    println!("Result: {}", result);
}
```

**é™¤éŒ¯éç¨‹**:
```bash
$ cargo build
$ rust-gdb target/debug/my_program

(gdb) break factorial
(gdb) run
# ç¨‹åºåœ¨ factorial åœæ­¢

(gdb) print n
$1 = 5

(gdb) next
(gdb) print n
$2 = 4

(gdb) backtrace
#0  factorial (n=4) at src/main.rs:2
#1  factorial (n=5) at src/main.rs:5
#2  main () at src/main.rs:10
```

### rust-lldb (macOS)

```bash
# å•Ÿå‹• lldb
$ rust-lldb target/debug/my_program

# å¸¸ç”¨å‘½ä»¤ (èˆ‡ gdb é¡ä¼¼)
(lldb) breakpoint set --name main
(lldb) breakpoint set --file main.rs --line 42
(lldb) run
(lldb) next
(lldb) step
(lldb) continue
(lldb) print variable_name
(lldb) bt                     # backtrace
(lldb) quit
```

### VS Code é™¤éŒ¯é…ç½®

**.vscode/launch.json**:
```json
{
    "version": "0.2.0",
    "configurations": [
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug executable 'my_program'",
            "cargo": {
                "args": [
                    "build",
                    "--bin=my_program",
                    "--package=my_package"
                ],
                "filter": {
                    "name": "my_program",
                    "kind": "bin"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        },
        {
            "type": "lldb",
            "request": "launch",
            "name": "Debug unit tests",
            "cargo": {
                "args": [
                    "test",
                    "--no-run",
                    "--lib",
                    "--package=my_package"
                ],
                "filter": {
                    "name": "my_package",
                    "kind": "lib"
                }
            },
            "args": [],
            "cwd": "${workspaceFolder}"
        }
    ]
}
```

---

## ğŸ“Š æ—¥èªŒèˆ‡è¿½è¹¤

### ä½¿ç”¨ log crate

#### åŸºæœ¬è¨­ç½®

```toml
[dependencies]
log = "0.4"
env_logger = "0.11"
```

```rust
use log::{debug, error, info, trace, warn};

fn process_data(data: &[u8]) {
    trace!("Entering process_data with {} bytes", data.len());
    
    if data.is_empty() {
        warn!("Received empty data");
        return;
    }
    
    info!("Processing {} bytes of data", data.len());
    
    // è™•ç†é‚è¼¯
    if let Err(e) = do_process(data) {
        error!("Failed to process data: {}", e);
        return;
    }
    
    debug!("Data processed successfully");
}

fn main() {
    // åˆå§‹åŒ–æ—¥èªŒ
    env_logger::init();
    
    process_data(&[1, 2, 3, 4, 5]);
}
```

**é‹è¡Œ**:
```bash
# è¨­ç½®æ—¥èªŒç´šåˆ¥
$ RUST_LOG=debug cargo run
$ RUST_LOG=info cargo run
$ RUST_LOG=trace cargo run

# é‡å°ç‰¹å®šæ¨¡çµ„
$ RUST_LOG=my_crate::module=debug cargo run

# å¤šå€‹æ¨¡çµ„
$ RUST_LOG=my_crate=debug,other_crate=info cargo run
```

### ä½¿ç”¨ tracing (æ¨è–¦)

#### åŸºæœ¬è¨­ç½®

```toml
[dependencies]
tracing = "0.1"
tracing-subscriber = "0.3"
```

```rust
use tracing::{debug, error, info, instrument, span, warn, Level};

#[instrument]  // è‡ªå‹•è¨˜éŒ„å‡½æ•¸é€²å‡º
fn process_user(user_id: u64, name: &str) -> Result<(), String> {
    info!("Processing user");
    
    let span = span!(Level::DEBUG, "validation");
    let _enter = span.enter();
    
    if name.is_empty() {
        error!("Invalid name");
        return Err("name cannot be empty".to_string());
    }
    
    debug!(user_id, name, "User validated");
    Ok(())
}

fn main() {
    // åˆå§‹åŒ– subscriber
    tracing_subscriber::fmt()
        .with_max_level(Level::DEBUG)
        .init();
    
    process_user(123, "Alice").ok();
}
```

**è¼¸å‡º**:
```
2025-01-17T10:30:45.123Z INFO  process_user{user_id=123 name="Alice"}: Processing user
2025-01-17T10:30:45.124Z DEBUG validation{user_id=123 name="Alice"}: User validated
```

#### çµæ§‹åŒ–æ—¥èªŒ

```rust
use tracing::{info, instrument};

#[derive(Debug)]
struct Request {
    id: String,
    method: String,
    path: String,
}

#[instrument(skip(req), fields(request_id = %req.id, method = %req.method))]
async fn handle_request(req: Request) {
    info!(path = %req.path, "Handling request");
    
    // è™•ç†é‚è¼¯
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    
    info!("Request completed");
}

#[tokio::main]
async fn main() {
    tracing_subscriber::fmt::init();
    
    let req = Request {
        id: "req-123".to_string(),
        method: "GET".to_string(),
        path: "/api/users".to_string(),
    };
    
    handle_request(req).await;
}
```

---

## ğŸ¨ color-backtrace ç¾åŒ–è¼¸å‡º

### å®‰è£èˆ‡ä½¿ç”¨

```toml
[dependencies]
color-backtrace = "0.6"
```

```rust
fn main() {
    color_backtrace::install();
    
    // ä½ çš„ç¨‹å¼ç¢¼
    panic!("Oops!");
}
```

**æ•ˆæœ**: æä¾›å½©è‰²çš„ã€æ›´æ˜“è®€çš„ panic è¼¸å‡ºã€‚

---

## ğŸ”§ å¯¦ç”¨é™¤éŒ¯å·¥å…·

### cargo-expand æŸ¥çœ‹å®å±•é–‹

```bash
# å®‰è£
$ cargo install cargo-expand

# æŸ¥çœ‹å®å±•é–‹
$ cargo expand

# æŸ¥çœ‹ç‰¹å®šæ¨¡çµ„
$ cargo expand module::submodule

# æŸ¥çœ‹ç‰¹å®šå‡½æ•¸
$ cargo expand main
```

**ç¯„ä¾‹**:
```rust
// åŸå§‹ä»£ç¢¼
#[derive(Debug)]
struct User {
    name: String,
    age: u32,
}

// å±•é–‹å¾Œ
impl std::fmt::Debug for User {
    fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
        f.debug_struct("User")
            .field("name", &self.name)
            .field("age", &self.age)
            .finish()
    }
}
```

### cargo-tree æŸ¥çœ‹ä¾è³´æ¨¹

```bash
# å®‰è£ (Rust 1.44+ å…§å»º)
$ cargo tree

# é¡¯ç¤ºç‰¹å®šåŒ…çš„ä¾è³´
$ cargo tree -p tokio

# é¡¯ç¤ºåå‘ä¾è³´
$ cargo tree -i serde

# é¡¯ç¤ºç‰¹å®š feature
$ cargo tree -f "{p} {f}"
```

### cargo-bloat åˆ†æäºŒé€²åˆ¶å¤§å°

```bash
# å®‰è£
$ cargo install cargo-bloat

# åˆ†æ
$ cargo bloat --release

# åˆ†æç‰¹å®š crate
$ cargo bloat --release --crates

# åˆ†æå‡½æ•¸å¤§å°
$ cargo bloat --release -n 20
```

---

## ğŸ¯ é™¤éŒ¯æŠ€å·§é›†

### æŠ€å·§ 1: æ¢ä»¶ç·¨è­¯é™¤éŒ¯ä»£ç¢¼

```rust
#[cfg(debug_assertions)]
macro_rules! debug_print {
    ($($arg:tt)*) => {
        eprintln!("[DEBUG] {}", format!($($arg)*));
    };
}

#[cfg(not(debug_assertions))]
macro_rules! debug_print {
    ($($arg:tt)*) => {
        // Release æ¨¡å¼ä¸‹ä¸è¼¸å‡º
    };
}

fn main() {
    debug_print!("This only prints in debug mode");
    
    let x = 42;
    debug_print!("x = {}", x);
}
```

### æŠ€å·§ 2: ä½¿ç”¨ #[track_caller] è¿½è¹¤èª¿ç”¨ä½ç½®

```rust
#[track_caller]
fn assert_positive(n: i32) {
    if n <= 0 {
        panic!("Expected positive number, got {}", n);
    }
}

fn main() {
    assert_positive(10);  // OK
    assert_positive(-5);  // Panic æœƒé¡¯ç¤ºé€™è¡Œçš„ä½ç½®
}
```

### æŠ€å·§ 3: è‡ªå®šç¾© Debug è¼¸å‡º

```rust
use std::fmt;

struct SensitiveData {
    username: String,
    password: String,
    token: String,
}

impl fmt::Debug for SensitiveData {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        f.debug_struct("SensitiveData")
            .field("username", &self.username)
            .field("password", &"<redacted>")
            .field("token", &"<redacted>")
            .finish()
    }
}

fn main() {
    let data = SensitiveData {
        username: "alice".to_string(),
        password: "secret123".to_string(),
        token: "abc123xyz".to_string(),
    };
    
    println!("{:?}", data);
    // è¼¸å‡º: SensitiveData { username: "alice", password: "<redacted>", token: "<redacted>" }
}
```

### æŠ€å·§ 4: ä½¿ç”¨ Option/Result çš„ inspect æ–¹æ³•

```rust
fn main() {
    let result = calculate()
        .inspect(|val| eprintln!("Success: {}", val))
        .inspect_err(|err| eprintln!("Error: {}", err));
}

fn calculate() -> Result<i32, String> {
    Ok(42)
}
```

### æŠ€å·§ 5: è‡¨æ™‚æ–·è¨€

```rust
fn process_data(data: &[u8]) {
    debug_assert!(!data.is_empty(), "data should not be empty");
    debug_assert!(data.len() <= 1024, "data too large: {}", data.len());
    
    // debug_assert! åªåœ¨ debug æ¨¡å¼ä¸‹åŸ·è¡Œ
    // release æ¨¡å¼ä¸‹æœƒè¢«å„ªåŒ–æ‰
}
```

---

## ğŸ“Š å®Œæ•´ç¯„ä¾‹: é™¤éŒ¯è¤‡é›œå•é¡Œ

```rust
use tracing::{debug, error, info, instrument, warn};
use tracing_subscriber;

#[derive(Debug)]
struct Config {
    database_url: String,
    max_connections: u32,
}

#[instrument]
fn load_config() -> Result<Config, String> {
    info!("Loading configuration");
    
    let config = Config {
        database_url: std::env::var("DATABASE_URL")
            .inspect_err(|e| error!("DATABASE_URL not set: {}", e))
            .map_err(|e| format!("Missing DATABASE_URL: {}", e))?,
        max_connections: std::env::var("MAX_CONNECTIONS")
            .ok()
            .and_then(|s| s.parse().ok())
            .inspect(|v| debug!("Parsed MAX_CONNECTIONS: {}", v))
            .unwrap_or_else(|| {
                warn!("MAX_CONNECTIONS not set, using default: 10");
                10
            }),
    };
    
    debug!(?config, "Configuration loaded");
    Ok(config)
}

#[instrument(skip(config))]
async fn connect_database(config: &Config) -> Result<(), String> {
    info!(url = %config.database_url, "Connecting to database");
    
    // æ¨¡æ“¬é€£æ¥
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    
    if config.database_url.is_empty() {
        error!("Invalid database URL");
        return Err("invalid database URL".to_string());
    }
    
    info!("Database connected successfully");
    Ok(())
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // è¨­ç½®æ—¥èªŒ
    tracing_subscriber::fmt()
        .with_max_level(tracing::Level::DEBUG)
        .with_target(false)
        .with_thread_ids(true)
        .with_file(true)
        .with_line_number(true)
        .init();
    
    // è¨­ç½® panic hook
    std::panic::set_hook(Box::new(|panic_info| {
        error!("Application panicked: {:?}", panic_info);
    }));
    
    // è¨­ç½®ç’°å¢ƒè®Šé‡ (ç¤ºä¾‹)
    std::env::set_var("DATABASE_URL", "postgres://localhost");
    
    // è¼‰å…¥é…ç½®
    let config = load_config()
        .inspect_err(|e| error!("Failed to load config: {}", e))?;
    
    // é€£æ¥è³‡æ–™åº«
    connect_database(&config)
        .await
        .inspect_err(|e| error!("Failed to connect to database: {}", e))?;
    
    info!("Application started successfully");
    Ok(())
}
```

---

## ğŸ” å¸¸è¦‹å•é¡Œé™¤éŒ¯

### å•é¡Œ 1: Lifetime éŒ¯èª¤

```rust
// âŒ éŒ¯èª¤
fn get_first<'a>(data: &'a Vec<String>) -> &'a str {
    &data[0]  // ç·¨è­¯éŒ¯èª¤: è¿”å›å€¼ç”Ÿå‘½é€±æœŸä¸åŒ¹é…
}

// âœ… æ­£ç¢º
fn get_first(data: &Vec<String>) -> &str {
    &data[0]  // ç·¨è­¯å™¨è‡ªå‹•æ¨æ–·ç”Ÿå‘½é€±æœŸ
}

// é™¤éŒ¯æŠ€å·§: ä½¿ç”¨ cargo-expand æŸ¥çœ‹ç”Ÿå‘½é€±æœŸæ¨™è¨»
```

### å•é¡Œ 2: å€Ÿç”¨æª¢æŸ¥éŒ¯èª¤

```rust
// âŒ éŒ¯èª¤
let mut vec = vec![1, 2, 3];
let first = &vec[0];
vec.push(4);  // éŒ¯èª¤: ä¸èƒ½åœ¨æœ‰ä¸å¯è®Šå€Ÿç”¨æ™‚ä¿®æ”¹
println!("{}", first);

// âœ… æ­£ç¢º: ç¸®å°å€Ÿç”¨ç¯„åœ
let mut vec = vec![1, 2, 3];
{
    let first = &vec[0];
    println!("{}", first);
}  // first çš„å€Ÿç”¨çµæŸ
vec.push(4);  // OK

// é™¤éŒ¯æŠ€å·§: ä»”ç´°é–±è®€ç·¨è­¯å™¨éŒ¯èª¤ä¿¡æ¯,å®ƒæœƒæŒ‡å‡ºå€Ÿç”¨ä½ç½®
```

### å•é¡Œ 3: å¾ªç’°å¼•ç”¨å°è‡´å…§å­˜æ´©æ¼

```rust
use std::rc::Rc;
use std::cell::RefCell;

#[derive(Debug)]
struct Node {
    value: i32,
    next: Option<Rc<RefCell<Node>>>,
}

// âŒ å¯èƒ½å°è‡´å¾ªç’°å¼•ç”¨
let a = Rc::new(RefCell::new(Node { value: 1, next: None }));
let b = Rc::new(RefCell::new(Node { value: 2, next: Some(a.clone()) }));
a.borrow_mut().next = Some(b.clone());  // å¾ªç’°å¼•ç”¨!

// âœ… ä½¿ç”¨ Weak æ‰“ç ´å¾ªç’°
use std::rc::Weak;

struct BetterNode {
    value: i32,
    next: Option<Rc<RefCell<BetterNode>>>,
    prev: Option<Weak<RefCell<BetterNode>>>,  // ä½¿ç”¨ Weak
}

// é™¤éŒ¯æŠ€å·§: ä½¿ç”¨ valgrind æˆ– AddressSanitizer æª¢æ¸¬å…§å­˜æ´©æ¼
```

---

## ğŸ“ é™¤éŒ¯æª¢æŸ¥æ¸…å–®

### é–‹å§‹é™¤éŒ¯å‰

- [ ] é–±è®€å®Œæ•´çš„éŒ¯èª¤ä¿¡æ¯
- [ ] æª¢æŸ¥æœ€è¿‘çš„ä»£ç¢¼æ›´æ”¹
- [ ] ç¢ºèªå•é¡Œæ˜¯å¯é‡ç¾çš„
- [ ] æŸ¥çœ‹ç›¸é—œæ—¥èªŒè¼¸å‡º

### é™¤éŒ¯éç¨‹ä¸­

- [ ] ä½¿ç”¨ `RUST_BACKTRACE=1` æŸ¥çœ‹å †ç–Šè¿½è¹¤
- [ ] æ·»åŠ  `dbg!()` æˆ– `println!()` è¼¸å‡ºé—œéµè®Šé‡
- [ ] ä½¿ç”¨é™¤éŒ¯å™¨è¨­ç½®æ–·é»
- [ ] æª¢æŸ¥ Clippy è­¦å‘Š: `cargo clippy`
- [ ] é‹è¡Œæ¸¬è©¦: `cargo test`

### é™¤éŒ¯å®Œæˆå¾Œ

- [ ] ç§»é™¤è‡¨æ™‚çš„ `dbg!()` å’Œ `println!()`
- [ ] æ·»åŠ æ¸¬è©¦è¦†è“‹æ­¤å•é¡Œ
- [ ] æ›´æ–°æ–‡æª”
- [ ] æª¢æŸ¥æ˜¯å¦æœ‰é¡ä¼¼å•é¡Œ

---

## ğŸ“– åƒè€ƒè³‡æ–™

1. [The Rust Programming Language - Debugging](https://doc.rust-lang.org/book/)
2. [Rust GDB Documentation](https://sourceware.org/gdb/current/onlinedocs/gdb/)
3. [LLDB Debugging Guide](https://lldb.llvm.org/use/tutorial.html)
4. [tracing Documentation](https://docs.rs/tracing/)
5. [The Little Book of Rust Macros](https://veykril.github.io/tlborm/)
6. [Rust Performance Book](https://nnethercote.github.io/perf-book/)

---

*æœ€å¾Œæ›´æ–°: 2025-01-17*  
*Rust ç‰ˆæœ¬: 1.90+*

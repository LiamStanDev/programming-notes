### 基本介紹
EF core 使用 metadata 來描述 model，用於映射到數據庫與建立合適存儲的數據型態。
配置方式有以下兩種:
1. mapping attributes: 也就是 data annotation
2. calling ModelBuilder method: 稱作 fluent API

## 配置 Model
---
優先級: Conventions < mapping attributes < fluent API
> Model 指的是 DbContext 而 Entity 指的是 Domain

### 方式一: mapping attributes
```c#
[Table("products")]
public class Product {
    [Key]
    public int ProductId { get; set; }
    [Required]
    public string Name { get; set; }
    public string Description { get; set; }
    public long Price { get; set; }
    public string PictureUrl { get; set; }
    public string Type { get; set; }
    public string Brand { get; set; }
    public int QuantityInStock { get; set; }
}
```
* Table: 指定 mapping 到的 talbe 名稱

### 方式二: fluent API
有三種方式，差別只是放在不同的地方:

1. **全部方在 DbContext 中** (最常見)
在 DbContext 的子類中重寫 OnModelCreating方法。
```c#
public class StoreContext : DbContext {

    public StoreContext(DbContextOptions options) : base(options) {
    }

    public DbSet<Product> Products { get; set; }

    protected override void OnModelCreating(ModelBuilder builder) {
	    base.OnModelCreating(builder); // neccessary
	    
        builder.Entity<Product>()
	        .ToTable("products")
            .Property(p => p.Id)
            .IsRequired();
    }
}
```
* 上述程式做以下事情:
	1. 從 ModelBuilder 取得指定 Entity，也可以使用 `builder.Entity(typeof(Product))`
	2. 取得 EntityTypeBuilder 後，使用 ToTable 設定 table 名稱，返回 EntityTypeBuilder
	4. 取得 EntityTypeBuilder 後，使用 Property 取得指定屬性
	5. 取得 PropertyBuilder 後，設定該屬性配置

2. 獨立出一個類，**由 DbContext 呼叫**
該方式是減少 DbContext 的程式碼大小，需要建立一個類實現 `IEntityTypeConfiguration<TEntity>`
```c#
public class ProductEntityTypeConfiguration : IEntityTypeConfiguration<Product> {
	public void Configure(EntityTypeBuilder<Product> builder) {
		builder
			.Property(p => p.Id)
			.IsRequired();
	}
}
```
在 OnModelCreating 中建立實例，並呼叫 Configure 方法
```c#
protected override void OnModelCreating(ModelBuilder builder) {
	new ProductEntityTypeConfiguration().Configure(builder.Entity<Product>());
}
```

3. 獨立出一個類，**放在 Entity 的 attribute 中**
好處是可以直接在 Entity 上看到指定的配置。與 2. 相同建立一個類實現`IEntityTypeConfiguration<TEntity>` 在 Model 上使用。
```c#
[EntityTypeConfiguration(typeof(ProductEntityTypeConfiguration))]
public class Product {
    public int Id { get; set; }
    public string Name { get; set; }
    public string Description { get; set; }
    public long Price { get; set; }
    public string PictureUrl { get; set; }
    public string Type { get; set; }
    public string Brand { get; set; }
    public int QuantityInStock { get; set; }
}
```


## 配置選項
---
### 用在 Entity 上
#### Table name & schema
* Data Annotation
```c#
[Table("products", Schema = "producing")]
public class Product {
	...
}
```
* Fluent API
```c# 
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
    modelBuilder.Entity<Blog>()
        .ToTable("blogs", schema: "blogging");
}
```
> schema 是可選的

#### Excluding
* Data Annotation: 使用 `[NotMapped]` 
* Fluent API: 使用 `Ignore<TEntity>()` 方法
```c#
protected override void OnModelCreating(ModelBuilder builder) {
	builder.Ignore<Product>();
}
```
#### View Mapping
* Data Annotation: 無法
* Fluent API
```c#
modelBuilder.Entity<Blog>()
    .ToView("blogsView", schema: "blogging");
```
### 用在 Property　上
#### Excluding 
* Data Annotation: `[NotMapped]`
* Fluent API
```c#
modelBuilder.Entity<Product>.Ignore(p => p.PictureUrl);
```

#### Column name
* Data Annotation: `[Column("col_name")`
* Fluent API
```c#
public class Blog
{
    [Column("blog_id")]
    public int BlogId { get; set; }
}
```

#### Column Data Type
* Data Annotation: 
```c#
public class Blog
{
    public int BlogId { get; set; }

    [Column(TypeName = "varchar(200)")]
    public string Url { get; set; }

    [Column(TypeName = "decimal(5, 2)")]
    public decimal Rating { get; set; }
}
```
* Fluent API
```c#
protected override void OnModelCreating(ModelBuilder builder)
{
	base.OnModelCreating(builder); // neccessary
    builder.Entity<Blog>(
        eb =>
        {
            eb.Property(b => b.Url).HasColumnType("varchar(200)");
            eb.Property(b => b.Rating).HasColumnType("decimal(5, 2)");
        });
}
```

### 設定 Keys
#### Primary Key
* 方式一: 命名使用 Id 結尾

* 方式二: 在對應 Property 上使用 `[Key]`
```c#
public class Product {
	public Guid ProductId { get; set; }
	...
}
```

* 方式三: 在 class 上使用 `[PrimaryKey]
這個方式好處是可以指定多個 column 合成一個 primary key。
```c#
[PrimaryKey(nameof(State), nameof(LicensePlate))]
internal class Car
{
    public string State { get; set; }
    public string LicensePlate { get; set; }
	...
}
```

* 方式三: Fluent API
在 Net 6 之前只能使用這種方式配置多個 Primary Key
```c#
protected override void OnModelCreating(ModelBuilder builder) {
	base.OnModelCreating(builder); // neccessary
	builder.Entity<Car>().HasKey( c => new { c.State, c.LicensePlate });
}
```

#### Alternate Key
用來作為 Primary key 的替代，與 Primary key 一樣有相同的唯一識別性。
> EFCore 建議不要為了將一個 Column 設定為 unique key 而將其設定為 alternate key，因為語意不同。
```c#
protected override void OnModelCreating(ModelBuilder modelBuilder)
{
	base.OnModelCreating(builder); // neccessary
    modelBuilder.Entity<Car>()
        .HasAlternateKey(c => c.LicensePlate);
}
```



## Relations
---
* Foreign key: 用於指定關係表的 Primary key
* Principle key: 用於指定關係表的 Alternate key

> 以下的 RelationShip 是否需要使用 Fluent API 或這 Data Annotation，一般情況不需要，可以先觀察 migrations 後的 .cs 文件是否符合需求再調整。

* Has 表示該 entity, With 表示對象
### One-to-many
例子: 一個 Blog 可以有很多個 Post，但一個 Post 只能在一個 Blog。
在 MySQL 中如下
```mysql
CREATE TABLE Blogs ( 
	Id INT AUTO_INCREMENT PRIMARY KEY
);

CREATE TABLE Posts (
	Id INT AUTO_INCREMENT PRIMARY KEY,
	BlogId INT,
	FOREIGN KEY (BlogId) References Blog(Id)  
);
```

1. Entity 設定
```c#
public class Blog {
	public int Id { get; set; }
	public ICollection<Post> Posts { get; set; }; // navigator
}

public class Post {
	public int Id { get; set; }
	public int BlogId { get; set; } // Foreign key
	public Blog Blog { get; set; } // navigator
}
```

2. 在 OnModelCreating 配置 (默認已經配置好了)
* 寫法一:
```c#
protected override void OnModelCreating(ModelBuilder builder) {
	base.OnModelCreating(builder); // neccessary
	builder.Entity<Blog>()
		.HashMany(b => b.Posts)
		.WithOne(p => p.Blog)
		.HasForeignKey(p => p.BlogId)
		.IsRequired();
}
```
上面表示 Blog 有多個 Posts，Post 只有一個 Blog，Post 中有一個 BlogId 作為 ForeignKey，最後這個關係是一定存在的 (表示Blog 中的 Post 不會為空)。
* 寫法二: 跟寫法一相反者寫
```c#
protected override void OnModelCreating(ModelBuilder builder) {
	base.OnModelCreating(builder); // neccessary
	builder.Entity<Post>()
		.HasOne(p => p.Blog)
		.WithMany(b => b.Posts)
		.HasForeignKey(p => p.BlogId)
		.IsRequired();
}
```

> 若關係可以為空，使用 IsRequired(false)
> ForeignKey 可以使用 Convension，他會默認知道是哪個

#### 其他內容
1. 可以去掉 Post 中的 BlogId 屬性
```c#
protected override void OnModelCreating(ModelBuilder builder) {
	base.OnModelCreating(builder); // neccessary
	builder.Entity<Post>()
		.HasOne(p => p.Blog)
		.WithMany(b => b.Posts)
		.HasForeignKey("blog_id")
		.IsRequired();
}
```
2. 可以設定 Composite foreign key
3. 可以設定 On Delete Cascade
source: [詳情請見 Doc](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/one-to-many)

### One-to-one
很簡單跳過...

### Many-to-many
例子: 一個 Post 會有很多 Tag，一個 Tag 也會有多個 Post。
Many-to-many relation 不能像其他兩個關係一樣，可以只透過一個 Foreign key 就能描述，需要將每一個 Post 與 Tag 的關係用另外一個表來記錄。在 mysql 如下
```mysql
CREATE TABLE Posts (
    Id INT NOT NULL AUTO_INCREMENT,
    PRIMARY KEY (Id)
);

CREATE TABLE Tags (
    Id INT NOT NULL AUTO_INCREMENT,
    PRIMARY KEY (Id)
);

CREATE TABLE PostTag (
    PostsId INT NOT NULL,
    TagsId INT NOT NULL,
    PRIMARY KEY (PostsId, TagsId),
    FOREIGN KEY (PostsId) REFERENCES Posts (Id) ON DELETE CASCADE,
    FOREIGN KEY (TagsId) REFERENCES Tags (Id) ON DELETE CASCADE
);
```

1. Entity 設定
```c#
public class Post {
    public int Id { get; set; }
    public List<PostTag> PostTags { get; }
}

public class Tag {
    public int Id { get; set; }
    public List<PostTag> PostTags { get; }
}
```
其實做到這邊 EF core 就會自動的生成 PostTag 表了，我們並不用手動操作且也不建議自己手動操作。
[更多內容](https://learn.microsoft.com/en-us/ef/core/modeling/relationships/many-to-many)

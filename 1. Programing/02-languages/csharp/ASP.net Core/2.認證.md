source: https://www.youtube.com/watch?v=02Yh3sxzAYI&t=1009s
# Info
---
### 認證的種類
1. **Cookie** for browser based authentication
2. Google, Facebook, and **other proprietary providers**
3. OpenID Connect / WS-Federation for **standards-based external authentication**
4. **JSON web token** (JWT) for token-based API authentication
每一種都可以是一個 handler 處理 Authentication，在中 ASP.NET 添加 handler 使用以下方式
```csharp
serverice.AddAuthentication(defaulScheme: "cookies")
	.AddCookies(scheme: "cookies")
	.AddGoogle(scheme: "google")
	.AddOpenIdConnect(scheme: "idsrv") // idsrc stands for idneity server
// ...
app.UseAuthentication();
```

# 基本概念
## Claim
---
Cliam 是關於一個人或者組織的陳述，比如說 Name、Role 等等，本質上就是一個鍵值對，是一種通用的保存用戶信息的方式。

### Cliam 類
在 Asp.net core 中使用 Claim 類來表示**用戶身份的一筆信息**，不用想的太複雜就是**一個鍵值對**，就是 key 與 value 都是字符串。
#### Constructor
```csharp
public Claim (string type, string value);

public Claim (string type, string value, string? valueType);

public Claim (string type, string value, string? valueType, string? issuer);

public Claim (string type, string value, string? valueType, string? issuer, string? originalIssuer, System.Security.Claims.ClaimsIdentity? subject);
```
#### 參數解釋
| 參數 | 描述 |
| ---- | ---- |
| type | 用來標識聲明代表的信息 |
| value | 具體值, e.g. 用戶名稱 |
| valueType | 用來標識值的類型，比如字符串、日期等。 |
| issuer | 表示誰創建並發行 |
| originalIssuer | 表示最初創建這個聲明的實體 |
| subject | 是一個 `ClaimsIdentity` 對象 |

### ClaimIdentity 類
* 由多個 `Claim` 組成一個用戶的身份。
* `ClaimIdentity` 需要指名 `AuthenticationType` 
* 爲 `HttpContext.User.Identity` 的類型
#### Contructor
```csharp
public ClaimsIdentity(string? authenticationType, string? nameType, string? roleType)
```
* `authenticationType`: 表示要使用是哪種驗證方式
	* e.g. `CookieAuthenticationScheme.Default` 等
* `nameType`: 要讓 `HttpContext.User.Identity.Name` 找到
* `roleType`: 要讓 `HttpContext.User.IsInRole()` 方法找到
	* 用於 e.g. `[Authorization(Role = "Admin")]`
> nameType, roleType 默認是找 `ClaimTypes.Name` 與 `ClaimTypes.Role`而不是 `JwtClaimTypes.Name` 與 `JwtClaimTypes.Role`

#### 使用方式: 
```csharp
// 建立多個聲明
var claims = List<Claim> 
{
	new Claim(ClaimType.Name, "Liam"),
	new Claim(ClaimType.Email, "geffc1454@gamil.com")
};

// 建立一個用戶的身份聲明
// 需要指明 AuthenticatoinType
var claimIdentity = new ClaimIdentity("Cookie");
// 添加身份
claimIdentity.AddClaims(claims);
```

### ClaimPrincipal 類
* 一個用戶可以有多個 `ClaimsIdentity`: 
	每個對應於用戶通過不同的身份服務或身份提供者進行身份驗證的結果。
* `ClaimsPrincipal` 代表了當前用戶並持有一個或多個 `ClaimsIdentity` 對象。簡而言之，它代表了**當前的用戶和這個用戶的所有身份**。
* 除了身份以外能存放 `Role`
* 爲 `HttpContext.User` 的類型
#### 使用方式
```csharp
var claimPrincipal = new ClaimPrincipal();
claimPrincipal.AddClaimIdentity(cookieIdentity);
claimPrincipal.AddClaimIdentity(tokenIdentity);

// 確認是否爲 Admin
HttpContext.User.IsInRole("Admin");
```

## Session Management
我們透過 Signin 與 Signout 來對一個 Session (這邊只的是一個用戶的會話)，我們會透過這兩種方法來建立或刪除用戶登入的 Cookies。Asp.net 爲我們提供 Exension method 在 HttpContext 上。
```cs
public static class AuthenticatoinHttpContextExtensions
{
	// 若沒有提供 scheme 就會使用在 authentication 配置中所設定的
	public static Task SignInAsync(this HttpConext context, ClaimPricipal principal)
	public static Task SignInAsync(this HttpConext context, string scheme, ClaimPricipal principal)
	
	public static Task SignOutAsync(this HttpConext context)
	public static Task SignOutAsync(this HttpConext context, string scheme)
	
	public static Task ChallengeAsync(this HttpConext context)
	public static Task ChallengeAsync(this HttpConext context, string scheme)

	public static Task ForbidAsync(this HttpConext context)
	public static Task ForbidAsync(this HttpConext context, string scheme)
	
	public static Task<AuthenticationResult> AuthenticateAsync(this HttpConext context)
	public static Task<AuthenticationResult> AuthenticateAsync(this HttpConext context, string scheme)
}
```


# Cookie 認證
---
因爲 Http 是無狀態的，需要透過一種機制來保存用戶狀態，最常用的本地驗證就是 Cookie。
> 本片不是教你怎麽使用 Cookie 來存放資訊而是用 Cookie 來進行認證，也就是說在 HttpContext 中可以獲得 User.Identity 對象。獲得用戶資訊。

註：Cookie 中裏面包含用戶的資訊，但是在前端頁面保存的爲加密後的，所以有一定的安全性保障。

#### 配置 Cookie 認證
* Program.cs
```cs
builder.Services.AddAuthentication(options => 
{
    options.DefaultScheme = "cookie";
}).AddCookie("cookie", opt => {
	// 設定 Cookie 的名稱, 默認爲 ASP.Netcore
	opt.Cookie.Name = "auth";
	opt.ClaimsIssuer = "TryAuth";
	opt.ExpireTimeSpan = TimeSpan.FromHours(8);
});

app.UseAuthentication();
app.UseAuthroization();
```
> 使用 `DefaultScheme` 表示 `DefaultSignInScheme` `DefaultSignOutScheme` `DefaultChallengeScheme` `DefaultForbidScheme` 都會設定爲 Cookie

#### 添加 Controller 測試
* AccountsController.cs
```csharp
[ApiController]
[Route("api/[controller]")]
public class AccountsController : ControllerBase
{
	private readonly UserManager<AppUser> _userMgr;

	public AccountsController(UserManager<AppUser> userMgr)
	{
		_userMgr = userMgr;
	}

	[HttpPost("login")]
	public async Task<IActionResult> Login(LoginDTO loginDTO)
	{
		// 查詢用戶是否存在
		var user = await _userMgr.FindByEmailAsync(loginDTO.Email);
		// 驗證密碼
		if (user is null || !await _userMgr.CheckPasswordAsync(user, loginDTO.Password))
		{
			return Unauthorized();
		}
		// 建構 ClaimPrincipal
		var claims = new List<Claim> {
			new Claim(ClaimTypes.Name, user.UserName),
			new Claim(ClaimTypes.Email, user.Email)
		};
		var claimIdentity = new ClaimsIdentity(CookieAuthenticationDefaults.AuthenticationScheme);
		claimIdentity.AddClaims(claims);

		var claimPricipal = new ClaimsPrincipal(claimIdentity);
		// 添加到 Cookie 中
		await HttpContext.SignInAsync(claimPricipal);
		// await HttpContext.SignInAsync("cookie", claimPricipal);
		
		return NoContent();
	}

	[Authorize]
	[HttpGet("logout")]
	public IActionResult Logout()
	{
		HttpContext.SignOutAsync();

		return NoContent();
	}

	[Authorize]
	[HttpGet("getUser")]
	public ActionResult<string> GetUser()
	{
		return HttpContext.Identity?.User.Name;
	}
}
```

#### (Optional): 前後端分離 Cors 政策
因爲 Cookie 沒辦法傳遞到前端頁面，因爲瀏覽器的同源政策，需要進行配置
* Program.cs
```csharp
builder.Services.AddCors();

app.UseCors(policy =>
{
	// 需要有 AllowCredentials Cookie 才能傳遞
	policy.WithOrigins("http://localhost:3000").AllowAnyHeader().AllowAnyMethod().AllowCredentials();
});
```
* Axios 配置
```ts
axios.defaults.withCredentials = true;
```


# JwtBearer 認證
---
現在的應用程序會使用 WebApp, NativeApp 等多種呈現方式，不是所有應用都向 Browser 支持 Cookie，所以我們需要一個標準的、通用的、無狀態的認證方式，也就是 JwtBear 認證。
**正常來說不會單獨使用 JwtBear 驗證，而是會採用 OAuth 2.0 + OIDC 方式更安全**

### 甚麼是 Bearer 認證？
Http 提供一套標準的身份認證框架，服務器可以對客戶端發送質詢 (Challenge)，客戶端根據質詢提供身份驗證憑證。
#### 流程
![[Pasted image 20240104125928.png]]
1. 服務器返回 401 Unauthorized 狀態碼，並在 `WWW-Authenticate` Header 中添加如何進行驗證的信息，包含至少一種質詢方式
2. 客戶端在請求中添加 `Authorization` Header 進行驗證。

#### 常見的標準
1. Basic: 使用用戶名與密碼使用 base64 編碼作爲憑證
2. Digest: 升級 Basic，加密後才傳輸
3. Bearer: 也是 Http 標準的驗證，後續介紹

#### Bearer 好處？
1. CORS: cookie 要跨域需要做額外操作，而 Beaer 不需要，因爲使用 Header 傳輸用戶訊息
2. 移動端友好：NativeApp 沒有 Cookie
3. CSRF: 不用擔心跨站請求僞造，因爲不使用 Cookie
4. 標準化： Cookie 認證中用戶未登入時返回的是 404，或者 302 Redirect，而 Bearer 返回 401

### JWT
Bearer 認證中核心就是 `BEARER_TOKEN` ，而最流行的 Token 編碼方式是 Json Web Token。
> JWT 是爲了在網路應用環境間傳遞 Claim 而執行的開放標準 (RFC 7519)
> 被設計的緊湊且安全，特別適用於 SSO 場景。 [[Cookie, Session, Token#JWT (Json Web Token)|Token 詳細資訊]]

#### 好處
* 通用：各種語言都支持，且被廣泛使用
* 緊湊：佔用字節數很少，可以放在 Header 中傳輸
* 擴展：自我包含所有必要信息，不需要在服務端存放 Session

### 實作
#### 產生 Token
* 引用：
	1. `dotnet add package IdentityModel`
		這個 package 提供 Auth 2.0 與 OIDC 的客戶端供能，在這邊是想要使用 `JwtRegisteredClaimNames` 取代 `ClaimTypes`，因爲 `ClaimTypes` 本身是很長的 URL
	1. `dotnet add package System.IdentityModel.Tokens.Jwt` 
		使用生成 Jwt 的工具 e.g. `JwtSecurityHandler`
* AccountsController.cs
```csharp
[HttpPost("login")]
public async Task<IActionResult> Login(LoginDTO loginDTO)
{

	var user = await _userMgr.FindByEmailAsync(loginDTO.Email);

	if (user is null || !await _userMgr.CheckPasswordAsync(user, loginDTO.Password))
	{
		return Unauthorized();
	}

	var claims = new List<Claim> {
		new Claim(JwtRegisteredClaimNames.Name, user.UserName),
		new Claim(JwtRegisteredClaimNames.Email, user.Email),
		new Claim(JwtRegisteredClaimNames.Role, "Member")
	};
	// 這邊驗證改爲 Jwt
	var claimIdentity = new ClaimsIdentity(JwtBearerDefaults.AuthenticationScheme, JwtClaimTypes.Name, JwtClaimTypes.Role);
	claimIdentity.AddClaims(claims);

	// 生產密鑰
	var secret = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(_config["JwtSecretKey"]));
	
	var tokenDescriptor = new SecurityTokenDescriptor
	{
		Subject = claimIdentity, // 我使用 sub 存放 profile Claim
		Expires = DateTime.UtcNow.AddDays(1),
		// 有些加密算法不行 e.g. SHA
		SigningCredentials = new SigningCredentials(secret, SecurityAlgorithms.HmacSha512)
	};

	var tokenHandler = new JwtSecurityTokenHandler();
	
	var token = tokenHandler.CreateToken(tokenDescriptor);
	var tokenString = tokenHandler.WriteToken(token);

	return Ok(new
	{
		AccessToken = tokenString,
	});
}
```

#### 配置 JwtBearer
* Program.cs
```csharp
builder.Services.AddAuthentication(options =>
{
	options.DefaultAuthenticateScheme = JwtBearerDefaults.AuthenticationScheme;
	// Chanllenge 是 HTTP 標準驗證必須，而不是 Cookie 必須
	options.DefaultChallengeScheme = JwtBearerDefaults.AuthenticationScheme;
}).AddJwtBearer(cfg =>
{
	// 若使用 Identity Server 如 Duende 需要指定 Authority 的地址
	cfg.Authority = config["IdentityServiceUrl"];
	
	// 若使用 HTTP 而不是 HTTPS 需要
	cfg.RequireHttpsMetadata = false;
	
	cfg.TokenValidationParameters = new TokenValidationParameters
	{
		ValidateIssuer = false,
		ValidateAudience = false,
		ValidateIssuerSigningKey = true,
		NameClaimType = JwtClaimTypes.Name,
		RoleClaimType = JwtClaimTypes.Role,
		IssuerSigningKey = new SymmetricSecurityKey(Encoding.UTF8.GetBytes(builder.Configuration["JwtSecretKey"]))
	};
});
```

##### TokenValidationParameter 參數
他用於檢查某些 Claim 是否符合

| 字段 | 默認值 | 描述 |
| ---- | ---- | ---- |
| ValidateIssuer | true | 是否要檢查發行者 |
| ValidatedIssuer | "" | 指定合法的Issuer |
| ValidateAudience | true<br> | 是否要檢查被頒發者是誰<br> |
| ValidatedAudience | "" | 指定合法的 Audience |
| ValidateIssuerSigningKey | false | 是否驗證簽名 |
| IssuerSigningKey | null | 簽名 |
| NameClaimType | ClaimTypes.Name | 與[[#構造器\|ClaimIdentity構造器一樣概念]] |
| RoleClaimType | ClaimTypes.Role | 同上 |
| ValidateLifetijme | true | 是否驗證有效期限 |

























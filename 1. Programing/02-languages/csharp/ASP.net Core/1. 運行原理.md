## Hosting
---
### Kestrel
#### 介紹
是一種網絡伺服器，專為運行ASP.NET Core應用程序而設計。
* 跨平台：Kestrel 是一款跨平台 Web 伺服器，可在 Windows、Linux 和 macOS 上運作。
* 高效能：Kestrel 經過最佳化，可高效處理大量並發連線。
* 輕量級：針對在資源受限的環境（例如容器和邊緣設備）中運作進行了最佳化。 
* 安全性得到強化：Kestrel 支援 HTTPS，並針對 Web 伺服器漏洞進行了強化。 
* 廣泛的協議支援：Kestrel 支援常見的 Web 協議，包括： HTTP/1.1、HTTP/2 和 HTTP/3 WebSockets 
* 與 ASP.NET Core 整合：與其他 ASP.NET Core 元件無縫集成，例如中間件管道、相依性注入和配置系統。 
* 靈活的工作負載：Kestrel 支援多種工作負載： ASP.NET 應用框架，例如最小 API、MVC、Razor 頁面、SignalR、Blazor 和 gRPC。 
* 可擴充性：透過配置、中間件和自訂傳輸來自訂 Kestrel。 
* 效能診斷：Kestrel 提供內建的效能診斷功能，例如日誌記錄和指標。
#### 爲什麼要使用 Kestrel?
HTTP 請求的處理涉及許多複雜的步驟，這些步驟通常超出了一般應用程序的範疇，所以需要獨立出來專門的網絡伺服器如 Kestrel 來處理 HTTP 請求。而直接在應用程序中接收和處理 HTTP 請求將需要開發者手動處理這些複雜的問題，這不僅效率低，而且容易出錯，對於安全性和性能的影響也很大。

#### 流程
1. **啟動Kestrel伺服器**：
    - 當你啟動ASP.NET Core應用程序時，它會配置並啟動Kestrel伺服器。這一步通常在程序的入口點完成。
2. **來自用戶的HTTP請求**：
    - 用戶（比如通過瀏覽器或其他客戶端）向應用程序發送一個HTTP請求。這個請求通過網路到達運行ASP.NET Core應用程序的伺服器。
3. **Kestrel接收請求**：
    - Kestrel伺服器監聽端口並接收進來的HTTP請求。它解析請求（包括URL、頭信息、請求體等）準備將其傳遞給應用程序。建立**HttpContext**。
4. **請求路由**：
    - ASP.NET Core中的路由系統接收到Kestrel處理過的請求，根據設定的路由規則，決定哪個 Controller 和 Action 應該處理這個請求。
5. **Controller處理**：
    - 一旦確定了適當的Controller和Action，ASP.NET Core會實例化Controller，並調用相應的Action方法。這個方法會執行業務邏輯，可能會訪問資料庫、進行計算等。
6. **生成響應**：
    - Controller 的 Action 方法處理完業務邏輯後，會生成一個 HTTP 響應。這個響應可能是一個 HTML 頁面、一個 JSON 物件、一個文件下載等。
7. **返回響應**：
    - HTTP 響應被送回 Kestrel 伺服器，Kestrel 再將其發送回請求的來源（即用戶的瀏覽器或其他客戶端）。
8. **等待下一個請求**：
    - 一旦響應發送完畢，Kestrel準備處理來自該用戶或其他用戶的進一步請求。

### WebHost 建立
```cs
var builder = WebApplication.CreateBuilder(args);
```
* 註冊 Kestrel 
* 設定 Context 根目錄也就是項目根目錄
* 初始化 DI 容器
* 讀取 appsettings.json 配置文件、UserSecrets 與環境變量
* 配置日誌系統
* 預設中間件和服務

### WebHost 啓動流程
#### 1. 建構 RequestDelegate 
`RequestDelegate`，是應用程序處理請求、輸出響應的整個過程，也就是 Request Pipeline。
#### 2. 啓動 Server
Server 會綁定一個監聽的端口，並建立 `HttpContext`。

## Middleware
---
Middleware 是一系列用於處理 HTTP request 的軟體，這些軟體可以對該請求進行操作，依照設定的順序排列執行。
![[middleware-pipeline 1.svg]]
### 自定義 Middleware
#### 條件
* 必須要有一個 `Invoke` 或者 `InvokeAsync` 方法，並有 `HttpContext` 參數
* 要使用 Dependency Injection 注入 `RequestDelegate`
* 最後要調用 RequestDelegate

##### 自製 Exception Middleware
```cs
public class ExceptionMiddleware
{
    private readonly RequestDelegate _next;
    private readonly ILogger<ExceptionMiddleware> _logger;
    private readonly IHostEnvironment _env;

		// Dependency injection
    public ExceptionMiddleware(RequestDelegate next, ILogger<ExceptionMiddleware> logger, IHostEnvironment env)
    {
        this._next = next;
        this._logger = logger;
        this._env = env;
    }
		
    public async Task InvokeAsync(HttpContext context)
    {
        try
        {
            await _next(context); // 將 HttpContext 傳遞下去
        }
        catch (Exception ex)
        {
            _logger.LogError(ex, ex.Message);

            /* Because we are not inside API controller,
             * so we need to manually setting response.
             */
            context.Response.ContentType = "application/json";
            context.Response.StatusCode = 500;

            var prob = new ProblemDetails()
            {
                Status = 500,
                Title = ex.Message,
                Detail = _env.IsDevelopment() ? ex.StackTrace?.ToString() : null,
            };
            /*
             * Becuase we are not in API controller,
             * we need to change object to json, and set
             * it to obey camelcase. The other method is call
             * context.Respone.WriteAsJsonAsync() method
             */
            var opt = new JsonSerializerOptions()
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase
            };

            string json = JsonSerializer.Serialize(prob, opt);

            await context.Response.WriteAsync(json);
        }
    }
}
```


## HttpContext
---
`HttpContext` 是 ASP.net core 中的核心對象，每一個請求都會創建一個對應的 `HttpContext` 對象，應用就是通過 HttpContext 對象來獲取請求信息，最終生成響應寫回 `HttpContext` 中。
### IFeatureCollection
它代表了 HTTP 請求和響應中的功能集合。他每個 Properties 都代表一個特定的功能或資訊集。許開發者在運行時添加、移除或替換應用的功能。可能特性如下：
1. IHttpRequestFeature
```csharp
public interface IHttpRequestFeature
{
    string Protocol { get; set; }
    string Scheme { get; set; }
    string Method { get; set; }
    string PathBase { get; set; }
    string Path { get; set; }
    string QueryString { get; set; }
    string RawTarget { get; set; }
    IHeaderDictionary Headers { get; set; }
    Stream Body { get; set; }
}
```
2. IHttpResponseFeature
3. IFormFeature
```csharp
public interface IFormFeature
{
    bool HasFormContentType { get; }
    IFormCollection Form { get; set; }
    IFormCollection ReadForm();
    Task<IFormCollection> ReadFormAsync(CancellationToken cancellationToken);
}
```

### HttpContext 
```cs
public abstract class HttpContext
{
	// 它代表了 HTTP 請求和響應中的功能集合。
	public abstract IFeatureCollection Features { get; }

	public abstract HttpRequest Request { get; }

	public abstract HttpResponse Response { get; }

	// 可以取得 Connection 的信息 e.g. Port, Address, Certificate..
	public abstract ConnectionInfo Connection { get; }

	// 使用 WebSocket 功能
	public abstract WebSocketManager WebSockets { get; }

	// 包含了用戶的安全信息，包括用戶的身份（Identity）和任何與
	// 身份相關的聲明（Claims）。
	// 當一個請求被驗證中間件處理後，HttpContext.User 會被設置為
	// 代表已驗證用戶的 ClaimsPrincipal。如果請求未被驗證，則
	// HttpContext.User 通常會設置為一個不包含任何身份或聲明的空
	// 的 ClaimsPrincipal 對象。
	public abstract ClaimsPrincipal User { get; set; }

	// 用於在一次 HTTP 請求的範圍內儲存和傳遞數據。這個屬性通常用於
	// 在中間件、控制器、視圖和其他處理流程中共享數據。
	public abstract IDictionary<object, object?> Items { get; set; }

	// 用於從 DI 容器取出服務，常用於無法使用構造器函數入的地方使用
	public abstract IServiceProvider RequestServices { get; set; }

	// 用於使 Request 取消。
	public abstract CancellationToken RequestAborted { get; set; }

	public abstract string TraceIdentifier { get; set; }

	// 管理 session, 可以取得 sessionID
	public abstract ISession Session { get; set; }

	// 廢棄這個 http request
	public abstract void Abort();
}
```

### HttpRequest
```csharp
public abstract class HttpRequest
{
	public abstract HttpContext HttpContext { get; }
	
	// 取得 Http Method
	public abstract string Method { get; set; }
	
	// 返回 http or https
	public abstract string Scheme { get; set; }

	public abstract bool IsHttps { get; set; }

	// 取得 Host Header
	public abstract HostString Host { get; set; }

	public abstract PathString PathBase { get; set; }

	public abstract PathString Path { get; set; }

	public abstract QueryString QueryString { get; set; }

	// 取得被解析過的 Query value
	public abstract IQueryCollection Query { get; set; }

	// e.g. HTTP/1.1
	public abstract string Protocol { get; set; }

	public abstract IHeaderDictionary Headers { get; }

	public abstract IRequestCookieCollection Cookies { get; set; }

	public abstract long? ContentLength { get; set; }

	public abstract string? ContentType { get; set; }

	public abstract Stream Body { get; set; }
	
	// 比 Body 更有效率的 Reader
	public virtual PipeReader BodyReader {get; set;}

	public abstract bool HasFormContentType { get; }
	
	// Form 表單
	public abstract IFormCollection Form { get; set; }

	public virtual RouteValueDictionary RouteValues {}

	public abstract Task<IFormCollection> ReadFormAsync(CancellationToken cancellationToken = default(CancellationToken));
}

```

### HttpResponse
以下只有與 HttpRequest 不同的
```csharp
public abstract class HttpResponse
{
	public abstract int StatusCode { get; set; }

	public virtual PipeWriter BodyWriter {get; set;}

	public abstract void OnStarting(Func<object, Task> callback, object state);

	public virtual void OnStarting(Func<Task> callback)
	{}

	public abstract void OnCompleted(Func<object, Task> callback, object state);

	public virtual void RegisterForDispose(IDisposable disposable)
	{}

	public virtual void RegisterForDisposeAsync(IAsyncDisposable disposable)
	{}

	public virtual void OnCompleted(Func<Task> callback)
	{}
	
	public virtual void Redirect(string location)
	{
		throw null;
	}

	public abstract void Redirect(string location, bool permanent);

	public virtual Task CompleteAsync() {}

	protected HttpResponse()
}
```
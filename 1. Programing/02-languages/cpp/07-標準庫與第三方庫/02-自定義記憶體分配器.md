# 自定義記憶體分配器

自定義分配器可顯著降低 HFT 系統的記憶體分配延遲。

---

## 1. Allocator 概念

### 1.1 標準分配器介面

```cpp
template <typename T>
class MyAllocator {
public:
    using value_type = T;
    
    MyAllocator() noexcept = default;
    
    template <typename U>
    MyAllocator(const MyAllocator<U>&) noexcept {}
    
    T* allocate(std::size_t n) {
        return static_cast<T*>(::operator new(n * sizeof(T)));
    }
    
    void deallocate(T* p, std::size_t) noexcept {
        ::operator delete(p);
    }
};

// 使用
std::vector<int, MyAllocator<int>> vec;
```

---

## 2. Memory Pool 實現

### 2.1 固定大小 Object Pool

```cpp
template <typename T, size_t BlockSize = 4096>
class ObjectPool {
    union Node {
        T value;
        Node* next;
    };
    
    Node* free_list_ = nullptr;
    std::vector<std::unique_ptr<char[]>> blocks_;
    
public:
    T* allocate() {
        if (!free_list_) {
            allocate_block();
        }
        
        Node* node = free_list_;
        free_list_ = free_list_->next;
        return &node->value;
    }
    
    void deallocate(T* ptr) {
        Node* node = reinterpret_cast<Node*>(ptr);
        node->next = free_list_;
        free_list_ = node;
    }
    
private:
    void allocate_block() {
        auto block = std::make_unique<char[]>(BlockSize);
        Node* nodes = reinterpret_cast<Node*>(block.get());
        
        size_t count = BlockSize / sizeof(Node);
        for (size_t i = 0; i < count - 1; ++i) {
            nodes[i].next = &nodes[i + 1];
        }
        nodes[count - 1].next = free_list_;
        free_list_ = nodes;
        
        blocks_.push_back(std::move(block));
    }
};

// HFT 應用: Order 物件池
ObjectPool<Order> order_pool;

Order* create_order() {
    Order* order = order_pool.allocate();
    new (order) Order();  // placement new
    return order;
}

void destroy_order(Order* order) {
    order->~Order();
    order_pool.deallocate(order);
}
```

---

## 3. PMR (Polymorphic Memory Resources, C++17)

### 3.1 基本使用

```cpp
#include <memory_resource>
#include <vector>

void pmr_example() {
    // 使用 monotonic_buffer_resource (適合臨時分配)
    char buffer[1024];
    std::pmr::monotonic_buffer_resource mbr{buffer, sizeof(buffer)};
    
    std::pmr::vector<int> vec{&mbr};
    for (int i = 0; i < 100; ++i) {
        vec.push_back(i);  // 從 buffer 分配,超快
    }
    
    // vec 析構時不會 deallocate,由 mbr 統一管理
}
```

### 3.2 HFT 應用: Per-Request Arena

```cpp
class RequestProcessor {
    std::pmr::monotonic_buffer_resource arena_;
    
public:
    void process_request(const Request& req) {
        // 所有臨時分配使用 arena
        std::pmr::vector<Order> orders{&arena_};
        std::pmr::string symbol{&arena_};
        
        // 處理邏輯...
        
        // 請求結束,arena 自動釋放所有記憶體
    }
};
```

---

## 參考資料

1. **C++17 PMR**
   - [std::pmr](https://en.cppreference.com/w/cpp/memory)

# 低延遲設計模式

本章介紹 HFT 系統中常用的低延遲設計模式。

---

## 1. 消除動態記憶體分配

### 1.1 Object Pool 模式

```cpp
template<typename T, size_t PoolSize = 1024>
class ObjectPool {
    std::array<T, PoolSize> storage_;
    std::array<bool, PoolSize> used_;
    size_t next_free_ = 0;
    
public:
    T* allocate() {
        for (size_t i = 0; i < PoolSize; ++i) {
            size_t idx = (next_free_ + i) % PoolSize;
            if (!used_[idx]) {
                used_[idx] = true;
                next_free_ = (idx + 1) % PoolSize;
                return &storage_[idx];
            }
        }
        return nullptr;  // Pool 滿了
    }
    
    void deallocate(T* ptr) {
        size_t idx = ptr - storage_.data();
        if (idx < PoolSize) {
            used_[idx] = false;
        }
    }
};

// 使用
ObjectPool<Order> order_pool;

void process_order() {
    Order* order = order_pool.allocate();
    // 使用 order...
    order_pool.deallocate(order);
}
```

---

## 2. Disruptor 模式 (LMAX Architecture)

### 2.1 無鎖環形緩衝區

```cpp
template<typename T, size_t Size>
class Disruptor {
    static_assert((Size & (Size - 1)) == 0, "Size must be power of 2");
    
    alignas(64) std::atomic<uint64_t> write_cursor_{0};
    alignas(64) std::atomic<uint64_t> read_cursor_{0};
    std::array<T, Size> buffer_;
    
public:
    // 生產者: 預留位置
    uint64_t claim() {
        uint64_t pos = write_cursor_.load(std::memory_order_relaxed);
        
        // 檢查是否有空間
        while (pos - read_cursor_.load(std::memory_order_acquire) >= Size) {
            // Busy-wait
        }
        
        write_cursor_.store(pos + 1, std::memory_order_relaxed);
        return pos;
    }
    
    // 生產者: 發布數據
    void publish(uint64_t pos, const T& data) {
        buffer_[pos & (Size - 1)] = data;
        std::atomic_thread_fence(std::memory_order_release);
    }
    
    // 消費者: 讀取
    bool try_consume(T& data) {
        uint64_t read_pos = read_cursor_.load(std::memory_order_relaxed);
        uint64_t write_pos = write_cursor_.load(std::memory_order_acquire);
        
        if (read_pos >= write_pos) {
            return false;  // 無數據
        }
        
        data = buffer_[read_pos & (Size - 1)];
        read_cursor_.store(read_pos + 1, std::memory_order_release);
        return true;
    }
};

// HFT 應用
Disruptor<MarketTick, 4096> market_data_ring;

void feed_handler() {
    MarketTick tick = receive_tick();
    uint64_t pos = market_data_ring.claim();
    market_data_ring.publish(pos, tick);
}

void trading_engine() {
    MarketTick tick;
    if (market_data_ring.try_consume(tick)) {
        process_tick(tick);
    }
}
```

---

## 3. Lock-Free 架構設計

### 3.1 SPSC Queue (單生產者單消費者)

```cpp
template<typename T, size_t Capacity>
class SPSCQueue {
    struct alignas(64) Slot {
        std::atomic<uint64_t> sequence{0};
        T data;
    };
    
    alignas(64) std::atomic<uint64_t> write_pos_{0};
    alignas(64) std::atomic<uint64_t> read_pos_{0};
    std::array<Slot, Capacity> slots_;
    
public:
    SPSCQueue() {
        for (size_t i = 0; i < Capacity; ++i) {
            slots_[i].sequence.store(i, std::memory_order_relaxed);
        }
    }
    
    bool try_push(const T& item) {
        uint64_t pos = write_pos_.load(std::memory_order_relaxed);
        Slot& slot = slots_[pos % Capacity];
        uint64_t seq = slot.sequence.load(std::memory_order_acquire);
        
        if (seq != pos) return false;
        
        slot.data = item;
        slot.sequence.store(pos + 1, std::memory_order_release);
        write_pos_.store(pos + 1, std::memory_order_release);
        return true;
    }
    
    bool try_pop(T& item) {
        uint64_t pos = read_pos_.load(std::memory_order_relaxed);
        Slot& slot = slots_[pos % Capacity];
        uint64_t seq = slot.sequence.load(std::memory_order_acquire);
        
        if (seq != pos + 1) return false;
        
        item = slot.data;
        slot.sequence.store(pos + Capacity, std::memory_order_release);
        read_pos_.store(pos + 1, std::memory_order_release);
        return true;
    }
};
```

---

## 4. 延遲預算分配 (Latency Budget)

### 4.1 延遲預算表

```cpp
struct LatencyBudget {
    std::chrono::nanoseconds total{100'000};  // 100 μs 總預算
    
    struct Component {
        const char* name;
        std::chrono::nanoseconds budget;
        std::chrono::nanoseconds actual;
    };
    
    std::array<Component, 5> components{{
        {"Network RX",         {10'000}, {0}},  // 10 μs
        {"Parse Protocol",     {5'000},  {0}},  // 5 μs
        {"Update Order Book",  {20'000}, {0}},  // 20 μs
        {"Strategy Decision",  {30'000}, {0}},  // 30 μs
        {"Network TX",         {10'000}, {0}},  // 10 μs
    }};
    
    void measure_component(size_t idx, auto func) {
        auto start = std::chrono::high_resolution_clock::now();
        func();
        auto end = std::chrono::high_resolution_clock::now();
        
        components[idx].actual = std::chrono::duration_cast<std::chrono::nanoseconds>(
            end - start);
        
        if (components[idx].actual > components[idx].budget) {
            spdlog::warn("{} exceeded budget: {} ns > {} ns",
                        components[idx].name,
                        components[idx].actual.count(),
                        components[idx].budget.count());
        }
    }
};
```

---

## 5. 完整 HFT 管線設計

```cpp
class HFTTradingPipeline {
    // Lock-free queues
    SPSCQueue<RawPacket, 4096> network_queue_;
    SPSCQueue<MarketTick, 4096> tick_queue_;
    SPSCQueue<Order, 1024> order_queue_;
    
    // Object pools
    ObjectPool<Order, 1024> order_pool_;
    
    // 執行緒
    std::thread network_thread_;
    std::thread parser_thread_;
    std::thread strategy_thread_;
    std::thread order_thread_;
    
public:
    void start() {
        // 網路接收執行緒 (CPU 0)
        network_thread_ = std::thread([this]() {
            bind_to_cpu(0);
            set_realtime_priority(90);
            network_loop();
        });
        
        // 協議解析執行緒 (CPU 1)
        parser_thread_ = std::thread([this]() {
            bind_to_cpu(1);
            set_realtime_priority(90);
            parser_loop();
        });
        
        // 策略執行緒 (CPU 2)
        strategy_thread_ = std::thread([this]() {
            bind_to_cpu(2);
            set_realtime_priority(90);
            strategy_loop();
        });
        
        // 訂單發送執行緒 (CPU 3)
        order_thread_ = std::thread([this]() {
            bind_to_cpu(3);
            set_realtime_priority(90);
            order_loop();
        });
    }
    
private:
    void network_loop() {
        while (running_) {
            RawPacket packet;
            if (receive_packet(packet)) {
                while (!network_queue_.try_push(packet)) {
                    // Busy-wait
                }
            }
        }
    }
    
    void parser_loop() {
        while (running_) {
            RawPacket packet;
            if (network_queue_.try_pop(packet)) {
                MarketTick tick = parse(packet);
                while (!tick_queue_.try_push(tick)) {}
            }
        }
    }
    
    void strategy_loop() {
        while (running_) {
            MarketTick tick;
            if (tick_queue_.try_pop(tick)) {
                if (should_trade(tick)) {
                    Order* order = order_pool_.allocate();
                    create_order(order, tick);
                    while (!order_queue_.try_push(*order)) {}
                }
            }
        }
    }
    
    void order_loop() {
        while (running_) {
            Order order;
            if (order_queue_.try_pop(order)) {
                send_order(order);
                order_pool_.deallocate(&order);
            }
        }
    }
};
```

---

## 參考資料

1. **LMAX Disruptor**
   - [Disruptor Pattern](https://lmax-exchange.github.io/disruptor/)
   
2. **Lock-Free Programming**
   - [1024cores.net](http://www.1024cores.net/home/lock-free-algorithms)

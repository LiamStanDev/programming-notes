# 部署與運維

HFT 系統的部署、監控與運維最佳實踐。

---

## 1. 系統調校 Checklist

```bash
#!/bin/bash
# production_setup.sh

# CPU 隔離
# 在 GRUB 中設定: isolcpus=0-3 nohz_full=0-3

# Huge Pages
echo 1024 | sudo tee /proc/sys/vm/nr_hugepages

# 網路優化
sudo sysctl -w net.core.rmem_max=134217728
sudo sysctl -w net.core.wmem_max=134217728

# 關閉 THP
echo never | sudo tee /sys/kernel/mm/transparent_hugepage/enabled

# CPU 頻率
for cpu in /sys/devices/system/cpu/cpu[0-3]; do
    echo performance | sudo tee $cpu/cpufreq/scaling_governor
done

echo "系統調校完成!"
```

---

## 2. 監控指標

### 2.1 關鍵指標

```cpp
class Metrics {
public:
    // 延遲指標
    void record_latency(std::chrono::nanoseconds latency) {
        latency_histogram_.record(latency.count());
    }
    
    // 吞吐量
    void increment_message_count() {
        message_count_.fetch_add(1);
    }
    
    // 錯誤率
    void record_error() {
        error_count_.fetch_add(1);
    }
    
    // 定期報告
    void report() {
        auto p50 = latency_histogram_.percentile(50);
        auto p99 = latency_histogram_.percentile(99);
        auto p999 = latency_histogram_.percentile(99.9);
        
        fmt::print("P50: {} ns, P99: {} ns, P99.9: {} ns\n", p50, p99, p999);
    }
    
private:
    Histogram latency_histogram_;
    std::atomic<uint64_t> message_count_{0};
    std::atomic<uint64_t> error_count_{0};
};
```

---

## 3. 容量規劃

### 3.1 負載測試

```cpp
void load_test() {
    constexpr int MESSAGES_PER_SECOND = 1000000;
    constexpr int DURATION_SECONDS = 60;
    
    auto start = std::chrono::steady_clock::now();
    int message_count = 0;
    
    while (true) {
        auto now = std::chrono::steady_clock::now();
        auto elapsed = std::chrono::duration_cast<std::chrono::seconds>(now - start);
        
        if (elapsed.count() >= DURATION_SECONDS) break;
        
        // 發送測試訊息
        send_test_message();
        ++message_count;
        
        // 控制速率
        if (message_count % 1000 == 0) {
            std::this_thread::sleep_for(std::chrono::microseconds(900));
        }
    }
    
    fmt::print("Total messages: {}\n", message_count);
    fmt::print("Rate: {} msg/s\n", message_count / DURATION_SECONDS);
}
```

---

## 4. 生產環境最佳實踐

### 4.1 啟動腳本

```bash
#!/bin/bash
# start_trading_system.sh

# 設定環境變數
export LD_LIBRARY_PATH=/opt/hft/lib
export HFT_CONFIG=/etc/hft/config.json

# 啟動系統
sudo -E nice -n -20     taskset -c 0-3     /opt/hft/bin/trading_engine     --config $HFT_CONFIG     --log-level info     2>&1 | tee /var/log/hft/trading_$(date +%Y%m%d_%H%M%S).log
```

### 4.2 健康檢查

```cpp
class HealthCheck {
public:
    struct Status {
        bool healthy = true;
        std::string message;
        std::map<std::string, bool> components;
    };
    
    Status check() {
        Status status;
        
        status.components["network"] = check_network();
        status.components["order_book"] = check_order_book();
        status.components["risk_manager"] = check_risk_manager();
        
        for (const auto& [name, healthy] : status.components) {
            if (!healthy) {
                status.healthy = false;
                status.message += name + " is unhealthy; ";
            }
        }
        
        return status;
    }
    
private:
    bool check_network() { /* ... */ return true; }
    bool check_order_book() { /* ... */ return true; }
    bool check_risk_manager() { /* ... */ return true; }
};
```

---

## 5. 災難恢復

### 5.1 狀態持久化

```cpp
class StatePersistence {
public:
    void save_state() {
        json state;
        state["positions"] = get_positions();
        state["orders"] = get_pending_orders();
        state["timestamp"] = std::time(nullptr);
        
        std::ofstream ofs("/var/lib/hft/state.json");
        ofs << state.dump(2);
    }
    
    void restore_state() {
        std::ifstream ifs("/var/lib/hft/state.json");
        json state;
        ifs >> state;
        
        restore_positions(state["positions"]);
        restore_orders(state["orders"]);
    }
};
```

---

## 參考資料

1. **Production Operations**
   - [Site Reliability Engineering](https://sre.google/books/)
   
2. **Monitoring**
   - [Prometheus Best Practices](https://prometheus.io/docs/practices/)
   
3. **Capacity Planning**
   - [The Art of Capacity Planning](https://www.oreilly.com/library/view/the-art-of/9780596518578/)

# 時間
---
```cpp
#include <chrono>
#include <cstdio>
#include <thread>

int main() {
  auto t0 = std::chrono::steady_clock::now();
  auto t1 = t0 + std::chrono::seconds(30);
  auto dt = t1 - t0;
  int64_t sec = std::chrono::duration_cast<std::chrono::seconds>(dt).count();

  printf("Before sleep\n");
  std::this_thread::sleep_for(std::chrono::milliseconds(1000));
  printf("After sleep\n");
  return 0;
}
```


# 線程
---
#### 問題一：怎麼實現不阻塞
```cpp
int download(std::string file) {
  for (int i = 0; i < 10; i++) {
    std::cout << "Dowloading " << file << " (" << i * 10 << "%)..."
              << std::endl;
    std::this_thread::sleep_for(std::chrono::milliseconds(400));
  }
  std::cout << "Download complete: " << file << std::endl;
  return 200;
}

void interact() {
  std::string name;
  std::cin >> name;
  std::cout << "Hi, " << name << std::endl;
}


int main() {
  std::thread t1([] {
    download("hello.zip");
  });
  
  interact();
  if (t1.joinable()) { // 避免 t1 已經被 move 了
    t1.join();
  }
}
```
* 為什麼要 join ?
	因為 C++ thread 使用了 RAII 思想，所以在 main 函數退出時，會調用 thread 的解構函數，此時因異步操做尚未完成，會造成強制退出的異常。
* 在調用 join 之前可以先判斷 `joinable` 判斷線程是否被移動了。
#### 問題二：函數中調用 thread，會導致異常
* 案例
```cpp
// 為了不讓函數組塞，所以我們沒有在函數中 join
void func() {
  std::thread t1([] {
    download("hello.zip");
  });  // 此時 thread 進行解構，導致異常
}

int main() {
  func();
  interact();
}
```
* 解決方式：透過變數管理: e.g. 封裝一個管理線程序的類
	* 因為全局變數的生命期與 main 函數相同
```cpp
// 線程管理類
class ThreadManager {
private:
  std::vector<std::thread> m_threads;

public:
  // 這邊使用右值，是因為 thr 已經山除了拷貝構造，我們也不希望它被拷貝
  void push_back(std::thread &&thr) { m_threads.push_back(std::move(thr)); }

  ~ThreadPool() { // 解構時候釋放
    for (auto &t : m_threads)
      t.join();
  }
};

// 全局變數
ThreadManager thread_manager;

void myfunc() {
  std::thread t1([] { download("hello.zip"); });
  thread_manager.push_back(std::move(t1)); // 交給線程管理者管理
}

int main() {
  func();
  interact();
}
```



# 異步
---
* `std::async`: 會返回 future 類，用於異步操作，它會開啟一個線程運行，並透過 future 管理生命週期，而不是像 `thread` 一樣需要手動 `join`，也能透過 `future` 的 `get()` 方法獲取返回值，或者 `wait` 方法等待異步操作完成。
	* 有兩個模式默認為 `std::launch::asyc`，另外一個為 `std::launch::defered`，表示惰性求值，直到返回值的 `future` 被進行 `get()` or `wait()` 操作時候才進行。
```cpp
int main() {
  std::future<int> fret = std::async([] { return download("hello.zip"); });
  do_something();
  int ret = fret.get(); // 取得異步操作的返回值
  std::cout << "Download result: " << ret << std::endl;

  return 0;
}
```
* `std::promise`: 為 `std::async` 的底層實現，表示一個異步的返回值，如下：
```cpp
int main() {
	std::promise<int> pret; // 設置異步操作返回值對象
	std::thread t1([&] { // 這邊要捕獲 pret
		auto ret = download("hello.zip");
		pret.set_value(ret);
	});
	std::future<int> fret = pret.get_future(); // 從 promise 生成 future
	do_something();
	int ret = fret.get(); // 操作 future
	std::cout << "Download result: " << ret << std::endl;
	t1.join(); // 這邊要注意，自己建立的 thread 需要手動管理
	return 0;
}
```

> 為什麼 `std::async` 不用自己管理線程？
> 因為它用的是它自己的線程池，就像之前講的全局線程池管理的線程的生命期，使用解構函數來處理，會在`main` 函數退出前進行解構。而 `std::promise` 用的是自己建立的線程，需要手動 `join`

##### future 細節
* future 考慮了三五法則，刪除了拷貝構造/賦值函數，故只能通過 `std::move` 進行移動，若想要進行淺拷貝可以使用 `std::shared_future`，如下
```cpp
std::future<int> fret = std::async([] {
	return download();
});
// 移動給 shared_future
std::shared_future<int> sfret = std::shared_future<int>(std::move(fret));
```

# 互斥量
---
##### 數據競爭問題
因為兩個線程都在同時寫入相同的對象，會導致數據是錯誤的。如下，
```cpp
int main() {
  std::vector<int> arr;
  // 捕獲 arr 並進行寫入
  std::thread t1([&] {
    for (int i = 0; i < 1000; i++) {
      arr.push_back(i);
    }
  });

  // 捕獲 arr 並進行寫入
  std::thread t2([&] {
    for (int i = 0; i < 1000; i++) {
      arr.push_back(i);
    }
  });

  t1.join();
  t2.join();
  return 0;
}
```

##### 解決方式：上鎖

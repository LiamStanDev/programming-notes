jjikijljalsdqw# Config
---
我們希望讀取配置文件來初始化各種模組。

# Log
---
我們希望實現一個可配置的日誌模組，可以訂製 patter，有不同功能的 Logger（可分為 Root, System, User），有不同的輸出地 （Stdout, File）等功能。
### 類定義
##### LogEvent
為日誌事件，包括所有日誌信息，如日誌時間、內容、線程 id、進程 id、運行時間、文件與行號等
##### Loggerj
為日誌器，可以依據系統有多個不同名稱的 Logger ，管理所有日誌輸出，持有多個 LogAppender。
##### LogEventTracker
為了方便管理 LogEvent 生命期，讓它在 out-of-scope 時候自動進行 Log，它需要持有 LogEvent、Logger。
##### LogAppender
為日誌輸出地點的基類，持有 LogLevel 與 LogForamtter
##### LogFormatter
用於解析日誌輸出格式的類，其中會有一個內部虛類 LogFormatterItem 並持有多個其多個實現類，用來解析輸出。
##### LogManager
用於管理多個 Logger，可以方便取得以及透過配置文件進行初始化。

### 流程如下
LogManager 按照配置文件初始化 Logger，並初始化 Logger 中所有的 Appender，並設置 Appender 中的 Level 與 LogFormatter

### 配置文件
* bin/conf/log.yaml
```yaml
logs:
    - name: root
      level: info
      appenders:
          - type: FileLogAppender
            file: /apps/logs/sylar/root.txt
          - type: StdoutLogAppender
    - name: system
      level: info
      appenders:
          - type: FileLogAppender
            file: /apps/logs/sylar/system.txt
          - type: StdoutLogAppender
```

# 線程模塊
---
為了方便調適以及學習，我並不使用 std::thread 來操作線程，而是使用 pthread 庫封裝一個自己的線程庫。
### 類定義
##### Thread
封裝 pthread 操作，讓我們可以方便使用，並可以定義該線程名稱，該名成也會顯示在 linux 系統中 (可以透過 `top -H -p 進程名`查看到)。
使用到 pthread.h API 如下： 
* handle 為 `pthread_t`
* `pthread_create` : 建立線程。
* `pthread_detach` : 將該線程與進程分離，資源（線程棧）回收交給 os 處理。
* `pthread_join` : 等待線程完成，並可以取得返回值
* `pthread_setname_np`：設置線程名稱。注意空間只有 16 字節
##### Semaphore
實做一個信號量，信號量內部為一個整數，提供 post 與 wait 兩個操作，當 poll 時候會將信號量 + 1，而當 wait 時候會將信號量 -1，當 wait 時候信號量為 0，則會讓該線程等待。
使用到的 semaphore.h API:
* handle 為 `sem_t`
* `sem_init`: 建立與初始化信號量
* `sem_pol`
* `sem_wait`
* `sem_destory`: 銷毀信號量
##### Mutex
實做互斥鎖，用於只有一個線程能獲得鎖。
使用到 pthread.h API:
* handle 為 `pthread_mutex_t`
* `pthread_mutex_init`
* `pthread_mutex_lock`
* `pthread_mutex_unlock`
* `pthread_mutex_destroy`
##### RwLock
* handle 為 `pthread_rwlock_t`
* `pthread_rwlock_init`
* `pthread_rwlock_rdlock` : 取得讀鎖
* `pthread_rwlock_wrlock` : 取得寫鎖
* `pthread_rwlock_unlock` : 解鎖
* `pthread_rwlock_destroy`


# Coroutine
---


# 信號 (Signal)
---
### 基本概念
在 Linux 中，信號（Signals）是一種輕量級的進程通信機制，用於通知進程發生了某種事件。**信號是一種中斷**，它可以被一個進程發送給另一個進程或者由內核發送給進程。信號的使用可以用於處理異常狀況、通知進程特定事件的發生，以及在進程之間進行簡單的通信。

##### 使用 shell kill 發送信號
```shell
kill -SINGNAL_TYPE process_number
killall -SINGNAL_TYPE process_name
```
> 不提供 -SINGNAL_TYPE 為 `-15` 表示終止進程信號

* 常見信號類型

| 信號名稱    | 信號值 | 原因                                 |
| ------- | --- | ---------------------------------- |
| SIGHUP  | 1   | 掛起                                 |
| SIGINT  | 2   | 鍵盤中斷 ctrl + c                      |
| SIGKILL | 9   | 採用 kill -9 強制殺死程序 (注: 該信號不能被捕獲與忽略) |
| SIGALRM | 14  | 由 alarm() 系統調用發出的信號                |
| SIGTERM | 15  | 使用 kill 通知程序終止                     |
| SIGCHLD | 17  | 子進程結束信號                            |

> alarm() 系統調用會發送 `SIGALRM`，常用於設置某時間後通知，


### 信號處理
進程對信號的處理方式有三種:
1. 默認操作: 大部分是採用終止進程。
2. 設置中斷處理函數: 提供函數，收到信號後調用該函數。
3. 忽略: 不做任何處理。

#### signal() 函數
該函數可以設置信號處理方式。
##### 簽名
```cpp
#include <signal.h>

typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
```
* signum: 表示處理的信號
* handler: 有三種方式 
	1. 提供信號處理函數地址 (函數指針)。
	2. 填上 `SIG_IGN` 表示忽略。
	3. 填上 `SIG_DFL` 表示重新設置為默認。

##### 使用
```cpp
void sig_handler(int signum)
{
  std::cout << "Received signal: " << signum << std::endl;
}

int main()
{
  while (true)
  {
    signal(SIGHUP, sig_handler);
    signal(15, sig_handler);

    std::cout << "process task." << std::endl;
    sleep(1);
  }

  return 0;
}
```

# 進程終止
---
一共有 8 種方式可以終止進程，其中 3 種為正常退出:
1. 在 `main()` 函數中使用 `return` 返回
2. 在任意函數中調用 `exit()` 函數
3. 在任意函數中調用 `_exit()` 或 `_Exit()` 函數
4. 最後一個線程從其線程主函數用 return 返回 (最後一個線程完成工作)
5. 在最後一個線程中調用 `pthread_exit()` 返回 
	* `pthread_exit()` 是 linux 原生線程庫的函數。
異常終止有 3 種方式:
6. 調用 `abort()` 函數終止 (abort 沒什麼用，誰會主動調用阿?)
7. 接收到一個信號
8. 最後一個線程對取消請求作響應

### 進程終止的狀態
在 main 函數中， `return` 的值就是進程終止的狀態，調用 `exit(int status)` 則終止狀態為 `status`。
```shell
# 查看上個程序終止狀態
echo $?
```

* 進程被異常終止為非零

### 資源釋放問題
* `return` 會調用局部對象的析構函數，在 main 中的 `return` 會調用全局的析構函數。
* `exit()` **不會調用局部的析構函數**，但會調用全局的析構函數。
	* 註: exit 隨然不會調用局部析構，但是還是**會進行清理** e.g. 將緩衝區數據寫入磁盤、關閉文件等。
* `_exit()` 與 `_Exit()` 不會調用任何析構函數，不會執行清理。 (不要使用)

# 調用可執行文件
---
Linux 提供 `system()` 函數和 `exec` 函數族，在 C++ 程序中，可以執行其他程序 (二進制文件、操作系統命令或 Shell 腳本)。

#### system() 函數
提供了一種簡單的執行程序的方法，把需要執行的命令和參數用一個字符串給 `system()` 函數就可以。
##### 簽名
```cpp
int system(const char *string);
```
* 返回值:
	* 程序不存在，返回非零，但不會設置 `errno`。
	* 程序成功，且返回 0，則返回 0。
	* 程序成功，返回非零，則返回非零。
##### 操作
```cpp
int main()
{
	int ret = system("/bin/ls -l /tmp");
	return 0;
}
```

#### exec 函數族
我感覺沒什麼用，skip...

# 創建進程
---


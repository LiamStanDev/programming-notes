# 多態錯誤碼思想
---
### 自己實現
```c++
#include <fmt/core.h>

#include <clocale>
#include <system_error>

struct ErrorCategory {
  virtual const char* message(int val) = 0;

};

enum LoginErrc { success = 0, not_valid_pass, not_login };

const char* LoginStrError(LoginErrc val) {
  switch (val) {
    case LoginErrc::success:
      return "success";
    case LoginErrc::not_valid_pass:
      return "not valid pass";
    case LoginErrc::not_login:
      return "not login";
    default:
      return "unknown";
  }
}

struct ErrorCode {
  int val;
  ErrorCategory* category;

  bool operator==(const ErrorCode&) const = default;

  void operator=(const ErrorCode& other) {
    val = other.val;
    category = other.category;
  }
};

auto* StdErrorCategory() {
  static struct StdErrorCategory : ErrorCategory {
    virtual const char* message(int val) override { return strerror(val); }
  } instance;
  return &instance;
}

auto* LoginErrorCategory() {
  static struct LoginErrorCategory : ErrorCategory {
    virtual const char* message(int val) override {
      return LoginStrError((LoginErrc)val);
    }
  } instance;
  return &instance;
}

ErrorCode MakeErrorCode(std::errc ec) {
  return {static_cast<int>(ec), StdErrorCategory()};
}
ErrorCode MakeErrorCode(LoginErrc ec) {
  return {static_cast<int>(ec), LoginErrorCategory()};
}

int sqrt(int x, ErrorCode& ec) {
  if (x < 0) {
    ec = MakeErrorCode(std::errc::argument_out_of_domain);
    return -1;
  }
  if (x == 3) {
    ec = MakeErrorCode(LoginErrc::not_valid_pass);
    return -1;
  }
  if (x == 4) {
    ec = MakeErrorCode(LoginErrc::not_login);
    return -1;
  }
  for (int i = 0;; i++) {
    if (i * i >= x) {
      return i;
    }
  }
}

int main() {
  ErrorCode ec = ErrorCode();
  int ret = sqrt(4, ec);
  if (ret != -1) {
    fmt::println("結果: {}", ret);
  } else {
    fmt::println("sqrt 出錯了!");
    const char* str = ec.category->message(ec.val);
    if (errno == EDOM) {
      fmt::println("sqrt 出錯原因: {}", str);
    } else {
      fmt::println("sqrt 出錯原因: {}", str);
    }
  }
}
```

### 標準庫實現
```c++
#include <fmt/core.h>

#include <clocale>
#include <system_error>

enum class login_errc { success = 0, not_valid_pass, not_login };

std::error_code make_error_code(login_errc ec) {
  static const struct LoginErrorCategory : std::error_category {
    virtual std::string message(int val) const noexcept override {
      switch (static_cast<login_errc>(val)) {
        case login_errc::success:
          return "success";
        case login_errc::not_valid_pass:
          return "not valid pass";
        case login_errc::not_login:
          return "not login";
        default:
          return "unknown";
      }
    }
    virtual const char* name() const noexcept override { return "LoginErrc"; }
  } category;
  return std::error_code{static_cast<int>(ec), category};
}

int sqrt(int x, std::error_code& ec) {
  if (x < 0) {
	// 注意這邊 make_error_code 實際上是調用 std::make_error_code，但是 C++ 只要參數調用有使用 std:: 就會先優先函數加上 std::
    ec = make_error_code(std::errc::argument_out_of_domain);
    return -1;
  }
  if (x == 3) {
    ec = make_error_code(login_errc::not_valid_pass);
    return -1;
  }
  if (x == 4) {
    ec = make_error_code(login_errc::not_login);
    return -1;
  }
  for (int i = 0;; i++) {
    if (i * i >= x) {
      return i;
    }
  }
}

int main() {
  std::error_code ec;
  int ret = sqrt(4, ec);
  if (!ec) {
    fmt::println("結果: {}", ret);
  } else {
    fmt::println("sqrt 出錯了!");
    std::string str = ec.message();
    if (errno == EDOM) {
      fmt::println("sqrt 出錯原因: {}", str);
    } else {
      fmt::println("sqrt 出錯原因: {}", str);
    }
  }
}
```

# 返回值包裝錯誤碼
---
### std::variant
```c++
#include <fmt/core.h>

#include <clocale>
#include <system_error>
#include <variant>

enum class login_errc { success = 0, not_valid_pass, not_login };

std::error_code make_error_code(login_errc ec) {
  static const struct LoginErrorCategory : std::error_category {
    virtual std::string message(int val) const noexcept override {
      switch (static_cast<login_errc>(val)) {
        case login_errc::success:
          return "success";
        case login_errc::not_valid_pass:
          return "not valid pass";
        case login_errc::not_login:
          return "not login";
        default:
          return "unknown";
      }
    }
    virtual const char* name() const noexcept override { return "LoginErrc";
    }
  } category;
  return std::error_code{static_cast<int>(ec), category};
}

std::variant<int, std::error_code> sqrt(int x) {
  if (x < 0) {
    return make_error_code(std::errc::argument_out_of_domain);
  }
  if (x == 3) {
    return make_error_code(login_errc::not_valid_pass);
  }
  if (x == 4) {
    return make_error_code(login_errc::not_login);
  }
  for (int i = 0;; i++) {
    if (i * i >= x) {
      return i;
    }
  }
}

int main() {
  auto ret = sqrt(3);
  if (ret.index() == 0) {
    fmt::println("結果: {}", get<0>(ret));
  } else {
    fmt::println("sqrt 出錯了!");
    fmt::println("出錯: {}", get<1>(ret).message());
  }
}

```

### std::expected
```c++
#include <fmt/core.h>

#include <clocale>
#include <expected>
#include <system_error>

enum class login_errc { success = 0, not_valid_pass, not_login };

std::error_code make_error_code(login_errc ec) {
  static const struct LoginErrorCategory : std::error_category {
    virtual std::string message(int val) const noexcept override {
      switch (static_cast<login_errc>(val)) {
        case login_errc::success:
          return "success";
        case login_errc::not_valid_pass:
          return "not valid pass";
        case login_errc::not_login:
          return "not login";
        default:
          return "unknown";
      }
    }
    virtual const char* name() const noexcept override { return "LoginErrc"; }
  } category;
  return std::error_code{static_cast<int>(ec), category};
}

std::expected<int, std::error_code> sqrt(int x) {
  if (x < 0) {
    // 標準庫在設計時考慮到可能會有 std::expected<int, int> 故為了區分需要在包一層 unexpected
    return std::unexpected{make_error_code(std::errc::argument_out_of_domain)};
  }
  if (x == 3) {
    return std::unexpected{make_error_code(login_errc::not_valid_pass)};
  };
  if (x == 4) {
    return std::unexpected{make_error_code(login_errc::not_login)};
  }
  for (int i = 0;; i++) {
    if (i * i >= x) {
      return i;
    }
  }
}

std::expected<int, std::error_code> sqrtfloor(int x) {
  if (x < 0) {
    return std::unexpected{make_error_code(std::errc::invalid_argument)};
  }
  auto ret = sqrt(x * x);

  // 對正確值進行轉換
  return ret.transform([](int x) {
    fmt::println("正確才會執行");
    return x * 2;
  });
  // transform 等價寫法
  // if (!ret.has_value()) {
  //   return ret;
  // }
  // return ret.value() * 2;

  // 對錯誤值進行轉換
  return ret.transform_error([](std::error_code ec) {
    if (ec == make_error_code(login_errc::not_login)) {
      ec = make_error_code(login_errc::not_valid_pass);
    }
    return ec;
  });
  // transform_error 等價寫法
  // if (!ret.has_value()) {
  //   if (ret.error() == make_error_code(login_errc::not_login)) {
  //     ret.error() = make_error_code(login_errc::not_valid_pass);
  //   }
  // }
  // return ret;
}

int main() {
  auto ret = sqrtfloor(10);
  if (ret.has_value()) {
    fmt::println("結果: {}", *ret);
  } else {
    fmt::println("sqrt 出錯了!");
    fmt::println("出錯: {}", ret.error().message());
  }
}
```

### 實戰: 包裝 Linux API
---
```c++
// 定義一個函數用來將 Linux API 返回值轉換成 expected
std::expected<int, std::error_code> expectedStdError(int ret) {
  if (ret == -1) {// poxis 返回 -1 表示出錯
	// 小彭老師說 system_category 等價於 generic_category，但是實際上 std::make_error_code() 的返回值是使用 generic_category
    return std::unexpected{ std::error_code(errno, std::generic_category{})}; 
  }
  return ret;
}

// 利用模板特化修改 expected 異常訊息 (會拋出 std::bad_expected_access)
template<>
struct std::bad_expected_access<std::error_code> : std::system_error {
  // 構造函數修改
  explicit bad_expected_access(std::error_code e) : std::system_error{e, "expected::value" }
}

int main() {
  auto ret = expectedStdError(::open("/no/file/exit", O_RDONLY)).value();
}
```
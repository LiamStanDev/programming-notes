##### P1 - 在代碼中直接表達思想
##### P2 - 使用 ISO 標準
##### P3 - 表達意圖
##### P4 - 理想情況下，程序應該是靜態類型安全的
##### P5 - 編譯期檢查優先於運行期檢查
##### P6 - 不能在編譯其檢查的事項應該在運行時間檢查
##### P7 - 盡早識別運行期間錯誤
##### P8 - 不要洩漏任何資源
資源可以是內存、文件句柄、socket 等，處理資源使用 RAII 思想，請求的資源須**綁定生命期間在一個對像上**，也就是**構造函數中獲取資源，解構函數中釋放資源**。
C++ 中大量使用 RAII，如: 
* `sdt::lock_guard` 管理 `mutex`
* 智能指針管理原始內存
* STL 容器負責管理底層元素

##### P9 - 不要浪費時間與空間
**減少空間與時間是一種美德，請避免不必要的拷貝**。

* 若用戶自定義數據類型聲明拷貝語意，編譯器就不會生成默認的移動語意。
```cpp
struct S {
  std::string m_s;
  S(std::string s) : m_s(s) {}
  S(const S &rhs) : m_s(rhs.m_s) {
    std::cout << "Copy Constructor" << std::endl;
  }
  S &operator=(const S &rhs) {
    std::cout << "Copy Assign" << std::endl;
    m_s = rhs.m_s;
    return *this;
  }
  // S(const S &rhs) = delete;
  // S &operator=(const S &rhs) = delete;
};

int main() {
  S s1{"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"};
  std::cout << reinterpret_cast<const void *>(s1.m_s.data()) << '\n';
  S s2 = std::move(s1); // 這邊就算使用 std::move 也不是進行移動，而是進行拷貝構造函數

  std::cout << reinterpret_cast<const void *>(s2.m_s.data()) << '\n';
  ;
  return 0;
}
```
不自定義的則會調用移動語意
```cpp
struct S {
  std::string m_s;
  S(std::string s) : m_s(s) {}
};

int main() {
  S s1{"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa"};
  std::cout << reinterpret_cast<const void *>(s1.m_s.data()) << '\n';
  S s2 = std::move(s1); // 這邊就算使用 std::move 也不是進行移動，而是進行拷貝構造函數

  std::cout << reinterpret_cast<const void *>(s2.m_s.data()) << '\n';
  ;
  return 0;
}
```
> 這邊有一個坑，s1 字符串長度不夠常的話，怎麼樣都是調用拷貝而不是移動。可能小數據拷貝開銷小於移動的指針交換。

##### P10 - 不可變數據優先於可變數據
常量有以下優勢：
1. 更高的編譯器優化潛力
2. 不可變數據是不存在競爭條件，在併發程序中有很大的優勢。
##### P11 - 封裝雜亂的構建，不要讓他在代碼中散佈開
##### P12 - 適當使用輔助工具
##### P13 - 適當使用支持庫

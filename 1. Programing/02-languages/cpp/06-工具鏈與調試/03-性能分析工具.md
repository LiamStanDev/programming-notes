# 性能分析工具

掌握 perf、valgrind、gdb 等工具,是優化 HFT 系統性能的關鍵。

---

## 1. perf - CPU 性能分析

### 1.1 基礎使用

```bash
# 記錄性能數據
perf record -g ./hft_engine

# 查看報告
perf report

# 即時監控
perf top

# 統計模式
perf stat ./hft_engine
```

### 1.2 Cache 分析

```bash
# Cache miss 分析
perf stat -e cache-references,cache-misses,L1-dcache-loads,L1-dcache-load-misses ./hft_engine

# 輸出範例:
# Performance counter stats:
#   125,430,234  cache-references
#     8,234,123  cache-misses    # 6.57% of all cache refs
```

### 1.3 分支預測分析

```bash
perf stat -e branches,branch-misses ./hft_engine

# 輸出:
#   234,567,890  branches
#     2,345,678  branch-misses   # 1.00% of all branches
```

### 1.4 記錄特定事件

```bash
# CPU cycles
perf record -e cycles -g ./hft_engine

# Cache misses
perf record -e cache-misses -g ./hft_engine

# 頁面錯誤
perf record -e page-faults -g ./hft_engine

# 系統調用
perf record -e 'syscalls:sys_enter_*' ./hft_engine
```

---

## 2. 火焰圖 (Flame Graphs)

### 2.1 生成火焰圖

```bash
# 1. 安裝工具
git clone https://github.com/brendangregg/FlameGraph.git

# 2. 記錄數據
perf record -F 99 -a -g -- sleep 30

# 3. 生成火焰圖
perf script | FlameGraph/stackcollapse-perf.pl | FlameGraph/flamegraph.pl > flame.svg

# 4. 在瀏覽器中開啟
firefox flame.svg
```

### 2.2 解讀火焰圖

```
寬度 = CPU 時間佔比
高度 = 調用堆疊深度
顏色 = 隨機 (僅作區分)

[最寬的區域 = 熱點函數]
```

---

## 3. Valgrind - 記憶體分析

### 3.1 Memcheck - 記憶體錯誤檢測

```bash
# 基本使用
valgrind --leak-check=full --show-leak-kinds=all ./hft_engine

# 追蹤來源
valgrind --leak-check=full --track-origins=yes ./hft_engine

# 輸出到檔案
valgrind --log-file=valgrind.log ./hft_engine
```

**檢測的錯誤**:
- 記憶體洩漏
- 使用未初始化的記憶體
- 無效的讀寫 (out-of-bounds)
- 重複釋放

### 3.2 Cachegrind - Cache 分析

```bash
# 執行分析
valgrind --tool=cachegrind ./hft_engine

# 查看結果
cg_annotate cachegrind.out.<pid>

# 輸出範例:
# I refs:        125,430,234
# I1  misses:      1,234,567  (0.98%)
# LLi misses:        123,456  (0.10%)
# D refs:         89,234,123
# D1  misses:      5,678,901  (6.36%)
# LLd misses:        456,789  (0.51%)
```

### 3.3 Callgrind - 調用圖分析

```bash
# 執行分析
valgrind --tool=callgrind ./hft_engine

# 可視化 (需要 KCachegrind)
kcachegrind callgrind.out.<pid>
```

---

## 4. gdb - 調試技巧

### 4.1 基本調試

```bash
# 啟動 gdb
gdb ./hft_engine

# gdb 命令
(gdb) run                     # 執行程式
(gdb) break main              # 設定斷點
(gdb) break file.cpp:123      # 特定行斷點
(gdb) break function_name     # 函數斷點
(gdb) continue                # 繼續執行
(gdb) next                    # 下一行 (不進入函數)
(gdb) step                    # 下一行 (進入函數)
(gdb) finish                  # 執行到函數返回
(gdb) print variable          # 查看變數
(gdb) backtrace               # 堆疊追蹤
(gdb) info locals             # 區域變數
(gdb) info args               # 函數參數
```

### 4.2 條件斷點

```bash
(gdb) break order_book.cpp:45 if price > 100.0
(gdb) condition 1 i == 1000  # 斷點 1 的條件
```

### 4.3 監視點 (Watchpoint)

```bash
# 變數改變時中斷
(gdb) watch variable_name

# 讀取時中斷
(gdb) rwatch variable_name

# 讀寫時中斷
(gdb) awatch variable_name
```

### 4.4 gdb 腳本

```python
# gdb_script.py
import gdb

class PrintOrderBook(gdb.Command):
    def __init__(self):
        super().__init__("print_orderbook", gdb.COMMAND_USER)
    
    def invoke(self, arg, from_tty):
        ob = gdb.parse_and_eval("order_book")
        # 自定義打印邏輯
        print(f"Order Book: {ob}")

PrintOrderBook()
```

```bash
# 使用腳本
gdb -x gdb_script.py ./hft_engine
```

---

## 5. Intel VTune

### 5.1 基本使用

```bash
# 安裝 VTune (需要 Intel 帳號)
# https://www.intel.com/content/www/us/en/developer/tools/oneapi/vtune-profiler.html

# Hotspot 分析
vtune -collect hotspots -result-dir vtune_results ./hft_engine

# 查看結果
vtune-gui vtune_results
```

### 5.2 微架構分析

```bash
# 微架構分析 (需要 root)
sudo vtune -collect uarch-exploration -result-dir vtune_uarch ./hft_engine
```

---

## 6. HFT 場景: 微秒級性能瓶頸定位

### 6.1 定位延遲熱點

```bash
#!/bin/bash
# profile_latency.sh

echo "=== 性能分析開始 ==="

# 1. CPU cycles 熱點
echo "1. CPU cycles 分析..."
perf record -e cycles:pp -g ./hft_engine --duration 60

# 2. Cache miss 分析
echo "2. Cache miss 分析..."
perf stat -e cache-references,cache-misses,L1-dcache-loads,L1-dcache-load-misses     ./hft_engine --duration 60

# 3. 分支預測
echo "3. 分支預測分析..."
perf stat -e branches,branch-misses ./hft_engine --duration 60

# 4. 生成火焰圖
echo "4. 生成火焰圖..."
perf script | stackcollapse-perf.pl | flamegraph.pl > flame.svg

echo "=== 分析完成 ==="
echo "火焰圖: flame.svg"
echo "perf 報告: perf report"
```

### 6.2 程式碼註解

```cpp
#include <chrono>
#include <iostream>

// 簡單的延遲測量
class LatencyMeasurement {
    using Clock = std::chrono::high_resolution_clock;
    using TimePoint = Clock::time_point;
    
    TimePoint start_;
    const char* label_;
    
public:
    LatencyMeasurement(const char* label) : label_(label) {
        start_ = Clock::now();
    }
    
    ~LatencyMeasurement() {
        auto end = Clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(
            end - start_);
        
        std::cout << label_ << ": " << duration.count() << " ns\n";
    }
};

void process_market_data() {
    LatencyMeasurement measure("process_market_data");
    
    // 處理邏輯...
}
```

---

## 7. 性能分析 Checklist

```bash
# 完整性能分析流程

# 1. CPU Profiling
perf record -F 99 -g ./hft_engine
perf report

# 2. Cache 分析
perf stat -e cache-references,cache-misses ./hft_engine

# 3. 記憶體分析
valgrind --tool=cachegrind ./hft_engine

# 4. 記憶體洩漏
valgrind --leak-check=full ./hft_engine

# 5. 火焰圖
perf script | stackcollapse-perf.pl | flamegraph.pl > flame.svg

# 6. 系統調用
strace -c ./hft_engine
```

---

## 參考資料

1. **perf**
   - [perf Examples](http://www.brendangregg.com/perf.html)
   - [Linux perf_events](https://perf.wiki.kernel.org/index.php/Main_Page)

2. **Valgrind**
   - [Valgrind User Manual](https://valgrind.org/docs/manual/manual.html)

3. **Flame Graphs**
   - [Brendan Gregg's Flame Graphs](http://www.brendangregg.com/flamegraphs.html)

4. **gdb**
   - [GDB Documentation](https://sourceware.org/gdb/documentation/)

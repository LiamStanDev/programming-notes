# 基準測試框架

準確的性能測試是 HFT 系統開發的基礎,本章介紹 Google Benchmark 等工具的使用。

---

## 1. Google Benchmark 基礎

### 1.1 安裝與設定

```cmake
# CMakeLists.txt
include(FetchContent)

FetchContent_Declare(
    benchmark
    GIT_REPOSITORY https://github.com/google/benchmark.git
    GIT_TAG v1.8.0
)

FetchContent_MakeAvailable(benchmark)

# 建立 benchmark 執行檔
add_executable(bench_orderbook bench_orderbook.cpp)
target_link_libraries(bench_orderbook PRIVATE benchmark::benchmark)
```

### 1.2 基本範例

```cpp
#include <benchmark/benchmark.h>
#include <vector>

// 簡單的 benchmark
static void BM_VectorPushBack(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<int> v;
        v.reserve(state.range(0));
        
        for (int i = 0; i < state.range(0); ++i) {
            v.push_back(i);
        }
        
        benchmark::DoNotOptimize(v.data());  // 防止編譯器優化掉
    }
    
    state.SetComplexityN(state.range(0));
}

// 註冊 benchmark
BENCHMARK(BM_VectorPushBack)->Range(8, 8<<10);

BENCHMARK_MAIN();
```

### 1.3 編譯與執行

```bash
# 編譯
g++ -std=c++17 -O3 bench_orderbook.cpp -lbenchmark -lpthread -o bench

# 執行
./bench

# 輸出範例:
# Benchmark                    Time       CPU   Iterations
# BM_VectorPushBack/8        45 ns     45 ns   15647894
# BM_VectorPushBack/64      312 ns    312 ns    2234567
# BM_VectorPushBack/512    2456 ns   2456 ns     284567
```

---

## 2. Benchmark 進階技巧

### 2.1 參數化測試

```cpp
// 測試不同大小
static void BM_OrderBookUpdate(benchmark::State& state) {
    int num_levels = state.range(0);
    OrderBook ob(num_levels);
    
    for (auto _ : state) {
        ob.update(100.0, 1000, Side::BID);
        benchmark::ClobberMemory();  // 防止跨迭代優化
    }
}

BENCHMARK(BM_OrderBookUpdate)
    ->Arg(10)
    ->Arg(100)
    ->Arg(1000);
```

### 2.2 多參數測試

```cpp
static void BM_MarketDataProcessing(benchmark::State& state) {
    int num_symbols = state.range(0);
    int num_updates = state.range(1);
    
    // ...
    
    for (auto _ : state) {
        // 測試邏輯
    }
}

BENCHMARK(BM_MarketDataProcessing)
    ->Args({10, 100})
    ->Args({10, 1000})
    ->Args({100, 100})
    ->Args({100, 1000});
```

### 2.3 時間單位與統計

```cpp
static void BM_LatencySensitive(benchmark::State& state) {
    for (auto _ : state) {
        // 極低延遲操作
        auto start = std::chrono::high_resolution_clock::now();
        process_tick();
        auto end = std::chrono::high_resolution_clock::now();
        
        auto latency = std::chrono::duration_cast<std::chrono::nanoseconds>(
            end - start);
        state.SetIterationTime(latency.count() * 1e-9);  // 秒
    }
}

BENCHMARK(BM_LatencySensitive)
    ->Unit(benchmark::kNanosecond)  // 顯示單位
    ->UseManualTime();              // 手動計時
```

---

## 3. 避免常見陷阱

### 3.1 編譯器優化

```cpp
// ❌ 錯誤: 編譯器會優化掉整個迴圈
static void BM_Wrong(benchmark::State& state) {
    for (auto _ : state) {
        int result = expensive_computation();
        // result 沒被使用,編譯器可能移除 expensive_computation
    }
}

// ✅ 正確: 使用 DoNotOptimize
static void BM_Correct(benchmark::State& state) {
    for (auto _ : state) {
        int result = expensive_computation();
        benchmark::DoNotOptimize(result);  // 告訴編譯器不要優化
    }
}
```

### 3.2 Cache 預熱

```cpp
static void BM_CacheAware(benchmark::State& state) {
    std::vector<int> data(1000000);
    
    // 預熱 cache
    for (auto& v : data) {
        v = rand();
    }
    
    for (auto _ : state) {
        long long sum = 0;
        for (int v : data) {
            sum += v;
        }
        benchmark::DoNotOptimize(sum);
    }
}
```

### 3.3 測量記憶體使用

```cpp
static void BM_MemoryAllocation(benchmark::State& state) {
    for (auto _ : state) {
        state.PauseTiming();  // 暫停計時
        
        // 準備工作 (不計時)
        auto* buffer = new char[state.range(0)];
        
        state.ResumeTiming();  // 恢復計時
        
        // 實際測試
        memset(buffer, 0, state.range(0));
        
        state.PauseTiming();
        delete[] buffer;
        state.ResumeTiming();
    }
    
    state.SetBytesProcessed(state.iterations() * state.range(0));
}

BENCHMARK(BM_MemoryAllocation)->Range(1<<10, 1<<20);
```

---

## 4. HFT 實戰測試

### 4.1 Order Book 性能測試

```cpp
#include <benchmark/benchmark.h>
#include "order_book.hpp"

static void BM_OrderBook_Insert(benchmark::State& state) {
    OrderBook ob;
    int order_id = 0;
    
    for (auto _ : state) {
        state.PauseTiming();
        Order order{order_id++, 100.0 + (order_id % 10) * 0.01, 
                    100, Side::BID};
        state.ResumeTiming();
        
        ob.insert(order);
    }
    
    state.SetItemsProcessed(state.iterations());
}

static void BM_OrderBook_Cancel(benchmark::State& state) {
    OrderBook ob;
    
    // 預先填充 order book
    for (int i = 0; i < 1000; ++i) {
        ob.insert({i, 100.0 + i * 0.01, 100, Side::BID});
    }
    
    int cancel_id = 0;
    for (auto _ : state) {
        ob.cancel(cancel_id++ % 1000);
    }
}

static void BM_OrderBook_Match(benchmark::State& state) {
    OrderBook ob;
    
    // 預先填充
    for (int i = 0; i < 500; ++i) {
        ob.insert({i, 100.0 - i * 0.01, 100, Side::BID});
        ob.insert({i + 500, 100.0 + i * 0.01, 100, Side::ASK});
    }
    
    for (auto _ : state) {
        // 新訂單會觸發撮合
        ob.insert({10000, 100.0, 50, Side::BID});
    }
}

BENCHMARK(BM_OrderBook_Insert);
BENCHMARK(BM_OrderBook_Cancel);
BENCHMARK(BM_OrderBook_Match);

BENCHMARK_MAIN();
```

### 4.2 網路協議解析

```cpp
static void BM_ParseMarketData(benchmark::State& state) {
    // 模擬市場數據封包
    constexpr size_t PACKET_SIZE = 1024;
    char packet[PACKET_SIZE];
    fill_test_packet(packet, PACKET_SIZE);
    
    for (auto _ : state) {
        MarketTick tick;
        parse_market_data(packet, PACKET_SIZE, tick);
        benchmark::DoNotOptimize(tick);
    }
    
    state.SetBytesProcessed(state.iterations() * PACKET_SIZE);
}

BENCHMARK(BM_ParseMarketData);
```

---

## 5. 結果分析與解讀

### 5.1 輸出格式

```bash
./bench --benchmark_format=json > results.json

# 或 CSV
./bench --benchmark_format=csv > results.csv
```

### 5.2 比較不同版本

```bash
# 執行基線版本
./bench_v1 --benchmark_out=baseline.json --benchmark_out_format=json

# 執行優化版本
./bench_v2 --benchmark_out=optimized.json --benchmark_out_format=json

# 比較
compare.py benchmarks baseline.json optimized.json

# 輸出:
# Benchmark                     Time       CPU    Time Old  Time New
# BM_OrderBook_Insert         +0.15     +0.15        120       138
# BM_OrderBook_Cancel         -0.45     -0.45        200       110
```

---

## 6. Catch2 單元測試

### 6.1 基本使用

```cpp
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>

TEST_CASE("OrderBook insert", "[orderbook]") {
    OrderBook ob;
    Order order{1, 100.0, 100, Side::BID};
    
    REQUIRE(ob.insert(order));
    REQUIRE(ob.size() == 1);
}

TEST_CASE("OrderBook cancel", "[orderbook]") {
    OrderBook ob;
    ob.insert({1, 100.0, 100, Side::BID});
    
    REQUIRE(ob.cancel(1));
    REQUIRE(ob.size() == 0);
}
```

### 6.2 性能測試整合

```cpp
TEST_CASE("OrderBook performance", "[.][benchmark]") {
    OrderBook ob;
    
    BENCHMARK("Insert 1000 orders") {
        for (int i = 0; i < 1000; ++i) {
            ob.insert({i, 100.0 + i * 0.01, 100, Side::BID});
        }
    };
}
```

---

## 7. CI/CD 整合

### 7.1 性能回歸測試

```yaml
# .github/workflows/benchmark.yml
name: Performance Benchmarks

on: [push, pull_request]

jobs:
  benchmark:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Build benchmarks
        run: |
          cmake -B build -DBUILD_BENCHMARKS=ON
          cmake --build build
      
      - name: Run benchmarks
        run: |
          cd build
          ./bench --benchmark_out=results.json
      
      - name: Store results
        uses: actions/upload-artifact@v3
        with:
          name: benchmark-results
          path: build/results.json
      
      - name: Compare with baseline
        run: |
          python3 tools/compare_benchmarks.py \
            baseline.json \
            build/results.json
```

---

## 參考資料

1. **Google Benchmark**
   - [Google Benchmark GitHub](https://github.com/google/benchmark)
   - [User Guide](https://github.com/google/benchmark/blob/main/docs/user_guide.md)

2. **Catch2**
   - [Catch2 Documentation](https://github.com/catchorg/Catch2)

3. **性能測試最佳實踐**
   - [Chandler Carruth - Benchmarking C++ Code](https://www.youtube.com/watch?v=nXaxk27zwlk)

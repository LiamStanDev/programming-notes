# 編譯器標誌與優化

深入理解 GCC 和 Clang 的優化選項,對於構建高性能 HFT 系統至關重要。

---

## 1. 優化等級

### 1.1 基本優化等級

| 選項 | 說明 | 編譯時間 | 效能 | 使用場景 |
|-----|------|---------|------|---------|
| `-O0` | 無優化 | 快 | 差 | Debug |
| `-O1` | 基本優化 | 中 | 中 | 快速測試 |
| `-O2` | 標準優化 | 中 | 好 | **Release 預設** |
| `-O3` | 激進優化 | 慢 | 最好* | **HFT 首選** |
| `-Ofast` | 極限優化 | 慢 | 最好** | 可接受精度損失 |
| `-Os` | 優化大小 | 中 | 中 | 嵌入式系統 |

\* 可能增加程式碼大小  
\** 違反 IEEE 754 標準

### 1.2 優化等級包含的選項

**`-O2` 包含**:
- `-finline-functions`
- `-funroll-loops` (部分)
- `-foptimize-sibling-calls`
- `-ftree-vectorize` (部分)

**`-O3` 額外包含**:
- `-finline-functions` (更激進)
- `-funroll-loops` (完整)
- `-fvect-cost-model=unlimited`
- `-fpredictive-commoning`
- `-fgcse-after-reload`

**`-Ofast` 額外包含**:
- `-ffast-math` (違反 IEEE 754)
- `-fno-protect-parens`
- `-fexcess-precision=fast`

---

## 2. 架構特定優化

### 2.1 CPU 指令集選擇

```bash
# 使用本機 CPU 所有特性 (推薦)
g++ -O3 -march=native -mtune=native main.cpp

# 指定特定 CPU 架構
g++ -O3 -march=skylake-avx512 main.cpp

# 查看本機 CPU 支援的指令集
gcc -march=native -Q --help=target | grep enabled
```

**常見選項**:
- `-march=native`: 使用編譯機器的 CPU 特性
- `-march=x86-64-v3`: AMD64 v3 (AVX2, BMI2, F16C, FMA)
- `-march=skylake-avx512`: Intel Skylake 伺服器
- `-mtune=native`: 針對本機 CPU 調校 (不限制指令集)

### 2.2 SIMD 優化

```bash
# 啟用 AVX2
g++ -O3 -mavx2 -mfma main.cpp

# 啟用 AVX-512
g++ -O3 -mavx512f -mavx512dq main.cpp

# 查看生成的向量化程式碼
g++ -O3 -march=native -fopt-info-vec-optimized main.cpp
```

---

## 3. LTO (Link-Time Optimization)

### 3.1 基本使用

```bash
# 編譯時啟用 LTO
g++ -O3 -flto -c file1.cpp -o file1.o
g++ -O3 -flto -c file2.cpp -o file2.o

# 連結時執行 LTO
g++ -O3 -flto file1.o file2.o -o program

# 或一步到位
g++ -O3 -flto file1.cpp file2.cpp -o program
```

### 3.2 Thin LTO (Clang)

```bash
# Thin LTO (更快的 LTO)
clang++ -O3 -flto=thin main.cpp -o program
```

### 3.3 效能提升

```cpp
// file1.cpp
int compute(int x) {
    return x * x + 2 * x + 1;
}

// file2.cpp
extern int compute(int);
int main() {
    int result = 0;
    for (int i = 0; i < 1000000; ++i) {
        result += compute(i);  // 沒有 LTO: 函數呼叫開銷
    }                          // 有 LTO: inline 到 main
    return result;
}

// 測試結果:
// 無 LTO:   25 ms
// 有 LTO:   8 ms (3x 提升)
```

---

## 4. PGO (Profile-Guided Optimization)

### 4.1 三步驟流程

```bash
# 步驟 1: 編譯並生成 profile
g++ -O3 -fprofile-generate main.cpp -o program

# 步驟 2: 執行程式收集數據 (使用真實工作負載)
./program < typical_input.txt

# 步驟 3: 使用 profile 重新編譯
g++ -O3 -fprofile-use main.cpp -o program_optimized
```

### 4.2 HFT 應用

```bash
#!/bin/bash
# pgo_build.sh

# 1. Profile 建置
g++ -O3 -march=native -fprofile-generate     hft_engine.cpp -o hft_engine_profile

# 2. 運行典型場景
./hft_engine_profile --replay market_data_sample.pcap

# 3. 最終建置
g++ -O3 -march=native -fprofile-use     hft_engine.cpp -o hft_engine

echo "PGO 建置完成!"
```

**效能提升**: 5-15% (分支預測優化、函數排列)

---

## 5. 編譯器內建函數 (Builtins)

### 5.1 分支預測提示

```cpp
// likely/unlikely 提示 (C++20)
if (price > threshold) [[likely]] {
    execute_trade();
} else [[unlikely]] {
    log_error();
}

// GCC/Clang builtin (C++17 以前)
if (__builtin_expect(price > threshold, 1)) {
    execute_trade();
} else {
    log_error();
}
```

### 5.2 位元操作

```cpp
// 計算前導零位元數 (CLZ)
int clz = __builtin_clz(value);

// 計算尾隨零位元數 (CTZ)
int ctz = __builtin_ctz(value);

// 計算 1 的個數 (Population count)
int popcount = __builtin_popcount(value);

// 64 位元版本
int clz64 = __builtin_clzll(value);
```

### 5.3 記憶體屏障

```cpp
// 編譯器屏障 (防止重排)
__asm__ volatile("" ::: "memory");

// CPU 記憶體屏障
__sync_synchronize();
```

---

## 6. 編譯選項對延遲的影響

### 6.1 關鍵選項對比

```cpp
// 測試程式碼
void benchmark_options() {
    constexpr int N = 1000000;
    std::vector<double> data(N);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < N; ++i) {
        data[i] = std::sqrt(i) * std::log(i + 1);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
        end - start);
    
    std::cout << "耗時: " << duration.count() << " ms\n";
}

/* 編譯選項對比:
-O0:                     450 ms
-O2:                     85 ms
-O3:                     75 ms
-O3 -march=native:       45 ms
-O3 -march=native -flto: 38 ms
-Ofast -march=native:    32 ms
*/
```

---

## 7. 推薦編譯選項組合

### 7.1 HFT Release 建置

```bash
g++ -O3     -march=native     -mtune=native     -flto     -fno-exceptions \           # 禁用例外 (可選)
    -fno-rtti \                 # 禁用 RTTI (可選)
    -ffast-math \               # 快速數學 (小心精度)
    -funroll-loops     -finline-functions     -fomit-frame-pointer     -DNDEBUG     hft_engine.cpp -o hft_engine
```

### 7.2 CMake 配置

```cmake
# CMakeLists.txt
if(CMAKE_BUILD_TYPE STREQUAL "Release")
    target_compile_options(hft_engine PRIVATE
        -O3
        -march=native
        -mtune=native
        -flto
        -ffast-math
        -funroll-loops
        -fomit-frame-pointer
    )
    
    target_compile_definitions(hft_engine PRIVATE
        NDEBUG
    )
    
    set_target_properties(hft_engine PROPERTIES
        INTERPROCEDURAL_OPTIMIZATION TRUE  # LTO
    )
endif()
```

---

## 8. GCC vs Clang 差異

### 8.1 優化策略差異

| 特性 | GCC | Clang |
|-----|-----|-------|
| **向量化** | 更激進 | 較保守 |
| **Inline** | 啟發式 | 更激進 |
| **迴圈優化** | 強大 | 中等 |
| **診斷訊息** | 普通 | 優秀 |
| **編譯速度** | 中 | 快 |
| **LTO** | Fat LTO | Thin LTO (更快) |

### 8.2 選擇建議

**GCC 適合**:
- 需要最極限性能
- 向量化密集運算
- 已有 GCC 調校經驗

**Clang 適合**:
- 開發階段 (編譯快、錯誤訊息好)
- 需要 Sanitizers
- 跨平台專案

---

## 參考資料

1. **GCC 文件**
   - [GCC Optimization Options](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)
   - [GCC x86 Options](https://gcc.gnu.org/onlinedocs/gcc/x86-Options.html)

2. **Clang 文件**
   - [Clang Optimization Flags](https://clang.llvm.org/docs/CommandGuide/clang.html)
   - [ThinLTO](https://clang.llvm.org/docs/ThinLTO.html)

3. **效能分析**
   - [Agner Fog's Optimization Manuals](https://www.agner.org/optimize/)

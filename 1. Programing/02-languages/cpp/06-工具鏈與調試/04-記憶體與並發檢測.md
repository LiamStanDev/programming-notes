# 記憶體與並發檢測

Sanitizers 是現代 C++ 開發必備的除錯工具,可在開發階段發現潛在錯誤。

---

## 1. AddressSanitizer (ASan)

### 1.1 基本使用

```bash
# 編譯時啟用 ASan
g++ -fsanitize=address -fno-omit-frame-pointer -g main.cpp -o program

# 執行
./program
```

### 1.2 檢測的錯誤類型

**1. Heap buffer overflow**
```cpp
int* arr = new int[10];
arr[10] = 42;  // ❌ ASan 檢測: heap-buffer-overflow
delete[] arr;
```

**2. Stack buffer overflow**
```cpp
void func() {
    int arr[10];
    arr[10] = 42;  // ❌ ASan 檢測: stack-buffer-overflow
}
```

**3. Use after free**
```cpp
int* ptr = new int(42);
delete ptr;
int value = *ptr;  // ❌ ASan 檢測: heap-use-after-free
```

**4. Use after return**
```cpp
int* dangerous() {
    int x = 42;
    return &x;  // ❌ ASan 檢測: stack-use-after-return
}
```

**5. Memory leaks**
```cpp
void leak() {
    int* ptr = new int(42);
    // 忘記 delete
}  // ❌ ASan 檢測: memory leak
```

### 1.3 CMake 配置

```cmake
option(ENABLE_ASAN "Enable AddressSanitizer" OFF)

if(ENABLE_ASAN)
    target_compile_options(${PROJECT_NAME} PRIVATE
        -fsanitize=address
        -fno-omit-frame-pointer
        -g
    )
    target_link_options(${PROJECT_NAME} PRIVATE
        -fsanitize=address
    )
endif()
```

---

## 2. ThreadSanitizer (TSan)

### 2.1 數據競爭檢測

```bash
# 編譯時啟用 TSan
g++ -fsanitize=thread -g main.cpp -o program
```

### 2.2 檢測範例

**數據競爭**:
```cpp
#include <thread>

int global_counter = 0;

void increment() {
    for (int i = 0; i < 100000; ++i) {
        ++global_counter;  // ❌ TSan 檢測: data race
    }
}

int main() {
    std::thread t1(increment);
    std::thread t2(increment);
    
    t1.join();
    t2.join();
}

// TSan 輸出:
// WARNING: ThreadSanitizer: data race
//   Write of size 4 at 0x... by thread T1
//   Previous write of size 4 at 0x... by thread T2
```

**正確版本**:
```cpp
#include <atomic>

std::atomic<int> global_counter{0};

void increment() {
    for (int i = 0; i < 100000; ++i) {
        global_counter.fetch_add(1, std::memory_order_relaxed);
    }
}
```

### 2.3 死鎖檢測

```cpp
std::mutex m1, m2;

void thread1() {
    std::lock_guard<std::mutex> lock1(m1);
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::lock_guard<std::mutex> lock2(m2);  // 死鎖!
}

void thread2() {
    std::lock_guard<std::mutex> lock2(m2);
    std::this_thread::sleep_for(std::chrono::milliseconds(10));
    std::lock_guard<std::mutex> lock1(m1);  // 死鎖!
}

// TSan 檢測死鎖並給出報告
```

---

## 3. UndefinedBehaviorSanitizer (UBSan)

### 3.1 基本使用

```bash
g++ -fsanitize=undefined -g main.cpp -o program
```

### 3.2 檢測的 UB

**1. 整數溢位**
```cpp
int x = INT_MAX;
x += 1;  // ❌ UBSan: signed integer overflow
```

**2. 除以零**
```cpp
int x = 10 / 0;  // ❌ UBSan: division by zero
```

**3. 空指針解引用**
```cpp
int* ptr = nullptr;
*ptr = 42;  // ❌ UBSan: null pointer dereference
```

**4. 未對齊的存取**
```cpp
char buffer[10];
int* ptr = reinterpret_cast<int*>(buffer + 1);
*ptr = 42;  // ❌ UBSan: misaligned address
```

---

## 4. LeakSanitizer (LSan)

### 4.1 獨立使用

```bash
g++ -fsanitize=leak -g main.cpp -o program
```

### 4.2 記憶體洩漏檢測

```cpp
void leak_example() {
    int* arr = new int[1000];
    // 忘記 delete[]
}

// LSan 輸出:
// Direct leak of 4000 byte(s) in 1 object(s)
//   #0 operator new[]
//   #1 leak_example()
//   #2 main
```

---

## 5. Valgrind Helgrind - 並發錯誤檢測

### 5.1 基本使用

```bash
valgrind --tool=helgrind ./program
```

### 5.2 檢測問題

**1. 數據競爭**
```cpp
int global = 0;

void* thread_func(void* arg) {
    global = 42;  // 未加鎖
    return nullptr;
}

// Helgrind 報告數據競爭
```

**2. 死鎖**
```cpp
pthread_mutex_t m1 = PTHREAD_MUTEX_INITIALIZER;
pthread_mutex_t m2 = PTHREAD_MUTEX_INITIALIZER;

void* thread1(void*) {
    pthread_mutex_lock(&m1);
    pthread_mutex_lock(&m2);
    // ...
}

void* thread2(void*) {
    pthread_mutex_lock(&m2);
    pthread_mutex_lock(&m1);  // 死鎖風險
    // ...
}
```

---

## 6. Sanitizer 對性能的影響

### 6.1 性能開銷

| Sanitizer | 速度影響 | 記憶體影響 | 使用場景 |
|-----------|---------|-----------|---------|
| ASan | 2x | 2-3x | 開發、測試 |
| TSan | 5-15x | 5-10x | 並發測試 |
| UBSan | 1.2x | 1x | 開發、CI |
| LSan | 1x | 1x | 測試結束時 |

### 6.2 測試範例

```cpp
void benchmark_with_sanitizer() {
    constexpr int N = 10000000;
    std::vector<int> data(N);
    
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < N; ++i) {
        data[i] = i * i;
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(
        end - start);
    
    std::cout << "耗時: " << duration.count() << " ms\n";
}

/* 測試結果:
無 Sanitizer:   120 ms
+ASan:          240 ms (2x)
+TSan:         1200 ms (10x)
+UBSan:         145 ms (1.2x)
*/
```

---

## 7. HFT 實戰: 開發流程整合

### 7.1 CMake 配置

```cmake
# 定義 Sanitizer 選項
option(ENABLE_ASAN "Enable AddressSanitizer" OFF)
option(ENABLE_TSAN "Enable ThreadSanitizer" OFF)
option(ENABLE_UBSAN "Enable UBSanitizer" ON)  # 預設啟用

# ASan 配置
if(ENABLE_ASAN)
    set(SANITIZER_FLAGS "${SANITIZER_FLAGS} -fsanitize=address")
    message(STATUS "AddressSanitizer enabled")
endif()

# TSan 配置
if(ENABLE_TSAN)
    if(ENABLE_ASAN)
        message(FATAL_ERROR "ASan and TSan cannot be used together")
    endif()
    set(SANITIZER_FLAGS "${SANITIZER_FLAGS} -fsanitize=thread")
    message(STATUS "ThreadSanitizer enabled")
endif()

# UBSan 配置
if(ENABLE_UBSAN)
    set(SANITIZER_FLAGS "${SANITIZER_FLAGS} -fsanitize=undefined")
    message(STATUS "UBSanitizer enabled")
endif()

# 應用到所有 targets
if(SANITIZER_FLAGS)
    add_compile_options(${SANITIZER_FLAGS} -fno-omit-frame-pointer -g)
    add_link_options(${SANITIZER_FLAGS})
endif()
```

### 7.2 建置腳本

```bash
#!/bin/bash
# build_with_sanitizers.sh

# Debug 建置 + ASan + UBSan
cmake -B build_debug \
    -DCMAKE_BUILD_TYPE=Debug \
    -DENABLE_ASAN=ON \
    -DENABLE_UBSAN=ON
cmake --build build_debug

# 執行測試
cd build_debug
ctest --output-on-failure

# TSan 建置 (單獨)
cmake -B build_tsan \
    -DCMAKE_BUILD_TYPE=Debug \
    -DENABLE_TSAN=ON
cmake --build build_tsan

cd build_tsan
ctest --output-on-failure
```

### 7.3 CI/CD 整合

```yaml
# .github/workflows/sanitizers.yml
name: Sanitizers

on: [push, pull_request]

jobs:
  asan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build with ASan
        run: |
          cmake -B build -DENABLE_ASAN=ON
          cmake --build build
      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure
  
  tsan:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Build with TSan
        run: |
          cmake -B build -DENABLE_TSAN=ON
          cmake --build build
      - name: Run tests
        run: |
          cd build
          ctest --output-on-failure
```

---

## 8. 除錯技巧

### 8.1 ASan 選項

```bash
# 環境變數控制 ASan 行為
export ASAN_OPTIONS="detect_leaks=1:halt_on_error=0:log_path=asan.log"

./program

# 選項說明:
# detect_leaks=1: 啟用洩漏檢測
# halt_on_error=0: 發現錯誤後繼續執行
# log_path=asan.log: 輸出到檔案
```

### 8.2 TSan 選項

```bash
export TSAN_OPTIONS="halt_on_error=0:log_path=tsan.log:history_size=7"

./program
```

### 8.3 suppressions 檔案

```bash
# asan_suppressions.txt
leak:^libcrypto.so
leak:^libssl.so

# 使用
export ASAN_OPTIONS="suppressions=asan_suppressions.txt"
./program
```

---

## 參考資料

1. **AddressSanitizer**
   - [ASan Wiki](https://github.com/google/sanitizers/wiki/AddressSanitizer)

2. **ThreadSanitizer**
   - [TSan Documentation](https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual)

3. **Valgrind**
   - [Helgrind Manual](https://valgrind.org/docs/manual/hg-manual.html)
   - [DRD Manual](https://valgrind.org/docs/manual/drd-manual.html)

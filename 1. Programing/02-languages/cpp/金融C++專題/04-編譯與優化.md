# 編譯與優化

> 本章涵蓋 C++ 編譯流程、編譯器優化技術、CMake 構建系統等,是構建高性能交易系統的基礎。

---

## 目錄

> **HFT 學習優先級**: ⭐⭐⭐ 必看 | ⭐⭐ 建議 | ⭐ 有空再看

1. [編譯流程](#1-編譯流程) ⭐
2. [編譯器優化級別](#2-編譯器優化級別) ⭐⭐⭐
3. [CPU 特定優化](#3-cpu-特定優化) ⭐⭐⭐
4. [鏈接時優化 (LTO)](#4-鏈接時優化-lto) ⭐⭐
5. [性能引導優化 (PGO)](#5-性能引導優化-pgo) ⭐
6. [內聯優化](#6-內聯優化) ⭐⭐
7. [編譯器內建函數](#7-編譯器內建函數) ⭐⭐
8. [CMake 構建系統](#8-cmake-構建系統) ⭐⭐

---

## 1. 編譯流程

### 1.0 概念解析: 為什麼需要編譯?

計算機只能理解二進制指令 (機器碼, Machine Code)。我們寫的 C++ 代碼 (源代碼) 是給人看的。**編譯**就是將"人看的代碼"翻譯成"機器看的代碼"的過程。

這個過程就像將一本中文書翻譯成英文書,需要經過幾個步驟:

1.  **預處理**: 整理格式,替換縮寫 (宏展開)。
2.  **編譯**: 翻譯成彙編語言 (類似將中文翻譯成通用的中間語言)。
3.  **彙編**: 將彙編語言轉成機器碼 (將中間語言轉成目標二進制)。
4.  **鏈接**: 將多個章節 (目標文件) 裝訂成一本書 (可執行文件)。

### 1.1 編譯流程詳解

C++ 編譯分為四個階段:

```bash
# 1. 預處理 (Preprocessing)
# 展開 #include, 替換 #define
g++ -E main.cpp -o main.i

# 2. 編譯 (Compilation)
# 將 C++ 代碼翻譯成彙編代碼
g++ -S main.i -o main.s

# 3. 彙編 (Assembly)
# 將彙編代碼翻譯成機器碼 (目標文件 .o)
g++ -c main.s -o main.o

# 4. 鏈接 (Linking)
# 將目標文件和庫文件合併成可執行程序
g++ main.o -o main
```

### 1.1 預處理階段

```cpp
// example.cpp
#include <iostream>
#define MAX_SIZE 1000

int main() {
    #ifdef DEBUG
    std::cout << "Debug mode\n";
    #endif

    int arr[MAX_SIZE];
    return 0;
}
```

```bash
# 查看預處理結果
g++ -E example.cpp -o example.i
# example.i 會展開所有 #include 和 #define
```

### 1.2 編譯階段

```bash
# 生成彙編代碼
g++ -S example.cpp -o example.s

# 查看彙編代碼
cat example.s
```

### 1.3 查看符號表

```bash
# 編譯為目標文件
g++ -c example.cpp -o example.o

# 查看符號
nm example.o

# 查看依賴
ldd ./program
```

---

## 2. 編譯器優化級別

### 2.1 優化級別對比

```bash
# -O0: 無優化 (默認,調試用)
g++ -O0 main.cpp -o main_O0

# -O1: 基本優化
g++ -O1 main.cpp -o main_O1

# -O2: 推薦優化 (平衡性能與編譯時間)
g++ -O2 main.cpp -o main_O2

# -O3: 激進優化 (可能增加代碼體積)
g++ -O3 main.cpp -o main_O3

# -Ofast: 最激進 (可能違反標準)
g++ -Ofast main.cpp -o main_Ofast

# -Os: 優化大小
g++ -Os main.cpp -o main_Os
```

### 2.2 性能測試

```cpp
#include <iostream>
#include <chrono>
#include <vector>

double compute_sum(const std::vector<double>& data) {
    double sum = 0.0;
    for (size_t i = 0; i < data.size(); ++i) {
        sum += data[i] * data[i];
    }
    return sum;
}

int main() {
    const int N = 10000000;
    std::vector<double> data(N, 1.5);

    auto start = std::chrono::high_resolution_clock::now();

    double result = compute_sum(data);

    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);

    std::cout << "Result: " << result << "\n";
    std::cout << "Time: " << duration.count() << " ms\n";

    return 0;
}
```

```bash
# 編譯並測試不同優化級別
g++ -O0 benchmark.cpp -o bench_O0 && ./bench_O0
# Time: ~150 ms

g++ -O2 benchmark.cpp -o bench_O2 && ./bench_O2
# Time: ~20 ms

g++ -O3 benchmark.cpp -o bench_O3 && ./bench_O3
# Time: ~15 ms
```

**優化效果對比:**

| 優化級別 | 編譯時間 | 執行時間 | 代碼大小 | HFT 推薦    |
| -------- | -------- | -------- | -------- | ----------- |
| -O0      | 最快     | 最慢     | 最大     | ❌ 僅調試   |
| -O1      | 快       | 慢       | 大       | ❌          |
| -O2      | 中等     | 快       | 中等     | ✅ 開發階段 |
| -O3      | 慢       | 最快     | 較大     | ✅ 生產環境 |
| -Ofast   | 慢       | 極快     | 較大     | ⚠️ 謹慎使用 |

---

## 3. CPU 特定優化

### 3.1 概念解析: 什麼是 SIMD?

**SIMD (Single Instruction, Multiple Data)** 即"單指令多數據"。

- **標量 (Scalar)**: 一次處理一個數據 (例如: 1 + 1)。
- **向量 (Vector/SIMD)**: 一次處理多個數據 (例如: [1,2,3,4] + [1,1,1,1])。

**類比**:

- **標量**: 一個人搬磚,一次搬一塊。
- **SIMD**: 一個人開推車,一次搬 8 塊。

在 HFT 中,我們利用 SIMD 指令集 (如 AVX2, AVX-512) 來同時處理多個行情數據或訂單,極大提升吞吐量。

### 3.2 架構特定優化

```bash
# 查看 CPU 信息
lscpu

# 針對本機 CPU 優化
g++ -O3 -march=native main.cpp -o main

# 針對特定架構
g++ -O3 -march=skylake main.cpp -o main
g++ -O3 -march=haswell main.cpp -o main

# 啟用 AVX2 指令集
g++ -O3 -mavx2 main.cpp -o main
```

### 3.2 SIMD 優化示例

```cpp
#include <immintrin.h>  // AVX intrinsics
#include <iostream>
#include <chrono>

// 標量版本
void add_scalar(float* a, float* b, float* c, int n) {
    for (int i = 0; i < n; ++i) {
        c[i] = a[i] + b[i];
    }
}

// AVX 向量化版本
void add_avx(float* a, float* b, float* c, int n) {
    int i = 0;
    for (; i + 8 <= n; i += 8) {
        __m256 va = _mm256_loadu_ps(&a[i]);
        __m256 vb = _mm256_loadu_ps(&b[i]);
        __m256 vc = _mm256_add_ps(va, vb);
        _mm256_storeu_ps(&c[i], vc);
    }

    // 處理剩餘元素
    for (; i < n; ++i) {
        c[i] = a[i] + b[i];
    }
}

int main() {
    const int N = 10000000;
    float* a = new float[N];
    float* b = new float[N];
    float* c = new float[N];

    // 初始化
    for (int i = 0; i < N; ++i) {
        a[i] = i * 1.0f;
        b[i] = i * 2.0f;
    }

    // 測試標量版本
    auto start = std::chrono::high_resolution_clock::now();
    add_scalar(a, b, c, N);
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "Scalar: " << duration.count() << " us\n";

    // 測試 AVX 版本
    start = std::chrono::high_resolution_clock::now();
    add_avx(a, b, c, N);
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
    std::cout << "AVX: " << duration.count() << " us\n";

    delete[] a;
    delete[] b;
    delete[] c;

    return 0;
}
```

```bash
# 編譯並運行
g++ -O3 -mavx2 simd_example.cpp -o simd
./simd
# Scalar: ~15000 us
# AVX: ~3000 us  (5x 加速!)
```

---

## 4. 鏈接時優化 (LTO)

### 4.0 概念解析: 什麼是鏈接?

**鏈接 (Linking)** 是將多個編譯好的目標文件 (`.o`) 和庫文件 (`.a` 或 `.so`) 合併成一個最終可執行文件的過程。

**靜態鏈接 vs 動態鏈接:**

| 特性               | 靜態鏈接 (Static Linking)      | 動態鏈接 (Dynamic Linking)      |
| :----------------- | :----------------------------- | :------------------------------ |
| **類比**           | 把參考書的內容抄到筆記本上     | 在筆記本上記下參考書的頁碼      |
| **文件後綴**       | `.a` (Linux), `.lib` (Windows) | `.so` (Linux), `.dll` (Windows) |
| **可執行文件大小** | 大 (包含所有代碼)              | 小 (只包含引用)                 |
| **運行依賴**       | 無 (獨立運行)                  | 需要庫文件存在                  |
| **性能**           | **快** (無跳轉開銷, 易於優化)  | 稍慢 (需要運行時解析地址)       |
| **HFT 推薦**       | ✅ **推薦** (性能最好)         | ❌ 避免 (增加延遲)              |

LTO (Link Time Optimization) 允許編譯器在鏈接階段進行跨文件優化,就像在裝訂書籍時,還能對整本書的內容進行前後校對和優化。

LTO 允許編譯器在鏈接階段進行跨文件優化。

### 4.1 LTO 示例

```cpp
// module1.cpp
int compute(int x) {
    return x * x + 2 * x + 1;
}

// module2.cpp
int compute(int x);

int main() {
    int result = 0;
    for (int i = 0; i < 1000000; ++i) {
        result += compute(i);
    }
    return result;
}
```

```bash
# 無 LTO
g++ -O3 -c module1.cpp -o module1.o
g++ -O3 -c module2.cpp -o module2.o
g++ -O3 module1.o module2.o -o program

# 使用 LTO (跨模塊內聯)
g++ -O3 -flto -c module1.cpp -o module1_lto.o
g++ -O3 -flto -c module2.cpp -o module2_lto.o
g++ -O3 -flto module1_lto.o module2_lto.o -o program_lto

# 性能對比
time ./program       # ~50 ms
time ./program_lto   # ~10 ms (5x 加速!)
```

---

## 5. 性能引導優化 (PGO)

PGO 通過運行時數據指導編譯器優化。

### 5.1 PGO 三步驟

```bash
# 步驟 1: 編譯並生成性能數據收集版本
g++ -O3 -fprofile-generate main.cpp -o main_gen

# 步驟 2: 運行程序收集性能數據
./main_gen
# 生成 *.gcda 文件

# 步驟 3: 使用性能數據重新編譯
g++ -O3 -fprofile-use main.cpp -o main_pgo
```

### 5.2 PGO 示例

```cpp
#include <iostream>
#include <random>

int process_data(int x) {
    if (x % 2 == 0) {  // 分支預測
        return x * x;
    } else {
        return x + 1;
    }
}

int main() {
    std::mt19937 gen(42);
    std::uniform_int_distribution<> dis(1, 100);

    long long sum = 0;
    for (int i = 0; i < 100000000; ++i) {
        int x = dis(gen);
        sum += process_data(x);
    }

    std::cout << "Sum: " << sum << "\n";
    return 0;
}
```

```bash
# 無 PGO
g++ -O3 pgo_example.cpp -o pgo_no
time ./pgo_no
# Time: ~2.5s

# 使用 PGO
g++ -O3 -fprofile-generate pgo_example.cpp -o pgo_gen
./pgo_gen  # 收集數據
g++ -O3 -fprofile-use pgo_example.cpp -o pgo_yes
time ./pgo_yes
# Time: ~2.0s (20% 提升!)
```

---

## 6. 內聯優化

### 6.1 內聯關鍵字

```cpp
// 建議內聯 (編譯器可能忽略)
inline int add(int a, int b) {
    return a + b;
}

// 強制內聯 (GCC/Clang)
__attribute__((always_inline)) inline int multiply(int a, int b) {
    return a * b;
}

// 禁止內聯
__attribute__((noinline)) int divide(int a, int b) {
    return a / b;
}

// C++20: [[likely]] / [[unlikely]]
int process(int x) {
    if (x > 0) [[likely]] {
        return x * 2;
    } else [[unlikely]] {
        return 0;
    }
}
```

### 6.2 內聯性能測試

```cpp
#include <iostream>
#include <chrono>

// 不內聯
__attribute__((noinline))
int compute_no_inline(int x) {
    return x * x + 2 * x + 1;
}

// 內聯
inline int compute_inline(int x) {
    return x * x + 2 * x + 1;
}

int main() {
    const int N = 100000000;

    // 測試不內聯
    auto start = std::chrono::high_resolution_clock::now();
    long long sum1 = 0;
    for (int i = 0; i < N; ++i) {
        sum1 += compute_no_inline(i);
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "No inline: " << duration.count() << " ms\n";

    // 測試內聯
    start = std::chrono::high_resolution_clock::now();
    long long sum2 = 0;
    for (int i = 0; i < N; ++i) {
        sum2 += compute_inline(i);
    }
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    std::cout << "Inline: " << duration.count() << " ms\n";

    return 0;
}
```

```bash
g++ -O3 inline_test.cpp -o inline_test
./inline_test
# No inline: ~300 ms
# Inline: ~50 ms (6x 加速!)
```

---

## 7. 編譯器內建函數

### 7.1 常用內建函數

```cpp
#include <iostream>

void builtin_examples() {
    int x = 42;

    // 計算前導零
    int leading_zeros = __builtin_clz(x);
    std::cout << "Leading zeros: " << leading_zeros << "\n";

    // 計算尾隨零
    int trailing_zeros = __builtin_ctz(x);
    std::cout << "Trailing zeros: " << trailing_zeros << "\n";

    // 計算 1 的個數
    int popcount = __builtin_popcount(x);
    std::cout << "Popcount: " << popcount << "\n";

    // 預取數據到緩存
    int arr[1000];
    __builtin_prefetch(&arr[100], 0, 3);

    // 分支預測提示
    if (__builtin_expect(x > 0, 1)) {  // 1 表示 likely
        std::cout << "Likely branch\n";
    }

    // 內存屏障
    __sync_synchronize();
}
```

### 7.2 快速數學函數

```cpp
#include <cmath>
#include <iostream>

void fast_math_examples() {
    double x = 3.14;

    // 快速平方根倒數
    float rsqrt = 1.0f / std::sqrt(x);

    // 編譯器優化的數學函數
    double result = std::fma(2.0, 3.0, 4.0);  // 2*3 + 4 (融合乘加)

    std::cout << "FMA result: " << result << "\n";
}
```

---

## 8. CMake 構建系統

### 8.1 基本 CMakeLists.txt

```cmake
cmake_minimum_required(VERSION 3.15)
project(HFTSystem VERSION 1.0 LANGUAGES CXX)

# 設置 C++ 標準
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)
set(CMAKE_CXX_EXTENSIONS OFF)

# 編譯選項
set(CMAKE_CXX_FLAGS_RELEASE "-O3 -march=native -flto")
set(CMAKE_CXX_FLAGS_DEBUG "-O0 -g -fsanitize=address")

# 可執行文件
add_executable(trading_system
    src/main.cpp
    src/order_book.cpp
    src/market_data.cpp
)

# 包含目錄
target_include_directories(trading_system PRIVATE
    ${CMAKE_SOURCE_DIR}/include
)

# 鏈接庫
target_link_libraries(trading_system PRIVATE
    pthread
)
```

### 8.2 高級 CMake 配置

```cmake
# CMakeLists.txt (高級版)
cmake_minimum_required(VERSION 3.15)
project(HFTSystem VERSION 1.0 LANGUAGES CXX)

# 選項
option(ENABLE_LTO "Enable Link Time Optimization" ON)
option(ENABLE_TESTING "Enable testing" ON)
option(BUILD_BENCHMARKS "Build benchmarks" ON)

# C++ 標準
set(CMAKE_CXX_STANDARD 20)
set(CMAKE_CXX_STANDARD_REQUIRED ON)

# 編譯器警告
if(CMAKE_CXX_COMPILER_ID MATCHES "GNU|Clang")
    add_compile_options(
        -Wall
        -Wextra
        -Wpedantic
        -Werror
    )
endif()

# Release 優化
set(CMAKE_CXX_FLAGS_RELEASE "-O3 -march=native -DNDEBUG")

# LTO
if(ENABLE_LTO)
    set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)
endif()

# 子目錄
add_subdirectory(src)
add_subdirectory(tests)
add_subdirectory(benchmarks)

# 安裝
install(TARGETS trading_system DESTINATION bin)
```

### 8.3 構建命令

```bash
# 創建構建目錄
mkdir build && cd build

# 配置 (Release)
cmake -DCMAKE_BUILD_TYPE=Release ..

# 編譯
cmake --build . -j$(nproc)

# 安裝
sudo cmake --install .

# 清理
rm -rf build
```

### 8.4 多配置構建

```bash
# Debug 構建
cmake -DCMAKE_BUILD_TYPE=Debug -B build/debug
cmake --build build/debug

# Release 構建
cmake -DCMAKE_BUILD_TYPE=Release -B build/release
cmake --build build/release

# RelWithDebInfo (帶調試信息的優化版本)
cmake -DCMAKE_BUILD_TYPE=RelWithDebInfo -B build/relwithdebinfo
cmake --build build/relwithdebinfo
```

---

## 總結

本章涵蓋了編譯與優化的核心技術:

1. **編譯流程**: 預處理、編譯、彙編、鏈接
2. **優化級別**: -O0 到 -O3/-Ofast
3. **CPU 優化**: -march=native、SIMD
4. **LTO**: 跨文件優化
5. **PGO**: 性能引導優化
6. **內聯**: inline、always_inline
7. **內建函數**: \__builtin_\* 系列
8. **CMake**: 現代構建系統

**HFT 編譯最佳實踐:**

```bash
# 生產環境編譯命令
g++ -std=c++20 \
    -O3 \
    -march=native \
    -flto \
    -DNDEBUG \
    -Wall -Wextra \
    main.cpp -o trading_system \
    -lpthread
```

**性能提升總結:**

| 優化技術      | 性能提升 | 編譯時間 | 風險 | HFT 推薦 |
| ------------- | -------- | -------- | ---- | -------- |
| -O3           | 5-10x    | +50%     | 低   | ✅       |
| -march=native | 1.2-2x   | +10%     | 低   | ✅       |
| LTO           | 1.5-3x   | +100%    | 低   | ✅       |
| PGO           | 1.1-1.3x | +200%    | 中等 | ⚠️       |
| SIMD 手動     | 2-8x     | 0%       | 高   | ⚠️       |

**下一步:**

- 學習網路編程 (epoll、io_uring)
- 掌握系統調優 (CPU、內存)
- 深入性能分析工具 (perf、valgrind)

## 參考資料 (References)

1. [GCC Optimization Options](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)
2. [Clang Optimization Flags](https://clang.llvm.org/docs/CommandGuide/clang.html#optimization-options)
3. [Link Time Optimization](https://gcc.gnu.org/wiki/LinkTimeOptimization)
4. [Profile-Guided Optimization](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html#index-fprofile-generate)
5. [Intel Intrinsics Guide](https://www.intel.com/content/www/us/en/docs/intrinsics-guide/index.html)
6. [CMake Documentation](https://cmake.org/documentation/)
7. [Compiler Explorer (Godbolt)](https://godbolt.org/) - 在線查看編譯器優化結果

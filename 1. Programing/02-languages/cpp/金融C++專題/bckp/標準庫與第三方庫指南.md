# C++ 標準庫與第三方庫完全指南 (HFT 視角)

## 目錄

1. [C++ 標準庫深入](#c-標準庫深入)
2. [網路庫](#網路庫)
3. [序列化庫](#序列化庫)
4. [金融專用庫](#金融專用庫)
5. [高性能通用庫](#高性能通用庫)
6. [日誌庫](#日誌庫)
7. [測試與基準測試](#測試與基準測試)
8. [數學與數據處理](#數學與數據處理)
9. [監控與性能分析](#監控與性能分析)
10. [庫選擇建議](#庫選擇建議-hft-場景)

---

## C++ 標準庫深入

### STL 容器深入

#### 序列容器 (Sequence Containers)

##### **std::vector**

```cpp
#include <vector>
#include <iostream>

void vector_best_practices() {
    // 預分配避免多次擴容
    std::vector<int> vec;
    vec.reserve(1000);  // 預分配空間
    
    // emplace_back 避免拷貝
    struct Order {
        int id;
        double price;
        Order(int i, double p) : id(i), price(p) {}
    };
    
    std::vector<Order> orders;
    orders.emplace_back(1, 150.0);  // 直接構造
    // orders.push_back(Order{1, 150.0});  // 拷貝/移動構造
    
    // shrink_to_fit 釋放多餘記憶體
    vec.shrink_to_fit();
}
```

**性能特性:**
- 隨機訪問: O(1)
- 尾部插入/刪除: O(1) 攤銷
- 中間插入/刪除: O(n)
- Cache-friendly: ✅ (連續記憶體)

**HFT 應用:**
- ✅ 訂單列表
- ✅ 價格歷史序列
- ✅ 市場數據緩衝
- ❌ 頻繁中間插入/刪除

##### **std::array (C++11)**

```cpp
#include <array>

void array_example() {
    // 編譯期固定大小,棧分配
    std::array<double, 10> prices{};
    
    prices[0] = 150.0;
    prices.fill(0.0);  // 填充
    
    // 與 std::算法無縫配合
    std::sort(prices.begin(), prices.end());
}
```

**HFT 應用:**
- ✅ 固定緩衝區
- ✅ 價格檔位 (Level 2 深度)
- ✅ 小型固定集合
- 優勢: 零動態分配,極致性能

#### 關聯容器

##### **std::map vs std::unordered_map**

```cpp
#include <map>
#include <unordered_map>
#include <chrono>

void map_benchmark() {
    const int N = 100000;
    
    // std::map - 紅黑樹,O(log n)
    {
        std::map<int, double> m;
        auto start = std::chrono::high_resolution_clock::now();
        
        for (int i = 0; i < N; ++i) {
            m[i] = i * 1.5;
        }
        
        for (int i = 0; i < N; ++i) {
            volatile double v = m[i];
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "std::map: " << duration.count() << " ms\n";
    }
    
    // std::unordered_map - 哈希表,O(1) 平均
    {
        std::unordered_map<int, double> um;
        um.reserve(N);  // 預分配避免 rehash
        
        auto start = std::chrono::high_resolution_clock::now();
        
        for (int i = 0; i < N; ++i) {
            um[i] = i * 1.5;
        }
        
        for (int i = 0; i < N; ++i) {
            volatile double v = um[i];
        }
        
        auto end = std::chrono::high_resolution_clock::now();
        auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
        std::cout << "std::unordered_map: " << duration.count() << " ms\n";
    }
}
```

**HFT 應用對比:**

| 場景 | 推薦容器 | 理由 |
|------|----------|------|
| 訂單簿價格層 | `std::map` | 需要有序遍歷 (best bid/ask) |
| 訂單 ID 查找 | `std::unordered_map` | O(1) 查找,無需排序 |
| 符號映射 | `std::unordered_map` | 快速查找 |
| Top-N 價格 | `std::map` + iterators | 範圍查詢 |

##### **自定義哈希函數**

```cpp
#include <unordered_map>
#include <string>

struct Symbol {
    std::string exchange;
    std::string ticker;
    
    bool operator==(const Symbol& other) const {
        return exchange == other.exchange && ticker == other.ticker;
    }
};

// 自定義哈希
struct SymbolHash {
    size_t operator()(const Symbol& s) const {
        size_t h1 = std::hash<std::string>{}(s.exchange);
        size_t h2 = std::hash<std::string>{}(s.ticker);
        return h1 ^ (h2 << 1);  // 組合哈希
    }
};

void custom_hash_example() {
    std::unordered_map<Symbol, double, SymbolHash> prices;
    
    prices[{"NYSE", "AAPL"}] = 150.0;
    prices[{"NASDAQ", "GOOGL"}] = 2800.0;
}
```

### STL 算法精選 (HFT 常用)

```cpp
#include <algorithm>
#include <numeric>
#include <vector>

void algorithm_examples() {
    std::vector<double> prices = {150.0, 149.5, 151.0, 148.0, 152.0};
    
    // 排序 (部分排序更快)
    std::partial_sort(prices.begin(), prices.begin() + 3, prices.end());
    // 結果: 前 3 個是最小的,但不保證順序
    
    // 快速選擇: 找第 n 大元素
    std::nth_element(prices.begin(), prices.begin() + 2, prices.end());
    double median = prices[2];  // 中位數
    
    // 二分查找 (需已排序)
    std::sort(prices.begin(), prices.end());
    bool found = std::binary_search(prices.begin(), prices.end(), 150.0);
    
    // 範圍查找
    auto lower = std::lower_bound(prices.begin(), prices.end(), 149.0);
    auto upper = std::upper_bound(prices.begin(), prices.end(), 151.0);
    // [lower, upper) 是 [149.0, 151.0] 範圍
    
    // 累加
    double sum = std::accumulate(prices.begin(), prices.end(), 0.0);
    double avg = sum / prices.size();
}
```

**性能關鍵:**
- `std::sort`: O(n log n),快速排序
- `std::partial_sort`: O(n log k),只排序前 k 個
- `std::nth_element`: O(n) 平均,找第 n 大
- `std::binary_search`: O(log n),需已排序

### C++20 Ranges (函數式編程)

```cpp
#include <ranges>
#include <vector>
#include <iostream>

namespace rng = std::ranges;
namespace views = std::views;

void ranges_example() {
    std::vector<int> orders = {1001, 1002, 1003, 1004, 1005};
    
    // 管道語法: 過濾 + 轉換
    auto result = orders 
        | views::filter([](int id) { return id % 2 == 0; })
        | views::transform([](int id) { return id * 10; });
    
    for (int val : result) {
        std::cout << val << " ";  // 10020 10040
    }
    std::cout << "\n";
}
```

**優勢:**
- 惰性求值 (Lazy Evaluation)
- 組合式算法
- 可讀性高
- HFT: 數據處理管道

---

## 網路庫

### Boost.Asio ⭐⭐⭐

**用途:** 跨平台異步 I/O、網路編程

```cpp
#include <boost/asio.hpp>
#include <iostream>

using boost::asio::ip::tcp;

void asio_tcp_client() {
    boost::asio::io_context io;
    
    tcp::socket socket(io);
    tcp::resolver resolver(io);
    
    // 連接
    auto endpoints = resolver.resolve("example.com", "80");
    boost::asio::connect(socket, endpoints);
    
    // 發送 HTTP 請求
    std::string request = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
    boost::asio::write(socket, boost::asio::buffer(request));
    
    // 接收響應
    boost::asio::streambuf response;
    boost::asio::read_until(socket, response, "\r\n");
    
    std::istream response_stream(&response);
    std::string http_version;
    response_stream >> http_version;
    
    std::cout << "Response: " << http_version << "\n";
}
```

**HFT 評價:**
- ✅ 功能完整 (TCP/UDP/定時器/串口)
- ✅ 跨平台 (Linux/Windows/macOS)
- ✅ C++20 Coroutines 支持
- ⚠️ 較重,學習曲線陡
- ⚠️ 性能不如原生 epoll/io_uring

**適用場景:**
- 複雜網路應用
- 跨平台需求
- 非極致延遲場景

**安裝:**
```bash
sudo apt install libboost-dev
```

### ZeroMQ ⭐⭐⭐⭐⭐

**用途:** 高性能消息隊列,進程間通信

```cpp
#include <zmq.hpp>
#include <string>
#include <iostream>

// 發送端 (REQ-REP 模式)
void zmq_server() {
    zmq::context_t context(1);
    zmq::socket_t socket(context, zmq::socket_type::rep);
    socket.bind("tcp://*:5555");
    
    while (true) {
        zmq::message_t request;
        socket.recv(request, zmq::recv_flags::none);
        
        std::cout << "Received: " << request.to_string() << "\n";
        
        zmq::message_t reply(5);
        memcpy(reply.data(), "World", 5);
        socket.send(reply, zmq::send_flags::none);
    }
}

// 接收端
void zmq_client() {
    zmq::context_t context(1);
    zmq::socket_t socket(context, zmq::socket_type::req);
    socket.connect("tcp://localhost:5555");
    
    zmq::message_t request(5);
    memcpy(request.data(), "Hello", 5);
    socket.send(request, zmq::send_flags::none);
    
    zmq::message_t reply;
    socket.recv(reply, zmq::recv_flags::none);
    std::cout << "Received: " << reply.to_string() << "\n";
}
```

**HFT 評價:**
- ✅ 極高性能 (百萬 msg/s)
- ✅ 多種模式: REQ-REP, PUB-SUB, PUSH-PULL
- ✅ 無 Broker,點對點
- ✅ 支持 IPC/TCP/inproc
- ✅ 自動重連

**適用場景:**
- ✅ 進程間通信 (策略 <-> 執行)
- ✅ 分布式系統
- ✅ 實時數據流

**安裝:**
```bash
sudo apt install libzmq3-dev
# C++ 綁定
git clone https://github.com/zeromq/cppzmq
```

---

## 序列化庫

### FlatBuffers ⭐⭐⭐⭐⭐

**用途:** Google 零拷貝序列化,HFT 首選

```cpp
// schema.fbs
namespace MyGame;

table Order {
  order_id:int;
  symbol:string;
  price:double;
  quantity:int;
}

root_type Order;
```

```bash
# 編譯 schema
flatc --cpp schema.fbs
```

```cpp
#include "schema_generated.h"
#include <flatbuffers/flatbuffers.h>

void flatbuffers_example() {
    // 序列化
    flatbuffers::FlatBufferBuilder builder(1024);
    
    auto symbol = builder.CreateString("AAPL");
    auto order = MyGame::CreateOrder(builder, 1001, symbol, 150.0, 100);
    builder.Finish(order);
    
    uint8_t* buf = builder.GetBufferPointer();
    int size = builder.GetSize();
    
    // 反序列化 (零拷貝!)
    auto decoded = MyGame::GetOrder(buf);
    std::cout << "Order ID: " << decoded->order_id() << "\n";
    std::cout << "Symbol: " << decoded->symbol()->c_str() << "\n";
    std::cout << "Price: " << decoded->price() << "\n";
}
```

**HFT 評價:**
- ✅ 零拷貝,無需解析
- ✅ 訪問延遲 <10 ns
- ✅ 向後/向前兼容
- ✅ 跨語言
- ⚠️ Schema 必須提前定義

**性能對比:**

| 庫 | 序列化時間 | 反序列化時間 | 訪問延遲 |
|---|-----------|-------------|---------|
| FlatBuffers | ~200 ns | 0 ns (零拷貝) | <10 ns |
| Protobuf | ~500 ns | ~1 μs | N/A |
| JSON | ~2 μs | ~5 μs | N/A |

### Protocol Buffers ⭐⭐⭐⭐

**用途:** Google 標準序列化框架

```protobuf
// order.proto
syntax = "proto3";

message Order {
  int32 order_id = 1;
  string symbol = 2;
  double price = 3;
  int32 quantity = 4;
}
```

```cpp
#include "order.pb.h"

void protobuf_example() {
    // 序列化
    Order order;
    order.set_order_id(1001);
    order.set_symbol("AAPL");
    order.set_price(150.0);
    order.set_quantity(100);
    
    std::string serialized;
    order.SerializeToString(&serialized);
    
    // 反序列化
    Order decoded;
    decoded.ParseFromString(serialized);
    
    std::cout << "Order ID: " << decoded.order_id() << "\n";
}
```

**HFT 評價:**
- ✅ 行業標準
- ✅ 跨語言
- ✅ 向後兼容
- ⚠️ 需要解析,延遲較高
- ⚠️ 比 FlatBuffers 慢 2-5x

**適用場景:**
- 非關鍵路徑序列化
- 跨語言系統
- 配置文件

---

## 金融專用庫

### QuickFIX ⭐⭐⭐⭐⭐

**用途:** FIX 協議引擎,行業標準

```cpp
#include <quickfix/Application.h>
#include <quickfix/MessageCracker.h>
#include <quickfix/SocketInitiator.h>
#include <quickfix/SessionSettings.h>

class Application : public FIX::Application, public FIX::MessageCracker {
public:
    void onCreate(const FIX::SessionID&) override {}
    void onLogon(const FIX::SessionID&) override {
        std::cout << "Logon successful\n";
    }
    void onLogout(const FIX::SessionID&) override {}
    void toAdmin(FIX::Message&, const FIX::SessionID&) override {}
    void toApp(FIX::Message&, const FIX::SessionID&) override {}
    void fromAdmin(const FIX::Message&, const FIX::SessionID&) override {}
    void fromApp(const FIX::Message& message, const FIX::SessionID&) override {
        crack(message, session);
    }
    
    // 處理 ExecutionReport
    void onMessage(const FIX44::ExecutionReport& msg, const FIX::SessionID&) {
        FIX::OrdStatus status;
        msg.get(status);
        std::cout << "Order status: " << status << "\n";
    }
};

int main() {
    try {
        FIX::SessionSettings settings("config.cfg");
        Application app;
        FIX::FileStoreFactory storeFactory(settings);
        FIX::SocketInitiator initiator(app, storeFactory, settings);
        
        initiator.start();
        // ... 運行 ...
        initiator.stop();
    } catch (std::exception& e) {
        std::cerr << e.what() << "\n";
    }
    return 0;
}
```

**HFT 評價:**
- ✅ 行業標準實現
- ✅ 支持 FIX 4.0-5.0
- ✅ Session 管理完善
- ✅ 消息驗證
- ⚠️ 性能一般 (非極致場景)

**適用場景:**
- ✅ 連接交易所
- ✅ FIX 網關
- ✅ OMS 系統

**安裝:**
```bash
sudo apt install libquickfix-dev
```

---

## 高性能通用庫

### Folly (Facebook) ⭐⭐⭐⭐⭐

**用途:** Facebook C++ 基礎庫,生產級性能

```cpp
#include <folly/MPMCQueue.h>
#include <folly/FBVector.h>
#include <folly/AtomicHashMap.h>

// 無鎖 MPMC 隊列
void folly_queue_example() {
    folly::MPMCQueue<int> queue(1024);
    
    // 生產者
    std::thread producer([&]() {
        for (int i = 0; i < 100; ++i) {
            queue.blockingWrite(i);
        }
    });
    
    // 消費者
    std::thread consumer([&]() {
        int value;
        for (int i = 0; i < 100; ++i) {
            queue.blockingRead(value);
            std::cout << value << " ";
        }
    });
    
    producer.join();
    consumer.join();
}

// FBVector: 優化的 vector
void folly_vector_example() {
    folly::fbvector<int> vec;
    vec.reserve(1000);
    // 比 std::vector 更好的小對象優化
}
```

**HFT 評價:**
- ✅ 生產驗證 (Facebook 規模)
- ✅ MPMCQueue: 無鎖多生產者多消費者
- ✅ AtomicHashMap: 無鎖哈希表
- ✅ Future/Promise 異步編程
- ⚠️ 較重,依賴多

**適用場景:**
- ✅ 高並發場景
- ✅ 複雜異步邏輯
- ✅ 需要經過驗證的數據結構

### Abseil (Google) ⭐⭐⭐⭐

**用途:** Google C++ 基礎庫

```cpp
#include <absl/container/flat_hash_map.h>
#include <absl/strings/str_cat.h>

void abseil_example() {
    // flat_hash_map: 比 std::unordered_map 快 2x
    absl::flat_hash_map<std::string, double> prices;
    prices["AAPL"] = 150.0;
    prices["GOOGL"] = 2800.0;
    
    // 字串拼接優化
    std::string msg = absl::StrCat("Order ", 1001, " price: ", 150.0);
}
```

**HFT 評價:**
- ✅ flat_hash_map 性能優異
- ✅ Google 生產驗證
- ✅ 字串/時間工具完善
- ✅ 比 std 更快的容器

---

## 日誌庫

### spdlog ⭐⭐⭐⭐⭐

**用途:** 高性能異步日誌,C++ 首選

```cpp
#include <spdlog/spdlog.h>
#include <spdlog/async.h>
#include <spdlog/sinks/basic_file_sink.h>

void spdlog_example() {
    // 同步日誌
    spdlog::info("Order placed: {}, price: {}", 1001, 150.0);
    
    // 異步日誌 (HFT 推薦)
    auto async_file = spdlog::basic_logger_mt<spdlog::async_factory>(
        "async_logger", "logs/async.log");
    
    async_file->info("High frequency message");
    
    // 格式化
    spdlog::set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%l] %v");
}
```

**HFT 評價:**
- ✅ 百萬條/秒吞吐
- ✅ 異步模式,微秒級延遲
- ✅ Header-only 可選
- ✅ 豐富的 sinks (文件/控制台/syslog)

**性能測試:**
```cpp
#include <spdlog/spdlog.h>
#include <chrono>

void benchmark_spdlog() {
    auto logger = spdlog::basic_logger_mt<spdlog::async_factory>("bench", "bench.log");
    
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < 1000000; ++i) {
        logger->info("Message {}", i);
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    
    std::cout << "1M messages in " << duration.count() << " ms\n";
    // 輸出: ~500-1000 ms (200萬條/秒)
}
```

---

## 測試與基準測試

### Google Benchmark ⭐⭐⭐⭐⭐

**用途:** 微基準測試,性能測試必備

```cpp
#include <benchmark/benchmark.h>
#include <vector>

// 測試 vector push_back vs emplace_back
static void BM_VectorPushBack(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<int> vec;
        for (int i = 0; i < state.range(0); ++i) {
            vec.push_back(i);
        }
    }
}
BENCHMARK(BM_VectorPushBack)->Range(8, 8<<10);

static void BM_VectorEmplaceBack(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<int> vec;
        for (int i = 0; i < state.range(0); ++i) {
            vec.emplace_back(i);
        }
    }
}
BENCHMARK(BM_VectorEmplaceBack)->Range(8, 8<<10);

BENCHMARK_MAIN();
```

**運行:**
```bash
g++ -std=c++17 -O3 benchmark.cpp -lbenchmark -lpthread -o bench
./bench
# 輸出:
# BM_VectorPushBack/8          120 ns
# BM_VectorPushBack/64         950 ns
# BM_VectorEmplaceBack/8       115 ns
# BM_VectorEmplaceBack/64      920 ns
```

**HFT 評價:**
- ✅ 統計分析 (均值、標準差、P50/P99)
- ✅ 避免編譯器優化干擾
- ✅ 參數化測試
- ✅ CI/CD 集成

---

## 庫選擇建議 (HFT 場景)

### 核心基礎設施

| 需求 | 推薦庫 | 替代方案 | 優先級 |
|------|--------|----------|--------|
| 網路 I/O | epoll/io_uring (原生) | Boost.Asio | ⭐⭐⭐⭐⭐ |
| 進程間通信 | ZeroMQ | nanomsg | ⭐⭐⭐⭐⭐ |
| 序列化 | FlatBuffers | Cap'n Proto | ⭐⭐⭐⭐⭐ |
| JSON 解析 | simdjson | RapidJSON | ⭐⭐⭐⭐ |
| 日誌 | spdlog/NanoLog | - | ⭐⭐⭐⭐⭐ |
| 測試 | Google Test | Catch2 | ⭐⭐⭐⭐⭐ |
| 基準測試 | Google Benchmark | - | ⭐⭐⭐⭐⭐ |

### 金融專用

| 需求 | 推薦庫 | 優先級 | 理由 |
|------|--------|--------|------|
| FIX 協議 | QuickFIX | ⭐⭐⭐⭐⭐ | 行業標準 |
| 定價 | QuantLib | ⭐⭐⭐ | 衍生品定價 |
| 技術分析 | TA-Lib | ⭐⭐ | 策略研究 |

### 性能優化

| 需求 | 推薦庫 | 優先級 | 性能提升 |
|------|--------|--------|----------|
| 哈希表 | Abseil flat_hash_map | ⭐⭐⭐⭐ | 2x vs std |
| 無鎖隊列 | Folly MPMCQueue | ⭐⭐⭐⭐⭐ | 生產驗證 |
| 內存分配 | jemalloc/tcmalloc | ⭐⭐⭐⭐⭐ | 多線程優化 |
| 字串處理 | Abseil StrCat | ⭐⭐⭐ | 減少分配 |

### 學習路線圖

**第 1-3 天 (基礎):**
- ✅ 專注標準庫 (STL, chrono, thread)
- ✅ Google Test 基本使用
- ❌ 不引入第三方庫

**第 4-7 天 (進階):**
- ✅ spdlog (日誌)
- ✅ Google Benchmark (性能測試)
- ✅ ZeroMQ (進程通信)
- ✅ FlatBuffers (序列化)

**第 8-10 天 (專家):**
- ✅ Folly/Abseil (高性能容器)
- ✅ QuickFIX (FIX 協議)
- ✅ jemalloc (內存分配優化)
- ✅ 對比不同庫性能

### 避免的陷阱

❌ **過早引入複雜庫**
- 先用標準庫實現,理解原理
- 確認性能瓶頸後再替換

❌ **盲目追求"最新最酷"**
- 優先生產驗證的成熟庫
- FlatBuffers > 新出的序列化庫

❌ **忽視標準庫性能**
- `std::vector` 已足夠快
- `std::unordered_map` 性能可接受

❌ **庫依賴爆炸**
- 每個庫都有成本 (編譯時間、二進制大小)
- 精選必要的庫

---

## 快速參考表

### 性能對比 (HFT 場景)

| 操作 | 方案 A | 方案 B | 性能差異 |
|------|--------|--------|----------|
| 容器查找 | std::map | Abseil flat_hash_map | 2-3x |
| 序列化 | Protobuf | FlatBuffers | 5-10x |
| JSON 解析 | nlohmann/json | simdjson | 10x |
| 日誌 | 同步 iostream | spdlog 異步 | 100x |
| 內存分配 | malloc | jemalloc | 1.5-2x |

### 安裝速查

```bash
# Ubuntu/Debian
sudo apt install \
    libboost-dev \
    libzmq3-dev \
    protobuf-compiler libprotobuf-dev \
    libquickfix-dev \
    libgtest-dev \
    libjemalloc-dev \
    libgoogle-perftools-dev

# 從源碼安裝
# Folly
git clone https://github.com/facebook/folly.git
cd folly && ./build.sh

# FlatBuffers
git clone https://github.com/google/flatbuffers.git
cd flatbuffers && cmake -G "Unix Makefiles" && make && sudo make install

# Google Benchmark
git clone https://github.com/google/benchmark.git
cd benchmark && cmake -E make_directory build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release && make && sudo make install
```

---

## 參考資料 (References)

### 官方文檔
1. [cppreference.com](https://en.cppreference.com/) - C++ 標準庫權威參考
2. [Boost Documentation](https://www.boost.org/doc/)
3. [ZeroMQ Guide](https://zguide.zeromq.org/)
4. [FlatBuffers Documentation](https://flatbuffers.dev/)
5. [Folly Documentation](https://github.com/facebook/folly)

### 性能分析
6. [Abseil Swiss Tables](https://abseil.io/about/design/swisstables) - 高性能哈希表設計
7. [FlatBuffers Benchmarks](https://flatbuffers.dev/flatbuffers_benchmarks.html)

### 書籍
8. Nicolai Josuttis, *The C++ Standard Library*, 2nd Edition (2012)
9. Scott Meyers, *Effective STL* (2001)

### 工具
10. [Compiler Explorer](https://godbolt.org/) - 在線查看編譯器輸出
11. [Quick Bench](https://quick-bench.com/) - 在線微基準測試

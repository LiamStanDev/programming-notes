# C++ 核心特性

> 本章涵蓋現代 C++ 核心特性,包括智能指針、移動語義、Lambda 表達式、模板編程、C++17/20 新特性等,為金融交易系統開發奠定基礎。

---

## 目錄

> **HFT 學習優先級**: ⭐⭐⭐ 必看 | ⭐⭐ 建議 | ⭐ 有空再看

1. [智能指針](#1-智能指針) ⭐⭐⭐
2. [移動語義](#2-移動語義) ⭐⭐⭐
3. [Lambda 表達式](#3-lambda-表達式) ⭐⭐
4. [模板編程](#4-模板編程) ⭐⭐
5. [C++17 新特性](#5-c17-新特性) ⭐
6. [C++20 新特性](#6-c20-新特性) ⭐⭐
7. [RAII 與資源管理](#7-raii-與資源管理) ⭐⭐⭐
8. [STL 容器與算法](#8-stl-容器與算法) ⭐⭐⭐
9. [標準庫與第三方庫](#9-標準庫與第三方庫) ⭐
10. [HFT 應用實踐](#10-hft-應用實踐) ⭐⭐⭐

---

## 1. 智能指針

智能指針是 C++ 自動內存管理的核心工具,通過 RAII 機制自動管理資源生命週期。

### 1.1 unique_ptr - 獨占所有權

```cpp
#include <memory>
#include <iostream>

class Resource {
public:
    Resource(int id) : id_(id) {
        std::cout << "Resource " << id_ << " created\n";
    }
    ~Resource() {
        std::cout << "Resource " << id_ << " destroyed\n";
    }
    void use() { std::cout << "Using resource " << id_ << "\n"; }
private:
    int id_;
};

void unique_ptr_example() {
    // 使用 make_unique (C++14)
    auto ptr1 = std::make_unique<Resource>(1);
    ptr1->use();

    // 移動語義
    auto ptr2 = std::move(ptr1);  // ptr1 現在為 nullptr
    if (!ptr1) {
        std::cout << "ptr1 is nullptr\n";
    }
    ptr2->use();

    // 自定義刪除器
    auto deleter = [](Resource* r) {
        std::cout << "Custom deleter\n";
        delete r;
    };
    std::unique_ptr<Resource, decltype(deleter)> ptr3(new Resource(3), deleter);
}
```

**HFT 應用場景:**

- ✅ 訂單對象管理
- ✅ 網路連接資源
- ✅ 文件句柄管理
- ✅ 確保無內存洩漏

### 1.2 shared_ptr - 共享所有權

```cpp
#include <memory>
#include <vector>

void shared_ptr_example() {
    // 創建共享指針
    auto ptr1 = std::make_shared<Resource>(1);
    std::cout << "Count: " << ptr1.use_count() << "\n";  // 1

    {
        auto ptr2 = ptr1;  // 引用計數 +1
        std::cout << "Count: " << ptr1.use_count() << "\n";  // 2

        std::vector<std::shared_ptr<Resource>> vec;
        vec.push_back(ptr1);  // 引用計數 +1
        std::cout << "Count: " << ptr1.use_count() << "\n";  // 3
    }  // ptr2 和 vec 銷毀,引用計數 -2

    std::cout << "Count: " << ptr1.use_count() << "\n";  // 1
}  // ptr1 銷毀,Resource 被釋放
```

**性能考量:**

- 引用計數是原子操作 (線程安全)
- 有額外開銷 (~8-16 bytes)
- HFT 場景慎用,優先 unique_ptr

### 1.3 weak_ptr - 弱引用

````cpp
#include <memory>

class Observer;
class Subject {
public:
    std::vector<std::weak_ptr<Observer>> observers_;

    void notify() {
        for (auto& weak_obs : observers_) {
            if (auto obs = weak_obs.lock()) {  // 嘗試提升為 shared_ptr
                // obs->update();
            }
        }
    }
};

void weak_ptr_example() {
    auto subject = std::make_shared<Subject>();
    auto observer = std::make_shared<Observer>();

    subject->observers_.push_back(observer);  // 不增加引用計數

    std::cout << "Observer count: " << observer.use_count() << "\n";  // 1
}

**應用場景:**

- 打破循環引用
- 觀察者模式
- 緩存實現

### 1.4 智能指針實戰練習

#### 練習 1: 使用 unique_ptr 實現單向鏈表

**核心概念:**

鏈表是學習智能指針的絕佳範例,因為它展示了**所有權鏈 (Ownership Chain)** 的概念:
- 每個節點**獨占**下一個節點的所有權
- 當節點被銷毀時,自動遞歸銷毀後續所有節點
- 無需手動 `delete`,完全避免內存洩漏

**為什麼使用 unique_ptr:**
1. **明確所有權**: 每個節點只有一個擁有者
2. **自動清理**: 析構函數自動遞歸釋放整條鏈
3. **性能**: 零開銷抽象,與裸指針性能相同
4. **安全**: 編譯期防止意外拷貝

```cpp
#include <memory>
#include <iostream>

template<typename T>
class LinkedList {
private:
    struct Node {
        T data;
        std::unique_ptr<Node> next;  // 獨占下一個節點的所有權

        Node(const T& value) : data(value), next(nullptr) {}
    };

    std::unique_ptr<Node> head_;  // 獨占頭節點的所有權
    size_t size_;

public:
    LinkedList() : head_(nullptr), size_(0) {}

    // 頭部插入
    void push_front(const T& value) {
        auto new_node = std::make_unique<Node>(value);

        // 關鍵: 使用 std::move 轉移所有權
        // 1. 將原 head_ 的所有權轉移給 new_node->next
        new_node->next = std::move(head_);

        // 2. 將 new_node 的所有權轉移給 head_
        head_ = std::move(new_node);

        ++size_;
    }

    // 尾部插入
    void push_back(const T& value) {
        auto new_node = std::make_unique<Node>(value);

        if (!head_) {
            // 空鏈表: 直接轉移所有權
            head_ = std::move(new_node);
        } else {
            // 找到最後一個節點
            Node* current = head_.get();  // get() 獲取裸指針,不轉移所有權
            while (current->next) {
                current = current->next.get();
            }
            // 將新節點的所有權轉移給最後節點的 next
            current->next = std::move(new_node);
        }
        ++size_;
    }

    // 刪除頭部
    bool pop_front() {
        if (!head_) return false;

        // 關鍵: 將 head_->next 的所有權轉移給 head_
        // 原 head_ 被銷毀,自動調用析構函數釋放內存
        head_ = std::move(head_->next);

        --size_;
        return true;
    }

    // 查找 (只讀操作,使用 get() 獲取裸指針)
    bool contains(const T& value) const {
        Node* current = head_.get();  // 不轉移所有權
        while (current) {
            if (current->data == value) return true;
            current = current->next.get();
        }
        return false;
    }

    // 打印
    void print() const {
        Node* current = head_.get();
        while (current) {
            std::cout << current->data << " -> ";
            current = current->next.get();
        }
        std::cout << "nullptr\n";
    }

    size_t size() const { return size_; }
    bool empty() const { return head_ == nullptr; }

    // 析構函數自動調用,遞歸釋放所有節點
    ~LinkedList() = default;
};

void linkedlist_example() {
    LinkedList<int> list;

    list.push_back(1);
    list.push_back(2);
    list.push_back(3);
    list.push_front(0);

    list.print();  // 輸出: 0 -> 1 -> 2 -> 3 -> nullptr

    std::cout << "Contains 2: " << list.contains(2) << "\n";  // 輸出: 1

    list.pop_front();
    list.print();  // 輸出: 1 -> 2 -> 3 -> nullptr

    // 離開作用域時,list 自動銷毀,所有節點自動釋放
}
```

**關鍵技術點解析:**

1. **std::move 的作用**:
   ```cpp
   new_node->next = std::move(head_);  // 轉移所有權
   // 之後 head_ 變為 nullptr,new_node->next 擁有原 head_ 的內容
   ```

2. **get() vs std::move()**:
   ```cpp
   Node* ptr = head_.get();      // 獲取裸指針,不轉移所有權,用於遍歷
   auto new_head = std::move(head_);  // 轉移所有權,head_ 變為 nullptr
   ```

3. **自動內存管理**:
   ```cpp
   {
       LinkedList<int> list;
       list.push_back(1);
       list.push_back(2);
   }  // 離開作用域,list 析構,自動釋放所有節點,無需手動 delete
   ```

**與傳統裸指針對比:**

```cpp
// ❌ 傳統方式 (容易內存洩漏)
struct Node {
    int data;
    Node* next;  // 裸指針
};

~LinkedList() {
    // 必須手動釋放每個節點
    while (head_) {
        Node* temp = head_;
        head_ = head_->next;
        delete temp;  // 容易忘記!
    }
}

// ✅ 現代方式 (自動管理)
struct Node {
    int data;
    std::unique_ptr<Node> next;  // 智能指針
};

~LinkedList() = default;  // 自動遞歸釋放,無需手動處理
```

#### 練習 2: 使用 unique_ptr 實現二叉搜索樹

**核心概念:**

二叉搜索樹 (Binary Search Tree, BST) 展示了**遞歸所有權 (Recursive Ownership)** 的概念:
- 每個節點獨占其左右子樹的所有權
- 樹的銷毀自動遞歸進行,無需手動後序遍歷刪除
- 完美體現了 RAII 原則

**為什麼 BST 適合 unique_ptr:**
1. **樹形結構**: 每個子節點只有一個父節點 (獨占所有權)
2. **遞歸操作**: 插入、查找、遍歷都是遞歸的,與 unique_ptr 的自動管理完美契合
3. **無環結構**: 不存在循環引用問題

```cpp
#include <memory>
#include <iostream>

template<typename T>
class BinarySearchTree {
private:
    struct Node {
        T data;
        std::unique_ptr<Node> left;   // 獨占左子樹
        std::unique_ptr<Node> right;  // 獨占右子樹

        Node(const T& value) : data(value), left(nullptr), right(nullptr) {}
    };

    std::unique_ptr<Node> root_;  // 獨占根節點

    // 遞歸插入 (通過引用修改 unique_ptr)
    void insert_helper(std::unique_ptr<Node>& node, const T& value) {
        if (!node) {
            // 基礎情況: 創建新節點
            node = std::make_unique<Node>(value);
            return;
        }

        // 遞歸情況: 根據 BST 性質選擇左或右子樹
        if (value < node->data) {
            insert_helper(node->left, value);   // 遞歸左子樹
        } else if (value > node->data) {
            insert_helper(node->right, value);  // 遞歸右子樹
        }
        // 相等則不插入 (BST 不允許重複值)
    }

    // 中序遍歷 (In-order: 左 -> 根 -> 右,輸出有序序列)
    void inorder_helper(const std::unique_ptr<Node>& node) const {
        if (!node) return;

        inorder_helper(node->left);           // 遍歷左子樹
        std::cout << node->data << " ";       // 訪問根節點
        inorder_helper(node->right);          // 遍歷右子樹
    }

    // 查找
    bool contains_helper(const std::unique_ptr<Node>& node, const T& value) const {
        if (!node) return false;  // 未找到

        if (value == node->data) return true;  // 找到
        if (value < node->data) return contains_helper(node->left, value);
        return contains_helper(node->right, value);
    }

public:
    BinarySearchTree() : root_(nullptr) {}

    void insert(const T& value) {
        insert_helper(root_, value);
    }

    bool contains(const T& value) const {
        return contains_helper(root_, value);
    }

    void print_inorder() const {
        inorder_helper(root_);
        std::cout << "\n";
    }

    // 析構函數自動遞歸釋放整棵樹
    ~BinarySearchTree() = default;
};

void bst_example() {
    BinarySearchTree<int> bst;

    // 插入節點
    bst.insert(5);
    bst.insert(3);
    bst.insert(7);
    bst.insert(1);
    bst.insert(9);

    // 中序遍歷輸出有序序列
    bst.print_inorder();  // 輸出: 1 3 5 7 9

    std::cout << "Contains 7: " << bst.contains(7) << "\n";  // 輸出: 1
    std::cout << "Contains 4: " << bst.contains(4) << "\n";  // 輸出: 0

    // 離開作用域,整棵樹自動遞歸釋放
}
```

**關鍵技術點解析:**

1. **通過引用修改 unique_ptr**:
   ```cpp
   void insert_helper(std::unique_ptr<Node>& node, const T& value) {
       // 使用引用可以直接修改父節點的 left/right 指針
       if (!node) {
           node = std::make_unique<Node>(value);  // 直接賦值
       }
   }
   ```

2. **遞歸所有權鏈**:
   ```
   root_ (unique_ptr)
     └─> Node(5)
           ├─> left (unique_ptr) -> Node(3)
           │     ├─> left (unique_ptr) -> Node(1)
           │     └─> right (unique_ptr) -> nullptr
           └─> right (unique_ptr) -> Node(7)
                 └─> right (unique_ptr) -> Node(9)
   ```
   當 `root_` 被銷毀時,自動遞歸銷毀所有子節點。

3. **自動內存管理的威力**:
   ```cpp
   {
       BinarySearchTree<int> bst;
       for (int i = 0; i < 1000; ++i) {
           bst.insert(i);
       }
   }  // 離開作用域,1000 個節點全部自動釋放,無需任何手動操作!
   ```

**與傳統裸指針對比:**

```cpp
// ❌ 傳統方式 (容易內存洩漏)
struct Node {
    int data;
    Node* left;
    Node* right;
};

~BinarySearchTree() {
    // 必須手動後序遍歷刪除
    delete_tree(root_);
}

void delete_tree(Node* node) {
    if (!node) return;
    delete_tree(node->left);   // 先刪除左子樹
    delete_tree(node->right);  // 再刪除右子樹
    delete node;               // 最後刪除根節點
}

// ✅ 現代方式 (自動管理)
struct Node {
    int data;
    std::unique_ptr<Node> left;
    std::unique_ptr<Node> right;
};

~BinarySearchTree() = default;  // 自動遞歸釋放,編譯器生成完美的後序遍歷刪除
```

**性能分析:**

| 操作 | 時間複雜度 | unique_ptr 開銷 |
|------|-----------|----------------|
| 插入 | O(log n) 平均 | 零開銷 |
| 查找 | O(log n) 平均 | 零開銷 |
| 刪除 | O(log n) 平均 | 零開銷 |
| 析構 | O(n) | 零開銷 |

unique_ptr 是零開銷抽象 (Zero-Overhead Abstraction),與裸指針性能完全相同!

#### 練習 3: 使用 shared_ptr 和 weak_ptr 實現圖結構

**核心概念:**

圖結構 (Graph) 是學習 `weak_ptr` 的最佳場景,因為它展示了**循環引用問題 (Circular Reference Problem)**:
- 圖中的節點可能互相引用 (A -> B, B -> A)
- 如果全用 `shared_ptr`,會導致引用計數永不為零,造成**內存洩漏**
- `weak_ptr` 打破循環引用,允許觀察但不延長生命週期

**為什麼需要 weak_ptr:**
1. **打破循環**: 雙向連接不會造成內存洩漏
2. **安全觀察**: 可以檢查節點是否仍然存活 (`lock()`)
3. **共享所有權**: 多個節點可以引用同一個節點

```cpp
#include <memory>
#include <vector>
#include <string>
#include <iostream>

class GraphNode {
public:
    std::string name;
    // 關鍵: 使用 weak_ptr 存儲鄰居,避免循環引用
    std::vector<std::weak_ptr<GraphNode>> neighbors;

    GraphNode(const std::string& n) : name(n) {
        std::cout << "Node " << name << " created\n";
    }

    ~GraphNode() {
        std::cout << "Node " << name << " destroyed\n";
    }

    void add_neighbor(std::shared_ptr<GraphNode> neighbor) {
        // 存儲為 weak_ptr,不增加引用計數
        neighbors.push_back(neighbor);
    }

    void print_neighbors() const {
        std::cout << name << " -> ";
        for (const auto& weak_neighbor : neighbors) {
            // 嘗試提升為 shared_ptr (檢查節點是否仍存活)
            if (auto neighbor = weak_neighbor.lock()) {
                std::cout << neighbor->name << " ";
            } else {
                std::cout << "[deleted] ";
            }
        }
        std::cout << "\n";
    }
};

void graph_example() {
    // 創建節點 (使用 shared_ptr 管理)
    auto node_a = std::make_shared<GraphNode>("A");
    auto node_b = std::make_shared<GraphNode>("B");
    auto node_c = std::make_shared<GraphNode>("C");

    std::cout << "\n=== 建立連接 ===\n";

    // 建立雙向連接
    node_a->add_neighbor(node_b);
    node_a->add_neighbor(node_c);
    node_b->add_neighbor(node_a);  // 雙向: B -> A
    node_c->add_neighbor(node_a);  // 雙向: C -> A

    // 打印鄰居
    node_a->print_neighbors();  // A -> B C
    node_b->print_neighbors();  // B -> A
    node_c->print_neighbors();  // C -> A

    std::cout << "\n=== 引用計數 ===\n";
    std::cout << "node_a use_count: " << node_a.use_count() << "\n";  // 1 (只有 node_a 變量)
    std::cout << "node_b use_count: " << node_b.use_count() << "\n";  // 1
    std::cout << "node_c use_count: " << node_c.use_count() << "\n";  // 1

    // 注意: weak_ptr 不增加引用計數!

    std::cout << "\n=== 刪除節點 B ===\n";
    node_b.reset();  // 手動釋放 node_b

    // node_a 的鄰居列表中,node_b 已被刪除
    node_a->print_neighbors();  // A -> [deleted] C

    std::cout << "\n=== 離開作用域 ===\n";
    // node_a 和 node_c 自動釋放
}
```

**關鍵技術點解析:**

1. **weak_ptr 不增加引用計數**:
   ```cpp
   auto node_a = std::make_shared<GraphNode>("A");
   std::cout << node_a.use_count() << "\n";  // 1

   std::vector<std::weak_ptr<GraphNode>> neighbors;
   neighbors.push_back(node_a);  // 添加 weak_ptr
   std::cout << node_a.use_count() << "\n";  // 仍然是 1!
   ```

2. **lock() 提升為 shared_ptr**:
   ```cpp
   std::weak_ptr<GraphNode> weak = node_a;

   if (auto shared = weak.lock()) {
       // 成功提升,節點仍存活
       shared->print_neighbors();
   } else {
       // 節點已被銷毀
       std::cout << "Node deleted\n";
   }
   ```

3. **循環引用問題演示**:
   ```cpp
   // ❌ 錯誤: 使用 shared_ptr 會導致內存洩漏
   struct BadNode {
       std::vector<std::shared_ptr<BadNode>> neighbors;
   };

   {
       auto a = std::make_shared<BadNode>();
       auto b = std::make_shared<BadNode>();

       a->neighbors.push_back(b);  // a 持有 b
       b->neighbors.push_back(a);  // b 持有 a (循環!)

       // a.use_count() == 2 (a 變量 + b 的 neighbors)
       // b.use_count() == 2 (b 變量 + a 的 neighbors)
   }  // 離開作用域,但引用計數不為 0,內存洩漏!

   // ✅ 正確: 使用 weak_ptr 打破循環
   struct GoodNode {
       std::vector<std::weak_ptr<GoodNode>> neighbors;  // 使用 weak_ptr
   };

   {
       auto a = std::make_shared<GoodNode>();
       auto b = std::make_shared<GoodNode>();

       a->neighbors.push_back(b);  // a 觀察 b,不增加引用計數
       b->neighbors.push_back(a);  // b 觀察 a,不增加引用計數

       // a.use_count() == 1
       // b.use_count() == 1
   }  // 離開作用域,正常釋放!
   ```

**圖結構可視化:**

```
使用 shared_ptr (錯誤):
┌─────┐  shared_ptr  ┌─────┐
│  A  │─────────────>│  B  │
└─────┘              └─────┘
   ^                    │
   │     shared_ptr     │
   └────────────────────┘
   (循環引用,內存洩漏!)

使用 weak_ptr (正確):
┌─────┐  shared_ptr  ┌─────┐
│  A  │─────────────>│  B  │
└─────┘              └─────┘
   ^                    │
   │      weak_ptr      │
   └────────────────────┘
   (無循環引用,正常釋放)
```

**實際應用場景:**

1. **社交網絡**: 用戶之間的好友關係
2. **路由圖**: 網路節點之間的連接
3. **依賴圖**: 軟件包之間的依賴關係
4. **觀察者模式**: Subject 持有 Observer 的 weak_ptr

**性能考量:**

| 操作 | shared_ptr | weak_ptr |
|------|-----------|----------|
| 創建 | 原子操作 (慢) | 原子操作 (慢) |
| 拷貝 | 原子 +1 | 原子 +1 (弱引用計數) |
| lock() | - | 原子操作 + 可能失敗 |
| 內存開銷 | 16 bytes | 0 bytes (共享控制塊) |

在 HFT 場景中,如果性能關鍵,考慮使用**索引**代替指針!

#### 練習 4: HFT 訂單簿實現 (使用智能指針)

```cpp
#include <memory>
#include <map>
#include <list>
#include <unordered_map>
#include <iostream>

struct Order {
    int id;
    double price;
    int quantity;

    Order(int i, double p, int q) : id(i), price(p), quantity(q) {}
};

class OrderBook {
private:
    // 價格層: 價格 -> 訂單列表
    std::map<double, std::list<std::shared_ptr<Order>>> buy_levels_;
    std::map<double, std::list<std::shared_ptr<Order>>, std::greater<double>> sell_levels_;

    // 快速查找: 訂單ID -> 訂單指針
    std::unordered_map<int, std::shared_ptr<Order>> order_map_;

public:
    // 添加買單
    void add_buy_order(int id, double price, int quantity) {
        auto order = std::make_shared<Order>(id, price, quantity);
        buy_levels_[price].push_back(order);
        order_map_[id] = order;
    }

    // 添加賣單
    void add_sell_order(int id, double price, int quantity) {
        auto order = std::make_shared<Order>(id, price, quantity);
        sell_levels_[price].push_back(order);
        order_map_[id] = order;
    }

    // 取消訂單
    bool cancel_order(int id) {
        auto it = order_map_.find(id);
        if (it == order_map_.end()) return false;

        auto order = it->second;

        // 從價格層中移除
        auto& levels = (order->price > 0) ?
            static_cast<std::map<double, std::list<std::shared_ptr<Order>>>&>(buy_levels_) :
            static_cast<std::map<double, std::list<std::shared_ptr<Order>>>&>(sell_levels_);

        auto level_it = levels.find(order->price);
        if (level_it != levels.end()) {
            level_it->second.remove(order);
            if (level_it->second.empty()) {
                levels.erase(level_it);
            }
        }

        order_map_.erase(it);
        return true;
    }

    // 獲取最佳買價
    double get_best_bid() const {
        if (buy_levels_.empty()) return 0.0;
        return buy_levels_.rbegin()->first;
    }

    // 獲取最佳賣價
    double get_best_ask() const {
        if (sell_levels_.empty()) return 0.0;
        return sell_levels_.begin()->first;
    }

    // 打印訂單簿
    void print() const {
        std::cout << "=== Order Book ===\n";
        std::cout << "Best Ask: " << get_best_ask() << "\n";
        std::cout << "Best Bid: " << get_best_bid() << "\n";
        std::cout << "Spread: " << (get_best_ask() - get_best_bid()) << "\n";
    }
};

void orderbook_example() {
    OrderBook book;

    // 添加訂單
    book.add_buy_order(1, 100.0, 10);
    book.add_buy_order(2, 99.5, 20);
    book.add_sell_order(3, 100.5, 15);
    book.add_sell_order(4, 101.0, 25);

    book.print();
    // Best Ask: 100.5
    // Best Bid: 100.0
    // Spread: 0.5

    // 取消訂單
    book.cancel_order(1);
    book.print();
    // Best Bid 變為 99.5
}
```

#### 練習 5: 使用 unique_ptr 實現 LRU Cache

```cpp
#include <memory>
#include <unordered_map>
#include <list>
#include <iostream>

template<typename K, typename V>
class LRUCache {
private:
    struct Node {
        K key;
        V value;
        Node(const K& k, const V& v) : key(k), value(v) {}
    };

    size_t capacity_;
    std::list<std::unique_ptr<Node>> cache_list_;
    std::unordered_map<K, typename std::list<std::unique_ptr<Node>>::iterator> cache_map_;

public:
    LRUCache(size_t capacity) : capacity_(capacity) {}

    V* get(const K& key) {
        auto it = cache_map_.find(key);
        if (it == cache_map_.end()) {
            return nullptr;  // 未找到
        }

        // 移動到最前面 (最近使用)
        cache_list_.splice(cache_list_.begin(), cache_list_, it->second);
        return &(it->second->get()->value);
    }

    void put(const K& key, const V& value) {
        auto it = cache_map_.find(key);

        if (it != cache_map_.end()) {
            // 更新現有值
            it->second->get()->value = value;
            cache_list_.splice(cache_list_.begin(), cache_list_, it->second);
            return;
        }

        // 檢查容量
        if (cache_list_.size() >= capacity_) {
            // 移除最久未使用的
            auto& back_node = cache_list_.back();
            cache_map_.erase(back_node->key);
            cache_list_.pop_back();
        }

        // 插入新節點
        cache_list_.push_front(std::make_unique<Node>(key, value));
        cache_map_[key] = cache_list_.begin();
    }

    void print() const {
        std::cout << "LRU Cache (MRU -> LRU): ";
        for (const auto& node : cache_list_) {
            std::cout << "(" << node->key << ":" << node->value << ") ";
        }
        std::cout << "\n";
    }
};

void lru_cache_example() {
    LRUCache<int, std::string> cache(3);

    cache.put(1, "one");
    cache.put(2, "two");
    cache.put(3, "three");
    cache.print();  // (3:three) (2:two) (1:one)

    cache.get(1);  // 訪問 1
    cache.print();  // (1:one) (3:three) (2:two)

    cache.put(4, "four");  // 超出容量,移除 2
    cache.print();  // (4:four) (1:one) (3:three)

    auto* value = cache.get(3);
    if (value) {
        std::cout << "Found: " << *value << "\n";
    }
}
```

#### 練習 6: 智能指針與多態

```cpp
#include <memory>
#include <vector>
#include <iostream>

// 基類
class Shape {
public:
    virtual ~Shape() = default;
    virtual void draw() const = 0;
    virtual double area() const = 0;
};

// 派生類
class Circle : public Shape {
private:
    double radius_;
public:
    Circle(double r) : radius_(r) {}

    void draw() const override {
        std::cout << "Drawing Circle with radius " << radius_ << "\n";
    }

    double area() const override {
        return 3.14159 * radius_ * radius_;
    }
};

class Rectangle : public Shape {
private:
    double width_, height_;
public:
    Rectangle(double w, double h) : width_(w), height_(h) {}

    void draw() const override {
        std::cout << "Drawing Rectangle " << width_ << "x" << height_ << "\n";
    }

    double area() const override {
        return width_ * height_;
    }
};

void polymorphism_example() {
    // 使用 unique_ptr 管理多態對象
    std::vector<std::unique_ptr<Shape>> shapes;

    shapes.push_back(std::make_unique<Circle>(5.0));
    shapes.push_back(std::make_unique<Rectangle>(4.0, 6.0));
    shapes.push_back(std::make_unique<Circle>(3.0));

    // 多態調用
    double total_area = 0.0;
    for (const auto& shape : shapes) {
        shape->draw();
        total_area += shape->area();
    }

    std::cout << "Total area: " << total_area << "\n";
}
```

### 1.5 智能指針最佳實踐總結

**何時使用 unique_ptr:**

- ✅ 獨占所有權 (鏈表、樹、棧)
- ✅ 工廠模式返回值
- ✅ RAII 資源管理
- ✅ 性能關鍵路徑 (無引用計數開銷)

**何時使用 shared_ptr:**

- ✅ 共享所有權 (圖結構)
- ✅ 回調函數需要保持對象存活
- ✅ 緩存實現
- ⚠️ 避免在 HFT 關鍵路徑使用 (原子操作開銷)

**何時使用 weak_ptr:**

- ✅ 打破循環引用
- ✅ 觀察者模式
- ✅ 緩存 (不延長生命週期)

**常見陷阱:**

```cpp
// ❌ 錯誤: 不要用裸指針初始化多個智能指針
int* raw = new int(42);
std::unique_ptr<int> p1(raw);
std::unique_ptr<int> p2(raw);  // 雙重釋放!

// ✅ 正確: 使用 make_unique/make_shared
auto p1 = std::make_unique<int>(42);

// ❌ 錯誤: 循環引用
struct Node {
    std::shared_ptr<Node> next;  // 會導致內存洩漏
};

// ✅ 正確: 使用 weak_ptr
struct Node {
    std::shared_ptr<Node> next;
    std::weak_ptr<Node> prev;  // 打破循環
};
```

---

## 2. 移動語義

移動語義是 C++11 引入的重要特性,避免不必要的拷貝,提升性能。

### 2.1 右值引用

```cpp
#include <iostream>
#include <vector>

void rvalue_reference() {
    int x = 10;
    int& lref = x;        // 左值引用
    // int&& rref = x;    // 錯誤! 不能綁定左值
    int&& rref = 10;      // 右值引用
    int&& rref2 = std::move(x);  // 強制轉換為右值

    std::vector<int> v1 = {1, 2, 3};
    std::vector<int> v2 = std::move(v1);  // 移動,v1 變為空
    std::cout << "v1 size: " << v1.size() << "\n";  // 0
    std::cout << "v2 size: " << v2.size() << "\n";  // 3
}
```

### 2.2 移動構造函數與移動賦值運算符

```cpp
#include <cstring>
#include <algorithm>

class String {
public:
    // 構造函數
    String(const char* str = "") {
        size_ = std::strlen(str);
        data_ = new char[size_ + 1];
        std::strcpy(data_, str);
        std::cout << "Constructor\n";
    }

    // 拷貝構造函數
    String(const String& other) {
        size_ = other.size_;
        data_ = new char[size_ + 1];
        std::strcpy(data_, other.data_);
        std::cout << "Copy constructor\n";
    }

    // 移動構造函數
    String(String&& other) noexcept {
        size_ = other.size_;
        data_ = other.data_;
        other.data_ = nullptr;
        other.size_ = 0;
        std::cout << "Move constructor\n";
    }

    // 拷貝賦值運算符
    String& operator=(const String& other) {
        if (this != &other) {
            delete[] data_;
            size_ = other.size_;
            data_ = new char[size_ + 1];
            std::strcpy(data_, other.data_);
        }
        std::cout << "Copy assignment\n";
        return *this;
    }

    // 移動賦值運算符
    String& operator=(String&& other) noexcept {
        if (this != &other) {
            delete[] data_;
            size_ = other.size_;
            data_ = other.data_;
            other.data_ = nullptr;
            other.size_ = 0;
        }
        std::cout << "Move assignment\n";
        return *this;
    }

    ~String() {
        delete[] data_;
    }

private:
    char* data_;
    size_t size_;
};

void move_semantics_example() {
    String s1("Hello");
    String s2 = s1;              // 拷貝構造
    String s3 = std::move(s1);   // 移動構造

    String s4;
    s4 = s2;                     // 拷貝賦值
    s4 = std::move(s3);          // 移動賦值
}
```

### 2.3 完美轉發

```cpp
#include <utility>

template<typename T>
void wrapper(T&& arg) {
    // std::forward 保持參數的值類別
    process(std::forward<T>(arg));
}

void process(int& x) { std::cout << "Lvalue\n"; }
void process(int&& x) { std::cout << "Rvalue\n"; }

void perfect_forwarding() {
    int x = 10;
    wrapper(x);       // 調用 process(int&)
    wrapper(20);      // 調用 process(int&&)
}
```

**HFT 應用:**

- 減少訂單對象拷貝
- 高效傳遞市場數據
- 容器操作優化

---

## 3. Lambda 表達式

Lambda 表達式提供簡潔的匿名函數語法,廣泛用於算法和回調。

### 3.1 基本語法

```cpp
#include <algorithm>
#include <vector>

void lambda_basics() {
    // [捕獲列表](參數列表) -> 返回類型 { 函數體 }

    auto add = [](int a, int b) -> int {
        return a + b;
    };
    std::cout << add(3, 4) << "\n";  // 7

    // 自動推導返回類型
    auto multiply = [](int a, int b) { return a * b; };

    // 無參數
    auto greet = []() { std::cout << "Hello\n"; };
    greet();
}
```

### 3.2 捕獲機制

```cpp
void lambda_capture() {
    int x = 10;
    int y = 20;

    // 值捕獲
    auto f1 = [x, y]() { return x + y; };

    // 引用捕獲
    auto f2 = [&x, &y]() { x++; y++; };

    // 混合捕獲
    auto f3 = [x, &y]() { y = x; };

    // 捕獲所有 (值)
    auto f4 = [=]() { return x + y; };

    // 捕獲所有 (引用)
    auto f5 = [&]() { x++; y++; };

    // 初始化捕獲 (C++14)
    auto f6 = [z = x + y]() { return z * 2; };

    // 移動捕獲
    auto ptr = std::make_unique<int>(42);
    auto f7 = [p = std::move(ptr)]() { return *p; };
}
```

### 3.3 泛型 Lambda (C++14)

```cpp
void generic_lambda() {
    // auto 參數
    auto print = [](const auto& x) {
        std::cout << x << "\n";
    };

    print(42);
    print(3.14);
    print("Hello");

    // 多個 auto 參數
    auto max_val = [](const auto& a, const auto& b) {
        return a > b ? a : b;
    };

    std::cout << max_val(10, 20) << "\n";
    std::cout << max_val(3.14, 2.71) << "\n";
}
```

### 3.4 HFT 應用實例

```cpp
#include <vector>
#include <algorithm>

struct Order {
    int id;
    double price;
    int quantity;
};

void hft_lambda_examples() {
    std::vector<Order> orders = {
        {1, 100.5, 10},
        {2, 101.0, 20},
        {3, 99.5, 15}
    };

    // 按價格排序
    std::sort(orders.begin(), orders.end(),
        [](const Order& a, const Order& b) {
            return a.price < b.price;
        });

    // 過濾大單
    std::vector<Order> large_orders;
    std::copy_if(orders.begin(), orders.end(),
        std::back_inserter(large_orders),
        [](const Order& o) { return o.quantity >= 15; });

    // 計算總金額
    double total = std::accumulate(orders.begin(), orders.end(), 0.0,
        [](double sum, const Order& o) {
            return sum + o.price * o.quantity;
        });
}
```

---

## 4. 模板編程

模板是 C++ 泛型編程的基礎,提供編譯期多態。

### 4.1 函數模板

```cpp
template<typename T>
T max_value(T a, T b) {
    return a > b ? a : b;
}

// 模板特化
template<>
const char* max_value<const char*>(const char* a, const char* b) {
    return std::strcmp(a, b) > 0 ? a : b;
}

void function_template_example() {
    std::cout << max_value(10, 20) << "\n";
    std::cout << max_value(3.14, 2.71) << "\n";
    std::cout << max_value("hello", "world") << "\n";
}
```

### 4.2 類模板

```cpp
template<typename T, size_t N>
class FixedArray {
public:
    T& operator[](size_t i) { return data_[i]; }
    const T& operator[](size_t i) const { return data_[i]; }

    size_t size() const { return N; }

private:
    T data_[N];
};

void class_template_example() {
    FixedArray<int, 10> arr;
    arr[0] = 42;
    std::cout << arr[0] << "\n";
}
```

### 4.3 變參模板 (C++11)

```cpp
#include <iostream>

// 遞歸終止
void print() {
    std::cout << "\n";
}

// 變參模板
template<typename T, typename... Args>
void print(T first, Args... args) {
    std::cout << first << " ";
    print(args...);  // 遞歸展開
}

void variadic_template_example() {
    print(1, 2.5, "hello", 'c');  // 1 2.5 hello c
}
```

### 4.4 SFINAE 與 enable_if

```cpp
#include <type_traits>

// 只對整數類型啟用
template<typename T>
typename std::enable_if<std::is_integral<T>::value, T>::type
process(T value) {
    return value * 2;
}

// 只對浮點類型啟用
template<typename T>
typename std::enable_if<std::is_floating_point<T>::value, T>::type
process(T value) {
    return value * 1.5;
}

void sfinae_example() {
    std::cout << process(10) << "\n";      // 20
    std::cout << process(3.14) << "\n";    // 4.71
}
```

---

## 5. C++17 新特性

### 5.1 結構化綁定

```cpp
#include <map>
#include <tuple>

void structured_bindings() {
    // pair 解構
    std::pair<int, std::string> p = {1, "one"};
    auto [id, name] = p;
    std::cout << id << ": " << name << "\n";

    // map 遍歷
    std::map<std::string, double> prices = {
        {"AAPL", 150.0},
        {"GOOGL", 2800.0}
    };

    for (const auto& [symbol, price] : prices) {
        std::cout << symbol << ": " << price << "\n";
    }

    // tuple 解構
    std::tuple<int, double, std::string> t = {1, 3.14, "hello"};
    auto [a, b, c] = t;
}
```

### 5.2 std::optional

```cpp
#include <optional>
#include <string>

std::optional<std::string> find_symbol(int id) {
    if (id == 1) {
        return "AAPL";
    }
    return std::nullopt;  // 無值
}

void optional_example() {
    auto result = find_symbol(1);

    if (result) {
        std::cout << "Found: " << *result << "\n";
    }

    // 提供默認值
    std::string symbol = find_symbol(2).value_or("UNKNOWN");

    // has_value 檢查
    if (result.has_value()) {
        std::cout << result.value() << "\n";
    }
}
```

### 5.3 std::variant

```cpp
#include <variant>
#include <string>

void variant_example() {
    std::variant<int, double, std::string> v;

    v = 42;
    std::cout << std::get<int>(v) << "\n";

    v = 3.14;
    std::cout << std::get<double>(v) << "\n";

    v = "hello";
    std::cout << std::get<std::string>(v) << "\n";

    // 訪問者模式
    std::visit([](const auto& x) {
        std::cout << x << "\n";
    }, v);

    // 類型檢查
    if (std::holds_alternative<std::string>(v)) {
        std::cout << "It's a string\n";
    }
}
```

### 5.4 std::string_view

```cpp
#include <string_view>

void process_string(std::string_view sv) {
    std::cout << sv << "\n";
}

void string_view_example() {
    // 零拷貝字符串視圖
    std::string s = "Hello, World!";
    std::string_view sv = s;

    process_string(sv);
    process_string("Literal");  // 無需構造 string

    // 子串 (零拷貝)
    std::string_view sub = sv.substr(0, 5);
    std::cout << sub << "\n";  // Hello
}
```

**HFT 應用:**

- ✅ 解析 FIX 消息 (避免拷貝)
- ✅ 符號查找
- ✅ 日誌輸出

---

## 6. C++20 新特性

### 6.1 Concepts

```cpp
#include <concepts>

// 定義概念
template<typename T>
concept Numeric = std::is_arithmetic_v<T>;

template<typename T>
concept Order = requires(T order) {
    { order.get_price() } -> std::convertible_to<double>;
    { order.get_quantity() } -> std::convertible_to<int>;
    { order.get_symbol() } -> std::convertible_to<std::string>;
};

// 使用概念約束
template<Numeric T>
T add(T a, T b) {
    return a + b;
}

template<Order T>
void process_order(const T& order) {
    std::cout << "Symbol: " << order.get_symbol() << "\n";
    std::cout << "Price: " << order.get_price() << "\n";
}
```

### 6.2 Ranges

```cpp
#include <ranges>
#include <vector>
#include <iostream>

namespace views = std::views;

void ranges_example() {
    std::vector<int> nums = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};

    // 過濾偶數並平方
    auto result = nums
        | views::filter([](int n) { return n % 2 == 0; })
        | views::transform([](int n) { return n * n; });

    for (int n : result) {
        std::cout << n << " ";  // 4 16 36 64 100
    }
    std::cout << "\n";
}
```

### 6.3 std::span

```cpp
#include <span>
#include <vector>

void process_data(std::span<const int> data) {
    for (int x : data) {
        std::cout << x << " ";
    }
    std::cout << "\n";
}

void span_example() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    int arr[] = {6, 7, 8, 9, 10};

    process_data(vec);  // 接受 vector
    process_data(arr);  // 接受 C 陣列

    // 子範圍
    std::span<int> sub = std::span(vec).subspan(1, 3);
    process_data(sub);  // 2 3 4
}
```

---

## 7. RAII 與資源管理

RAII (Resource Acquisition Is Initialization) 是 C++ 資源管理的核心原則。

### 7.1 RAII 基本原理

```cpp
class FileHandle {
public:
    FileHandle(const char* filename) {
        file_ = fopen(filename, "r");
        if (!file_) {
            throw std::runtime_error("Failed to open file");
        }
    }

    ~FileHandle() {
        if (file_) {
            fclose(file_);
        }
    }

    // 禁止拷貝
    FileHandle(const FileHandle&) = delete;
    FileHandle& operator=(const FileHandle&) = delete;

    // 允許移動
    FileHandle(FileHandle&& other) noexcept : file_(other.file_) {
        other.file_ = nullptr;
    }

    FILE* get() { return file_; }

private:
    FILE* file_;
};

void raii_example() {
    FileHandle file("data.txt");
    // 使用文件...
}  // 自動關閉文件
```

### 7.2 內存池 (HFT 優化)

```cpp
#include <vector>
#include <memory>

template<typename T, size_t BlockSize = 4096>
class MemoryPool {
public:
    MemoryPool() {
        expand();
    }

    ~MemoryPool() {
        for (auto block : blocks_) {
            ::operator delete(block);
        }
    }

    T* allocate() {
        if (free_list_.empty()) {
            expand();
        }
        T* ptr = free_list_.back();
        free_list_.pop_back();
        return ptr;
    }

    void deallocate(T* ptr) {
        free_list_.push_back(ptr);
    }

private:
    void expand() {
        void* block = ::operator new(BlockSize * sizeof(T));
        blocks_.push_back(block);

        for (size_t i = 0; i < BlockSize; ++i) {
            free_list_.push_back(static_cast<T*>(block) + i);
        }
    }

    std::vector<void*> blocks_;
    std::vector<T*> free_list_;
};

struct Order {
    int id;
    double price;
    int quantity;
};

void memory_pool_example() {
    MemoryPool<Order> pool;

    // 快速分配
    Order* o1 = pool.allocate();
    new (o1) Order{1, 100.0, 10};  // placement new

    // 使用訂單...

    // 釋放
    o1->~Order();
    pool.deallocate(o1);
}
```

---

## 8. STL 容器與算法

### 8.1 容器性能對比

| 容器          | 隨機訪問 | 插入/刪除 | 查找     | Cache 友好 | HFT 推薦   |
| ------------- | -------- | --------- | -------- | ---------- | ---------- |
| vector        | O(1)     | O(n)      | O(n)     | ✅         | ⭐⭐⭐⭐⭐ |
| deque         | O(1)     | O(1)頭尾  | O(n)     | ⚠️         | ⭐⭐⭐     |
| list          | O(n)     | O(1)      | O(n)     | ❌         | ⭐         |
| array         | O(1)     | N/A       | O(n)     | ✅         | ⭐⭐⭐⭐⭐ |
| map           | O(log n) | O(log n)  | O(log n) | ❌         | ⭐⭐⭐⭐   |
| unordered_map | O(1)     | O(1)      | O(1)     | ⚠️         | ⭐⭐⭐⭐⭐ |

### 8.2 常用算法

```cpp
#include <algorithm>
#include <vector>
#include <numeric>

void algorithm_examples() {
    std::vector<int> v = {3, 1, 4, 1, 5, 9, 2, 6};

    // 排序
    std::sort(v.begin(), v.end());

    // 二分查找 (需已排序)
    bool found = std::binary_search(v.begin(), v.end(), 5);

    // 查找
    auto it = std::find(v.begin(), v.end(), 5);

    // 計數
    int count = std::count(v.begin(), v.end(), 1);

    // 累加
    int sum = std::accumulate(v.begin(), v.end(), 0);

    // 最大/最小
    auto max_it = std::max_element(v.begin(), v.end());
    auto min_it = std::min_element(v.begin(), v.end());

    // 去重 (需先排序)
    v.erase(std::unique(v.begin(), v.end()), v.end());
}
```

---

## 9. 標準庫與第三方庫

### 9.1 標準庫容器深入

**vector 最佳實踐:**

```cpp
void vector_best_practices() {
    std::vector<int> vec;
    vec.reserve(1000);  // 預分配避免擴容

    // emplace_back 避免拷貝
    struct Order {
        int id;
        double price;
        Order(int i, double p) : id(i), price(p) {}
    };

    std::vector<Order> orders;
    orders.emplace_back(1, 150.0);  // 直接構造
}
```

**map vs unordered_map:**

| 場景         | 推薦容器             | 理由         |
| ------------ | -------------------- | ------------ |
| 訂單簿價格層 | `std::map`           | 需要有序遍歷 |
| 訂單 ID 查找 | `std::unordered_map` | O(1) 查找    |
| 符號映射     | `std::unordered_map` | 快速查找     |

### 9.2 第三方庫推薦 (HFT)

**序列化:**

- **FlatBuffers** ⭐⭐⭐⭐⭐: 零拷貝,訪問延遲 <10ns
- **Protocol Buffers** ⭐⭐⭐⭐: 行業標準,跨語言

**網路:**

- **ZeroMQ** ⭐⭐⭐⭐⭐: 高性能消息隊列
- **Boost.Asio** ⭐⭐⭐: 跨平台異步 I/O

**日誌:**

- **spdlog** ⭐⭐⭐⭐⭐: 百萬條/秒,異步模式

**測試:**

- **Google Test** ⭐⭐⭐⭐⭐: 單元測試
- **Google Benchmark** ⭐⭐⭐⭐⭐: 性能測試

---

## 10. HFT 應用實踐

### 10.1 訂單類設計

```cpp
#include <string>
#include <memory>

class Order {
public:
    enum class Side { Buy, Sell };
    enum class Type { Market, Limit };

    Order(int id, std::string symbol, Side side, Type type,
          double price, int quantity)
        : id_(id), symbol_(std::move(symbol)), side_(side),
          type_(type), price_(price), quantity_(quantity) {}

    // 移動語義
    Order(Order&&) noexcept = default;
    Order& operator=(Order&&) noexcept = default;

    // 禁止拷貝
    Order(const Order&) = delete;
    Order& operator=(const Order&) = delete;

    int get_id() const { return id_; }
    const std::string& get_symbol() const { return symbol_; }
    double get_price() const { return price_; }
    int get_quantity() const { return quantity_; }

private:
    int id_;
    std::string symbol_;
    Side side_;
    Type type_;
    double price_;
    int quantity_;
};

void order_example() {
    auto order = std::make_unique<Order>(
        1, "AAPL", Order::Side::Buy, Order::Type::Limit, 150.0, 100
    );

    std::cout << "Order: " << order->get_symbol()
              << " @ " << order->get_price() << "\n";
}
```

### 10.2 性能優化技巧

**1. 避免不必要的拷貝:**

```cpp
// ❌ 錯誤: 多次拷貝
void process_orders(std::vector<Order> orders) {
    for (Order o : orders) {  // 拷貝!
        // ...
    }
}

// ✅ 正確: 引用傳遞
void process_orders(const std::vector<Order>& orders) {
    for (const auto& o : orders) {  // 無拷貝
        // ...
    }
}
```

**2. 使用 emplace 而非 push:**

```cpp
std::vector<Order> orders;

// ❌ 錯誤: 構造臨時對象再移動
orders.push_back(Order(1, "AAPL", ...));

// ✅ 正確: 直接構造
orders.emplace_back(1, "AAPL", ...);
```

**3. 預分配容器:**

```cpp
std::vector<int> prices;
prices.reserve(10000);  // 避免多次擴容
```

---

## 總結

本章涵蓋了現代 C++ 的核心特性:

1. **智能指針**: 自動內存管理,避免洩漏
2. **移動語義**: 零拷貝優化,提升性能
3. **Lambda**: 簡潔的函數式編程
4. **模板**: 泛型編程,編譯期優化
5. **C++17/20**: 結構化綁定、Concepts、Ranges
6. **RAII**: 資源管理的黃金法則
7. **STL**: 高效的容器與算法
8. **第三方庫**: 生產級工具鏈

**HFT 關鍵要點:**

- ✅ 優先使用 `unique_ptr` 而非 `shared_ptr`
- ✅ 善用移動語義減少拷貝
- ✅ 選擇合適的容器 (vector > list)
- ✅ 預分配內存避免動態分配
- ✅ 使用內存池管理高頻對象
- ✅ 利用 C++17/20 新特性提升代碼質量

**下一步:**

- 學習並發編程 (多線程、原子操作)
- 掌握編譯優化技術
- 深入網路編程與系統調優

## 參考資料 (References)

1. [C++ Reference](https://en.cppreference.com/) - C++ 標準庫完整參考
2. [Effective Modern C++](https://www.oreilly.com/library/view/effective-modern-c/9781491908419/) - Scott Meyers
3. [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines) - Bjarne Stroustrup
4. [C++17/C++20 Features](https://github.com/AnthonyCalandra/modern-cpp-features)
5. [Smart Pointers Best Practices](https://herbsutter.com/2013/06/05/gotw-91-solution-smart-pointer-parameters/)
6. [Move Semantics and Perfect Forwarding](https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html)
7. [Lambda Expressions in C++](https://docs.microsoft.com/en-us/cpp/cpp/lambda-expressions-in-cpp)

````

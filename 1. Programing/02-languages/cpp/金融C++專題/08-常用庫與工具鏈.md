# 常用庫與工具鏈

> 本章介紹 C++ 開發中常用的第三方庫,特別關注高性能計算和 HFT 場景,包含詳細的使用教學、性能對比和實戰案例。

---

## 目錄

> **HFT 學習優先級**: ⭐⭐⭐ 必看 | ⭐⭐ 建議 | ⭐ 有空再看

1. [序列化庫](#1-序列化庫) ⭐⭐⭐
2. [網路庫](#2-網路庫) ⭐⭐
3. [日誌庫](#3-日誌庫) ⭐⭐⭐
4. [測試與基準](#4-測試與基準) ⭐⭐
5. [數據結構與算法庫](#5-數據結構與算法庫) ⭐⭐
6. [時間與日期](#6-時間與日期) ⭐
7. [配置與命令行](#7-配置與命令行) ⭐
8. [HFT 專用庫](#8-hft-專用庫) ⭐⭐⭐

---

## 1. 序列化庫

### 1.0 概念解析: 為什麼需要序列化?

**序列化 (Serialization)** 是將內存中的對象 (Object) 轉換成字節流 (Bytes) 的過程,以便通過網絡傳輸或保存到文件。

**類比**:

- **對象**: 一個組裝好的樂高模型 (有結構,有指針引用)。
- **序列化**: 將樂高拆成一塊塊積木,並寫下說明書 (變成扁平的數據流)。
- **反序列化**: 根據說明書將積木重新組裝成模型。

**HFT 的痛點**: 傳統序列化 (如 JSON) 需要"拆"和"裝",非常耗時。我們追求 **Zero-copy (零拷貝)** 序列化 (如 FlatBuffers),就像直接把整個樂高模型搬走,不需要拆裝。

### 1.1 FlatBuffers ⭐⭐⭐⭐⭐

**為什麼選擇 FlatBuffers:**

- **零拷貝**: 直接訪問序列化數據,無需解析
- **極低延遲**: 訪問延遲 < 10ns
- **跨語言**: 支持 C++, Python, Java 等
- **向後兼容**: Schema 演化支持

**安裝:**

```bash
# Ubuntu/Debian
sudo apt-get install flatbuffers-compiler libflatbuffers-dev

# 或從源碼編譯
git clone https://github.com/google/flatbuffers.git
cd flatbuffers
cmake -G "Unix Makefiles" -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)
sudo make install
```

**定義 Schema:**

```flatbuffers
// order.fbs
namespace Trading;

enum Side : byte { Buy = 0, Sell = 1 }
enum OrderType : byte { Market = 0, Limit = 1 }

table Order {
  order_id: ulong;
  symbol: string;
  side: Side;
  type: OrderType;
  price: double;
  quantity: uint;
  timestamp: ulong;
}

root_type Order;
```

**編譯 Schema:**

```bash
flatc --cpp order.fbs
# 生成 order_generated.h
```

**C++ 使用示例:**

```cpp
#include "order_generated.h"
#include <flatbuffers/flatbuffers.h>
#include <iostream>
#include <chrono>

// 創建 FlatBuffer
std::vector<uint8_t> create_order() {
    flatbuffers::FlatBufferBuilder builder(1024);

    // 創建字符串
    auto symbol = builder.CreateString("AAPL");

    // 創建 Order
    auto order = Trading::CreateOrder(builder,
        12345,                      // order_id
        symbol,                     // symbol
        Trading::Side_Buy,          // side
        Trading::OrderType_Limit,   // type
        150.50,                     // price
        100,                        // quantity
        1234567890                  // timestamp
    );

    builder.Finish(order);

    // 獲取緩衝區
    uint8_t* buf = builder.GetBufferPointer();
    int size = builder.GetSize();

    return std::vector<uint8_t>(buf, buf + size);
}

// 讀取 FlatBuffer (零拷貝!)
void read_order(const std::vector<uint8_t>& buffer) {
    auto order = Trading::GetOrder(buffer.data());

    std::cout << "Order ID: " << order->order_id() << "\n";
    std::cout << "Symbol: " << order->symbol()->str() << "\n";
    std::cout << "Side: " << (order->side() == Trading::Side_Buy ? "Buy" : "Sell") << "\n";
    std::cout << "Price: " << order->price() << "\n";
    std::cout << "Quantity: " << order->quantity() << "\n";
}

// 性能測試
void benchmark_flatbuffers() {
    const int iterations = 1000000;

    // 序列化性能
    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        auto buffer = create_order();
    }
    auto end = std::chrono::high_resolution_clock::now();
    auto duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    std::cout << "Serialize: " << duration.count() / iterations << " ns/op\n";

    // 反序列化性能 (零拷貝,幾乎無開銷)
    auto buffer = create_order();
    start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        auto order = Trading::GetOrder(buffer.data());
        volatile auto id = order->order_id();  // 防止優化
    }
    end = std::chrono::high_resolution_clock::now();
    duration = std::chrono::duration_cast<std::chrono::nanoseconds>(end - start);
    std::cout << "Deserialize: " << duration.count() / iterations << " ns/op\n";
}
```

**HFT 應用場景:**

```cpp
// 市場數據序列化
namespace Trading;

table MarketData {
  symbol_id: uint;
  bid_price: double;
  bid_size: uint;
  ask_price: double;
  ask_size: uint;
  timestamp: ulong;
}

// 使用內存池優化
class MarketDataSerializer {
public:
    MarketDataSerializer() : builder_(4096) {}

    // 重用 builder,避免分配
    const uint8_t* serialize(uint32_t symbol_id, double bid, uint32_t bid_size,
                             double ask, uint32_t ask_size, uint64_t ts) {
        builder_.Clear();  // 重用緩衝區

        auto md = Trading::CreateMarketData(builder_,
            symbol_id, bid, bid_size, ask, ask_size, ts);

        builder_.Finish(md);
        return builder_.GetBufferPointer();
    }

    size_t size() const { return builder_.GetSize(); }

private:
    flatbuffers::FlatBufferBuilder builder_;
};
```

---

### 1.2 Protocol Buffers ⭐⭐⭐⭐

**優勢:**

- 行業標準,廣泛使用
- 強大的 Schema 演化
- 跨語言支持

**缺點:**

- 需要解析,延遲較高 (~100-500ns)
- 不適合極端延遲敏感場景

**安裝:**

```bash
# Ubuntu/Debian
sudo apt-get install protobuf-compiler libprotobuf-dev

# 驗證安裝
protoc --version
```

**定義 .proto 文件:**

```protobuf
// order.proto
syntax = "proto3";

package trading;

enum Side {
  BUY = 0;
  SELL = 1;
}

enum OrderType {
  MARKET = 0;
  LIMIT = 1;
}

message Order {
  uint64 order_id = 1;
  string symbol = 2;
  Side side = 3;
  OrderType type = 4;
  double price = 5;
  uint32 quantity = 6;
  uint64 timestamp = 7;
}
```

**編譯:**

```bash
protoc --cpp_out=. order.proto
# 生成 order.pb.h 和 order.pb.cc
```

**C++ 使用:**

```cpp
#include "order.pb.h"
#include <iostream>
#include <fstream>

void protobuf_example() {
    // 創建消息
    trading::Order order;
    order.set_order_id(12345);
    order.set_symbol("AAPL");
    order.set_side(trading::Side::BUY);
    order.set_type(trading::OrderType::LIMIT);
    order.set_price(150.50);
    order.set_quantity(100);
    order.set_timestamp(1234567890);

    // 序列化到字符串
    std::string serialized;
    order.SerializeToString(&serialized);

    std::cout << "Serialized size: " << serialized.size() << " bytes\n";

    // 反序列化
    trading::Order order2;
    order2.ParseFromString(serialized);

    std::cout << "Order ID: " << order2.order_id() << "\n";
    std::cout << "Symbol: " << order2.symbol() << "\n";
    std::cout << "Price: " << order2.price() << "\n";

    // 序列化到文件
    std::ofstream output("order.bin", std::ios::binary);
    order.SerializeToOstream(&output);
}
```

**性能對比:**

| 庫          | 序列化 (ns) | 反序列化 (ns) | 大小 (bytes) | HFT 推薦   |
| ----------- | ----------- | ------------- | ------------ | ---------- |
| FlatBuffers | ~50         | ~5 (零拷貝)   | 80           | ⭐⭐⭐⭐⭐ |
| Protobuf    | ~200        | ~300          | 60           | ⭐⭐⭐     |
| JSON        | ~1000       | ~2000         | 120          | ⭐         |

---

### 1.3 JSON 庫

#### nlohmann/json ⭐⭐⭐⭐

**優勢:**

- Header-only,易於集成
- 現代 C++ API
- 功能豐富

**安裝:**

```bash
# 單文件,直接下載
wget https://github.com/nlohmann/json/releases/download/v3.11.2/json.hpp
```

**使用示例:**

```cpp
#include "json.hpp"
#include <iostream>

using json = nlohmann::json;

void json_example() {
    // 創建 JSON
    json order = {
        {"order_id", 12345},
        {"symbol", "AAPL"},
        {"side", "Buy"},
        {"price", 150.50},
        {"quantity", 100}
    };

    // 序列化
    std::string serialized = order.dump();
    std::cout << serialized << "\n";

    // 反序列化
    json order2 = json::parse(serialized);
    std::cout << "Order ID: " << order2["order_id"] << "\n";

    // 類型安全訪問
    int order_id = order2["order_id"].get<int>();
    std::string symbol = order2["symbol"].get<std::string>();
}

// 與自定義類型綁定
struct Order {
    int order_id;
    std::string symbol;
    double price;
    int quantity;
};

// 定義序列化
void to_json(json& j, const Order& o) {
    j = json{
        {"order_id", o.order_id},
        {"symbol", o.symbol},
        {"price", o.price},
        {"quantity", o.quantity}
    };
}

// 定義反序列化
void from_json(const json& j, Order& o) {
    j.at("order_id").get_to(o.order_id);
    j.at("symbol").get_to(o.symbol);
    j.at("price").get_to(o.price);
    j.at("quantity").get_to(o.quantity);
}

void custom_type_example() {
    Order order{12345, "AAPL", 150.50, 100};

    // 自動序列化
    json j = order;
    std::cout << j.dump(4) << "\n";  // 美化輸出

    // 自動反序列化
    Order order2 = j.get<Order>();
}
```

#### simdjson ⭐⭐⭐⭐⭐

**優勢:**

- 極快的 JSON 解析 (GB/s)
- SIMD 優化
- 適合大量 JSON 數據

**安裝:**

```bash
git clone https://github.com/simdjson/simdjson.git
cd simdjson
mkdir build && cd build
cmake ..
make -j$(nproc)
sudo make install
```

**使用:**

```cpp
#include "simdjson.h"
#include <iostream>

void simdjson_example() {
    simdjson::dom::parser parser;

    std::string json_str = R"({
        "order_id": 12345,
        "symbol": "AAPL",
        "price": 150.50,
        "quantity": 100
    })";

    // 解析
    simdjson::dom::element doc = parser.parse(json_str);

    // 訪問字段
    uint64_t order_id = doc["order_id"];
    std::string_view symbol = doc["symbol"];
    double price = doc["price"];

    std::cout << "Order ID: " << order_id << "\n";
    std::cout << "Symbol: " << symbol << "\n";
    std::cout << "Price: " << price << "\n";
}
```

**JSON 庫對比:**

| 庫            | 解析速度       | 易用性 | HFT 推薦   |
| ------------- | -------------- | ------ | ---------- |
| nlohmann/json | 慢 (~2 μs)     | 極好   | ⭐⭐⭐     |
| simdjson      | 極快 (~200 ns) | 好     | ⭐⭐⭐⭐⭐ |
| RapidJSON     | 快 (~500 ns)   | 中等   | ⭐⭐⭐⭐   |

**HFT 建議**: 配置文件用 nlohmann/json,運行時數據用 FlatBuffers

---

## 2. 網路庫

### 2.1 Boost.Asio ⭐⭐⭐⭐

**優勢:**

- 跨平台異步 I/O
- 功能豐富 (TCP, UDP, 定時器等)
- 成熟穩定

**安裝:**

```bash
# Ubuntu/Debian
sudo apt-get install libboost-all-dev

# 或只安裝 Asio (header-only)
sudo apt-get install libasio-dev
```

**TCP 客戶端示例:**

```cpp
#include <boost/asio.hpp>
#include <iostream>

using boost::asio::ip::tcp;

void asio_tcp_client() {
    boost::asio::io_context io_context;

    // 解析地址
    tcp::resolver resolver(io_context);
    auto endpoints = resolver.resolve("example.com", "80");

    // 連接
    tcp::socket socket(io_context);
    boost::asio::connect(socket, endpoints);

    // 發送 HTTP 請求
    std::string request = "GET / HTTP/1.1\r\nHost: example.com\r\n\r\n";
    boost::asio::write(socket, boost::asio::buffer(request));

    // 接收響應
    boost::asio::streambuf response;
    boost::asio::read_until(socket, response, "\r\n");

    std::istream response_stream(&response);
    std::string http_version;
    response_stream >> http_version;

    unsigned int status_code;
    response_stream >> status_code;

    std::cout << "HTTP/" << http_version << " " << status_code << "\n";
}
```

**異步 TCP 服務器:**

```cpp
#include <boost/asio.hpp>
#include <memory>
#include <iostream>

using boost::asio::ip::tcp;

class Session : public std::enable_shared_from_this<Session> {
public:
    Session(tcp::socket socket) : socket_(std::move(socket)) {}

    void start() {
        do_read();
    }

private:
    void do_read() {
        auto self(shared_from_this());
        socket_.async_read_some(
            boost::asio::buffer(data_, max_length),
            [this, self](boost::system::error_code ec, std::size_t length) {
                if (!ec) {
                    do_write(length);
                }
            });
    }

    void do_write(std::size_t length) {
        auto self(shared_from_this());
        boost::asio::async_write(socket_,
            boost::asio::buffer(data_, length),
            [this, self](boost::system::error_code ec, std::size_t /*length*/) {
                if (!ec) {
                    do_read();
                }
            });
    }

    tcp::socket socket_;
    enum { max_length = 1024 };
    char data_[max_length];
};

class Server {
public:
    Server(boost::asio::io_context& io_context, short port)
        : acceptor_(io_context, tcp::endpoint(tcp::v4(), port)) {
        do_accept();
    }

private:
    void do_accept() {
        acceptor_.async_accept(
            [this](boost::system::error_code ec, tcp::socket socket) {
                if (!ec) {
                    std::make_shared<Session>(std::move(socket))->start();
                }
                do_accept();
            });
    }

    tcp::acceptor acceptor_;
};

void asio_server_example() {
    boost::asio::io_context io_context;
    Server server(io_context, 8080);
    io_context.run();
}
```

**定時器:**

```cpp
#include <boost/asio.hpp>
#include <iostream>
#include <chrono>

void asio_timer_example() {
    boost::asio::io_context io_context;

    boost::asio::steady_timer timer(io_context, std::chrono::seconds(1));

    timer.async_wait([](const boost::system::error_code& ec) {
        if (!ec) {
            std::cout << "Timer expired!\n";
        }
    });

    io_context.run();
}
```

---

### 2.2 ZeroMQ ⭐⭐⭐⭐⭐

#### 概念解析: 什麼是消息隊列 (Message Queue)?

**消息隊列** 是不同程序之間通信的"郵局"。

- **解耦 (Decoupling)**: 發送者不需要知道接收者是誰,也不需要等待接收者處理完。
- **異步 (Asynchronous)**: 發送者把信丟進郵筒就可以走了,不用等郵差送信。

**ZeroMQ** 是一個極高性能的"無中間件"消息隊列庫。它不像 RabbitMQ 需要一個單獨的服務器進程,而是直接嵌入在你的程序中,像 Socket 一樣快,但功能更強大。

**優勢:**

- 高性能消息隊列
- 多種通信模式 (PUB/SUB, REQ/REP, PUSH/PULL)
- 無需中間件

**安裝:**

```bash
# Ubuntu/Debian
sudo apt-get install libzmq3-dev

# C++ 綁定
git clone https://github.com/zeromq/cppzmq.git
cd cppzmq
mkdir build && cd build
cmake ..
sudo make install
```

**PUB/SUB 模式 (市場數據分發):**

```cpp
#include <zmq.hpp>
#include <string>
#include <iostream>
#include <thread>
#include <chrono>

// 發布者 (市場數據源)
void publisher() {
    zmq::context_t context(1);
    zmq::socket_t publisher(context, zmq::socket_type::pub);
    publisher.bind("tcp://*:5555");

    int msg_count = 0;
    while (true) {
        // 發布市場數據
        std::string topic = "AAPL";
        std::string data = "150.50,100";  // price,quantity

        zmq::message_t topic_msg(topic.data(), topic.size());
        zmq::message_t data_msg(data.data(), data.size());

        publisher.send(topic_msg, zmq::send_flags::sndmore);
        publisher.send(data_msg, zmq::send_flags::none);

        std::cout << "Published: " << topic << " " << data << "\n";

        std::this_thread::sleep_for(std::chrono::milliseconds(100));
    }
}

// 訂閱者 (策略引擎)
void subscriber() {
    zmq::context_t context(1);
    zmq::socket_t subscriber(context, zmq::socket_type::sub);
    subscriber.connect("tcp://localhost:5555");

    // 訂閱 AAPL
    subscriber.set(zmq::sockopt::subscribe, "AAPL");

    while (true) {
        zmq::message_t topic_msg;
        zmq::message_t data_msg;

        subscriber.recv(topic_msg);
        subscriber.recv(data_msg);

        std::string topic(static_cast<char*>(topic_msg.data()), topic_msg.size());
        std::string data(static_cast<char*>(data_msg.data()), data_msg.size());

        std::cout << "Received: " << topic << " " << data << "\n";
    }
}
```

**REQ/REP 模式 (訂單發送):**

```cpp
// 客戶端 (發送訂單)
void order_client() {
    zmq::context_t context(1);
    zmq::socket_t socket(context, zmq::socket_type::req);
    socket.connect("tcp://localhost:5556");

    std::string order = "BUY AAPL 100@150.50";
    zmq::message_t request(order.data(), order.size());
    socket.send(request, zmq::send_flags::none);

    // 等待確認
    zmq::message_t reply;
    socket.recv(reply);

    std::string ack(static_cast<char*>(reply.data()), reply.size());
    std::cout << "Order ACK: " << ack << "\n";
}

// 服務器 (訂單網關)
void order_server() {
    zmq::context_t context(1);
    zmq::socket_t socket(context, zmq::socket_type::rep);
    socket.bind("tcp://*:5556");

    while (true) {
        zmq::message_t request;
        socket.recv(request);

        std::string order(static_cast<char*>(request.data()), request.size());
        std::cout << "Received order: " << order << "\n";

        // 處理訂單...

        // 發送確認
        std::string ack = "ACK-12345";
        zmq::message_t reply(ack.data(), ack.size());
        socket.send(reply, zmq::send_flags::none);
    }
}
```

**性能對比:**

| 庫                  | 延遲      | 吞吐量 | 易用性 | HFT 推薦   |
| ------------------- | --------- | ------ | ------ | ---------- |
| Boost.Asio          | ~1-5 μs   | 高     | 中等   | ⭐⭐⭐⭐   |
| ZeroMQ              | ~10-50 μs | 極高   | 高     | ⭐⭐⭐⭐⭐ |
| 原生 Socket + epoll | ~0.5-2 μs | 極高   | 低     | ⭐⭐⭐⭐⭐ |

---

## 3. 日誌庫

### 3.0 概念解析: 為什麼需要異步日誌?

**同步日誌 (printf/cout)**:

1.  程序執行到打印語句。
2.  **暫停**,等待磁盤寫入完成 (磁盤很慢!)。
3.  繼續執行。
    **後果**: 在 HFT 中,這幾毫秒的暫停是致命的。

**異步日誌 (Async Logging)**:

1.  程序執行到打印語句。
2.  將日誌內容丟進一個內存隊列 (極快, 納秒級)。
3.  程序**立即繼續執行**。
4.  後台線程慢慢從隊列取出日誌寫入磁盤。

### 3.1 spdlog ⭐⭐⭐⭐⭐

**優勢:**

- 極快 (百萬條/秒)
- Header-only 或編譯版本
- 異步日誌支持
- 多種 sink (控制台、文件、旋轉文件等)

**安裝:**

```bash
# Header-only
git clone https://github.com/gabime/spdlog.git
# 將 include/spdlog 複製到項目中

# 或使用包管理器
sudo apt-get install libspdlog-dev
```

**基本使用:**

```cpp
#include "spdlog/spdlog.h"
#include "spdlog/sinks/stdout_color_sinks.h"
#include "spdlog/sinks/basic_file_sink.h"

void spdlog_basic() {
    // 控制台日誌
    auto console = spdlog::stdout_color_mt("console");
    console->info("Welcome to spdlog!");
    console->error("Some error message with arg: {}", 42);

    // 文件日誌
    auto file_logger = spdlog::basic_logger_mt("file_logger", "logs/basic.txt");
    file_logger->info("Log to file");

    // 設置日誌級別
    spdlog::set_level(spdlog::level::debug);
    spdlog::debug("This is a debug message");

    // 格式化
    spdlog::info("Support for floats {:03.2f}", 1.23456);
    spdlog::info("Positional args are {1} {0}..", "too", "supported");
}
```

**異步日誌 (HFT 推薦):**

```cpp
#include "spdlog/async.h"
#include "spdlog/sinks/basic_file_sink.h"

void spdlog_async() {
    // 創建異步日誌器
    // 參數: 隊列大小, 線程數
    auto async_file = spdlog::basic_logger_mt<spdlog::async_factory>(
        "async_file_logger", "logs/async.txt");

    // 關鍵路徑中使用
    for (int i = 0; i < 1000000; ++i) {
        async_file->info("Async message #{}", i);
    }

    // 日誌在後台線程中寫入,不阻塞主線程
}
```

**自定義格式:**

```cpp
#include "spdlog/spdlog.h"

void spdlog_custom_format() {
    // 設置全局格式
    spdlog::set_pattern("[%Y-%m-%d %H:%M:%S.%e] [%^%l%$] [%t] %v");

    // 格式說明:
    // %Y-%m-%d %H:%M:%S.%e - 時間戳 (精確到毫秒)
    // %l - 日誌級別
    // %t - 線程 ID
    // %v - 消息內容

    spdlog::info("This is an info message");
    spdlog::warn("This is a warning");
}
```

**HFT 日誌系統:**

```cpp
#include "spdlog/async.h"
#include "spdlog/sinks/rotating_file_sink.h"
#include <memory>

class HFTLogger {
public:
    static void init() {
        // 異步旋轉文件日誌
        // 每個文件 10MB,最多保留 3 個文件
        auto rotating = spdlog::rotating_logger_mt<spdlog::async_factory>(
            "hft_logger", "logs/hft.log", 1024 * 1024 * 10, 3);

        // 設置格式 (包含納秒級時間戳)
        rotating->set_pattern("[%Y-%m-%d %H:%M:%S.%f] [%l] %v");

        // 設置為默認日誌器
        spdlog::set_default_logger(rotating);

        // 設置刷新策略 (每秒刷新一次)
        spdlog::flush_every(std::chrono::seconds(1));
    }

    // 便捷宏
    template<typename... Args>
    static void trade(Args&&... args) {
        spdlog::info(std::forward<Args>(args)...);
    }

    template<typename... Args>
    static void error(Args&&... args) {
        spdlog::error(std::forward<Args>(args)...);
    }
};

void hft_logging_example() {
    HFTLogger::init();

    // 記錄交易
    HFTLogger::trade("Order sent: {} @ {}", "AAPL", 150.50);
    HFTLogger::trade("Order filled: {} shares", 100);

    // 記錄錯誤
    HFTLogger::error("Connection lost to exchange");
}
```

**性能測試:**

```cpp
#include "spdlog/spdlog.h"
#include <chrono>

void benchmark_spdlog() {
    auto logger = spdlog::basic_logger_mt("bench", "logs/bench.txt");

    const int iterations = 1000000;

    auto start = std::chrono::high_resolution_clock::now();
    for (int i = 0; i < iterations; ++i) {
        logger->info("Iteration {}", i);
    }
    auto end = std::chrono::high_resolution_clock::now();

    auto duration = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
    double throughput = iterations / (duration.count() / 1000.0);

    std::cout << "Throughput: " << throughput << " logs/sec\n";
    // 典型結果: 1,000,000+ logs/sec (異步模式)
}
```

**日誌庫對比:**

| 庫             | 吞吐量 (logs/s) | 異步支持 | 易用性 | HFT 推薦   |
| -------------- | --------------- | -------- | ------ | ---------- |
| spdlog         | 1M+             | ✅       | 極好   | ⭐⭐⭐⭐⭐ |
| glog           | 100K            | ❌       | 好     | ⭐⭐⭐     |
| Boost.Log      | 50K             | ✅       | 中等   | ⭐⭐       |
| 自定義環形緩衝 | 10M+            | ✅       | 低     | ⭐⭐⭐⭐⭐ |

---

## 4. 測試與基準

### 4.1 Google Test ⭐⭐⭐⭐⭐

**安裝:**

```bash
git clone https://github.com/google/googletest.git
cd googletest
mkdir build && cd build
cmake ..
make -j$(nproc)
sudo make install
```

**基本測試:**

```cpp
#include <gtest/gtest.h>

// 被測試的類
class OrderBook {
public:
    void add_order(int price, int quantity) {
        orders_[price] += quantity;
    }

    int get_quantity(int price) const {
        auto it = orders_.find(price);
        return it != orders_.end() ? it->second : 0;
    }

private:
    std::map<int, int> orders_;
};

// 測試用例
TEST(OrderBookTest, AddOrder) {
    OrderBook book;
    book.add_order(100, 50);

    EXPECT_EQ(book.get_quantity(100), 50);
    EXPECT_EQ(book.get_quantity(101), 0);
}

TEST(OrderBookTest, MultipleOrders) {
    OrderBook book;
    book.add_order(100, 50);
    book.add_order(100, 30);

    EXPECT_EQ(book.get_quantity(100), 80);
}

// 測試夾具 (Fixture)
class OrderBookFixture : public ::testing::Test {
protected:
    void SetUp() override {
        book.add_order(100, 50);
        book.add_order(101, 30);
    }

    OrderBook book;
};

TEST_F(OrderBookFixture, InitialState) {
    EXPECT_EQ(book.get_quantity(100), 50);
    EXPECT_EQ(book.get_quantity(101), 30);
}

// 主函數
int main(int argc, char **argv) {
    ::testing::InitGoogleTest(&argc, argv);
    return RUN_ALL_TESTS();
}
```

**編譯和運行:**

```bash
g++ -std=c++17 test.cpp -lgtest -lgtest_main -pthread -o test
./test
```

---

### 4.2 Google Benchmark ⭐⭐⭐⭐⭐

**安裝:**

```bash
git clone https://github.com/google/benchmark.git
cd benchmark
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)
sudo make install
```

**基準測試示例:**

```cpp
#include <benchmark/benchmark.h>
#include <vector>
#include <algorithm>

// 測試 std::vector push_back vs emplace_back
static void BM_PushBack(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<int> v;
        for (int i = 0; i < state.range(0); ++i) {
            v.push_back(i);
        }
        benchmark::DoNotOptimize(v);
    }
}
BENCHMARK(BM_PushBack)->Range(8, 8<<10);

static void BM_EmplaceBack(benchmark::State& state) {
    for (auto _ : state) {
        std::vector<int> v;
        for (int i = 0; i < state.range(0); ++i) {
            v.emplace_back(i);
        }
        benchmark::DoNotOptimize(v);
    }
}
BENCHMARK(BM_EmplaceBack)->Range(8, 8<<10);

// HFT 相關: 測試訂單簿性能
static void BM_OrderBookInsert(benchmark::State& state) {
    std::map<int, int> book;

    for (auto _ : state) {
        book[100] = 50;
        benchmark::DoNotOptimize(book);
    }

    state.SetItemsProcessed(state.iterations());
}
BENCHMARK(BM_OrderBookInsert);

// 測試不同容器的查找性能
static void BM_MapLookup(benchmark::State& state) {
    std::map<int, int> map;
    for (int i = 0; i < 1000; ++i) {
        map[i] = i;
    }

    for (auto _ : state) {
        auto it = map.find(500);
        benchmark::DoNotOptimize(it);
    }
}
BENCHMARK(BM_MapLookup);

static void BM_UnorderedMapLookup(benchmark::State& state) {
    std::unordered_map<int, int> map;
    for (int i = 0; i < 1000; ++i) {
        map[i] = i;
    }

    for (auto _ : state) {
        auto it = map.find(500);
        benchmark::DoNotOptimize(it);
    }
}
BENCHMARK(BM_UnorderedMapLookup);

BENCHMARK_MAIN();
```

**編譯和運行:**

```bash
g++ -std=c++17 benchmark.cpp -lbenchmark -lpthread -o bench
./bench
```

**輸出示例:**

```
-------------------------------------------------------------------
Benchmark                         Time             CPU   Iterations
-------------------------------------------------------------------
BM_PushBack/8                    15 ns           15 ns     46666667
BM_PushBack/64                  120 ns          120 ns      5833333
BM_EmplaceBack/8                 14 ns           14 ns     50000000
BM_EmplaceBack/64               115 ns          115 ns      6086957
BM_OrderBookInsert               25 ns           25 ns     28000000
BM_MapLookup                     45 ns           45 ns     15555556
BM_UnorderedMapLookup            12 ns           12 ns     58333333
```

---

## 5. 數據結構與算法庫

### 5.1 Abseil (Google) ⭐⭐⭐⭐

**優勢:**

- Google 內部使用的 C++ 庫
- 高性能容器 (flat_hash_map, flat_hash_set)
- 實用工具 (字符串、時間等)

**安裝:**

```bash
git clone https://github.com/abseil/abseil-cpp.git
cd abseil-cpp
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
make -j$(nproc)
sudo make install
```

**flat_hash_map 示例:**

```cpp
#include "absl/container/flat_hash_map.h"
#include <iostream>

void abseil_hashmap() {
    // 比 std::unordered_map 更快
    absl::flat_hash_map<int, std::string> map;

    map[1] = "AAPL";
    map[2] = "GOOGL";
    map[3] = "MSFT";

    if (auto it = map.find(1); it != map.end()) {
        std::cout << "Found: " << it->second << "\n";
    }

    // 性能優勢: 更好的緩存局部性
}
```

**字符串工具:**

```cpp
#include "absl/strings/str_split.h"
#include "absl/strings/str_join.h"
#include <vector>

void abseil_strings() {
    // 字符串分割
    std::string data = "AAPL,150.50,100";
    std::vector<std::string> parts = absl::StrSplit(data, ',');

    // 字符串連接
    std::string joined = absl::StrJoin(parts, "|");
    std::cout << joined << "\n";  // AAPL|150.50|100
}
```

---

## 6. 時間與日期

### 6.1 Howard Hinnant's date ⭐⭐⭐⭐⭐

**優勢:**

- C++20 chrono 的基礎
- 時區支持
- 高精度時間處理

**安裝:**

```bash
git clone https://github.com/HowardHinnant/date.git
# Header-only,包含 include/date 即可
```

**使用示例:**

```cpp
#include "date/date.h"
#include <iostream>

void date_example() {
    using namespace date;
    using namespace std::chrono;

    // 獲取當前時間
    auto now = system_clock::now();
    auto today = floor<days>(now);

    std::cout << "Today: " << today << "\n";

    // 格式化輸出
    std::cout << "Formatted: " << format("%Y-%m-%d %H:%M:%S", now) << "\n";

    // 時間計算
    auto tomorrow = today + days{1};
    std::cout << "Tomorrow: " << tomorrow << "\n";
}
```

**HFT 時間戳:**

```cpp
#include <chrono>
#include <x86intrin.h>  // RDTSC

// 高精度時間戳 (納秒)
uint64_t get_timestamp_ns() {
    auto now = std::chrono::high_resolution_clock::now();
    return std::chrono::duration_cast<std::chrono::nanoseconds>(
        now.time_since_epoch()).count();
}

// 極低延遲時間戳 (CPU 週期)
uint64_t rdtsc() {
    return __rdtsc();
}

// 將 CPU 週期轉換為納秒
double cycles_to_ns(uint64_t cycles, double cpu_freq_ghz) {
    return cycles / cpu_freq_ghz;
}
```

---

## 7. 配置與命令行

### 7.1 CLI11 ⭐⭐⭐⭐⭐

**優勢:**

- Header-only
- 現代 C++ API
- 自動生成幫助信息

**安裝:**

```bash
# 單文件
wget https://github.com/CLIUtils/CLI11/releases/download/v2.3.2/CLI11.hpp
```

**使用示例:**

```cpp
#include "CLI11.hpp"
#include <iostream>

int main(int argc, char** argv) {
    CLI::App app{"HFT Trading System"};

    std::string config_file = "config.json";
    int port = 8080;
    bool verbose = false;

    app.add_option("-c,--config", config_file, "Config file path");
    app.add_option("-p,--port", port, "Server port");
    app.add_flag("-v,--verbose", verbose, "Verbose output");

    CLI11_PARSE(app, argc, argv);

    std::cout << "Config: " << config_file << "\n";
    std::cout << "Port: " << port << "\n";
    std::cout << "Verbose: " << (verbose ? "yes" : "no") << "\n";

    return 0;
}
```

---

### 7.2 yaml-cpp ⭐⭐⭐⭐

**配置文件解析:**

```bash
sudo apt-get install libyaml-cpp-dev
```

**使用:**

```cpp
#include <yaml-cpp/yaml.h>
#include <iostream>

void yaml_example() {
    // 讀取 YAML 配置
    YAML::Node config = YAML::LoadFile("config.yaml");

    std::string host = config["server"]["host"].as<std::string>();
    int port = config["server"]["port"].as<int>();

    std::cout << "Host: " << host << "\n";
    std::cout << "Port: " << port << "\n";

    // 遍歷數組
    for (const auto& symbol : config["symbols"]) {
        std::cout << "Symbol: " << symbol.as<std::string>() << "\n";
    }
}
```

**config.yaml 示例:**

```yaml
server:
  host: localhost
  port: 8080

symbols:
  - AAPL
  - GOOGL
  - MSFT

logging:
  level: info
  file: logs/trading.log
```

---

## 8. HFT 專用庫

### 8.1 QuickFIX ⭐⭐⭐⭐

**FIX 協議實現:**

```bash
git clone https://github.com/quickfix/quickfix.git
cd quickfix
./bootstrap
./configure
make -j$(nproc)
sudo make install
```

**基本使用:**

```cpp
#include "quickfix/Application.h"
#include "quickfix/MessageCracker.h"
#include "quickfix/Values.h"
#include "quickfix/Mutex.h"

class TradingApplication : public FIX::Application,
                          public FIX::MessageCracker {
public:
    void onCreate(const FIX::SessionID&) override {}
    void onLogon(const FIX::SessionID&) override {
        std::cout << "Logged on\n";
    }
    void onLogout(const FIX::SessionID&) override {}
    void toAdmin(FIX::Message&, const FIX::SessionID&) override {}
    void toApp(FIX::Message&, const FIX::SessionID&) override {}
    void fromAdmin(const FIX::Message&, const FIX::SessionID&) override {}
    void fromApp(const FIX::Message& message, const FIX::SessionID&) override {
        crack(message, sessionID);
    }

    // 處理執行報告
    void onMessage(const FIX44::ExecutionReport& message,
                   const FIX::SessionID&) {
        FIX::OrderID orderID;
        message.get(orderID);
        std::cout << "Execution Report for order: " << orderID << "\n";
    }
};
```

---

## 總結

**庫選擇建議:**

| 用途   | 推薦庫                   | HFT 推薦度 |
| ------ | ------------------------ | ---------- |
| 序列化 | FlatBuffers              | ⭐⭐⭐⭐⭐ |
| 網路   | ZeroMQ / Boost.Asio      | ⭐⭐⭐⭐⭐ |
| 日誌   | spdlog (異步)            | ⭐⭐⭐⭐⭐ |
| 測試   | Google Test              | ⭐⭐⭐⭐⭐ |
| 基準   | Google Benchmark         | ⭐⭐⭐⭐⭐ |
| 容器   | Abseil flat_hash_map     | ⭐⭐⭐⭐   |
| 配置   | yaml-cpp / nlohmann/json | ⭐⭐⭐⭐   |
| FIX    | QuickFIX                 | ⭐⭐⭐⭐   |

**關鍵要點:**

1. **序列化**: 關鍵路徑用 FlatBuffers,配置用 JSON
2. **網路**: 進程間通信用 ZeroMQ,極致性能用原生 socket + io_uring
3. **日誌**: 必須使用異步日誌 (spdlog),避免阻塞關鍵路徑
4. **測試**: 單元測試 (Google Test) + 性能測試 (Google Benchmark)
5. **容器**: 優先使用 Abseil 的 flat_hash_map/set

**下一步:**

- 實踐各個庫的示例代碼
- 根據項目需求選擇合適的庫
- 進行性能測試和對比
- 整合到實際 HFT 系統中

## 參考資料 (References)

1. [FlatBuffers Documentation](https://google.github.io/flatbuffers/)
2. [Protocol Buffers Guide](https://developers.google.com/protocol-buffers)
3. [Boost.Asio Documentation](https://www.boost.org/doc/libs/release/doc/html/boost_asio.html)
4. [ZeroMQ Guide](https://zguide.zeromq.org/)
5. [spdlog GitHub](https://github.com/gabime/spdlog)
6. [Google Test Primer](https://google.github.io/googletest/primer.html)
7. [Google Benchmark User Guide](https://github.com/google/benchmark/blob/main/docs/user_guide.md)
8. [Abseil C++ Tips](https://abseil.io/tips/)

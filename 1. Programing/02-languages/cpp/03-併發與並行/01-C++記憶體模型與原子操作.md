# C++ 記憶體模型與原子操作 (C++ Memory Model and Atomic Operations)

## 概述

C++11 引入了明確的記憶體模型 (Memory Model),定義了多執行緒環境下記憶體操作的可見性與順序保證。理解記憶體模型是撰寫正確無鎖程式的基礎。

## C++ 記憶體模型基礎

### 記憶體位置 (Memory Location)

```cpp
struct Data {
    int a;           // 記憶體位置 1
    int b;           // 記憶體位置 2
    char c;          // 記憶體位置 3
    char d;          // 記憶體位置 3 (bit-field 除外)
};

// 兩個執行緒可以安全地同時修改不同的記憶體位置
// 但同一記憶體位置的並發寫入需要同步
```

### Happens-Before 關係

Happens-before 定義了操作間的順序保證:

```cpp
// 單執行緒內的順序保證
int x = 0;
x = 1;           // happens-before
int y = x + 1;   // 保證看到 x = 1

// 跨執行緒的 happens-before 需要同步機制
std::atomic<bool> ready{false};
int data = 0;

// Thread 1
data = 42;           // (1)
ready.store(true);   // (2) synchronizes-with (3)

// Thread 2
while (!ready.load());  // (3)
assert(data == 42);     // (4) 保證成立,因為 (1) happens-before (4)
```

## 原子操作 (Atomic Operations)

### std::atomic 基礎

```cpp
#include <atomic>

// 原子型別
std::atomic<int> counter{0};
std::atomic<bool> flag{false};
std::atomic<void*> ptr{nullptr};

// 基本操作
counter.store(10);              // 原子寫入
int value = counter.load();     // 原子讀取
int old = counter.exchange(20); // 原子交換

// Read-Modify-Write 操作
counter.fetch_add(1);   // 原子 ++
counter.fetch_sub(1);   // 原子 --
counter++;              // 等同於 fetch_add(1)

// Compare-And-Swap (CAS)
int expected = 10;
bool success = counter.compare_exchange_strong(expected, 20);
// 如果 counter == 10,則設為 20,返回 true
// 否則將 expected 更新為 counter 的實際值,返回 false
```

### Lock-Free 屬性查詢

```cpp
#include <atomic>
#include <iostream>

template<typename T>
void check_lock_free() {
    std::atomic<T> a;
    std::cout << "std::atomic<" << typeid(T).name() << "> "
              << "is_lock_free: " << a.is_lock_free() << "\n";
}

int main() {
    check_lock_free<bool>();        // 通常 true
    check_lock_free<int>();         // 通常 true
    check_lock_free<double>();      // 通常 true
    check_lock_free<std::string>(); // 通常 false (太大)
    
    // 編譯期檢查
    static_assert(std::atomic<int>::is_always_lock_free);
}
```

## 記憶體順序 (Memory Ordering)

### 六種記憶體順序

C++ 提供六種記憶體順序,權衡效能與順序保證:

```cpp
namespace std {
    enum memory_order {
        memory_order_relaxed,   // 最弱,無順序保證
        memory_order_consume,   // 資料依賴順序 (不推薦使用)
        memory_order_acquire,   // 取得語意
        memory_order_release,   // 釋放語意
        memory_order_acq_rel,   // 取得-釋放語意
        memory_order_seq_cst    // 最強,循序一致 (預設)
    };
}
```

### Relaxed Ordering

```cpp
#include <atomic>
#include <thread>
#include <cassert>

std::atomic<int> x{0}, y{0};
std::atomic<int> r1{0}, r2{0};

void thread1() {
    x.store(1, std::memory_order_relaxed);  // (1)
    r1 = y.load(std::memory_order_relaxed); // (2)
}

void thread2() {
    y.store(1, std::memory_order_relaxed);  // (3)
    r2 = x.load(std::memory_order_relaxed); // (4)
}

// 可能結果: r1 == 0 && r2 == 0
// relaxed 不保證跨執行緒的可見性順序
```

**使用場景**: 計數器、統計資料 (順序無關的場合)

```cpp
// HFT 範例: 訊息計數器
class MessageCounter {
    std::atomic<uint64_t> count_{0};
public:
    void increment() {
        count_.fetch_add(1, std::memory_order_relaxed);
    }
    
    uint64_t get() const {
        return count_.load(std::memory_order_relaxed);
    }
};
```

### Acquire-Release Ordering

```cpp
std::atomic<bool> ready{false};
int data = 0;

// Producer (Thread 1)
void producer() {
    data = 42;                                    // (1)
    ready.store(true, std::memory_order_release); // (2) 釋放操作
    // (1) happens-before (2)
}

// Consumer (Thread 2)
void consumer() {
    while (!ready.load(std::memory_order_acquire)); // (3) 取得操作
    assert(data == 42);                             // (4)
    // (2) synchronizes-with (3),因此 (1) happens-before (4)
}
```

**語意保證**:
- **Release**: 此操作前的所有寫入,對執行 Acquire 的執行緒可見
- **Acquire**: 此操作後的所有讀取,能看到 Release 前的所有寫入

**HFT 應用**: 生產者-消費者佇列

```cpp
// 單生產者單消費者佇列 (SPSC Queue)
template<typename T, size_t Size>
class SPSCQueue {
    std::array<T, Size> buffer_;
    std::atomic<size_t> write_idx_{0};
    std::atomic<size_t> read_idx_{0};
    
public:
    bool try_push(const T& item) {
        size_t current_write = write_idx_.load(std::memory_order_relaxed);
        size_t next_write = (current_write + 1) % Size;
        
        if (next_write == read_idx_.load(std::memory_order_acquire)) {
            return false;  // 佇列滿
        }
        
        buffer_[current_write] = item;
        write_idx_.store(next_write, std::memory_order_release);
        return true;
    }
    
    bool try_pop(T& item) {
        size_t current_read = read_idx_.load(std::memory_order_relaxed);
        
        if (current_read == write_idx_.load(std::memory_order_acquire)) {
            return false;  // 佇列空
        }
        
        item = buffer_[current_read];
        read_idx_.store((current_read + 1) % Size, std::memory_order_release);
        return true;
    }
};
```

### Sequential Consistency (預設)

```cpp
std::atomic<bool> x{false}, y{false};
std::atomic<int> z{0};

void thread1() {
    x.store(true, std::memory_order_seq_cst);  // (1)
}

void thread2() {
    y.store(true, std::memory_order_seq_cst);  // (2)
}

void thread3() {
    while (!x.load(std::memory_order_seq_cst));  // (3)
    if (y.load(std::memory_order_seq_cst)) {     // (4)
        ++z;
    }
}

void thread4() {
    while (!y.load(std::memory_order_seq_cst));  // (5)
    if (x.load(std::memory_order_seq_cst)) {     // (6)
        ++z;
    }
}

// 保證: z >= 1 (至少一個執行緒看到另一個的 store)
```

**代價**: 效能開銷最大,通常包含記憶體柵欄 (Memory Fence)

## Compare-And-Swap (CAS) 詳解

### Strong vs Weak CAS

```cpp
std::atomic<int> value{0};

// Strong CAS: 只在值不匹配時返回 false
int expected = 0;
bool success = value.compare_exchange_strong(expected, 10);

// Weak CAS: 可能 spuriously fail (即使值匹配也可能失敗)
// 用於迴圈中,效能可能更好
expected = 0;
while (!value.compare_exchange_weak(expected, 10,
                                    std::memory_order_release,
                                    std::memory_order_relaxed)) {
    // 重試迴圈
    expected = 0;  // 重置 expected
}
```

### CAS 應用: Lock-Free Stack

```cpp
template<typename T>
class LockFreeStack {
    struct Node {
        T data;
        Node* next;
        Node(const T& d) : data(d), next(nullptr) {}
    };
    
    std::atomic<Node*> head_{nullptr};
    
public:
    void push(const T& data) {
        Node* new_node = new Node(data);
        new_node->next = head_.load(std::memory_order_relaxed);
        
        // CAS 迴圈直到成功
        while (!head_.compare_exchange_weak(new_node->next, new_node,
                                           std::memory_order_release,
                                           std::memory_order_relaxed));
    }
    
    bool pop(T& result) {
        Node* old_head = head_.load(std::memory_order_acquire);
        
        while (old_head && !head_.compare_exchange_weak(old_head, old_head->next,
                                                        std::memory_order_release,
                                                        std::memory_order_acquire));
        
        if (!old_head) return false;
        
        result = old_head->data;
        delete old_head;  // 注意: 簡化版,實際需處理 ABA 問題
        return true;
    }
};
```

## Memory Fence (記憶體柵欄)

```cpp
#include <atomic>

std::atomic<bool> ready{false};
int data = 0;

// Producer
void producer() {
    data = 42;
    std::atomic_thread_fence(std::memory_order_release);  // 釋放柵欄
    ready.store(true, std::memory_order_relaxed);
}

// Consumer
void consumer() {
    while (!ready.load(std::memory_order_relaxed));
    std::atomic_thread_fence(std::memory_order_acquire);  // 取得柵欄
    assert(data == 42);
}
```

**使用時機**: 與非原子操作建立同步關係

## HFT 實戰範例

### 低延遲訂單狀態追蹤

```cpp
#include <atomic>
#include <cstdint>

enum class OrderState : uint8_t {
    Created, Submitted, Acked, Filled, Rejected
};

class OrderStatus {
    std::atomic<uint64_t> version_{0};
    std::atomic<OrderState> state_{OrderState::Created};
    
    // 非原子資料 (由 version 保護)
    uint64_t order_id_;
    double price_;
    int quantity_;
    
public:
    // 生產者: 更新訂單狀態
    void update(OrderState new_state, double price, int qty) {
        // 準備新資料
        order_id_ = generate_order_id();
        price_ = price;
        quantity_ = qty;
        
        // Release: 確保上述寫入在狀態更新前完成
        state_.store(new_state, std::memory_order_release);
        version_.fetch_add(1, std::memory_order_release);
    }
    
    // 消費者: 讀取訂單狀態
    OrderState get_state_with_data(double& price, int& qty) {
        uint64_t v1 = version_.load(std::memory_order_acquire);
        OrderState s = state_.load(std::memory_order_acquire);
        
        price = price_;
        qty = quantity_;
        
        uint64_t v2 = version_.load(std::memory_order_acquire);
        
        // 檢查是否在讀取過程中被更新
        if (v1 != v2) {
            return OrderState::Created;  // 指示需重試
        }
        
        return s;
    }
};
```

### 高效能計數器 (多生產者)

```cpp
// Cache-line 對齊,避免 false sharing
struct alignas(64) Counter {
    std::atomic<uint64_t> value{0};
    
    void increment() {
        value.fetch_add(1, std::memory_order_relaxed);
    }
    
    uint64_t get() const {
        return value.load(std::memory_order_relaxed);
    }
};

// 分片計數器 (減少競爭)
template<size_t NumShards = 8>
class ShardedCounter {
    std::array<Counter, NumShards> shards_;
    
public:
    void increment() {
        // 使用執行緒 ID 選擇分片
        size_t idx = std::hash<std::thread::id>{}(std::this_thread::get_id()) % NumShards;
        shards_[idx].increment();
    }
    
    uint64_t get() const {
        uint64_t total = 0;
        for (const auto& shard : shards_) {
            total += shard.get();
        }
        return total;
    }
};
```

## 常見陷阱

### 1. ABA 問題

```cpp
// 問題: CAS 無法區分 A -> B -> A 的變化
std::atomic<Node*> head;

// Thread 1: pop
Node* old_head = head.load();
// ... 中斷 ...

// Thread 2: pop A, push B, pop B, push A (指標相同!)

// Thread 1: 繼續
head.compare_exchange_strong(old_head, old_head->next);  // 成功,但 A 已變化!
```

**解決方案**: 使用版本計數 (Tagged Pointer)

```cpp
struct TaggedPointer {
    Node* ptr;
    uint64_t tag;
};

std::atomic<TaggedPointer> head;

void push(Node* node) {
    TaggedPointer old_head = head.load();
    TaggedPointer new_head;
    
    do {
        node->next = old_head.ptr;
        new_head.ptr = node;
        new_head.tag = old_head.tag + 1;  // 遞增版本
    } while (!head.compare_exchange_weak(old_head, new_head));
}
```

### 2. Data Race

```cpp
// 錯誤: data 不是原子的
std::atomic<bool> ready{false};
int data = 0;  // 普通變數

// Thread 1
data = 42;                                     // (1)
ready.store(true, std::memory_order_relaxed); // (2)

// Thread 2
if (ready.load(std::memory_order_relaxed)) {  // (3)
    int x = data;                              // (4) Data Race!
}

// 修正: 使用 acquire-release
ready.store(true, std::memory_order_release);
ready.load(std::memory_order_acquire);
```

## 效能檢查清單

- [ ] 使用 `is_lock_free()` 確認原子操作真正 lock-free
- [ ] 計數器等簡單操作使用 `memory_order_relaxed`
- [ ] 生產者-消費者使用 `acquire-release`
- [ ] 避免不必要的 `seq_cst` (預設值)
- [ ] 注意 cache-line 對齊,避免 false sharing
- [ ] CAS 迴圈使用 `compare_exchange_weak`
- [ ] 考慮 ABA 問題的解決方案
- [ ] 使用分片技術減少原子變數競爭

## 除錯工具

```bash
# ThreadSanitizer 檢測 data race
g++ -fsanitize=thread -g program.cpp -o program
./program

# Valgrind Helgrind
valgrind --tool=helgrind ./program

# C++20 jthread + stop_token 可簡化執行緒管理
```

---

## 參考資料 (References)

1. [C++ Reference - Memory Order](https://en.cppreference.com/w/cpp/atomic/memory_order)
2. [C++ Reference - std::atomic](https://en.cppreference.com/w/cpp/atomic/atomic)
3. Herlihy, Maurice & Shavit, Nir. *The Art of Multiprocessor Programming* (2012)
4. Williams, Anthony. *C++ Concurrency in Action*, 2nd Edition (2019)
5. [Preshing on Programming - Memory Ordering](https://preshing.com/20120913/acquire-and-release-semantics/)
6. [Linux Kernel Memory Barriers](https://www.kernel.org/doc/Documentation/memory-barriers.txt)

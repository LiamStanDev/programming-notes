# 執行緒同步機制 (Thread Synchronization Mechanisms)

## 概述

執行緒同步 (Thread Synchronization) 確保多執行緒環境下的資料一致性與正確性。C++ 提供多種同步原語 (Synchronization Primitives),從傳統的 Mutex 到現代的 Semaphore 與 Latch/Barrier。

## Mutex (互斥鎖)

### std::mutex 基礎

```cpp
#include <mutex>
#include <vector>

class ThreadSafeCounter {
    mutable std::mutex mtx_;
    int value_ = 0;
    
public:
    void increment() {
        std::lock_guard<std::mutex> lock(mtx_);  // RAII 自動解鎖
        ++value_;
    }
    
    int get() const {
        std::lock_guard<std::mutex> lock(mtx_);
        return value_;
    }
};
```

### RAII 鎖管理

```cpp
// 1. std::lock_guard - 最簡單,不可手動解鎖
{
    std::lock_guard<std::mutex> lock(mtx);
    // 臨界區
}  // 自動解鎖

// 2. std::unique_lock - 靈活,可手動解鎖/重新上鎖
{
    std::unique_lock<std::mutex> lock(mtx);
    // 臨界區
    lock.unlock();  // 手動解鎖
    // 非臨界區
    lock.lock();    // 重新上鎖
}

// 3. std::scoped_lock (C++17) - 多鎖同時上鎖,避免死鎖
std::mutex mtx1, mtx2;
{
    std::scoped_lock lock(mtx1, mtx2);  // 同時上鎖,避免死鎖
    // 臨界區
}
```

### Mutex 類型

```cpp
#include <mutex>

// 1. std::mutex - 基本互斥鎖
std::mutex mtx;

// 2. std::recursive_mutex - 可遞迴上鎖 (同一執行緒)
std::recursive_mutex rmtx;
void recursive_function() {
    std::lock_guard<std::recursive_mutex> lock(rmtx);
    // 可再次呼叫 recursive_function() 而不會死鎖
}

// 3. std::timed_mutex - 支援超時
std::timed_mutex tmtx;
if (tmtx.try_lock_for(std::chrono::milliseconds(100))) {
    // 成功取得鎖
    tmtx.unlock();
} else {
    // 超時
}

// 4. std::shared_mutex (C++17) - 讀寫鎖
std::shared_mutex smtx;

// 讀者 (共享鎖)
void reader() {
    std::shared_lock<std::shared_mutex> lock(smtx);
    // 多個讀者可同時進入
}

// 寫者 (獨佔鎖)
void writer() {
    std::unique_lock<std::shared_mutex> lock(smtx);
    // 獨佔存取
}
```

### 避免死鎖 (Deadlock)

```cpp
// 死鎖範例
std::mutex mtx1, mtx2;

// Thread 1
void thread1() {
    std::lock_guard<std::mutex> lock1(mtx1);
    // 等待 mtx2
    std::lock_guard<std::mutex> lock2(mtx2);  // 死鎖!
}

// Thread 2
void thread2() {
    std::lock_guard<std::mutex> lock2(mtx2);
    // 等待 mtx1
    std::lock_guard<std::mutex> lock1(mtx1);  // 死鎖!
}

// 解決方案 1: 統一上鎖順序
void safe_thread() {
    std::lock_guard<std::mutex> lock1(mtx1);  // 總是先鎖 mtx1
    std::lock_guard<std::mutex> lock2(mtx2);  // 再鎖 mtx2
}

// 解決方案 2: std::scoped_lock (C++17)
void safe_thread_cpp17() {
    std::scoped_lock lock(mtx1, mtx2);  // 同時上鎖,內部使用死鎖避免演算法
}

// 解決方案 3: std::lock + std::adopt_lock
void safe_thread_manual() {
    std::lock(mtx1, mtx2);  // 同時上鎖
    std::lock_guard<std::mutex> lock1(mtx1, std::adopt_lock);
    std::lock_guard<std::mutex> lock2(mtx2, std::adopt_lock);
}
```

## Condition Variable (條件變數)

### 生產者-消費者模式

```cpp
#include <condition_variable>
#include <queue>

template<typename T>
class ThreadSafeQueue {
    mutable std::mutex mtx_;
    std::condition_variable cv_;
    std::queue<T> queue_;
    
public:
    void push(T value) {
        {
            std::lock_guard<std::mutex> lock(mtx_);
            queue_.push(std::move(value));
        }
        cv_.notify_one();  // 喚醒一個等待的消費者
    }
    
    T pop() {
        std::unique_lock<std::mutex> lock(mtx_);
        
        // 等待直到佇列非空
        cv_.wait(lock, [this] { return !queue_.empty(); });
        
        T value = std::move(queue_.front());
        queue_.pop();
        return value;
    }
    
    bool try_pop(T& value, std::chrono::milliseconds timeout) {
        std::unique_lock<std::mutex> lock(mtx_);
        
        // 等待指定時間
        if (!cv_.wait_for(lock, timeout, [this] { return !queue_.empty(); })) {
            return false;  // 超時
        }
        
        value = std::move(queue_.front());
        queue_.pop();
        return true;
    }
};
```

### Spurious Wakeup 問題

```cpp
// 錯誤: 未檢查條件
void wrong_wait() {
    std::unique_lock<std::mutex> lock(mtx_);
    cv_.wait(lock);  // 可能虛假喚醒 (spurious wakeup)
    // 假設佇列非空 - 錯誤!
}

// 正確: 使用 predicate
void correct_wait() {
    std::unique_lock<std::mutex> lock(mtx_);
    cv_.wait(lock, [this] { return !queue_.empty(); });  // 迴圈檢查條件
    // 保證佇列非空
}

// wait() 等價於
while (!predicate()) {
    cv_.wait(lock);
}
```

### notify_one vs notify_all

```cpp
// notify_one: 喚醒一個等待的執行緒
cv_.notify_one();

// notify_all: 喚醒所有等待的執行緒
cv_.notify_all();

// 使用情境
class Barrier {
    std::mutex mtx_;
    std::condition_variable cv_;
    size_t count_;
    size_t waiting_ = 0;
    
public:
    explicit Barrier(size_t count) : count_(count) {}
    
    void wait() {
        std::unique_lock<std::mutex> lock(mtx_);
        
        if (++waiting_ == count_) {
            waiting_ = 0;
            cv_.notify_all();  // 喚醒所有執行緒
        } else {
            cv_.wait(lock, [this] { return waiting_ == 0; });
        }
    }
};
```

## Semaphore (信號量, C++20)

### Counting Semaphore

```cpp
#include <semaphore>

// 限制並發執行緒數量
std::counting_semaphore<10> pool_semaphore{10};  // 最多 10 個執行緒

void worker() {
    pool_semaphore.acquire();  // P 操作,可能阻塞
    
    try {
        // 臨界區 (最多 10 個執行緒同時執行)
        do_work();
    } catch (...) {
        pool_semaphore.release();  // V 操作
        throw;
    }
    
    pool_semaphore.release();
}

// 或使用 RAII
void worker_raii() {
    // 自動 acquire/release
    auto guard = [&]() {
        pool_semaphore.acquire();
        return std::unique_ptr<void, decltype(&release)>(
            nullptr, [](void*) { pool_semaphore.release(); });
    };
    
    auto _ = guard();
    do_work();
}
```

### Binary Semaphore

```cpp
#include <semaphore>

// 二元信號量 (類似 mutex,但可跨執行緒 release)
std::binary_semaphore signal{0};  // 初始計數 0

// Thread 1: 等待信號
void waiter() {
    signal.acquire();  // 阻塞直到 Thread 2 發送信號
    process_data();
}

// Thread 2: 發送信號
void signaler() {
    prepare_data();
    signal.release();  // 喚醒 Thread 1
}
```

### HFT 應用: 連線池

```cpp
#include <semaphore>
#include <vector>
#include <memory>

class Connection {
public:
    void execute_query(const std::string& sql) { /* ... */ }
};

class ConnectionPool {
    std::vector<std::unique_ptr<Connection>> connections_;
    std::counting_semaphore<100> available_;
    std::mutex mtx_;
    
public:
    ConnectionPool(size_t pool_size) : available_(pool_size) {
        for (size_t i = 0; i < pool_size; ++i) {
            connections_.push_back(std::make_unique<Connection>());
        }
    }
    
    std::unique_ptr<Connection> acquire() {
        available_.acquire();  // 等待可用連線
        
        std::lock_guard<std::mutex> lock(mtx_);
        auto conn = std::move(connections_.back());
        connections_.pop_back();
        return conn;
    }
    
    void release(std::unique_ptr<Connection> conn) {
        std::lock_guard<std::mutex> lock(mtx_);
        connections_.push_back(std::move(conn));
        available_.release();
    }
};

// RAII 包裝
class PooledConnection {
    ConnectionPool& pool_;
    std::unique_ptr<Connection> conn_;
    
public:
    PooledConnection(ConnectionPool& pool) 
        : pool_(pool), conn_(pool.acquire()) {}
    
    ~PooledConnection() {
        if (conn_) pool_.release(std::move(conn_));
    }
    
    Connection* operator->() { return conn_.get(); }
};

// 使用
void execute_trade(ConnectionPool& pool) {
    PooledConnection conn(pool);
    conn->execute_query("INSERT INTO trades ...");
}  // 自動歸還連線
```

## Latch 與 Barrier (C++20)

### std::latch - 一次性同步點

```cpp
#include <latch>
#include <thread>
#include <vector>

// Latch: 計數到 0 時釋放,不可重用
std::latch workers_done{3};  // 等待 3 個執行緒

void worker(int id) {
    do_work(id);
    workers_done.count_down();  // 遞減計數
}

void coordinator() {
    std::vector<std::thread> threads;
    for (int i = 0; i < 3; ++i) {
        threads.emplace_back(worker, i);
    }
    
    workers_done.wait();  // 阻塞直到計數為 0
    std::cout << "All workers done\n";
    
    for (auto& t : threads) t.join();
}

// 組合操作
void worker_v2(int id) {
    do_work(id);
    workers_done.arrive_and_wait();  // count_down() + wait()
}
```

### std::barrier - 可重用同步點

```cpp
#include <barrier>

// Barrier: 可重用,支援完成回呼
void process_data_in_phases() {
    constexpr int NUM_THREADS = 4;
    
    // 完成回呼 (可選)
    auto on_completion = []() noexcept {
        std::cout << "Phase completed\n";
    };
    
    std::barrier sync_point(NUM_THREADS, on_completion);
    
    auto worker = [&](int id) {
        for (int phase = 0; phase < 10; ++phase) {
            // Phase 1: 載入資料
            load_data(id, phase);
            sync_point.arrive_and_wait();  // 等待所有執行緒完成
            
            // Phase 2: 處理資料
            process_data(id, phase);
            sync_point.arrive_and_wait();
            
            // Phase 3: 輸出結果
            output_results(id, phase);
            sync_point.arrive_and_wait();
        }
    };
    
    std::vector<std::thread> threads;
    for (int i = 0; i < NUM_THREADS; ++i) {
        threads.emplace_back(worker, i);
    }
    
    for (auto& t : threads) t.join();
}
```

### HFT 應用: 多階段市場資料處理

```cpp
#include <barrier>

struct MarketDataBatch {
    std::vector<double> prices;
    std::vector<int64_t> volumes;
};

class ParallelMarketDataProcessor {
    static constexpr int NUM_WORKERS = 4;
    std::barrier<> phase_sync_{NUM_WORKERS};
    
    std::array<MarketDataBatch, NUM_WORKERS> batches_;
    std::array<double, NUM_WORKERS> vwap_results_;
    
public:
    void process_parallel() {
        std::vector<std::thread> workers;
        
        for (int i = 0; i < NUM_WORKERS; ++i) {
            workers.emplace_back([this, i]() {
                // Phase 1: 載入資料
                batches_[i] = load_batch(i);
                phase_sync_.arrive_and_wait();
                
                // Phase 2: 計算 VWAP (成交量加權平均價)
                vwap_results_[i] = calculate_vwap(batches_[i]);
                phase_sync_.arrive_and_wait();
                
                // Phase 3: 聚合結果 (僅 worker 0)
                if (i == 0) {
                    double total_vwap = aggregate_vwap(vwap_results_);
                    publish_result(total_vwap);
                }
                phase_sync_.arrive_and_wait();
            });
        }
        
        for (auto& t : workers) t.join();
    }
    
private:
    MarketDataBatch load_batch(int worker_id) { /* ... */ }
    double calculate_vwap(const MarketDataBatch& batch) { /* ... */ }
    double aggregate_vwap(const std::array<double, NUM_WORKERS>& results) { /* ... */ }
    void publish_result(double vwap) { /* ... */ }
};
```

## Atomic Flag - 最輕量的同步原語

### Spinlock 實作

```cpp
#include <atomic>

class Spinlock {
    std::atomic_flag flag_ = ATOMIC_FLAG_INIT;
    
public:
    void lock() {
        while (flag_.test_and_set(std::memory_order_acquire)) {
            // 自旋等待
            // 可加入 backoff 策略
            #if defined(__x86_64__) || defined(_M_X64)
            __builtin_ia32_pause();  // x86 PAUSE 指令
            #endif
        }
    }
    
    void unlock() {
        flag_.clear(std::memory_order_release);
    }
};

// C++20: test() 方法
class AdaptiveSpinlock {
    std::atomic_flag flag_ = ATOMIC_FLAG_INIT;
    
public:
    void lock() {
        // 先嘗試 test() 避免 cache invalidation
        while (flag_.test(std::memory_order_relaxed) || 
               flag_.test_and_set(std::memory_order_acquire)) {
            __builtin_ia32_pause();
        }
    }
    
    void unlock() {
        flag_.clear(std::memory_order_release);
    }
};
```

### 何時使用 Spinlock

```cpp
// 適用場景:
// 1. 臨界區極短 (< 100 ns)
// 2. 競爭低
// 3. 即時系統 (避免 context switch)

// HFT 範例: 保護熱路徑上的計數器
class LatencyTracker {
    alignas(64) Spinlock lock_;
    uint64_t count_ = 0;
    uint64_t sum_ = 0;
    
public:
    void record(uint64_t latency_ns) {
        lock_.lock();
        ++count_;
        sum_ += latency_ns;
        lock_.unlock();
    }
    
    double average() {
        lock_.lock();
        double avg = count_ > 0 ? static_cast<double>(sum_) / count_ : 0.0;
        lock_.unlock();
        return avg;
    }
};
```

## 讀寫鎖 (Reader-Writer Lock)

### std::shared_mutex 應用

```cpp
#include <shared_mutex>
#include <map>

template<typename Key, typename Value>
class ThreadSafeMap {
    mutable std::shared_mutex mtx_;
    std::map<Key, Value> map_;
    
public:
    // 讀操作 (共享鎖)
    std::optional<Value> find(const Key& key) const {
        std::shared_lock<std::shared_mutex> lock(mtx_);
        
        auto it = map_.find(key);
        return it != map_.end() ? std::optional{it->second} : std::nullopt;
    }
    
    // 寫操作 (獨佔鎖)
    void insert(const Key& key, const Value& value) {
        std::unique_lock<std::shared_mutex> lock(mtx_);
        map_[key] = value;
    }
    
    void erase(const Key& key) {
        std::unique_lock<std::shared_mutex> lock(mtx_);
        map_.erase(key);
    }
    
    size_t size() const {
        std::shared_lock<std::shared_mutex> lock(mtx_);
        return map_.size();
    }
};
```

### HFT 應用: 交易品資訊快取

```cpp
struct InstrumentInfo {
    std::string symbol;
    double tick_size;
    int64_t lot_size;
    double price_limit_up;
    double price_limit_down;
};

class InstrumentCache {
    mutable std::shared_mutex mtx_;
    std::unordered_map<uint32_t, InstrumentInfo> cache_;
    
public:
    // 高頻讀取 (多執行緒並發讀)
    std::optional<InstrumentInfo> get(uint32_t symbol_id) const {
        std::shared_lock lock(mtx_);  // C++17: CTAD
        
        auto it = cache_.find(symbol_id);
        return it != cache_.end() ? std::optional{it->second} : std::nullopt;
    }
    
    // 低頻更新 (獨佔寫)
    void update(uint32_t symbol_id, const InstrumentInfo& info) {
        std::unique_lock lock(mtx_);
        cache_[symbol_id] = info;
    }
    
    // 批次載入 (啟動時)
    void load_all(const std::vector<InstrumentInfo>& instruments) {
        std::unique_lock lock(mtx_);
        
        cache_.clear();
        for (const auto& info : instruments) {
            uint32_t id = hash_symbol(info.symbol);
            cache_[id] = info;
        }
    }
};
```

## 同步機制效能比較

```cpp
#include <chrono>
#include <iostream>

// Benchmark 框架
template<typename Func>
auto benchmark(Func&& f, int iterations) {
    auto start = std::chrono::high_resolution_clock::now();
    
    for (int i = 0; i < iterations; ++i) {
        f();
    }
    
    auto end = std::chrono::high_resolution_clock::now();
    return std::chrono::duration_cast<std::chrono::nanoseconds>(end - start).count() / iterations;
}

void compare_synchronization() {
    constexpr int ITERATIONS = 1000000;
    
    // 1. Atomic (無競爭)
    std::atomic<int> atomic_counter{0};
    auto atomic_ns = benchmark([&] {
        atomic_counter.fetch_add(1, std::memory_order_relaxed);
    }, ITERATIONS);
    
    // 2. Spinlock
    Spinlock spinlock;
    int spin_counter = 0;
    auto spin_ns = benchmark([&] {
        spinlock.lock();
        ++spin_counter;
        spinlock.unlock();
    }, ITERATIONS);
    
    // 3. Mutex
    std::mutex mtx;
    int mutex_counter = 0;
    auto mutex_ns = benchmark([&] {
        std::lock_guard<std::mutex> lock(mtx);
        ++mutex_counter;
    }, ITERATIONS);
    
    std::cout << "Atomic:   " << atomic_ns << " ns\n";
    std::cout << "Spinlock: " << spin_ns << " ns\n";
    std::cout << "Mutex:    " << mutex_ns << " ns\n";
}

// 典型結果 (無競爭):
// Atomic:   ~5 ns
// Spinlock: ~20 ns
// Mutex:    ~50 ns
```

## 檢查清單

- [ ] 優先考慮無鎖設計 (Atomic)
- [ ] 臨界區越短越好 (減少鎖持有時間)
- [ ] 使用 RAII 管理鎖 (避免忘記解鎖)
- [ ] 統一鎖順序避免死鎖
- [ ] Condition Variable 使用 predicate 避免 spurious wakeup
- [ ] 讀多寫少場景使用 `shared_mutex`
- [ ] 極短臨界區考慮 Spinlock (HFT)
- [ ] C++20 優先使用 Latch/Barrier 替代手動同步
- [ ] 使用 ThreadSanitizer 檢測 data race

---

## 參考資料 (References)

1. [C++ Reference - Thread Support Library](https://en.cppreference.com/w/cpp/thread)
2. Williams, Anthony. *C++ Concurrency in Action*, 2nd Edition (2019)
3. [C++20 Synchronization Library](https://en.cppreference.com/w/cpp/thread#Synchronization)
4. Butenhof, David R. *Programming with POSIX Threads* (1997)
5. [GCC Thread Sanitizer](https://github.com/google/sanitizers/wiki/ThreadSanitizerCppManual)

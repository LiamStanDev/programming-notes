# 編譯器優化原理 (Compiler Optimization Principles)

## 概述

編譯器優化是高性能 C++ 程序的基礎。理解編譯器如何優化代碼,能幫助我們:
- **編寫可優化代碼**: 避免阻礙編譯器優化的模式
- **驗證優化效果**: 檢查生成的匯編代碼
- **調試性能問題**: 理解為何某些代碼未被優化

在高頻交易中,微秒級別的優化都至關重要。

---

## 優化等級 (Optimization Levels)

### GCC/Clang 優化選項

```bash
# -O0: 無優化 (默認)
# - 保留所有變量
# - 保留所有函數調用
# - 生成可調試代碼
g++ -O0 program.cpp -o program

# -O1: 基本優化
# - 減少代碼大小
# - 常量折疊
# - 死代碼消除
g++ -O1 program.cpp -o program

# -O2: 標準優化 (推薦用於生產)
# - 函數內聯
# - 循環優化
# - 指令調度
# - 不會顯著增加編譯時間
g++ -O2 program.cpp -o program

# -O3: 激進優化
# - 更激進的內聯
# - 向量化
# - 可能增加代碼大小
g++ -O3 program.cpp -o program

# -Os: 優化大小
# - 類似 -O2 但優先減小體積
g++ -Os program.cpp -o program

# -Ofast: 最快速度 (可能破壞標準合規性)
# - -O3 + 快速數學 (-ffast-math)
# - 打破 IEEE 754 浮點標準
g++ -Ofast program.cpp -o program
```

### 優化等級效果對比

```cpp
// test.cpp
int sum(int n) {
    int result = 0;
    for (int i = 0; i <= n; ++i) {
        result += i;
    }
    return result;
}

int main() {
    return sum(100);
}
```

```bash
# 生成匯編代碼
g++ -O0 -S test.cpp -o test_O0.s
g++ -O2 -S test.cpp -o test_O2.s
g++ -O3 -S test.cpp -o test_O3.s

# -O0: 完整循環 (~10 條指令)
# -O2: 可能優化為公式 n*(n+1)/2 (~3 條指令)
# -O3: 直接計算結果 5050 (~1 條指令)
```

---

## 關鍵優化技術

### 1. 內聯 (Inlining)

```cpp
// 未內聯: 函數調用開銷
int add(int a, int b) {
    return a + b;
}

int main() {
    int result = add(10, 20);  // call add
    return result;
}

// -O2 後內聯
int main() {
    int result = 10 + 20;  // 直接計算
    return result;
}
```

**內聯決策因素**:
- 函數大小 (小函數優先)
- 調用頻率 (熱路徑優先)
- 編譯選項 (`-finline-limit`, `-finline-functions`)

**強制內聯**:
```cpp
// GCC/Clang
__attribute__((always_inline)) inline int add(int a, int b) {
    return a + b;
}

// MSVC
__forceinline int add(int a, int b) {
    return a + b;
}
```

**禁止內聯**:
```cpp
__attribute__((noinline)) int compute(int x) {
    return x * x;
}
```

### 2. 常量折疊 (Constant Folding)

```cpp
// 源代碼
int x = 10 * 20 + 5;

// 優化後
int x = 205;  // 編譯期計算

// constexpr 保證編譯期計算
constexpr int compute(int a, int b) {
    return a * b + 5;
}

constexpr int x = compute(10, 20);  // 編譯期求值
```

### 3. 常量傳播 (Constant Propagation)

```cpp
// 源代碼
int a = 10;
int b = a + 5;
int c = b * 2;

// 優化後
int a = 10;
int b = 15;
int c = 30;
```

### 4. 死代碼消除 (Dead Code Elimination)

```cpp
// 源代碼
int compute(int x) {
    int unused = x * 2;  // 未使用
    return x + 1;
}

// 優化後
int compute(int x) {
    return x + 1;
}

// if constexpr 的死代碼消除
template<typename T>
int process(T value) {
    if constexpr (std::is_integral_v<T>) {
        return value * 2;
    } else {
        return static_cast<int>(value);  // T=int 時此分支不存在
    }
}
```

### 5. 公共子表達式消除 (CSE)

```cpp
// 源代碼
int a = x * y + 1;
int b = x * y + 2;

// 優化後
int temp = x * y;
int a = temp + 1;
int b = temp + 2;
```

### 6. 循環優化

#### 循環展開 (Loop Unrolling)

```cpp
// 源代碼
for (int i = 0; i < 4; ++i) {
    array[i] = i;
}

// 優化後 (完全展開)
array[0] = 0;
array[1] = 1;
array[2] = 2;
array[3] = 3;

// 部分展開
for (int i = 0; i < 100; i += 4) {
    array[i] = i;
    array[i+1] = i+1;
    array[i+2] = i+2;
    array[i+3] = i+3;
}
```

**手動展開**:
```cpp
// 高頻交易: 處理固定大小數據
void process_quotes(const Quote quotes[8]) {
    // 完全展開避免循環開銷
    process_quote(quotes[0]);
    process_quote(quotes[1]);
    process_quote(quotes[2]);
    process_quote(quotes[3]);
    process_quote(quotes[4]);
    process_quote(quotes[5]);
    process_quote(quotes[6]);
    process_quote(quotes[7]);
}
```

#### 循環不變量外提 (Loop-Invariant Code Motion)

```cpp
// 源代碼
for (int i = 0; i < n; ++i) {
    int limit = get_limit();  // 循環不變
    if (i < limit) {
        process(i);
    }
}

// 優化後
int limit = get_limit();
for (int i = 0; i < n; ++i) {
    if (i < limit) {
        process(i);
    }
}
```

#### 循環融合 (Loop Fusion)

```cpp
// 源代碼
for (int i = 0; i < n; ++i) {
    a[i] = b[i] + 1;
}
for (int i = 0; i < n; ++i) {
    c[i] = a[i] * 2;
}

// 優化後 (改善 cache 局部性)
for (int i = 0; i < n; ++i) {
    a[i] = b[i] + 1;
    c[i] = a[i] * 2;
}
```

---

## 鏈接時優化 (LTO)

### 跨翻譯單元優化

```bash
# 啟用 LTO
g++ -flto -O2 file1.cpp file2.cpp -o program

# LTO 能做什麼:
# 1. 跨文件內聯
# 2. 全局死代碼消除
# 3. 跨模塊常量傳播
```

```cpp
// file1.cpp
int helper(int x) {
    return x * 2;
}

// file2.cpp
extern int helper(int x);

int main() {
    return helper(10);  // 無 LTO: 函數調用
                        // 有 LTO: 內聯為 return 20;
}
```

### Profile-Guided Optimization (PGO)

```bash
# 步驟 1: 編譯插樁版本
g++ -fprofile-generate -O2 program.cpp -o program

# 步驟 2: 運行程序收集數據
./program < typical_input.txt

# 步驟 3: 使用 profile 重新編譯
g++ -fprofile-use -O2 program.cpp -o program_optimized

# PGO 能做什麼:
# 1. 優化分支預測
# 2. 優化函數內聯決策
# 3. 優化代碼佈局 (熱代碼聚集)
```

---

## 阻礙優化的模式

### 1. 別名 (Aliasing)

```cpp
// 編譯器無法確定 p1 和 p2 是否指向同一記憶體
void update(int* p1, int* p2, int value) {
    *p1 = value;
    *p2 = value + 1;  // 可能改變 *p1
    int x = *p1;      // 必須重新讀取
}

// 使用 restrict (C99, 非標準 C++)
void update(int* __restrict p1, int* __restrict p2, int value) {
    *p1 = value;
    *p2 = value + 1;
    int x = *p1;  // 可優化為 x = value
}

// C++ 方式: 使用引用
void update(int& r1, int& r2, int value) {
    r1 = value;
    r2 = value + 1;
    int x = r1;  // 仍需重新讀取 (可能 &r1 == &r2)
}
```

### 2. 虛函數調用

```cpp
// 無法內聯: 運行時多態
struct Base {
    virtual int compute(int x) const = 0;
};

void process(const Base& obj, int value) {
    int result = obj.compute(value);  // 虛函數調用,無法內聯
}

// 可優化: 編譯期多態
template<typename T>
void process(const T& obj, int value) {
    int result = obj.compute(value);  // 可內聯
}
```

### 3. 間接調用

```cpp
// 函數指針: 無法內聯
int (*operation)(int, int);

int result = operation(a, b);  // 間接調用

// 優化方式 1: 直接調用
int result = add(a, b);

// 優化方式 2: 使用 lambda (可內聯)
auto operation = [](int a, int b) { return a + b; };
int result = operation(a, b);
```

### 4. 異常

```cpp
// 異常處理代碼阻礙優化
int compute(int x) {
    if (x < 0) throw std::invalid_argument("negative");
    return x * x;
}

// noexcept 允許更多優化
int compute(int x) noexcept {
    return x * x;  // 編譯器知道不會拋異常
}
```

### 5. volatile

```cpp
// volatile 禁止優化
volatile int counter = 0;

for (int i = 0; i < 1000; ++i) {
    counter++;  // 每次都必須讀寫記憶體
}

// 去除 volatile 允許優化為
int temp = 0;
for (int i = 0; i < 1000; ++i) {
    temp++;
}
counter = temp;
```

---

## 查看優化效果

### 使用 Compiler Explorer (godbolt.org)

```cpp
// 在線查看不同優化等級的匯編輸出
// https://godbolt.org/

int sum(int n) {
    int result = 0;
    for (int i = 0; i <= n; ++i) {
        result += i;
    }
    return result;
}

// -O0: 完整循環
// -O2: 可能優化為公式
// -O3: 常量 n 時直接計算結果
```

### 生成匯編代碼

```bash
# 生成 AT&T 語法匯編
g++ -S -O2 program.cpp -o program.s

# 生成 Intel 語法匯編 (更易讀)
g++ -S -masm=intel -O2 program.cpp -o program.s

# 反匯編二進制文件
objdump -d -M intel program > program.asm
```

### 查看優化報告

```bash
# GCC: 查看優化報告
g++ -O3 -fopt-info-vec -fopt-info-inline program.cpp

# Clang: 查看優化報告
clang++ -O3 -Rpass=inline -Rpass=loop-vectorize program.cpp

# 輸出示例:
# program.cpp:10:5: remark: loop vectorized
# program.cpp:20:10: remark: inlined function 'helper'
```

---

## 高頻交易優化實例

### 案例 1: 訂單簿更新

```cpp
// ❌ 未優化版本
class OrderBook {
    std::map<double, uint64_t> bids_;  // 紅黑樹
    
public:
    void add_bid(double price, uint64_t quantity) {
        bids_[price] += quantity;  // 查找 + 插入
    }
};

// ✅ 優化版本
class OrderBook {
    // 預分配固定大小數組 (價格精度已知)
    static constexpr int PRICE_LEVELS = 1000;
    static constexpr double MIN_PRICE = 100.0;
    static constexpr double TICK_SIZE = 0.01;
    
    std::array<uint64_t, PRICE_LEVELS> bids_{};
    
    // 內聯價格轉索引
    inline int price_to_index(double price) const {
        return static_cast<int>((price - MIN_PRICE) / TICK_SIZE);
    }
    
public:
    void add_bid(double price, uint64_t quantity) {
        int idx = price_to_index(price);
        bids_[idx] += quantity;  // O(1) 數組訪問
    }
};
```

### 案例 2: 市場數據解碼

```cpp
// ❌ 未優化: 逐字節解析
struct MarketData {
    uint64_t timestamp;
    double price;
    uint32_t quantity;
};

MarketData parse(const uint8_t* buffer) {
    MarketData data;
    std::memcpy(&data.timestamp, buffer, 8);
    std::memcpy(&data.price, buffer + 8, 8);
    std::memcpy(&data.quantity, buffer + 16, 4);
    return data;
}

// ✅ 優化: 直接轉型 (需對齊)
struct alignas(8) MarketData {
    uint64_t timestamp;
    double price;
    uint32_t quantity;
    uint32_t padding;  // 保持 8 字節對齊
};

static_assert(sizeof(MarketData) == 24);
static_assert(std::is_trivially_copyable_v<MarketData>);

const MarketData* parse(const uint8_t* buffer) {
    return reinterpret_cast<const MarketData*>(buffer);  // 零拷貝
}
```

### 案例 3: 批量訂單處理

```cpp
// ❌ 未優化: 逐個處理
void process_orders(const std::vector<Order>& orders) {
    for (const auto& order : orders) {
        validate(order);
        execute(order);
        log(order);
    }
}

// ✅ 優化: 批量處理 (改善 cache 局部性)
void process_orders(const std::vector<Order>& orders) {
    // 階段 1: 驗證 (所有驗證邏輯的數據在 cache 中)
    std::vector<bool> valid(orders.size());
    for (size_t i = 0; i < orders.size(); ++i) {
        valid[i] = validate(orders[i]);
    }
    
    // 階段 2: 執行
    for (size_t i = 0; i < orders.size(); ++i) {
        if (valid[i]) {
            execute(orders[i]);
        }
    }
    
    // 階段 3: 日誌 (非關鍵路徑,異步)
    async_log(orders);
}
```

---

## 編譯器特定優化屬性

### GCC/Clang 屬性

```cpp
// 函數熱度標記
[[gnu::hot]] void critical_path() {
    // 高頻調用,優化為速度
}

[[gnu::cold]] void error_handler() {
    // 低頻調用,優化為大小,移到冷區
}

// 純函數 (無副作用)
[[gnu::pure]] int compute(int x) {
    return x * x;  // 結果僅依賴參數
}

// 常函數 (更嚴格的純函數)
[[gnu::const]] int square(int x) {
    return x * x;  // 不讀取全局狀態
}

// 目標特定優化
[[gnu::target("avx2")]] void process_avx2(float* data, size_t n) {
    // 使用 AVX2 指令
}

// 假設對齊
void process(int* __attribute__((aligned(64))) data) {
    // 編譯器假設 data 為 64 字節對齊
}
```

### 內建函數 (Builtins)

```cpp
// 分支預測提示
if (__builtin_expect(ptr != nullptr, 1)) {  // likely
    // 高概率路徑
} else {  // unlikely
    // 低概率路徑
}

// C++20 標準屬性
if (ptr != nullptr) [[likely]] {
    // 高概率路徑
}

// 預取數據到 cache
__builtin_prefetch(&data[i + 8]);  // 預取未來數據

// 假設條件
void process(int x) {
    __builtin_assume(x > 0);  // Clang
    // 或
    if (x <= 0) __builtin_unreachable();  // GCC
    
    // 編譯器可利用此假設優化
}

// 內建數學函數
int pop_count = __builtin_popcount(value);  // 計算 1 的個數
int leading_zeros = __builtin_clz(value);   // 前導零個數
```

---

## 優化驗證與測試

### 性能基準測試

```cpp
#include <benchmark/benchmark.h>

// 測試不同優化方案
static void BM_Unoptimized(benchmark::State& state) {
    for (auto _ : state) {
        int result = unoptimized_version(100);
        benchmark::DoNotOptimize(result);
    }
}

static void BM_Optimized(benchmark::State& state) {
    for (auto _ : state) {
        int result = optimized_version(100);
        benchmark::DoNotOptimize(result);
    }
}

BENCHMARK(BM_Unoptimized);
BENCHMARK(BM_Optimized);

BENCHMARK_MAIN();
```

### 防止優化消除

```cpp
// ❌ 錯誤: 編譯器可能優化掉整個計算
void test() {
    int result = expensive_computation();
    // result 未使用,整個函數可能被消除
}

// ✅ 正確: 防止優化
void test() {
    int result = expensive_computation();
    benchmark::DoNotOptimize(result);  // 告訴編譯器不要優化
}

// 或使用 volatile
void test() {
    volatile int result = expensive_computation();
}

// 或使用內聯匯編
void test() {
    int result = expensive_computation();
    asm volatile("" : "+r"(result));  // 防止優化
}
```

---

## 實戰檢查清單

### 編譯選項

- [ ] 生產環境使用 `-O2` 或 `-O3`
- [ ] 啟用 LTO: `-flto`
- [ ] 考慮 PGO 用於關鍵服務
- [ ] 使用 `-march=native` 利用 CPU 特性
- [ ] 查看優化報告: `-fopt-info`

### 代碼模式

- [ ] 關鍵函數標記 `inline` 或強制內聯
- [ ] 使用 `constexpr` 進行編譯期計算
- [ ] 避免虛函數在熱路徑
- [ ] 使用 `noexcept` 允許更多優化
- [ ] 小心別名問題,考慮 `__restrict`

### 驗證優化

- [ ] 檢查生成的匯編代碼
- [ ] 使用 Compiler Explorer 驗證
- [ ] 使用 benchmark 測量性能
- [ ] 使用 perf 分析熱點

### 高頻交易特定

- [ ] 熱路徑函數使用 `[[gnu::hot]]`
- [ ] 使用 `[[likely]]`/`[[unlikely]]`
- [ ] 預取關鍵數據 `__builtin_prefetch`
- [ ] 批量處理改善 cache 局部性

---

## 參考資料 (References)

1. [GCC Optimization Options](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)
2. [Clang Optimization Guide](https://clang.llvm.org/docs/CommandGuide/clang.html)
3. Fog, Agner. *Optimizing software in C++*. Technical University of Denmark, 2004.
4. [Compiler Explorer](https://godbolt.org/)
5. [Google Benchmark](https://github.com/google/benchmark)

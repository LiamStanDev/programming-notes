# 錯誤處理策略 (Error Handling Strategies)

## 概述

C++ 提供多種錯誤處理機制:
1. **異常 (Exceptions)**: 自動傳播,清理資源
2. **錯誤碼 (Error Codes)**: 顯式檢查,零開銷
3. **std::expected (C++23)**: Rust-style Result
4. **契約 (Contracts)**: 編譯期與運行時斷言

在高頻交易中,錯誤處理策略影響:
- **延遲 (Latency)**: 異常展開開銷 vs 分支預測
- **正確性 (Correctness)**: 錯誤是否能被忽略
- **可維護性 (Maintainability)**: 錯誤處理代碼的清晰度

---

## 異常機制 (Exceptions)

### 基本用法

```cpp
#include <stdexcept>
#include <iostream>

double divide(double a, double b) {
    if (b == 0.0) {
        throw std::invalid_argument("Division by zero");
    }
    return a / b;
}

int main() {
    try {
        double result = divide(10.0, 0.0);
        std::cout << result << '\n';
    } 
    catch (const std::invalid_argument& e) {
        std::cerr << "Error: " << e.what() << '\n';
    }
    catch (const std::exception& e) {
        std::cerr << "Unexpected error: " << e.what() << '\n';
    }
    catch (...) {
        std::cerr << "Unknown error\n";
    }
}
```

### 標準異常層次

```cpp
std::exception
├── std::logic_error
│   ├── std::invalid_argument
│   ├── std::domain_error
│   ├── std::length_error
│   ├── std::out_of_range
│   └── std::future_error
└── std::runtime_error
    ├── std::range_error
    ├── std::overflow_error
    ├── std::underflow_error
    └── std::system_error
```

### 自定義異常

```cpp
// 繼承自 std::exception
class OrderValidationError : public std::exception {
    std::string message_;
    
public:
    explicit OrderValidationError(std::string message) 
        : message_(std::move(message)) {}
    
    const char* what() const noexcept override {
        return message_.c_str();
    }
};

// 使用
void validate_order(const Order& order) {
    if (order.quantity <= 0) {
        throw OrderValidationError("Invalid quantity");
    }
    if (order.price <= 0.0) {
        throw OrderValidationError("Invalid price");
    }
}
```

### RAII 與異常安全

```cpp
// 異常安全的資源管理
class Connection {
    int socket_fd_;
    
public:
    explicit Connection(const char* host, int port) 
        : socket_fd_(connect_to(host, port)) {
        if (socket_fd_ < 0) {
            throw std::runtime_error("Connection failed");
        }
    }
    
    ~Connection() {
        if (socket_fd_ >= 0) {
            ::close(socket_fd_);
        }
    }
    
    // 禁止拷貝,允許移動
    Connection(const Connection&) = delete;
    Connection& operator=(const Connection&) = delete;
    
    Connection(Connection&& other) noexcept 
        : socket_fd_(std::exchange(other.socket_fd_, -1)) {}
    
    Connection& operator=(Connection&& other) noexcept {
        if (this != &other) {
            if (socket_fd_ >= 0) ::close(socket_fd_);
            socket_fd_ = std::exchange(other.socket_fd_, -1);
        }
        return *this;
    }
};

// 使用: 即使拋出異常也會自動清理
void send_data() {
    Connection conn("localhost", 8080);  // 構造失敗會拋異常
    // 若下面拋異常, conn 解構函數自動關閉連接
    conn.send(data);
}
```

### 異常安全保證

```cpp
// 1. 不拋出保證 (No-throw guarantee)
void log_message(const char* msg) noexcept {
    // 保證不拋異常
    try {
        std::cout << msg << '\n';
    } catch (...) {
        // 內部處理,不向外傳播
    }
}

// 2. 強異常保證 (Strong guarantee): Copy-and-swap
class OrderBook {
    std::vector<Order> orders_;
    
public:
    void add_order(const Order& order) {
        std::vector<Order> temp = orders_;  // 拷貝
        temp.push_back(order);              // 可能拋異常
        orders_.swap(temp);                 // 不拋異常
        // 若 push_back 失敗,原始 orders_ 不變
    }
};

// 3. 基本異常保證 (Basic guarantee): 不洩漏資源
class Buffer {
    char* data_;
    size_t size_;
    
public:
    void resize(size_t new_size) {
        char* new_data = new char[new_size];  // 可能拋異常
        std::copy(data_, data_ + std::min(size_, new_size), new_data);
        delete[] data_;  // 不拋異常
        data_ = new_data;
        size_ = new_size;
    }
};
```

---

## 異常的性能開銷

### Zero-Cost Exception Model

現代 C++ 使用"零成本異常"模型:
- **正常路徑**: 幾乎無開銷 (無分支檢查)
- **異常路徑**: 開銷大 (棧展開,查找處理器)

```cpp
// 測試異常開銷
#include <benchmark/benchmark.h>

// 使用異常
int divide_exception(int a, int b) {
    if (b == 0) throw std::invalid_argument("div by zero");
    return a / b;
}

static void BM_Exception_NoThrow(benchmark::State& state) {
    for (auto _ : state) {
        int result = divide_exception(10, 2);  // 不拋異常
        benchmark::DoNotOptimize(result);
    }
}

static void BM_Exception_Throw(benchmark::State& state) {
    for (auto _ : state) {
        try {
            int result = divide_exception(10, 0);  // 拋異常
            benchmark::DoNotOptimize(result);
        } catch (...) {}
    }
}

// 結果:
// BM_Exception_NoThrow:   ~1ns  (正常路徑快)
// BM_Exception_Throw:     ~1000ns (異常路徑慢)
```

### 禁用異常

```bash
# 編譯選項禁用異常
g++ -fno-exceptions -o program program.cpp

# 代碼體積減少,性能提升
# 但標準庫部分功能不可用 (如 std::vector::at)
```

```cpp
// 標記函數不拋異常
void critical_path() noexcept {
    // 若內部拋異常會調用 std::terminate
}

// 條件 noexcept
template<typename T>
void swap(T& a, T& b) noexcept(std::is_nothrow_move_constructible_v<T>) {
    T temp = std::move(a);
    a = std::move(b);
    b = std::move(temp);
}
```

---

## 錯誤碼 (Error Codes)

### C 風格錯誤碼

```cpp
// 傳統方式: 返回值表示錯誤
int connect_to_server(const char* host, int port, int* out_fd) {
    int fd = ::socket(AF_INET, SOCK_STREAM, 0);
    if (fd < 0) return -1;  // 錯誤: 無法創建 socket
    
    // ... connect ...
    
    if (::connect(fd, ...) < 0) {
        ::close(fd);
        return -2;  // 錯誤: 連接失敗
    }
    
    *out_fd = fd;
    return 0;  // 成功
}

// 使用
int fd;
int result = connect_to_server("localhost", 8080, &fd);
if (result != 0) {
    std::cerr << "Connection failed: " << result << '\n';
    return;
}
```

### std::error_code (C++11)

```cpp
#include <system_error>

// 定義錯誤碼
enum class OrderError {
    SUCCESS = 0,
    INVALID_PRICE,
    INVALID_QUANTITY,
    INSUFFICIENT_BALANCE,
    DUPLICATE_ORDER
};

// 創建 error_category
class OrderErrorCategory : public std::error_category {
public:
    const char* name() const noexcept override {
        return "order";
    }
    
    std::string message(int ev) const override {
        switch (static_cast<OrderError>(ev)) {
            case OrderError::SUCCESS: return "Success";
            case OrderError::INVALID_PRICE: return "Invalid price";
            case OrderError::INVALID_QUANTITY: return "Invalid quantity";
            case OrderError::INSUFFICIENT_BALANCE: return "Insufficient balance";
            case OrderError::DUPLICATE_ORDER: return "Duplicate order";
            default: return "Unknown error";
        }
    }
};

const OrderErrorCategory& order_category() {
    static OrderErrorCategory instance;
    return instance;
}

// 創建 error_code
std::error_code make_error_code(OrderError e) {
    return {static_cast<int>(e), order_category()};
}

// 註冊到 std::error_code
namespace std {
    template<>
    struct is_error_code_enum<OrderError> : true_type {};
}

// 使用
std::error_code validate_order(const Order& order) {
    if (order.price <= 0) {
        return OrderError::INVALID_PRICE;
    }
    if (order.quantity <= 0) {
        return OrderError::INVALID_QUANTITY;
    }
    return OrderError::SUCCESS;
}

int main() {
    Order order{/*...*/};
    auto error = validate_order(order);
    
    if (error) {
        std::cerr << "Validation failed: " << error.message() << '\n';
        return 1;
    }
    
    // 處理訂單...
}
```

---

## std::expected (C++23)

### 基本用法

```cpp
#include <expected>

// 返回值或錯誤
std::expected<int, std::string> divide(int a, int b) {
    if (b == 0) {
        return std::unexpected("Division by zero");
    }
    return a / b;
}

int main() {
    auto result = divide(10, 2);
    
    if (result) {
        std::cout << "Result: " << *result << '\n';
    } else {
        std::cerr << "Error: " << result.error() << '\n';
    }
    
    // 或使用 value_or
    int value = divide(10, 0).value_or(0);
}
```

### 鏈式操作

```cpp
// 使用 and_then, or_else, transform
auto result = divide(10, 2)
    .and_then([](int x) { return divide(x, 2); })  // 成功則繼續
    .transform([](int x) { return x * 2; })        // 轉換值
    .or_else([](auto&& err) {                      // 失敗處理
        std::cerr << "Error: " << err << '\n';
        return std::expected<int, std::string>(0);
    });
```

### 高頻交易應用

```cpp
enum class TradeError {
    INVALID_ORDER,
    INSUFFICIENT_BALANCE,
    MARKET_CLOSED,
    NETWORK_ERROR
};

std::expected<Trade, TradeError> execute_trade(const Order& order) {
    // 驗證訂單
    if (!is_valid(order)) {
        return std::unexpected(TradeError::INVALID_ORDER);
    }
    
    // 檢查餘額
    if (!has_sufficient_balance(order)) {
        return std::unexpected(TradeError::INSUFFICIENT_BALANCE);
    }
    
    // 檢查市場狀態
    if (!is_market_open()) {
        return std::unexpected(TradeError::MARKET_CLOSED);
    }
    
    // 執行交易
    Trade trade = /*...*/;
    return trade;
}

// 使用
auto result = execute_trade(order);

if (result) {
    Trade trade = std::move(*result);
    std::cout << "Trade executed: " << trade.id << '\n';
} else {
    switch (result.error()) {
        case TradeError::INVALID_ORDER:
            log_error("Invalid order");
            break;
        case TradeError::INSUFFICIENT_BALANCE:
            log_error("Insufficient balance");
            break;
        // ...
    }
}
```

---

## 性能對比: 異常 vs 錯誤碼

### 實測對比

```cpp
#include <benchmark/benchmark.h>

// 1. 使用異常
int divide_exception(int a, int b) {
    if (b == 0) throw std::runtime_error("div by zero");
    return a / b;
}

static void BM_Exception_Success(benchmark::State& state) {
    for (auto _ : state) {
        try {
            int result = divide_exception(10, 2);
            benchmark::DoNotOptimize(result);
        } catch (...) {}
    }
}

// 2. 使用錯誤碼
std::pair<int, bool> divide_errorcode(int a, int b) {
    if (b == 0) return {0, false};
    return {a / b, true};
}

static void BM_ErrorCode_Success(benchmark::State& state) {
    for (auto _ : state) {
        auto [result, ok] = divide_errorcode(10, 2);
        if (!ok) { /* handle error */ }
        benchmark::DoNotOptimize(result);
    }
}

// 3. 使用 expected
std::expected<int, const char*> divide_expected(int a, int b) {
    if (b == 0) return std::unexpected("div by zero");
    return a / b;
}

static void BM_Expected_Success(benchmark::State& state) {
    for (auto _ : state) {
        auto result = divide_expected(10, 2);
        if (!result) { /* handle error */ }
        benchmark::DoNotOptimize(result);
    }
}

// 結果 (成功路徑):
// Exception:   ~1ns   (零開銷)
// ErrorCode:   ~1ns   (可能額外分支)
// Expected:    ~1ns   (可內聯優化)

// 結果 (失敗路徑):
// Exception:   ~1000ns (棧展開)
// ErrorCode:   ~1ns    (簡單分支)
// Expected:    ~1ns    (簡單分支)
```

### 選擇建議

| 場景 | 推薦方案 | 理由 |
|------|---------|------|
| 真正異常情況 (< 1%) | 異常 | 正常路徑無開銷 |
| 常見錯誤 (> 10%) | 錯誤碼/expected | 避免異常展開 |
| 熱路徑 (高頻調用) | 錯誤碼 | 可預測性能 |
| 複雜錯誤傳播 | 異常/expected | 自動傳播 |
| 不可恢復錯誤 | std::terminate | 立即終止 |

---

## 斷言與契約 (Assertions & Contracts)

### 斷言

```cpp
#include <cassert>

void process_order(const Order* order) {
    assert(order != nullptr);  // Debug 構建檢查
    // Release 構建會被移除
    
    // 處理訂單...
}

// static_assert: 編譯期斷言
template<typename T>
void serialize(const T& value) {
    static_assert(std::is_trivially_copyable_v<T>, 
                  "Type must be trivially copyable");
    // ...
}
```

### 自定義斷言

```cpp
// 總是檢查的斷言
#define ALWAYS_ASSERT(condition, message) \
    do { \
        if (!(condition)) { \
            std::cerr << "Assertion failed: " << message << '\n'; \
            std::cerr << "File: " << __FILE__ << '\n'; \
            std::cerr << "Line: " << __LINE__ << '\n'; \
            std::terminate(); \
        } \
    } while(0)

// 僅 Debug 構建檢查
#ifdef NDEBUG
    #define DEBUG_ASSERT(condition, message) ((void)0)
#else
    #define DEBUG_ASSERT(condition, message) ALWAYS_ASSERT(condition, message)
#endif

// 使用
void execute_order(const Order& order) {
    ALWAYS_ASSERT(order.quantity > 0, "Invalid quantity");
    DEBUG_ASSERT(order.price > 0, "Invalid price");
    // ...
}
```

### Contracts (C++20 提案,未完全採納)

```cpp
// 前置條件 (Precondition)
int divide(int a, int b) 
    [[expects: b != 0]]  // 調用者保證
{
    return a / b;
}

// 後置條件 (Postcondition)
int* allocate(size_t size)
    [[ensures result: result != nullptr]]  // 函數保證
{
    return new int[size];
}

// 斷言 (Assertion)
void process(int value) {
    [[assert: value > 0]];  // 運行時檢查
    // ...
}
```

---

## 高頻交易錯誤處理策略

### 分層錯誤處理

```cpp
// 1. 關鍵路徑: 錯誤碼 (零開銷)
enum class FastPathError : uint8_t {
    SUCCESS = 0,
    INVALID_PRICE,
    INVALID_QUANTITY,
    RATE_LIMIT_EXCEEDED
};

FastPathError validate_order_fast(const Order& order) noexcept {
    if (order.price <= 0) [[unlikely]] {
        return FastPathError::INVALID_PRICE;
    }
    if (order.quantity <= 0) [[unlikely]] {
        return FastPathError::INVALID_QUANTITY;
    }
    return FastPathError::SUCCESS;
}

// 2. 非關鍵路徑: 異常 (可維護性)
void load_configuration(const std::string& path) {
    std::ifstream file(path);
    if (!file) {
        throw std::runtime_error("Cannot open config file: " + path);
    }
    // ...
}

// 3. 初始化階段: 異常
class TradingEngine {
public:
    TradingEngine() {
        // 初始化失敗直接拋異常,無需複雜錯誤處理
        if (!connect_to_market()) {
            throw std::runtime_error("Market connection failed");
        }
    }
};
```

### 錯誤日誌策略

```cpp
// 關鍵錯誤: 同步日誌
void log_critical_error(const std::string& msg) {
    std::cerr << "[CRITICAL] " << msg << std::endl;  // 立即刷新
    // 可能觸發告警
}

// 一般錯誤: 異步日誌
class AsyncLogger {
    std::queue<std::string> queue_;
    std::mutex mutex_;
    std::condition_variable cv_;
    std::thread worker_;
    std::atomic<bool> stop_{false};
    
public:
    AsyncLogger() : worker_([this] { process_logs(); }) {}
    
    ~AsyncLogger() {
        stop_ = true;
        cv_.notify_one();
        worker_.join();
    }
    
    void log(std::string msg) {
        std::lock_guard lock(mutex_);
        queue_.push(std::move(msg));
        cv_.notify_one();
    }
    
private:
    void process_logs() {
        while (!stop_) {
            std::unique_lock lock(mutex_);
            cv_.wait(lock, [this] { return !queue_.empty() || stop_; });
            
            while (!queue_.empty()) {
                auto msg = std::move(queue_.front());
                queue_.pop();
                lock.unlock();
                
                // 寫入文件 (I/O 操作)
                std::cout << msg << '\n';
                
                lock.lock();
            }
        }
    }
};
```

### 降級策略

```cpp
class OrderExecutor {
    enum class Mode {
        NORMAL,      // 正常模式
        DEGRADED,    // 降級模式
        EMERGENCY    // 緊急模式
    };
    
    std::atomic<Mode> mode_{Mode::NORMAL};
    
public:
    bool execute(const Order& order) {
        switch (mode_.load(std::memory_order_relaxed)) {
            case Mode::NORMAL:
                return execute_normal(order);
                
            case Mode::DEGRADED:
                // 降級: 僅處理重要訂單
                if (order.is_critical()) {
                    return execute_degraded(order);
                }
                return false;
                
            case Mode::EMERGENCY:
                // 緊急: 停止接受新訂單
                return false;
        }
    }
    
    void on_error(const std::error_code& error) {
        if (error == SystemError::HIGH_LATENCY) {
            // 延遲過高,進入降級模式
            mode_ = Mode::DEGRADED;
        } else if (error == SystemError::CONNECTION_LOST) {
            // 連接丟失,進入緊急模式
            mode_ = Mode::EMERGENCY;
        }
    }
};
```

---

## 錯誤恢復模式

### 重試機制

```cpp
template<typename Func, typename... Args>
auto retry_on_error(int max_attempts, Func&& func, Args&&... args) 
    -> std::expected<decltype(func(args...)), std::string> 
{
    for (int attempt = 0; attempt < max_attempts; ++attempt) {
        try {
            return func(std::forward<Args>(args)...);
        } 
        catch (const std::exception& e) {
            if (attempt == max_attempts - 1) {
                return std::unexpected(
                    std::string("Failed after ") + 
                    std::to_string(max_attempts) + 
                    " attempts: " + e.what()
                );
            }
            
            // 指數退避
            std::this_thread::sleep_for(
                std::chrono::milliseconds(100 * (1 << attempt))
            );
        }
    }
    return std::unexpected("Unreachable");
}

// 使用
auto result = retry_on_error(3, []() {
    return connect_to_market();
});
```

### 熔斷器模式 (Circuit Breaker)

```cpp
class CircuitBreaker {
    enum class State { CLOSED, OPEN, HALF_OPEN };
    
    std::atomic<State> state_{State::CLOSED};
    std::atomic<int> failure_count_{0};
    std::chrono::steady_clock::time_point last_failure_;
    
    static constexpr int FAILURE_THRESHOLD = 5;
    static constexpr auto TIMEOUT = std::chrono::seconds(60);
    
public:
    template<typename Func>
    auto execute(Func&& func) -> decltype(func()) {
        auto current_state = state_.load();
        
        if (current_state == State::OPEN) {
            // 檢查是否該嘗試恢復
            auto now = std::chrono::steady_clock::now();
            if (now - last_failure_ > TIMEOUT) {
                state_ = State::HALF_OPEN;
            } else {
                throw std::runtime_error("Circuit breaker is OPEN");
            }
        }
        
        try {
            auto result = func();
            
            // 成功: 重置
            if (current_state == State::HALF_OPEN) {
                state_ = State::CLOSED;
                failure_count_ = 0;
            }
            
            return result;
        } 
        catch (...) {
            on_failure();
            throw;
        }
    }
    
private:
    void on_failure() {
        last_failure_ = std::chrono::steady_clock::now();
        
        if (++failure_count_ >= FAILURE_THRESHOLD) {
            state_ = State::OPEN;
        }
    }
};
```

---

## 實戰檢查清單

### 異常使用

- [ ] 僅在真正異常情況使用異常
- [ ] 關鍵路徑避免異常 (noexcept)
- [ ] 使用 RAII 保證異常安全
- [ ] 自定義異常繼承 std::exception
- [ ] 解構函數標記 noexcept

### 錯誤碼使用

- [ ] 高頻路徑使用錯誤碼
- [ ] 使用 std::error_code 統一錯誤處理
- [ ] 不可忽略的錯誤使用 [[nodiscard]]
- [ ] 考慮使用 std::expected (C++23)

### 高頻交易特定

- [ ] 熱路徑使用輕量級錯誤處理
- [ ] 關鍵錯誤同步日誌
- [ ] 實現降級與熔斷機制
- [ ] 使用 [[likely]]/[[unlikely]] 優化分支

---

## 參考資料 (References)

1. Meyers, Scott. "Exception Specifications." *Effective C++ (3rd Edition)*. Addison-Wesley, 2005.
2. Sutter, Herb. "Exception Safety and Exception Specifications." *Exceptional C++*. Addison-Wesley, 1999.
3. [std::expected Proposal (P0323R12)](http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p0323r12.html)
4. [Error Handling in C++](https://www.joelonsoftware.com/2003/10/13/13/)
5. Nystrom, Robert. "Exception Handling." *Game Programming Patterns*. Genever Benning, 2014.

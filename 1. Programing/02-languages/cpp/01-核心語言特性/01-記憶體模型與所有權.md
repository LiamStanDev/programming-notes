# 記憶體模型與所有權 (Memory Model & Ownership)

## 概述

C++ 與 Rust 都強調明確的資源所有權,但實現方式不同:
- **Rust**: 編譯期借用檢查器 (Borrow Checker) 強制執行
- **C++**: 透過慣例 (RAII) 與工具 (智能指針) 實現,需開發者自律

在高頻交易系統中,記憶體管理直接影響延遲:
- **分配/釋放開銷**: 每次 `new`/`delete` 可能觸發系統調用
- **記憶體碎片**: 導致 cache miss 增加
- **所有權不明**: 引發 double-free 或記憶體洩漏

---

## RAII (Resource Acquisition Is Initialization)

### 核心理念

**資源獲取即初始化,資源釋放即解構**

```cpp
class FileHandler {
    int fd_;
public:
    explicit FileHandler(const char* path) 
        : fd_(::open(path, O_RDONLY)) {
        if (fd_ < 0) throw std::runtime_error("open failed");
    }
    
    ~FileHandler() {
        if (fd_ >= 0) ::close(fd_);
    }
    
    // 禁止拷貝,允許移動
    FileHandler(const FileHandler&) = delete;
    FileHandler& operator=(const FileHandler&) = delete;
    
    FileHandler(FileHandler&& other) noexcept 
        : fd_(std::exchange(other.fd_, -1)) {}
    
    FileHandler& operator=(FileHandler&& other) noexcept {
        if (this != &other) {
            if (fd_ >= 0) ::close(fd_);
            fd_ = std::exchange(other.fd_, -1);
        }
        return *this;
    }
    
    int get() const { return fd_; }
};

void process_file() {
    FileHandler fh("/path/to/file");
    // 即使發生異常,解構函數也會被調用
    // 無需手動 close(fd)
} // 自動關閉文件
```

### 與 C# 的對比

```csharp
// C# 使用 IDisposable + using
using (var file = File.OpenRead("path")) {
    // 處理文件
} // 自動調用 Dispose()
```

### 高頻交易應用

```cpp
// 交易會話管理
class TradingSession {
    std::unique_ptr<MarketDataConnection> md_conn_;
    std::unique_ptr<OrderConnection> order_conn_;
    
public:
    TradingSession(const Config& cfg) 
        : md_conn_(std::make_unique<MarketDataConnection>(cfg.md_endpoint))
        , order_conn_(std::make_unique<OrderConnection>(cfg.order_endpoint)) {
        // 連接建立失敗會自動清理已分配資源
    }
    
    // 解構時自動斷開所有連接
    ~TradingSession() = default;
};
```

---

## 物件生命週期與值語意 (Value Semantics)

### 物件大小與記憶體佈局

```cpp
#include <iostream>

struct Empty {};  // 仍佔用 1 byte (佔位符)

struct Aligned {
    char c;      // 1 byte
    // 3 bytes padding
    int i;       // 4 bytes
    char c2;     // 1 byte
    // 7 bytes padding (對齊至 8 的倍數)
}; // sizeof = 16 bytes

struct Optimized {
    int i;       // 4 bytes
    char c;      // 1 byte
    char c2;     // 1 byte
    // 2 bytes padding
}; // sizeof = 8 bytes

int main() {
    std::cout << sizeof(Empty) << '\n';      // 1
    std::cout << sizeof(Aligned) << '\n';    // 16
    std::cout << sizeof(Optimized) << '\n';  // 8
}
```

**高頻交易要點**:
- 小心結構體填充 (padding),影響 cache line 利用率
- 通常一個 cache line 為 64 bytes
- 熱路徑數據結構應盡量緊湊

### 值類別 (Value Categories)

C++11 引入五種值類別:

```cpp
int x = 10;
int& lref = x;           // lvalue reference
int&& rref = 10;         // rvalue reference

// lvalue: 有名字,可取地址
std::string s1 = "hello";

// prvalue (pure rvalue): 臨時對象
std::string{"world"};
42;

// xvalue (expiring value): 即將銷毀的對象
std::move(s1);
std::string{"temp"}.substr(0, 2);
```

---

## 移動語意 (Move Semantics)

### 為何需要移動?

```cpp
// 低效的拷貝
std::vector<int> create_large_vector() {
    std::vector<int> v(1'000'000);
    // ... 填充數據
    return v;  // C++11 前: 拷貝整個 vector
}

// C++11 後: 自動移動 (RVO/NRVO)
std::vector<int> v = create_large_vector();  // O(1) 移動,非 O(n) 拷貝
```

### 五大特殊成員函數 (Rule of Five)

```cpp
class Buffer {
    char* data_;
    size_t size_;
    
public:
    // 1. 構造函數
    explicit Buffer(size_t size) 
        : data_(new char[size]), size_(size) {}
    
    // 2. 解構函數
    ~Buffer() { 
        delete[] data_; 
    }
    
    // 3. 拷貝構造函數
    Buffer(const Buffer& other) 
        : data_(new char[other.size_]), size_(other.size_) {
        std::memcpy(data_, other.data_, size_);
    }
    
    // 4. 拷貝賦值運算符
    Buffer& operator=(const Buffer& other) {
        if (this != &other) {
            // Copy-and-swap idiom (異常安全)
            Buffer temp(other);
            swap(temp);
        }
        return *this;
    }
    
    // 5. 移動構造函數
    Buffer(Buffer&& other) noexcept 
        : data_(std::exchange(other.data_, nullptr))
        , size_(std::exchange(other.size_, 0)) {}
    
    // 6. 移動賦值運算符
    Buffer& operator=(Buffer&& other) noexcept {
        if (this != &other) {
            delete[] data_;
            data_ = std::exchange(other.data_, nullptr);
            size_ = std::exchange(other.size_, 0);
        }
        return *this;
    }
    
    void swap(Buffer& other) noexcept {
        std::swap(data_, other.data_);
        std::swap(size_, other.size_);
    }
};
```

### Rule of Zero vs Rule of Five

**優先使用 Rule of Zero**:

```cpp
// ❌ 不好: 手動管理資源
class BadOrderBook {
    Order* orders_;
    size_t capacity_;
public:
    BadOrderBook() : orders_(new Order[100]), capacity_(100) {}
    ~BadOrderBook() { delete[] orders_; }
    // 需要定義拷貝/移動...
};

// ✅ 好: 使用標準容器
class GoodOrderBook {
    std::vector<Order> orders_;
public:
    GoodOrderBook() : orders_(100) {}
    // 編譯器自動生成正確的拷貝/移動
};
```

### 移動語意最佳實踐

```cpp
// 1. 按值返回 (依賴 RVO/NRVO)
std::vector<Trade> get_trades() {
    std::vector<Trade> trades;
    // ... 填充
    return trades;  // 不要 std::move(trades)!
}

// 2. 函數參數: sink 參數使用按值傳遞
class OrderManager {
    std::vector<Order> pending_orders_;
public:
    // sink 參數: 支持移動與拷貝
    void add_order(Order order) {
        pending_orders_.push_back(std::move(order));
    }
};

// 使用方式
Order o = create_order();
manager.add_order(std::move(o));  // 移動
manager.add_order(create_order()); // 移動 (臨時對象)
```

---

## 智能指針 (Smart Pointers)

### 所有權模型對比

| 指針類型 | 所有權 | 適用場景 |
|---------|--------|----------|
| `std::unique_ptr` | 唯一所有權 | 默認選擇,獨佔資源 |
| `std::shared_ptr` | 共享所有權 | 多個所有者,計數管理 |
| `std::weak_ptr` | 非所有權 | 打破循環引用 |
| 原始指針 (`T*`) | 借用 (non-owning) | 觀察者,不負責釋放 |

### unique_ptr: 零開銷抽象

```cpp
#include <memory>

// 創建方式
auto p1 = std::make_unique<Order>(/*args*/);  // C++14
std::unique_ptr<Order> p2(new Order(/*args*/)); // C++11

// 自定義刪除器 (Deleter)
auto fd_deleter = [](int* pfd) { 
    if (pfd && *pfd >= 0) ::close(*pfd); 
    delete pfd;
};

std::unique_ptr<int, decltype(fd_deleter)> 
    fd_ptr(new int(::open("file", O_RDONLY)), fd_deleter);

// 高頻交易: 管理市場數據訂閱
class MarketDataSubscription {
    struct SubscriptionDeleter {
        void operator()(Subscription* sub) const {
            if (sub) {
                sub->unsubscribe();  // 先取消訂閱
                delete sub;
            }
        }
    };
    
    std::unique_ptr<Subscription, SubscriptionDeleter> sub_;
    
public:
    explicit MarketDataSubscription(const Symbol& symbol) 
        : sub_(SubscriptionManager::subscribe(symbol)) {}
};
```

### shared_ptr: 引用計數的代價

```cpp
// 引用計數開銷:
// 1. 額外記憶體: 控制塊 (control block)
// 2. 原子操作: 計數增減是 thread-safe 的
// 3. cache 友好性差: 控制塊與對象分離

auto sp1 = std::make_shared<Data>(/*args*/);  // 一次分配 (推薦)
std::shared_ptr<Data> sp2(new Data(/*args*/)); // 兩次分配

// 高頻交易中避免過度使用 shared_ptr
// 每次拷貝都有原子操作開銷
void process_orders(std::shared_ptr<OrderBook> book) {
    // ❌ 每次調用都增減引用計數 (atomic++)
}

void process_orders(const OrderBook& book) {
    // ✅ 零開銷,僅借用
}
```

### weak_ptr: 解決循環引用

```cpp
class Portfolio;

class Position {
    std::weak_ptr<Portfolio> portfolio_;  // 不增加引用計數
public:
    void check_risk() {
        if (auto port = portfolio_.lock()) {  // 安全升級為 shared_ptr
            // 使用 port
        } else {
            // portfolio 已被銷毀
        }
    }
};

class Portfolio {
    std::vector<std::shared_ptr<Position>> positions_;
};
```

### 智能指針性能對比

```cpp
#include <benchmark/benchmark.h>

// 性能測試
static void BM_RawPointer(benchmark::State& state) {
    for (auto _ : state) {
        int* p = new int(42);
        benchmark::DoNotOptimize(p);
        delete p;
    }
}

static void BM_UniquePtr(benchmark::State& state) {
    for (auto _ : state) {
        auto p = std::make_unique<int>(42);
        benchmark::DoNotOptimize(p);
    }
}

static void BM_SharedPtr(benchmark::State& state) {
    for (auto _ : state) {
        auto p = std::make_shared<int>(42);
        benchmark::DoNotOptimize(p);
    }
}

BENCHMARK(BM_RawPointer);   // 基線
BENCHMARK(BM_UniquePtr);    // ~相同開銷
BENCHMARK(BM_SharedPtr);    // ~2x 開銷 (控制塊 + 原子操作)
```

---

## 完美轉發 (Perfect Forwarding)

### 萬能引用 (Universal Reference)

```cpp
template<typename T>
void wrapper(T&& arg) {  // T&& 不一定是右值引用!
    // 引用折疊規則:
    // T& && -> T&
    // T&& && -> T&&
    process(std::forward<T>(arg));
}

int x = 10;
wrapper(x);          // T = int&, arg 類型為 int&
wrapper(10);         // T = int,  arg 類型為 int&&
wrapper(std::move(x)); // T = int,  arg 類型為 int&&
```

### std::forward 實現原理

```cpp
// 簡化版實現
template<typename T>
constexpr T&& forward(std::remove_reference_t<T>& arg) noexcept {
    return static_cast<T&&>(arg);
}

// 使用案例: 工廠函數
template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

// 高頻交易: 訊息構造與轉發
template<typename MsgType, typename... Args>
void send_message(Args&&... args) {
    MsgType msg(std::forward<Args>(args)...);
    network_send(std::move(msg));
}

send_message<OrderRequest>(symbol, price, quantity);
```

---

## 高頻交易中的記憶體管理策略

### 1. 物件池 (Object Pool)

避免頻繁分配/釋放:

```cpp
template<typename T>
class ObjectPool {
    std::vector<std::unique_ptr<T>> pool_;
    std::vector<T*> available_;
    
public:
    explicit ObjectPool(size_t initial_size) {
        pool_.reserve(initial_size);
        available_.reserve(initial_size);
        
        for (size_t i = 0; i < initial_size; ++i) {
            auto obj = std::make_unique<T>();
            available_.push_back(obj.get());
            pool_.push_back(std::move(obj));
        }
    }
    
    T* acquire() {
        if (available_.empty()) {
            auto obj = std::make_unique<T>();
            T* ptr = obj.get();
            pool_.push_back(std::move(obj));
            return ptr;
        }
        
        T* obj = available_.back();
        available_.pop_back();
        return obj;
    }
    
    void release(T* obj) {
        obj->reset();  // 重置狀態
        available_.push_back(obj);
    }
};

// 使用 RAII 管理物件生命週期
template<typename T>
class PooledObject {
    T* obj_;
    ObjectPool<T>* pool_;
    
public:
    PooledObject(ObjectPool<T>& pool) 
        : obj_(pool.acquire()), pool_(&pool) {}
    
    ~PooledObject() { 
        if (obj_) pool_->release(obj_); 
    }
    
    PooledObject(PooledObject&&) = default;
    PooledObject& operator=(PooledObject&&) = default;
    
    PooledObject(const PooledObject&) = delete;
    PooledObject& operator=(const PooledObject&) = delete;
    
    T* operator->() { return obj_; }
    T& operator*() { return *obj_; }
};
```

### 2. 環形緩衝 (Ring Buffer)

```cpp
template<typename T, size_t N>
class RingBuffer {
    alignas(64) std::array<T, N> buffer_;  // cache line 對齊
    alignas(64) std::atomic<size_t> write_pos_{0};
    alignas(64) std::atomic<size_t> read_pos_{0};
    
public:
    bool try_push(T&& item) {
        const size_t current_write = write_pos_.load(std::memory_order_relaxed);
        const size_t next_write = (current_write + 1) % N;
        
        if (next_write == read_pos_.load(std::memory_order_acquire)) {
            return false;  // 滿了
        }
        
        buffer_[current_write] = std::move(item);
        write_pos_.store(next_write, std::memory_order_release);
        return true;
    }
    
    bool try_pop(T& item) {
        const size_t current_read = read_pos_.load(std::memory_order_relaxed);
        
        if (current_read == write_pos_.load(std::memory_order_acquire)) {
            return false;  // 空的
        }
        
        item = std::move(buffer_[current_read]);
        read_pos_.store((current_read + 1) % N, std::memory_order_release);
        return true;
    }
};
```

### 3. 預分配與就地構造

```cpp
class OrderBook {
    // 預分配,避免運行時分配
    std::array<Order, 10000> orders_;
    size_t size_ = 0;
    
public:
    template<typename... Args>
    Order& emplace_order(Args&&... args) {
        // 就地構造,避免臨時對象
        new (&orders_[size_]) Order(std::forward<Args>(args)...);
        return orders_[size_++];
    }
};
```

---

## 與 Rust 的對比

| 特性 | C++ | Rust |
|------|-----|------|
| 所有權檢查 | 運行時 (智能指針) | 編譯期 (借用檢查器) |
| 移動語意 | 可選 (`std::move`) | 默認行為 |
| 引用有效性 | 需手動保證 | 編譯期保證 |
| 性能 | 零開銷抽象 | 零開銷抽象 |
| 記憶體安全 | 需紀律 + 工具 | 編譯期強制 |

```rust
// Rust 版本
struct Buffer {
    data: Vec<u8>,
}

impl Buffer {
    fn new(size: usize) -> Self {
        Self { data: vec![0; size] }
    }
    // 無需手動實現 Drop/Clone/Move
}

fn consume(buf: Buffer) {  // 獲得所有權
    // buf 在此作用域結束時自動釋放
}

let buf = Buffer::new(1024);
consume(buf);
// buf 已失效,無法再使用 (編譯器檢查)
```

---

## 實戰檢查清單

### 類設計檢查

- [ ] 是否需要自定義解構函數? → 考慮 Rule of Five
- [ ] 是否能使用 Rule of Zero? (優先選擇)
- [ ] 移動操作是否標記為 `noexcept`?
- [ ] 是否使用 `= delete` 禁止不必要的操作?
- [ ] 成員變量順序是否優化 (減少 padding)?

### 智能指針選擇

- [ ] 默認使用 `std::unique_ptr`
- [ ] 確實需要共享所有權才用 `std::shared_ptr`
- [ ] 使用 `std::make_unique`/`std::make_shared` (異常安全)
- [ ] 避免從 `this` 創建 `shared_ptr` (使用 `enable_shared_from_this`)

### 高頻交易優化

- [ ] 熱路徑避免動態分配
- [ ] 使用物件池管理頻繁創建/銷毀的對象
- [ ] 數據結構 cache line 對齊
- [ ] 避免不必要的 `shared_ptr` 拷貝

---

## 參考資料 (References)

1. Meyers, Scott. *Effective Modern C++*. O'Reilly, 2014.
2. Stroustrup, Bjarne. *A Tour of C++ (2nd Edition)*. Addison-Wesley, 2018.
3. [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
4. [Understanding Move Semantics](https://www.cprogramming.com/c++11/rvalue-references-and-move-semantics-in-c++11.html)
5. Alexandrescu, Andrei. *Modern C++ Design*. Addison-Wesley, 2001.

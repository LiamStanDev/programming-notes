# 型別系統與編譯期計算 (Type System & Compile-Time Computation)

## 概述

C++ 的型別系統是其最強大也最複雜的特性之一:
- **靜態型別**: 編譯期確定所有型別
- **強型別**: 禁止隱式不安全轉換
- **編譯期計算**: 將運行時工作轉移到編譯期

對高頻交易系統:
- **型別安全 = 正確性**: 編譯期捕獲單位錯誤、協議錯誤
- **編譯期計算 = 性能**: 零運行時開銷的抽象
- **模板元編程 = 靈活性**: 代碼生成與優化

---

## 型別推導 (Type Deduction)

### auto 型別推導

```cpp
// 基本用法
auto x = 42;              // int
auto y = 3.14;            // double
auto z = "hello";         // const char*
auto s = std::string{"world"}; // std::string

// 引用推導
int i = 10;
auto a = i;               // int (拷貝)
auto& b = i;              // int& (引用)
const auto& c = i;        // const int&
auto&& d = 42;            // int&& (右值引用)
auto&& e = i;             // int& (萬能引用折疊)

// 指針推導
int* p = &i;
auto q = p;               // int*
auto* r = p;              // int* (明確指針)
```

### decltype 型別推導

```cpp
int x = 10;
decltype(x) y = 20;       // int

int& ref = x;
decltype(ref) z = x;      // int& (保留引用)

decltype(auto) func() {
    int local = 42;
    return local;         // 返回 int (非引用)
}

decltype(auto) func2() {
    static int local = 42;
    return (local);       // 返回 int& (加括號變引用!)
}
```

### 返回值型別推導 (C++14)

```cpp
// auto 返回值
auto add(int a, int b) {
    return a + b;  // 推導為 int
}

// decltype(auto) 保留值類別
template<typename Container>
decltype(auto) get_element(Container& c, size_t idx) {
    return c[idx];  // 若 c[idx] 返回引用,則保留引用
}

std::vector<int> v = {1, 2, 3};
decltype(auto) elem = get_element(v, 0);  // int&
elem = 100;  // 修改 v[0]
```

### 高頻交易應用: 自動型別推導

```cpp
// 避免冗長的迭代器型別
std::map<std::string, std::vector<Order>> order_map;

// ❌ 冗長
std::map<std::string, std::vector<Order>>::iterator it = order_map.begin();

// ✅ 簡潔
auto it = order_map.begin();

// 結構化綁定 (C++17)
for (const auto& [symbol, orders] : order_map) {
    std::cout << symbol << ": " << orders.size() << " orders\n";
}
```

---

## 型別特性 (Type Traits)

### 標準型別特性

```cpp
#include <type_traits>

// 基本型別檢查
static_assert(std::is_integral_v<int>);
static_assert(std::is_floating_point_v<double>);
static_assert(std::is_pointer_v<int*>);
static_assert(std::is_reference_v<int&>);

// 組合檢查
static_assert(std::is_arithmetic_v<int>);  // 整數或浮點
static_assert(std::is_scalar_v<int*>);     // 標量類型

// 型別關係
static_assert(std::is_same_v<int, int32_t>);
static_assert(std::is_base_of_v<Base, Derived>);
static_assert(std::is_convertible_v<Derived*, Base*>);

// 型別屬性
static_assert(std::is_trivially_copyable_v<int>);
static_assert(std::is_standard_layout_v<MyStruct>);
static_assert(std::is_pod_v<PlainOldData>);  // C++20 deprecated
```

### 型別變換 (Type Transformations)

```cpp
// 移除修飾符
using T1 = std::remove_const_t<const int>;      // int
using T2 = std::remove_reference_t<int&>;       // int
using T3 = std::remove_pointer_t<int*>;         // int
using T4 = std::decay_t<int[10]>;               // int*

// 添加修飾符
using T5 = std::add_const_t<int>;               // const int
using T6 = std::add_lvalue_reference_t<int>;    // int&
using T7 = std::add_pointer_t<int>;             // int*

// 條件型別
using T8 = std::conditional_t<true, int, double>;  // int
using T9 = std::conditional_t<false, int, double>; // double
```

### SFINAE (Substitution Failure Is Not An Error)

```cpp
// 傳統 SFINAE: 使用 enable_if
template<typename T>
typename std::enable_if_t<std::is_integral_v<T>, T>
double_value(T value) {
    return value * 2;
}

template<typename T>
typename std::enable_if_t<std::is_floating_point_v<T>, T>
double_value(T value) {
    return value * 2.0;
}

// C++17: if constexpr (更清晰)
template<typename T>
T double_value(T value) {
    if constexpr (std::is_integral_v<T>) {
        return value * 2;
    } else if constexpr (std::is_floating_point_v<T>) {
        return value * 2.0;
    } else {
        static_assert(sizeof(T) == 0, "Unsupported type");
    }
}
```

### 自定義型別特性

```cpp
// 檢測型別是否有 serialize 方法
template<typename T, typename = void>
struct has_serialize : std::false_type {};

template<typename T>
struct has_serialize<T, std::void_t<decltype(std::declval<T>().serialize())>>
    : std::true_type {};

template<typename T>
inline constexpr bool has_serialize_v = has_serialize<T>::value;

// 使用
struct Message {
    void serialize() { /* ... */ }
};

static_assert(has_serialize_v<Message>);
static_assert(!has_serialize_v<int>);
```

---

## Concepts (C++20): 約束與需求

### 基本 Concept 定義

```cpp
#include <concepts>

// 使用標準 concept
template<std::integral T>
T add(T a, T b) {
    return a + b;
}

// 自定義 concept
template<typename T>
concept Numeric = std::integral<T> || std::floating_point<T>;

template<Numeric T>
T multiply(T a, T b) {
    return a * b;
}

// 複合需求
template<typename T>
concept Serializable = requires(T obj) {
    { obj.serialize() } -> std::same_as<std::vector<uint8_t>>;
    { obj.deserialize(std::declval<const std::vector<uint8_t>&>()) } -> std::same_as<void>;
};
```

### Requires 表達式

```cpp
// 簡單需求
template<typename T>
concept Hashable = requires(T a) {
    { std::hash<T>{}(a) } -> std::convertible_to<std::size_t>;
};

// 型別需求
template<typename T>
concept Container = requires {
    typename T::value_type;
    typename T::iterator;
};

// 複合需求
template<typename T>
concept Incrementable = requires(T x) {
    { ++x } -> std::same_as<T&>;
    { x++ } -> std::same_as<T>;
};

// 巢狀需求
template<typename T>
concept Comparable = requires(T a, T b) {
    { a < b } -> std::convertible_to<bool>;
    requires std::is_copy_constructible_v<T>;
};
```

### 高頻交易: 訊息型別約束

```cpp
// 定義市場數據訊息的需求
template<typename T>
concept MarketDataMessage = requires(T msg) {
    { msg.symbol } -> std::convertible_to<std::string_view>;
    { msg.timestamp } -> std::convertible_to<uint64_t>;
    { msg.price } -> std::convertible_to<double>;
    { msg.quantity } -> std::convertible_to<uint64_t>;
};

// 定義訂單訊息的需求
template<typename T>
concept OrderMessage = requires(T msg) {
    { msg.order_id } -> std::convertible_to<uint64_t>;
    { msg.symbol } -> std::convertible_to<std::string_view>;
    { msg.side } -> std::convertible_to<Side>;
    { msg.price } -> std::convertible_to<double>;
    { msg.quantity } -> std::convertible_to<uint64_t>;
};

// 使用 concept 約束函數
template<MarketDataMessage T>
void process_market_data(const T& msg) {
    // 編譯期保證 msg 有所需成員
    std::cout << msg.symbol << ": " << msg.price << "\n";
}

// Concept 重載
void handle_message(MarketDataMessage auto& msg) {
    update_order_book(msg);
}

void handle_message(OrderMessage auto& msg) {
    execute_order(msg);
}
```

---

## 編譯期計算進階

### constexpr 容器與算法 (C++20)

```cpp
#include <vector>
#include <algorithm>

// C++20: std::vector 可在 constexpr 中使用
constexpr int compute_sum() {
    std::vector<int> v = {1, 2, 3, 4, 5};
    int sum = 0;
    for (int x : v) sum += x;
    return sum;
}

static_assert(compute_sum() == 15);

// constexpr 算法
constexpr auto find_max() {
    std::array arr = {5, 2, 8, 1, 9, 3};
    return *std::max_element(arr.begin(), arr.end());
}

static_assert(find_max() == 9);
```

### 編譯期字串處理

```cpp
// C++20: 使用 constexpr std::string
constexpr std::string to_upper(std::string_view sv) {
    std::string result;
    result.reserve(sv.size());
    
    for (char c : sv) {
        result.push_back(static_cast<char>(std::toupper(c)));
    }
    return result;
}

// 編譯期驗證
static_assert(to_upper("hello") == "HELLO");

// 編譯期字串拼接
constexpr auto make_key(std::string_view prefix, int id) {
    return std::string(prefix) + "_" + std::to_string(id);
}
```

### 編譯期映射表 (Compile-Time Map)

```cpp
// 使用 std::array 模擬編譯期 map
template<typename Key, typename Value, size_t N>
struct CompileTimeMap {
    std::array<std::pair<Key, Value>, N> data;
    
    constexpr CompileTimeMap(std::initializer_list<std::pair<Key, Value>> init) {
        std::copy(init.begin(), init.end(), data.begin());
    }
    
    constexpr const Value* find(const Key& key) const {
        for (const auto& [k, v] : data) {
            if (k == key) return &v;
        }
        return nullptr;
    }
};

// 使用
constexpr CompileTimeMap<std::string_view, int, 3> error_codes{{
    {"SUCCESS", 0},
    {"INVALID_ORDER", -1},
    {"INSUFFICIENT_BALANCE", -2}
}};

static_assert(*error_codes.find("SUCCESS") == 0);
```

### 高頻交易: 編譯期配置

```cpp
// 編譯期交易策略配置
struct StrategyConfig {
    double max_position_size;
    double risk_limit;
    int max_orders_per_second;
    
    constexpr bool validate() const {
        return max_position_size > 0 
            && risk_limit > 0 
            && max_orders_per_second > 0;
    }
};

constexpr StrategyConfig config{
    .max_position_size = 1000000.0,
    .risk_limit = 50000.0,
    .max_orders_per_second = 100
};

static_assert(config.validate(), "Invalid strategy config");

// 使用配置 (運行時零開銷)
class TradingStrategy {
    static constexpr auto CONFIG = config;
    
public:
    bool can_place_order(double size) const {
        return size <= CONFIG.max_position_size;
    }
};
```

---

## 模板元編程進階

### 變參模板 (Variadic Templates)

```cpp
// 基礎變參函數
template<typename... Args>
void print(Args... args) {
    (std::cout << ... << args) << '\n';  // C++17 折疊表達式
}

print(1, 2.5, "hello", 'x');  // 輸出: 12.5hellox

// 遞迴展開 (C++11/14)
template<typename T>
void print_recursive(T value) {
    std::cout << value << '\n';
}

template<typename T, typename... Args>
void print_recursive(T first, Args... rest) {
    std::cout << first << ' ';
    print_recursive(rest...);
}

// 折疊表達式 (C++17)
template<typename... Args>
auto sum(Args... args) {
    return (... + args);  // 一元左折疊
}

template<typename... Args>
auto sum_with_init(Args... args) {
    return (0 + ... + args);  // 二元左折疊
}
```

### 型別包操作

```cpp
// 計算型別包大小
template<typename... Args>
constexpr size_t count_types() {
    return sizeof...(Args);
}

static_assert(count_types<int, double, char>() == 3);

// 獲取第 N 個型別
template<size_t N, typename... Args>
struct TypeAt;

template<typename T, typename... Args>
struct TypeAt<0, T, Args...> {
    using type = T;
};

template<size_t N, typename T, typename... Args>
struct TypeAt<N, T, Args...> {
    using type = typename TypeAt<N - 1, Args...>::type;
};

template<size_t N, typename... Args>
using TypeAt_t = typename TypeAt<N, Args...>::type;

// 使用
using SecondType = TypeAt_t<1, int, double, char>;  // double
```

### 完美轉發與參數包

```cpp
// 工廠函數
template<typename T, typename... Args>
std::unique_ptr<T> make_unique(Args&&... args) {
    return std::unique_ptr<T>(new T(std::forward<Args>(args)...));
}

// 多次轉發
template<typename... Args>
void forward_to_multiple(Args&&... args) {
    func1(std::forward<Args>(args)...);
    func2(std::forward<Args>(args)...);  // 可多次轉發
}

// 條件轉發
template<typename... Args>
void conditional_forward(bool condition, Args&&... args) {
    if (condition) {
        func1(std::forward<Args>(args)...);
    } else {
        func2(std::forward<Args>(args)...);
    }
}
```

### 高頻交易: 變參訊息構造

```cpp
// 統一訊息發送接口
template<typename MsgType, typename... Args>
void send_message(int socket_fd, Args&&... args) {
    // 就地構造訊息
    alignas(MsgType) std::byte buffer[sizeof(MsgType)];
    MsgType* msg = new (buffer) MsgType(std::forward<Args>(args)...);
    
    // 發送
    ::send(socket_fd, buffer, sizeof(MsgType), 0);
    
    // 清理
    msg->~MsgType();
}

// 使用
send_message<NewOrderMsg>(socket_fd, 
    "AAPL", Side::BUY, 150.0, 100);

// 批量處理不同型別
template<typename... Handlers>
class MessageDispatcher {
    std::tuple<Handlers...> handlers_;
    
public:
    explicit MessageDispatcher(Handlers... handlers) 
        : handlers_(std::move(handlers)...) {}
    
    template<typename Msg>
    void dispatch(const Msg& msg) {
        std::apply([&msg](auto&... handlers) {
            (handlers.handle(msg), ...);  // 折疊表達式
        }, handlers_);
    }
};
```

---

## std::variant 與型別安全聯合

### 基本用法

```cpp
#include <variant>

// 型別安全的聯合
std::variant<int, double, std::string> value;

value = 42;                    // 持有 int
value = 3.14;                  // 持有 double
value = std::string{"hello"};  // 持有 std::string

// 訪問
if (auto* p = std::get_if<int>(&value)) {
    std::cout << "int: " << *p << '\n';
}

// std::visit
std::visit([](auto&& arg) {
    std::cout << arg << '\n';
}, value);
```

### 訪問者模式

```cpp
// 為每種型別定義不同處理
struct Visitor {
    void operator()(int i) const {
        std::cout << "Processing int: " << i << '\n';
    }
    
    void operator()(double d) const {
        std::cout << "Processing double: " << d << '\n';
    }
    
    void operator()(const std::string& s) const {
        std::cout << "Processing string: " << s << '\n';
    }
};

std::visit(Visitor{}, value);

// Lambda 重載技巧
template<typename... Ts>
struct Overloaded : Ts... {
    using Ts::operator()...;
};

template<typename... Ts>
Overloaded(Ts...) -> Overloaded<Ts...>;

std::visit(Overloaded{
    [](int i) { std::cout << "int: " << i << '\n'; },
    [](double d) { std::cout << "double: " << d << '\n'; },
    [](const std::string& s) { std::cout << "string: " << s << '\n'; }
}, value);
```

### 高頻交易: 多型別訊息

```cpp
// 使用 variant 表示不同訊息型別
using Message = std::variant<
    NewOrderMsg,
    CancelOrderMsg,
    ReplaceOrderMsg,
    MarketDataMsg
>;

// 統一處理
class MessageHandler {
public:
    void handle(const Message& msg) {
        std::visit(Overloaded{
            [this](const NewOrderMsg& m) { handle_new_order(m); },
            [this](const CancelOrderMsg& m) { handle_cancel(m); },
            [this](const ReplaceOrderMsg& m) { handle_replace(m); },
            [this](const MarketDataMsg& m) { handle_market_data(m); }
        }, msg);
    }
    
private:
    void handle_new_order(const NewOrderMsg&) { /* ... */ }
    void handle_cancel(const CancelOrderMsg&) { /* ... */ }
    void handle_replace(const ReplaceOrderMsg&) { /* ... */ }
    void handle_market_data(const MarketDataMsg&) { /* ... */ }
};

// 效能優勢: 無虛函數調用,可內聯
```

---

## std::optional 與可選值

### 基本用法

```cpp
#include <optional>

// 可能有值或無值
std::optional<int> divide(int a, int b) {
    if (b == 0) return std::nullopt;
    return a / b;
}

auto result = divide(10, 2);
if (result) {
    std::cout << "Result: " << *result << '\n';
} else {
    std::cout << "Division by zero\n";
}

// value_or: 提供默認值
int value = divide(10, 0).value_or(0);
```

### 高頻交易應用

```cpp
// 查找訂單簿中的最佳價格
class OrderBook {
    std::map<double, uint64_t> bids_;
    std::map<double, uint64_t> asks_;
    
public:
    std::optional<double> get_best_bid() const {
        if (bids_.empty()) return std::nullopt;
        return bids_.rbegin()->first;
    }
    
    std::optional<double> get_best_ask() const {
        if (asks_.empty()) return std::nullopt;
        return asks_.begin()->first;
    }
    
    std::optional<double> get_spread() const {
        auto bid = get_best_bid();
        auto ask = get_best_ask();
        
        if (!bid || !ask) return std::nullopt;
        return *ask - *bid;
    }
};

// 使用
OrderBook book;
if (auto spread = book.get_spread()) {
    std::cout << "Spread: " << *spread << '\n';
}
```

---

## 型別擦除 (Type Erasure)

### 使用 std::function

```cpp
#include <functional>

// 型別擦除的函數包裝
std::function<int(int, int)> operation;

operation = [](int a, int b) { return a + b; };
std::cout << operation(1, 2) << '\n';  // 3

operation = [](int a, int b) { return a * b; };
std::cout << operation(3, 4) << '\n';  // 12

// 性能代價: 間接調用,無法內聯
```

### 自定義型別擦除

```cpp
// 高性能型別擦除 (避免堆分配)
template<typename Signature, size_t BufferSize = 32>
class SmallFunction;

template<typename Ret, typename... Args, size_t BufferSize>
class SmallFunction<Ret(Args...), BufferSize> {
    using InvokeFunc = Ret(*)(void*, Args...);
    using DestroyFunc = void(*)(void*);
    
    alignas(std::max_align_t) std::byte buffer_[BufferSize];
    InvokeFunc invoke_ = nullptr;
    DestroyFunc destroy_ = nullptr;
    
public:
    template<typename F>
    SmallFunction(F&& f) {
        static_assert(sizeof(F) <= BufferSize, "Functor too large");
        new (buffer_) F(std::forward<F>(f));
        
        invoke_ = [](void* ptr, Args... args) -> Ret {
            return (*static_cast<F*>(ptr))(std::forward<Args>(args)...);
        };
        
        destroy_ = [](void* ptr) {
            static_cast<F*>(ptr)->~F();
        };
    }
    
    ~SmallFunction() {
        if (destroy_) destroy_(buffer_);
    }
    
    Ret operator()(Args... args) {
        return invoke_(buffer_, std::forward<Args>(args)...);
    }
};
```

---

## 實戰檢查清單

### 型別推導

- [ ] 使用 `auto` 簡化迭代器與複雜型別
- [ ] 使用 `decltype(auto)` 完美轉發返回值
- [ ] 避免 `decltype((expr))` 的引用陷阱
- [ ] 結構化綁定簡化 pair/tuple 解包

### Concepts (C++20)

- [ ] 使用標準 concepts 約束模板
- [ ] 自定義 concept 表達領域需求
- [ ] 優先使用 concept 而非 SFINAE
- [ ] 使用 requires 表達式檢測成員

### 編譯期計算

- [ ] 盡可能使用 `constexpr`
- [ ] 編譯期驗證使用 `static_assert`
- [ ] 使用 `constexpr if` 簡化模板
- [ ] C++20 使用 `consteval` 強制編譯期

### 高頻交易特定

- [ ] 使用 variant 替代虛函數多態
- [ ] 編譯期計算查找表與配置
- [ ] 型別安全的單位與協議
- [ ] 避免型別擦除的性能開銷

---

## 參考資料 (References)

1. Vandevoorde, David, et al. *C++ Templates: The Complete Guide (2nd Edition)*. Addison-Wesley, 2017.
2. Grimm, Rainer. *C++20 - The Complete Guide*. Leanpub, 2021.
3. [C++ Concepts](https://en.cppreference.com/w/cpp/language/constraints)
4. [constexpr Guide](https://www.modernescpp.com/index.php/constexpr)
5. Sutton, Andrew, et al. "Concepts: The Future of Generic Programming in C++."

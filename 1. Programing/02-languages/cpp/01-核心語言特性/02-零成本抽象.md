# 零成本抽象 (Zero-Cost Abstraction)

## 核心理念

> "What you don't use, you don't pay for. And further: What you do use, you couldn't hand code any better."  
> — Bjarne Stroustrup

零成本抽象意味著:
1. **不使用的功能不付出代價**: 未使用的特性不影響生成代碼
2. **使用的功能無法手寫得更好**: 抽象層編譯後與手寫等價

在高頻交易中,零成本抽象允許我們編寫可維護的代碼,同時保持最佳性能。

---

## 內聯 (Inline) 與編譯期優化

### inline 關鍵字

```cpp
// 傳統 inline: 建議編譯器內聯展開
inline int add(int a, int b) {
    return a + b;
}

// 現代用法: inline 主要用於避免 ODR 違規
// 定義在頭文件中的函數
inline void log_message(const char* msg) {
    std::cout << msg << '\n';
}
```

### 強制內聯 (Compiler-Specific)

```cpp
// GCC/Clang
#define FORCE_INLINE __attribute__((always_inline)) inline

// MSVC
#define FORCE_INLINE __forceinline

// 高頻交易: 關鍵路徑函數
FORCE_INLINE uint64_t rdtsc() {
    uint32_t lo, hi;
    __asm__ volatile ("rdtsc" : "=a"(lo), "=d"(hi));
    return (static_cast<uint64_t>(hi) << 32) | lo;
}

FORCE_INLINE double calculate_vwap(double price, uint64_t volume, 
                                     double total_value, uint64_t total_volume) {
    return (total_value + price * volume) / (total_volume + volume);
}
```

### 編譯器優化等級影響

```cpp
// test.cpp
int compute(int x) {
    return x * 2 + 1;
}

int main() {
    int result = compute(10);
    return result;
}
```

```bash
# -O0: 無優化
g++ -O0 -S test.cpp -o test_O0.s

# -O2: 標準優化
g++ -O2 -S test.cpp -o test_O2.s
# 可能內聯 compute(),直接計算 21

# -O3: 激進優化
g++ -O3 -S test.cpp -o test_O3.s

# 查看差異
diff test_O0.s test_O2.s
```

---

## 模板 (Templates): 編譯期多態

### 函數模板

```cpp
// 泛型加法
template<typename T>
T add(T a, T b) {
    return a + b;
}

// 編譯器生成的實際代碼:
// int add(int a, int b) { return a + b; }
// double add(double a, double b) { return a + b; }

int x = add(1, 2);         // 實例化 add<int>
double y = add(1.5, 2.5);  // 實例化 add<double>
```

### 類模板

```cpp
template<typename T>
class Stack {
    std::vector<T> data_;
    
public:
    void push(const T& item) { data_.push_back(item); }
    void push(T&& item) { data_.push_back(std::move(item)); }
    
    T pop() {
        T item = std::move(data_.back());
        data_.pop_back();
        return item;
    }
    
    bool empty() const { return data_.empty(); }
};

Stack<int> int_stack;
Stack<std::string> str_stack;
```

### 模板特化 (Specialization)

```cpp
// 主模板
template<typename T>
struct Serializer {
    static std::vector<uint8_t> serialize(const T& value) {
        // 通用序列化
        return {reinterpret_cast<const uint8_t*>(&value),
                reinterpret_cast<const uint8_t*>(&value) + sizeof(T)};
    }
};

// 完全特化: 針對 std::string
template<>
struct Serializer<std::string> {
    static std::vector<uint8_t> serialize(const std::string& str) {
        std::vector<uint8_t> result(4 + str.size());
        uint32_t size = str.size();
        std::memcpy(result.data(), &size, 4);
        std::memcpy(result.data() + 4, str.data(), str.size());
        return result;
    }
};

// 偏特化: 針對所有指針類型
template<typename T>
struct Serializer<T*> {
    static std::vector<uint8_t> serialize(T* ptr) {
        return Serializer<uintptr_t>::serialize(reinterpret_cast<uintptr_t>(ptr));
    }
};
```

### 高頻交易案例: 定點數 (Fixed-Point)

```cpp
// 使用模板實現定點數運算,避免浮點數誤差
template<typename BaseType, int FracBits>
class FixedPoint {
    BaseType value_;
    
    static constexpr BaseType SCALE = BaseType(1) << FracBits;
    
public:
    constexpr FixedPoint() : value_(0) {}
    
    constexpr explicit FixedPoint(double d) 
        : value_(static_cast<BaseType>(d * SCALE)) {}
    
    constexpr FixedPoint operator+(FixedPoint other) const {
        FixedPoint result;
        result.value_ = value_ + other.value_;
        return result;
    }
    
    constexpr FixedPoint operator*(FixedPoint other) const {
        FixedPoint result;
        result.value_ = (value_ * other.value_) >> FracBits;
        return result;
    }
    
    constexpr double to_double() const {
        return static_cast<double>(value_) / SCALE;
    }
};

using Price = FixedPoint<int64_t, 16>;  // 16 位小數

Price p1(100.25);
Price p2(50.50);
Price total = p1 + p2;  // 編譯期類型安全,運行時整數運算
```

---

## constexpr: 編譯期計算

### constexpr 變量

```cpp
constexpr int BUFFER_SIZE = 1024;
constexpr double PI = 3.14159265358979323846;

// 必須在編譯期求值
std::array<int, BUFFER_SIZE> buffer;  // OK
```

### constexpr 函數

```cpp
// C++11: 單一 return 語句
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}

// C++14: 允許多語句
constexpr int fibonacci(int n) {
    if (n <= 1) return n;
    
    int a = 0, b = 1;
    for (int i = 2; i <= n; ++i) {
        int temp = a + b;
        a = b;
        b = temp;
    }
    return b;
}

// 編譯期計算
constexpr int fib_10 = fibonacci(10);  // 編譯期求值
static_assert(fib_10 == 55);

// 運行時計算
int n;
std::cin >> n;
int fib_n = fibonacci(n);  // 運行時求值
```

### constexpr 與 consteval (C++20)

```cpp
// constexpr: 可在編譯期或運行時執行
constexpr int square(int x) {
    return x * x;
}

// consteval: 強制編譯期執行
consteval int cube(int x) {
    return x * x * x;
}

constexpr int a = square(5);  // 編譯期
int b = square(5);            // 可能運行時

constexpr int c = cube(5);    // 編譯期
// int d = cube(n);           // 錯誤: n 不是常量表達式
```

### 高頻交易: 編譯期訊息格式驗證

```cpp
// 編譯期字串操作
constexpr size_t str_len(const char* s) {
    return *s ? 1 + str_len(s + 1) : 0;
}

constexpr bool validate_symbol(const char* symbol) {
    // 驗證 symbol 格式: 1-8 個大寫字母
    size_t len = str_len(symbol);
    if (len == 0 || len > 8) return false;
    
    for (size_t i = 0; i < len; ++i) {
        if (symbol[i] < 'A' || symbol[i] > 'Z') return false;
    }
    return true;
}

template<size_t N>
struct Symbol {
    char data[N];
    
    constexpr Symbol(const char (&s)[N]) {
        static_assert(validate_symbol(s), "Invalid symbol format");
        for (size_t i = 0; i < N; ++i) data[i] = s[i];
    }
};

constexpr Symbol sym1("AAPL");   // OK
// constexpr Symbol sym2("aapl"); // 編譯錯誤
// constexpr Symbol sym3("TOOLONGSYMBOL"); // 編譯錯誤
```

---

## if constexpr (C++17): 編譯期分支

### 基本用法

```cpp
template<typename T>
auto get_value(T&& t) {
    if constexpr (std::is_pointer_v<std::decay_t<T>>) {
        return *t;  // 指針: 解引用
    } else {
        return t;   // 值類型: 直接返回
    }
}

int x = 10;
int* px = &x;

auto v1 = get_value(x);   // 返回 10
auto v2 = get_value(px);  // 返回 10 (解引用)
```

### 編譯期類型分發

```cpp
template<typename T>
void serialize(std::ostream& os, const T& value) {
    if constexpr (std::is_integral_v<T>) {
        // 整數: 二進制寫入
        os.write(reinterpret_cast<const char*>(&value), sizeof(T));
    } 
    else if constexpr (std::is_floating_point_v<T>) {
        // 浮點數: 轉換為定點數後寫入
        int64_t fixed = static_cast<int64_t>(value * 1000000);
        os.write(reinterpret_cast<const char*>(&fixed), sizeof(fixed));
    }
    else if constexpr (std::is_same_v<T, std::string>) {
        // 字串: 長度 + 內容
        uint32_t len = value.size();
        os.write(reinterpret_cast<const char*>(&len), 4);
        os.write(value.data(), len);
    }
    else {
        static_assert(sizeof(T) == 0, "Unsupported type for serialization");
    }
}
```

### 與運行時 if 的性能對比

```cpp
// 運行時多態
struct Serializer {
    virtual void serialize(std::ostream&) const = 0;
};

struct IntSerializer : Serializer {
    int value;
    void serialize(std::ostream& os) const override {
        os.write(reinterpret_cast<const char*>(&value), sizeof(value));
    }
};

// if constexpr: 零開銷,編譯期確定
template<typename T>
struct StaticSerializer {
    T value;
    void serialize(std::ostream& os) const {
        if constexpr (std::is_integral_v<T>) {
            os.write(reinterpret_cast<const char*>(&value), sizeof(value));
        }
        // 其他分支在此實例化中不存在
    }
};

// 性能對比:
// 虛函數:          間接調用,無法內聯
// if constexpr:    直接調用,可內聯,無分支
```

---

## 模板元編程 (Template Metaprogramming)

### 編譯期遞迴

```cpp
// 編譯期計算階乘
template<int N>
struct Factorial {
    static constexpr int value = N * Factorial<N - 1>::value;
};

template<>
struct Factorial<0> {
    static constexpr int value = 1;
};

static_assert(Factorial<5>::value == 120);

// C++14 後更推薦使用 constexpr 函數
constexpr int factorial(int n) {
    return n <= 1 ? 1 : n * factorial(n - 1);
}
```

### 型別列表 (Type List)

```cpp
// 實現 std::tuple 的簡化版
template<typename... Types>
struct TypeList {};

// 取得第 N 個型別
template<size_t N, typename List>
struct GetType;

template<size_t N, typename Head, typename... Tail>
struct GetType<N, TypeList<Head, Tail...>> {
    using type = typename GetType<N - 1, TypeList<Tail...>>::type;
};

template<typename Head, typename... Tail>
struct GetType<0, TypeList<Head, Tail...>> {
    using type = Head;
};

using MyTypes = TypeList<int, double, std::string>;
using SecondType = typename GetType<1, MyTypes>::type;  // double
```

### 高頻交易: 編譯期訊息路由

```cpp
// 編譯期建立訊息類型 -> 處理器映射
template<typename MsgType>
struct MessageHandler;

template<>
struct MessageHandler<NewOrderMsg> {
    static void handle(const NewOrderMsg& msg) {
        // 處理新訂單
    }
};

template<>
struct MessageHandler<CancelOrderMsg> {
    static void handle(const CancelOrderMsg& msg) {
        // 處理取消訂單
    }
};

// 統一入口: 編譯期分發
template<typename MsgType>
void dispatch_message(const MsgType& msg) {
    MessageHandler<MsgType>::handle(msg);  // 零開銷分發
}
```

---

## Lambda 表達式優化

### Lambda 的零開銷本質

```cpp
// Lambda 本質是匿名函數對象
auto add = [](int a, int b) { return a + b; };

// 等價於:
struct __lambda_add {
    auto operator()(int a, int b) const { return a + b; }
};
__lambda_add add;

// 編譯後內聯展開,無函數調用開銷
```

### 捕獲優化

```cpp
// ❌ 值捕獲大對象
std::vector<int> data(1000);
auto lambda1 = [data]() {  // 拷貝整個 vector!
    return data.size();
};

// ✅ 引用捕獲
auto lambda2 = [&data]() {
    return data.size();
};

// ✅ 移動捕獲 (C++14)
auto lambda3 = [data = std::move(data)]() {
    return data.size();
};

// ✅ 成員捕獲 (C++14)
auto lambda4 = [size = data.size()]() {
    return size;
};
```

### 立即調用 Lambda (IIFE)

```cpp
// 初始化複雜常量
const auto config = [&]() {
    Config cfg;
    cfg.load_from_file("config.json");
    cfg.validate();
    return cfg;
}();

// 條件初始化
const int value = [](bool condition) {
    if (condition) {
        return expensive_computation();
    } else {
        return default_value();
    }
}(some_condition);
```

### 高頻交易: 無狀態 Lambda

```cpp
// 無捕獲 Lambda 可轉換為函數指針 (零開銷)
using Predicate = bool(*)(const Order&);

Predicate is_valid = [](const Order& order) {
    return order.price > 0 && order.quantity > 0;
};

// 可內聯,無間接調用
bool check_order(const Order& order, Predicate pred) {
    return pred(order);  // 編譯器可內聯
}
```

---

## 屬性 (Attributes): 編譯器提示

### 標準屬性 (C++11/14/17/20)

```cpp
// [[nodiscard]]: 警告忽略返回值
[[nodiscard]] int calculate() {
    return 42;
}

void test() {
    calculate();  // 警告: 忽略了返回值
}

// [[maybe_unused]]: 消除未使用警告
void process([[maybe_unused]] int debug_param) {
#ifdef DEBUG
    std::cout << debug_param;
#endif
}

// [[likely]] / [[unlikely]]: 分支預測提示 (C++20)
int process_order(Order& order) {
    if (order.is_valid()) [[likely]] {
        // 大多數情況走這個分支
        return execute_order(order);
    } else [[unlikely]] {
        // 極少發生
        return reject_order(order);
    }
}

// [[fallthrough]]: 顯式 switch fallthrough
switch (msg_type) {
    case MsgType::NEW_ORDER:
        log("New order");
        [[fallthrough]];
    case MsgType::REPLACE_ORDER:
        validate_order();
        break;
}
```

### 編譯器特定屬性

```cpp
// GCC/Clang: hot/cold 提示
[[gnu::hot]] void critical_path() {
    // 頻繁調用的函數
}

[[gnu::cold]] void error_handler() {
    // 極少調用,可放到冷區
}

// 禁用優化 (調試用)
[[gnu::optimize("O0")]] void debug_function() {
    // 此函數不優化
}

// 對齊屬性
struct [[gnu::packed]] PackedData {
    char c;
    int i;
};  // 無 padding

struct [[gnu::aligned(64)]] CacheLineAligned {
    int data[16];
};  // 對齊到 cache line
```

---

## 零開銷抽象實戰案例

### 案例 1: 型別安全的訊息處理

```cpp
// 編譯期保證訊息類型安全
template<typename MsgType>
class TypedMessage {
    std::vector<uint8_t> buffer_;
    
public:
    TypedMessage() : buffer_(sizeof(MsgType)) {}
    
    MsgType* data() {
        return reinterpret_cast<MsgType*>(buffer_.data());
    }
    
    const MsgType* data() const {
        return reinterpret_cast<const MsgType*>(buffer_.data());
    }
    
    void send(int socket_fd) const {
        ::send(socket_fd, buffer_.data(), buffer_.size(), 0);
    }
};

// 使用
TypedMessage<NewOrderMsg> msg;
msg.data()->symbol = "AAPL";
msg.data()->price = 150.25;
msg.send(socket_fd);  // 類型安全,零運行時開銷
```

### 案例 2: 編譯期單位檢查

```cpp
// 防止單位混淆的零開銷抽象
template<typename Unit>
struct Quantity {
    double value;
    
    explicit constexpr Quantity(double v) : value(v) {}
    
    constexpr Quantity operator+(Quantity other) const {
        return Quantity(value + other.value);
    }
    
    constexpr Quantity operator-(Quantity other) const {
        return Quantity(value - other.value);
    }
    
    // 不同單位之間禁止運算 (編譯期錯誤)
};

struct PriceUnit {};
struct QuantityUnit {};

using Price = Quantity<PriceUnit>;
using Size = Quantity<QuantityUnit>;

Price p1(100.0);
Price p2(50.0);
Price total = p1 + p2;  // OK

Size s(1000);
// Price wrong = p1 + s;  // 編譯錯誤: 單位不匹配!

// 定義有意義的運算
constexpr double notional_value(Price price, Size size) {
    return price.value * size.value;
}
```

### 案例 3: 環形緩衝區模板

```cpp
template<typename T, size_t Capacity>
class RingBuffer {
    static_assert(Capacity > 0, "Capacity must be positive");
    static_assert((Capacity & (Capacity - 1)) == 0, 
                  "Capacity must be power of 2");  // 編譯期檢查
    
    std::array<T, Capacity> buffer_;
    size_t head_ = 0;
    size_t tail_ = 0;
    
    static constexpr size_t MASK = Capacity - 1;
    
public:
    bool push(const T& item) {
        size_t next = (head_ + 1) & MASK;  // 位運算取代取模
        if (next == tail_) return false;
        
        buffer_[head_] = item;
        head_ = next;
        return true;
    }
    
    bool pop(T& item) {
        if (tail_ == head_) return false;
        
        item = buffer_[tail_];
        tail_ = (tail_ + 1) & MASK;
        return true;
    }
};

// 實例化: 編譯期確定大小,無動態分配
RingBuffer<Order, 1024> order_queue;
```

---

## 效能分析: 零成本驗證

### 使用 Compiler Explorer

```cpp
// https://godbolt.org/

// 測試代碼
int add_raw(int a, int b) {
    return a + b;
}

template<typename T>
T add_template(T a, T b) {
    return a + b;
}

auto add_lambda = [](int a, int b) { return a + b; };

// 比較生成的匯編代碼
// 編譯選項: -O2 -std=c++20
// 結果: 三者生成完全相同的機器碼!
```

### 使用 Benchmark

```cpp
#include <benchmark/benchmark.h>

// 運行時多態
struct Base {
    virtual int compute(int x) const = 0;
};

struct Derived : Base {
    int compute(int x) const override { return x * 2; }
};

static void BM_Virtual(benchmark::State& state) {
    Derived d;
    Base* p = &d;
    for (auto _ : state) {
        benchmark::DoNotOptimize(p->compute(42));
    }
}

// 編譯期多態
template<typename T>
int compute_static(const T& obj, int x) {
    return obj.compute(x);
}

struct StaticCompute {
    int compute(int x) const { return x * 2; }
};

static void BM_Static(benchmark::State& state) {
    StaticCompute obj;
    for (auto _ : state) {
        benchmark::DoNotOptimize(compute_static(obj, 42));
    }
}

BENCHMARK(BM_Virtual);   // ~2-3ns
BENCHMARK(BM_Static);    // ~0.5ns (內聯後可能為 0)
```

---

## 實戰檢查清單

### 模板使用

- [ ] 優先使用函數模板而非宏
- [ ] 對不變的模板參數使用 `constexpr`
- [ ] 使用 `if constexpr` 替代 SFINAE (C++17+)
- [ ] 避免過度模板化 (編譯時間 vs 性能)

### constexpr 優化

- [ ] 所有可編譯期計算的值標記為 `constexpr`
- [ ] 使用 `constexpr` 函數替代宏
- [ ] 使用 `consteval` 強制編譯期求值 (C++20)
- [ ] 利用 `static_assert` 進行編譯期驗證

### 內聯優化

- [ ] 關鍵路徑小函數標記 `inline`
- [ ] 必要時使用編譯器特定的強制內聯
- [ ] 使用 `-flto` 啟用鏈接時優化 (LTO)
- [ ] 檢查生成的匯編代碼驗證內聯

### 高頻交易特定

- [ ] 熱路徑使用編譯期多態 (模板)
- [ ] 避免虛函數調用
- [ ] 使用 `[[likely]]`/`[[unlikely]]` 優化分支
- [ ] 編譯期計算查找表

---

## 參考資料 (References)

1. Alexandrescu, Andrei. *Modern C++ Design*. Addison-Wesley, 2001.
2. Vandevoorde, David, et al. *C++ Templates: The Complete Guide (2nd Edition)*. Addison-Wesley, 2017.
3. [Compiler Explorer (Godbolt)](https://godbolt.org/)
4. [C++ Insights - See how the compiler sees your code](https://cppinsights.io/)
5. Stroustrup, Bjarne. "Zero-overhead principle." *The C++ Programming Language (4th Edition)*. Addison-Wesley, 2013.

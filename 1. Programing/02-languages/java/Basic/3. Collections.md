# 集合體系結構
---
集合分為 Collection 與 Map 兩種分別對應單列與雙列。
### Collection
表示單列結構，本身**為 interface**，繼承於 **Iterable** 接口，有兩個重要的繼承接口
1. List: 有索引，有三個重要的實現類
	1. ArrayList
	2. LinkedList
	3. Vector
2. Set: 沒有索引，有三個重要的實現類
	1. HashSet
	2. LinkedHashSet
	3. TreeSet
![[Screen Shot 2022-10-17 at 11.21.23 AM.png|500]]
### Map
表示雙鏈結構，本身**為 interface**，有三個重要的實現類
1. Hashtable
2. HashMap
3. TreeMap
![[Screen Shot 2022-10-17 at 11.21.28 AM.png|500]]

# Collection
---
### Collection 接口
```java
public interface Collection<E> extends Iterable<E>
```
* Collection 接口沒有直接的實現類，都是使用其子接口 List 與 Set 來實現的。
* Collection 的實現類可以是有索引(List)的與無索引(Set)的。
* Collection 繼承 [[4. Useful Interface#Iterable <T>|Iterable<E>]] 接口。
#### 常用的CRUD方法
##### 單個
1. 添加: boolean add(E e)
2. 刪除: boolean remove(E e)
3. 存在: boolean contains(E e)
##### 多個
1. 添加多個: boolean addAll(Collection \<? extends E\> c)
2. 刪除相同: boolean removeAll(Collection\<? extends E\> c)
3. 同時存在: boolean containsAll(Collection\<? extends E\> c)
```java
Collection<String> list = new List<>();
list.add("abc");
list.add("dbc");

Collection<String> list2 = new List<>();
list2.add("abc");
list1.removeAll(list);
```
##### 其他
1. 轉成Array: \<T\> T\[\] toArray();
2. 數量: int size()
3. 清空: void clear()
4. 是否空: boolean isEmpty();

### List 接口
為**可索引的單列**結構。
```java
public interface List<E> extends Collection<E>
```
#### 常用的CRUD方法
這邊只列出 List 相較於 Collection 獨有的方法。
##### 單個
1. 按索引添加一個: boolean add(int index, E e)
2. 按索引刪除一個: boolean remove(index)
##### 多個
1. 按索引添加多個: boolean addAll(int index, Collection\<? extends E\> c)
##### 其他
1. 取得: get(int index)
2. 改寫: set(int index, E e)
3. 取得第一個相同的索引: indexOf(Object e)
4. 取得最後一個相同的索引: lastIndexOf(Object e)

#### ArrayList
與 Vector 相同，但是沒有多線程安全，但在單線程下效率較高。
```java
public class ArrayList<E> extends AbstractList<E>  
        implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```
* 以上接口請參照: [[4. Useful Interface]]

底層維護一個**數組**用還存儲數據
```java
transient Object[] elementData;
```
* 使用Object 是因為[[The Java Pitfall|java不支持泛型數組]]
* transient 表示不會被序列化。
	* 主要是因為 elementData 與實際 Data 有差，序列化只會在實際數據上，這不會影響整個 ArrayList 能否被序列化。

#### Vector
為多線程安全版 ArrayList，所有方法都有 synchronized 修飾
```java
public class Vector<E>  
    extends AbstractList<E>  
    implements List<E>, RandomAccess, Cloneable, java.io.Serializable
```

底層也是維護**數組**
```java
protected Object[] elementData;
```

#### LinkedList
為線程不安全的雙向鍊表。
```java
public class LinkedList<E>  
    extends AbstractSequentialList<E>  
    implements List<E>, Deque<E>, Cloneable, java.io.Serializable  
{  
    transient int size = 0;  
    transient Node<E> first;
    transient Node<E> last;
}
```
##### 特有方法
* 向頭添加: void addFirst(E e)
* 向頭添加: E removeFirst()
* 向尾添加: void addLast(E e)
* 向尾添加: E removeLast()

### Set 接口
為**不可索引**且**不可有重複元素**的單列結構。
```java
public interface Set<E> extends Collection<E>
```
* Set 為  Collection 的子接口，故可以使用所有 Collection 的方法。 
* 方法與 List 很相似，只是沒有關於索引的一系列方法。

#### HashSet
```java
public class HashSet<E>  
    extends AbstractSet<E>  
    implements Set<E>, Cloneable, java.io.Serializable
```
為 Set 的實現類之一，**本質上是沒有 value 的 HashMap**，故不保證元素有序，順序取決於對象的 Hash 值，且不能有重複的對象。
##### 底層機制
![[Screen Shot 2022-10-19 at 9.18.11 PM.png|500]]
1. 添加元素時，計算其 Hash 值，並轉換成索引值
2. 找到 table 中對應的位置。
3. 若索引位置為空，則直接放入
4. 若索引位置不為空，調用 equals() 方法進行比較
5. 相同則不添加。
6. 不相同則在 LinkedList 中添加。
7. 若 LinkedList 長度超過 TREEIFY_THRESHOLD (默認為8) 時，會將 LinkedList 轉換成 RBTree
> 不同的對象比較:
> 1. 比較地址: new A() == new A();
> 2. 比較HashCode: new A().hashCode() == new A().hashCode();
> 3. 比較equals: new A().equals(new A())
> 此三種比較各自獨立。

#### LinkedHashSet
```java
public class LinkedHashSet<E>  
    extends HashSet<E>  
    implements Set<E>, Cloneable, java.io.Serializable {
```
為可以保證順序(插入與讀取)一致的 HashSet，原理與 HashSet 一樣，但是維護了一個雙向練表保存插入順序，實際為沒有 value 的 LinkedHashMap。


# Map
---
### Map 接口
```java
public interface Map<K, V>
```

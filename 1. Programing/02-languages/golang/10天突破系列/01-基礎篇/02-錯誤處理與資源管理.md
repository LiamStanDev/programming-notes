# Day 2ï¼šéŒ¯èª¤è™•ç†èˆ‡è³‡æºç®¡ç†

## ğŸ“š å­¸ç¿’ç›®æ¨™

- æŒæ¡ Go çš„é¡¯å¼éŒ¯èª¤è™•ç†æ…£ä¾‹
- ç†è§£éŒ¯èª¤åŒ…è£èˆ‡è‡ªå®šç¾©éŒ¯èª¤
- ç†Ÿç·´ä½¿ç”¨ `defer` ç®¡ç†è³‡æºç”Ÿå‘½é€±æœŸ
- ç†è§£ `panic` èˆ‡ `recover` çš„é©ç”¨å ´æ™¯

---

## 1. Go çš„éŒ¯èª¤è™•ç†å“²å­¸

### 1.1 éŒ¯èª¤æ˜¯å€¼ (Errors are Values)

Go ä¸ä½¿ç”¨ç•°å¸¸æ©Ÿåˆ¶ï¼Œè€Œæ˜¯å°‡éŒ¯èª¤ä½œç‚ºæ™®é€šçš„è¿”å›å€¼ã€‚

```go
// æ¨™æº–éŒ¯èª¤è™•ç†æ¨¡å¼
func ReadConfig(filename string) (*Config, error) {
    data, err := os.ReadFile(filename)
    if err != nil {
        return nil, err  // é¡¯å¼è¿”å›éŒ¯èª¤
    }
    
    var config Config
    err = json.Unmarshal(data, &config)
    if err != nil {
        return nil, err
    }
    
    return &config, nil  // æˆåŠŸæ™‚è¿”å› nil éŒ¯èª¤
}

// ä½¿ç”¨
config, err := ReadConfig("config.json")
if err != nil {
    log.Fatal(err)
}
```

### 1.2 error æ¥å£

```go
// error æ˜¯ä¸€å€‹å…§å»ºæ¥å£
type error interface {
    Error() string
}

// ä»»ä½•å¯¦ç¾äº† Error() æ–¹æ³•çš„é¡å‹éƒ½æ˜¯ error
type MyError struct {
    Message string
    Code    int
}

func (e *MyError) Error() string {
    return fmt.Sprintf("Error %d: %s", e.Code, e.Message)
}
```

---

## 2. å‰µå»ºéŒ¯èª¤

### 2.1 ä½¿ç”¨ errors.New

```go
import "errors"

func ValidateAge(age int) error {
    if age < 0 {
        return errors.New("age cannot be negative")
    }
    if age > 150 {
        return errors.New("age is unrealistically high")
    }
    return nil
}
```

### 2.2 ä½¿ç”¨ fmt.Errorfï¼ˆæ ¼å¼åŒ–éŒ¯èª¤ï¼‰

```go
func GetUser(id int) (*User, error) {
    if id <= 0 {
        return nil, fmt.Errorf("invalid user ID: %d", id)
    }
    // ...
}
```

### 2.3 è‡ªå®šç¾©éŒ¯èª¤é¡å‹

```go
// å®šç¾©éŒ¯èª¤é¡å‹
type ValidationError struct {
    Field   string
    Message string
}

func (e *ValidationError) Error() string {
    return fmt.Sprintf("validation failed on field '%s': %s", e.Field, e.Message)
}

// ä½¿ç”¨
func ValidateUser(user *User) error {
    if user.Email == "" {
        return &ValidationError{
            Field:   "email",
            Message: "email is required",
        }
    }
    return nil
}

// å‹åˆ¥æ–·è¨€æª¢æŸ¥éŒ¯èª¤é¡å‹
err := ValidateUser(user)
if err != nil {
    var valErr *ValidationError
    if errors.As(err, &valErr) {
        fmt.Printf("Field: %s, Message: %s\n", valErr.Field, valErr.Message)
    }
}
```

---

## 3. éŒ¯èª¤åŒ…è£ (Error Wrapping)

### 3.1 ä½¿ç”¨ fmt.Errorf èˆ‡ %w

Go 1.13+ å¼•å…¥äº†éŒ¯èª¤åŒ…è£æ©Ÿåˆ¶ï¼Œç”¨æ–¼ä¿ç•™åŸå§‹éŒ¯èª¤éˆã€‚

```go
func LoadUser(id int) (*User, error) {
    user, err := db.Query(id)
    if err != nil {
        // %w åŒ…è£åŸå§‹éŒ¯èª¤
        return nil, fmt.Errorf("failed to load user %d: %w", id, err)
    }
    return user, nil
}

func GetUserProfile(id int) (*Profile, error) {
    user, err := LoadUser(id)
    if err != nil {
        // ç¹¼çºŒåŒ…è£
        return nil, fmt.Errorf("get user profile: %w", err)
    }
    // ...
}
```

### 3.2 è§£åŒ…éŒ¯èª¤

```go
import "errors"

// errors.Isï¼šåˆ¤æ–·éŒ¯èª¤éˆä¸­æ˜¯å¦åŒ…å«ç‰¹å®šéŒ¯èª¤
var ErrNotFound = errors.New("not found")

func FindUser(id int) error {
    return fmt.Errorf("user lookup failed: %w", ErrNotFound)
}

err := FindUser(1)
if errors.Is(err, ErrNotFound) {
    fmt.Println("User not found")
}

// errors.Asï¼šæå–éŒ¯èª¤éˆä¸­çš„ç‰¹å®šé¡å‹
type DBError struct {
    Query string
    Err   error
}

func (e *DBError) Error() string {
    return fmt.Sprintf("database error on query '%s': %v", e.Query, e.Err)
}

func (e *DBError) Unwrap() error {
    return e.Err
}

var dbErr *DBError
if errors.As(err, &dbErr) {
    fmt.Println("Database query:", dbErr.Query)
}
```

---

## 4. è³‡æºç®¡ç†ï¼šdefer

### 4.1 defer åŸºç¤

`defer` å»¶é²å‡½æ•¸èª¿ç”¨ï¼Œåœ¨å‡½æ•¸è¿”å›å‰åŸ·è¡Œï¼ˆç„¡è«–æ˜¯æ­£å¸¸è¿”å›é‚„æ˜¯ panicï¼‰ã€‚

```go
func ReadFile(filename string) (string, error) {
    file, err := os.Open(filename)
    if err != nil {
        return "", err
    }
    defer file.Close()  // ä¿è­‰æ–‡ä»¶è¢«é—œé–‰
    
    data, err := io.ReadAll(file)
    if err != nil {
        return "", err
    }
    
    return string(data), nil
}
```

### 4.2 defer çš„åŸ·è¡Œé †åºï¼ˆLIFOï¼‰

```go
func main() {
    defer fmt.Println("First")
    defer fmt.Println("Second")
    defer fmt.Println("Third")
    
    fmt.Println("Main")
}

// è¼¸å‡º:
// Main
// Third
// Second
// First
```

### 4.3 defer çš„å¸¸è¦‹é™·é˜±

#### é™·é˜± 1ï¼šåƒæ•¸ç«‹å³æ±‚å€¼

```go
func main() {
    x := 1
    defer fmt.Println(x)  // æ•ç²ç•¶å‰å€¼ 1
    x = 2
    // è¼¸å‡º: 1ï¼ˆä¸æ˜¯ 2ï¼‰
}

// è§£æ±ºæ–¹æ¡ˆï¼šä½¿ç”¨é–‰åŒ…
func main() {
    x := 1
    defer func() {
        fmt.Println(x)  // è¼¸å‡º: 2
    }()
    x = 2
}
```

#### é™·é˜± 2ï¼šåœ¨å¾ªç’°ä¸­ä½¿ç”¨ defer

```go
// âŒ éŒ¯èª¤ï¼šæ‰€æœ‰æ–‡ä»¶åœ¨å‡½æ•¸çµæŸæ™‚æ‰é—œé–‰
func ProcessFiles(filenames []string) error {
    for _, name := range filenames {
        file, err := os.Open(name)
        if err != nil {
            return err
        }
        defer file.Close()  // ç´¯ç© deferï¼Œå¯èƒ½è€—ç›¡æ–‡ä»¶æè¿°ç¬¦
        
        // è™•ç†æ–‡ä»¶...
    }
    return nil
}

// âœ… æ­£ç¢ºï¼šä½¿ç”¨åŒ¿åå‡½æ•¸ç«‹å³é—œé–‰
func ProcessFiles(filenames []string) error {
    for _, name := range filenames {
        err := func() error {
            file, err := os.Open(name)
            if err != nil {
                return err
            }
            defer file.Close()  // æ¯æ¬¡è¿­ä»£çµæŸæ™‚é—œé–‰
            
            // è™•ç†æ–‡ä»¶...
            return nil
        }()
        if err != nil {
            return err
        }
    }
    return nil
}
```

### 4.4 defer èˆ‡è¿”å›å€¼

```go
// å‘½åè¿”å›å€¼å¯ä»¥åœ¨ defer ä¸­ä¿®æ”¹
func Increment(x int) (result int) {
    defer func() {
        result++  // ä¿®æ”¹è¿”å›å€¼
    }()
    return x
}

fmt.Println(Increment(5))  // è¼¸å‡º: 6

// å¯¦æˆ°æ¡ˆä¾‹ï¼šè³‡æºæ¸…ç† + éŒ¯èª¤è™•ç†
func UpdateUser(id int, data map[string]interface{}) (err error) {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    
    defer func() {
        if err != nil {
            tx.Rollback()  // ç™¼ç”ŸéŒ¯èª¤æ™‚å›æ»¾
        } else {
            err = tx.Commit()  // æˆåŠŸæ™‚æäº¤
        }
    }()
    
    // åŸ·è¡Œå¤šå€‹æ•¸æ“šåº«æ“ä½œ
    err = tx.Update("users", id, data)
    if err != nil {
        return err
    }
    
    err = tx.Log("user_updated", id)
    if err != nil {
        return err
    }
    
    return nil
}
```

---

## 5. panic èˆ‡ recover

### 5.1 ä½•æ™‚ä½¿ç”¨ panic

`panic` æ‡‰è©²åƒ…åœ¨ä¸å¯æ¢å¾©çš„éŒ¯èª¤æ™‚ä½¿ç”¨ï¼Œä¾‹å¦‚ï¼š
- åˆå§‹åŒ–å¤±æ•—ï¼ˆç¨‹åºç„¡æ³•ç¹¼çºŒï¼‰
- ç¨‹åºé‚è¼¯éŒ¯èª¤ï¼ˆä¸æ‡‰è©²ç™¼ç”Ÿçš„æƒ…æ³ï¼‰

```go
func MustLoadConfig(filename string) *Config {
    config, err := LoadConfig(filename)
    if err != nil {
        panic(fmt.Sprintf("failed to load config: %v", err))
    }
    return config
}

func init() {
    // åˆå§‹åŒ–å‡½æ•¸ä¸­å¯ä»¥ä½¿ç”¨ panic
    db = MustConnect("localhost:5432")
}
```

### 5.2 recover æ•ç² panic

```go
func SafeExecute(fn func()) (err error) 
    defer func() {
        if r := recover(); r != nil {
            // å°‡ panic è½‰æ›ç‚º error
            err = fmt.Errorf("panic recovered: %v", r)
        }
    }()
    
    fn()
    return nil
}

// ä½¿ç”¨
err := SafeExecute(func() {
    panic("something went wrong")
})
if err != nil {
    fmt.Println(err)  // è¼¸å‡º: panic recovered: something went wrong
}
```

### 5.3 å¯¦æˆ°ï¼šHTTP æœå‹™å™¨çš„ panic æ¢å¾©

```go
func RecoveryMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        defer func() {
            if err := recover(); err != nil {
                // è¨˜éŒ„éŒ¯èª¤
                log.Printf("Panic: %v\n%s", err, debug.Stack())
                
                // è¿”å› 500 éŒ¯èª¤
                http.Error(w, "Internal Server Error", http.StatusInternalServerError)
            }
        }()
        
        next.ServeHTTP(w, r)
    })
}
```

---

## 6. éŒ¯èª¤è™•ç†æœ€ä½³å¯¦è¸

### 6.1 éŒ¯èª¤åˆ†é¡

```go
package errs

import "errors"

var (
    // é ˜åŸŸéŒ¯èª¤
    ErrUserNotFound     = errors.New("user not found")
    ErrInvalidInput     = errors.New("invalid input")
    ErrUnauthorized     = errors.New("unauthorized")
    
    // åŸºç¤è¨­æ–½éŒ¯èª¤
    ErrDatabaseConnection = errors.New("database connection failed")
    ErrCacheTimeout       = errors.New("cache operation timeout")
)

// è‡ªå®šç¾©éŒ¯èª¤é¡å‹
type AppError struct {
    Code    string
    Message string
    Err     error
}

func (e *AppError) Error() string {
    if e.Err != nil {
        return fmt.Sprintf("[%s] %s: %v", e.Code, e.Message, e.Err)
    }
    return fmt.Sprintf("[%s] %s", e.Code, e.Message)
}

func (e *AppError) Unwrap() error {
    return e.Err
}

// å·¥å» å‡½æ•¸
func NewAppError(code, message string, err error) *AppError {
    return &AppError{
        Code:    code,
        Message: message,
        Err:     err,
    }
}
```

### 6.2 Repository å±¤éŒ¯èª¤è™•ç†

```go
package repository

type UserRepository struct {
    db *sqlx.DB
}

func (r *UserRepository) GetByID(id int) (*User, error) {
    var user User
    err := r.db.Get(&user, "SELECT * FROM users WHERE id = $1", id)
    if err != nil {
        if err == sql.ErrNoRows {
            return nil, errs.ErrUserNotFound
        }
        return nil, fmt.Errorf("query user by id: %w", err)
    }
    return &user, nil
}
```

### 6.3 Service å±¤éŒ¯èª¤è™•ç†

```go
package service

type UserService struct {
    repo   *repository.UserRepository
    logger Logger
}

func (s *UserService) GetUser(id int) (*User, error) {
    user, err := s.repo.GetByID(id)
    if err != nil {
        if errors.Is(err, errs.ErrUserNotFound) {
            s.logger.Info("User not found", "id", id)
            return nil, err
        }
        s.logger.Error("Failed to get user", "id", id, "error", err)
        return nil, fmt.Errorf("get user service: %w", err)
    }
    return user, nil
}
```

### 6.4 Handler å±¤éŒ¯èª¤è™•ç†

```go
package handler

func (h *UserHandler) GetUser(c *fiber.Ctx) error {
    id, err := c.ParamsInt("id")
    if err != nil {
        return c.Status(400).JSON(fiber.Map{
            "error": "invalid user ID",
        })
    }
    
    user, err := h.service.GetUser(id)
    if err != nil {
        if errors.Is(err, errs.ErrUserNotFound) {
            return c.Status(404).JSON(fiber.Map{
                "error": "user not found",
            })
        }
        return c.Status(500).JSON(fiber.Map{
            "error": "internal server error",
        })
    }
    
    return c.JSON(user)
}
```

---

## 7. è³‡æºç®¡ç†æ¨¡å¼

### 7.1 æ•¸æ“šåº«é€£æ¥æ± ç®¡ç†

```go
type DB struct {
    *sqlx.DB
}

func NewDB(dsn string) (*DB, error) {
    db, err := sqlx.Connect("postgres", dsn)
    if err != nil {
        return nil, fmt.Errorf("connect to database: %w", err)
    }
    
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    db.SetConnMaxLifetime(5 * time.Minute)
    
    return &DB{db}, nil
}

func (db *DB) Close() error {
    return db.DB.Close()
}

// ä½¿ç”¨
func main() {
    db, err := NewDB(os.Getenv("DATABASE_URL"))
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    // æ‡‰ç”¨é‚è¼¯...
}
```

### 7.2 æ–‡ä»¶æ“ä½œæ¨¡å¼

```go
func WriteJSON(filename string, data interface{}) error {
    file, err := os.Create(filename)
    if err != nil {
        return fmt.Errorf("create file: %w", err)
    }
    defer file.Close()
    
    encoder := json.NewEncoder(file)
    encoder.SetIndent("", "  ")
    
    if err := encoder.Encode(data); err != nil {
        return fmt.Errorf("encode json: %w", err)
    }
    
    return nil
}
```

### 7.3 HTTP è«‹æ±‚è³‡æºç®¡ç†

```go
func FetchData(url string) ([]byte, error) {
    resp, err := http.Get(url)
    if err != nil {
        return nil, fmt.Errorf("http get: %w", err)
    }
    defer resp.Body.Close()
    
    if resp.StatusCode != http.StatusOK {
        return nil, fmt.Errorf("unexpected status code: %d", resp.StatusCode)
    }
    
    body, err := io.ReadAll(resp.Body)
    if err != nil {
        return nil, fmt.Errorf("read response body: %w", err)
    }
    
    return body, nil
}
```

---

## 8. å¯¦æˆ°ç·´ç¿’

### ç·´ç¿’ 1ï¼šå¯¦ç¾é‡è©¦æ©Ÿåˆ¶

```go
func RetryWithBackoff(fn func() error, maxRetries int) error {
    var err error
    for i := 0; i < maxRetries; i++ {
        err = fn()
        if err == nil {
            return nil
        }
        
        // TODO: å¯¦ç¾æŒ‡æ•¸é€€é¿
        // time.Sleep(?)
    }
    return fmt.Errorf("max retries exceeded: %w", err)
}
```

### ç·´ç¿’ 2ï¼šå¯¦ç¾éŒ¯èª¤èšåˆ

```go
type MultiError struct {
    Errors []error
}

func (m *MultiError) Error() string {
    // TODO: å¯¦ç¾
}

func (m *MultiError) Add(err error) {
    // TODO: å¯¦ç¾
}

func ValidateUser(user *User) error {
    var merr MultiError
    
    if user.Email == "" {
        merr.Add(errors.New("email is required"))
    }
    if user.Age < 0 {
        merr.Add(errors.New("age cannot be negative"))
    }
    
    if len(merr.Errors) > 0 {
        return &merr
    }
    return nil
}
```

### ç·´ç¿’ 3ï¼šå¯¦ç¾äº‹å‹™åŒ…è£å™¨

```go
func WithTransaction(db *sqlx.DB, fn func(*sqlx.Tx) error) error {
    // TODO: å¯¦ç¾äº‹å‹™é–‹å•Ÿã€æäº¤å’Œå›æ»¾é‚è¼¯
}

// ä½¿ç”¨ç¤ºä¾‹
err := WithTransaction(db, func(tx *sqlx.Tx) error {
    _, err := tx.Exec("INSERT INTO users ...")
    if err != nil {
        return err
    }
    
    _, err = tx.Exec("INSERT INTO profiles ...")
    return err
})
```

---

## 9. æœ€ä½³å¯¦è¸ç¸½çµ

### âœ… Do's
1. **ç¸½æ˜¯æª¢æŸ¥ error è¿”å›å€¼**
2. **ä½¿ç”¨ `%w` åŒ…è£éŒ¯èª¤ä»¥ä¿ç•™ä¸Šä¸‹æ–‡**
3. **åœ¨å‡½æ•¸é–‹å§‹è™•æª¢æŸ¥åƒæ•¸ï¼Œå¿«é€Ÿå¤±æ•—**
4. **ä½¿ç”¨ `defer` ç®¡ç†è³‡æºï¼Œä¿è­‰æ¸…ç†**
5. **å®šç¾©é ˜åŸŸç‰¹å®šçš„éŒ¯èª¤å¸¸é‡**
6. **åœ¨é©ç•¶çš„å±¤ç´šè™•ç†éŒ¯èª¤ï¼ˆä¸è¦éæ—©åŒ…è£ï¼‰**

### âŒ Don'ts
1. **ä¸è¦å¿½ç•¥éŒ¯èª¤ï¼ˆä½¿ç”¨ `_` æ™‚éœ€ä¸‰æ€ï¼‰**
2. **ä¸è¦éåº¦ä½¿ç”¨ panicï¼ˆåƒ…ç”¨æ–¼çœŸæ­£çš„ç¨‹åºéŒ¯èª¤ï¼‰**
3. **ä¸è¦åœ¨å¾ªç’°ä¸­ç´¯ç© defer**
4. **ä¸è¦é‡è¤‡è™•ç†åŒä¸€å€‹éŒ¯èª¤**
5. **ä¸è¦è¿”å›æ¨¡ç³Šçš„éŒ¯èª¤ä¿¡æ¯**

---

## 10. å»¶ä¼¸é–±è®€

- [Error Handling in Go](https://go.dev/blog/error-handling-and-go)
- [Working with Errors in Go 1.13](https://go.dev/blog/go1.13-errors)
- [Defer, Panic, and Recover](https://go.dev/blog/defer-panic-and-recover)

---

**ä¸Šä¸€ç¯‡**: [Day 1 - Go èªæ³•åŸºç¤èˆ‡å‹åˆ¥ç³»çµ±](01-Goèªæ³•åŸºç¤èˆ‡å‹åˆ¥ç³»çµ±.md)  
**ä¸‹ä¸€ç¯‡**: [Day 3 - æ•¸æ“šåº«é€£æ¥èˆ‡ SQL æ“ä½œ](03-æ•¸æ“šåº«é€£æ¥èˆ‡SQLæ“ä½œ.md)

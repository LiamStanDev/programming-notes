# 數據庫操作

## 數據庫架構

```mermaid
graph TB
    A[Go 數據庫] --> B[database/sql]
    A --> C[ORM 框架]
    A --> D[NoSQL]
    
    B --> B1[連接池]
    B --> B2[預編譯語句]
    B --> B3[事務]
    
    C --> C1[GORM]
    C --> C2[ent]
    C --> C3[sqlx]
    
    D --> D1[Redis]
    D --> D2[MongoDB]
```

## database/sql 標準庫

### 連接數據庫

```go
import (
    "database/sql"
    _ "github.com/lib/pq"           // PostgreSQL
    _ "github.com/go-sql-driver/mysql"  // MySQL
)

func main() {
    dsn := "postgres://user:password@localhost:5432/dbname?sslmode=disable"
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    if err := db.Ping(); err != nil {
        log.Fatal(err)
    }
    
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(25)
    db.SetConnMaxLifetime(5 * time.Minute)
}
```

### MySQL 連接

```go
dsn := "user:password@tcp(127.0.0.1:3306)/dbname?parseTime=true"
db, err := sql.Open("mysql", dsn)
```

### 查詢操作

#### 查詢多行

```go
type User struct {
    ID    int
    Name  string
    Email string
    Age   int
}

func getUsers(db *sql.DB) ([]User, error) {
    query := "SELECT id, name, email, age FROM users WHERE age > $1"
    
    rows, err := db.Query(query, 18)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var users []User
    for rows.Next() {
        var u User
        if err := rows.Scan(&u.ID, &u.Name, &u.Email, &u.Age); err != nil {
            return nil, err
        }
        users = append(users, u)
    }
    
    if err = rows.Err(); err != nil {
        return nil, err
    }
    
    return users, nil
}
```

#### 查詢單行

```go
func getUserByID(db *sql.DB, id int) (*User, error) {
    query := "SELECT id, name, email, age FROM users WHERE id = $1"
    
    var u User
    err := db.QueryRow(query, id).Scan(&u.ID, &u.Name, &u.Email, &u.Age)
    
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    
    return &u, nil
}
```

### 插入操作

```go
func createUser(db *sql.DB, user *User) (int64, error) {
    query := "INSERT INTO users (name, email, age) VALUES ($1, $2, $3) RETURNING id"
    
    err := db.QueryRow(query, user.Name, user.Email, user.Age).Scan(&user.ID)
    if err != nil {
        return 0, err
    }
    
    return user.ID, nil
}

func createUserMySQL(db *sql.DB, user *User) (int64, error) {
    query := "INSERT INTO users (name, email, age) VALUES (?, ?, ?)"
    
    result, err := db.Exec(query, user.Name, user.Email, user.Age)
    if err != nil {
        return 0, err
    }
    
    id, err := result.LastInsertId()
    if err != nil {
        return 0, err
    }
    
    return id, nil
}
```

### 更新操作

```go
func updateUser(db *sql.DB, user *User) error {
    query := "UPDATE users SET name = $1, email = $2, age = $3 WHERE id = $4"
    
    result, err := db.Exec(query, user.Name, user.Email, user.Age, user.ID)
    if err != nil {
        return err
    }
    
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rowsAffected == 0 {
        return errors.New("user not found")
    }
    
    return nil
}
```

### 刪除操作

```go
func deleteUser(db *sql.DB, id int) error {
    query := "DELETE FROM users WHERE id = $1"
    
    result, err := db.Exec(query, id)
    if err != nil {
        return err
    }
    
    rowsAffected, err := result.RowsAffected()
    if err != nil {
        return err
    }
    
    if rowsAffected == 0 {
        return errors.New("user not found")
    }
    
    return nil
}
```

### 預編譯語句

```go
func batchInsert(db *sql.DB, users []User) error {
    stmt, err := db.Prepare("INSERT INTO users (name, email, age) VALUES ($1, $2, $3)")
    if err != nil {
        return err
    }
    defer stmt.Close()
    
    for _, user := range users {
        if _, err := stmt.Exec(user.Name, user.Email, user.Age); err != nil {
            return err
        }
    }
    
    return nil
}
```

### 事務處理

```go
func transfer(db *sql.DB, fromID, toID int, amount float64) error {
    tx, err := db.Begin()
    if err != nil {
        return err
    }
    
    defer func() {
        if p := recover(); p != nil {
            tx.Rollback()
            panic(p)
        } else if err != nil {
            tx.Rollback()
        } else {
            err = tx.Commit()
        }
    }()
    
    _, err = tx.Exec("UPDATE accounts SET balance = balance - $1 WHERE id = $2", amount, fromID)
    if err != nil {
        return err
    }
    
    _, err = tx.Exec("UPDATE accounts SET balance = balance + $1 WHERE id = $2", amount, toID)
    if err != nil {
        return err
    }
    
    return nil
}
```

### Context 支持

```go
func getUserWithContext(ctx context.Context, db *sql.DB, id int) (*User, error) {
    query := "SELECT id, name, email, age FROM users WHERE id = $1"
    
    var u User
    err := db.QueryRowContext(ctx, query, id).Scan(&u.ID, &u.Name, &u.Email, &u.Age)
    
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    
    return &u, nil
}

func main() {
    ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
    defer cancel()
    
    user, err := getUserWithContext(ctx, db, 1)
    if err != nil {
        log.Fatal(err)
    }
}
```

## GORM

### 安裝

```bash
go get -u gorm.io/gorm
go get -u gorm.io/driver/postgres
go get -u gorm.io/driver/mysql
go get -u gorm.io/driver/sqlite
```

### 連接數據庫

```go
import (
    "gorm.io/driver/postgres"
    "gorm.io/gorm"
    "gorm.io/gorm/logger"
)

func main() {
    dsn := "host=localhost user=gorm password=gorm dbname=gorm port=5432 sslmode=disable"
    db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
        Logger: logger.Default.LogMode(logger.Info),
    })
    if err != nil {
        log.Fatal(err)
    }
    
    sqlDB, err := db.DB()
    sqlDB.SetMaxIdleConns(10)
    sqlDB.SetMaxOpenConns(100)
    sqlDB.SetConnMaxLifetime(time.Hour)
}
```

### 定義模型

```go
type User struct {
    ID        uint           `gorm:"primarykey"`
    Name      string         `gorm:"size:100;not null"`
    Email     string         `gorm:"uniqueIndex;not null"`
    Age       int            `gorm:"default:0"`
    Birthday  *time.Time
    Active    bool           `gorm:"default:true"`
    CreatedAt time.Time
    UpdatedAt time.Time
    DeletedAt gorm.DeletedAt `gorm:"index"`
}

type Product struct {
    ID          uint    `gorm:"primaryKey"`
    Code        string  `gorm:"uniqueIndex"`
    Price       float64
    UserID      uint
    User        User    `gorm:"foreignKey:UserID"`
}

type CreditCard struct {
    gorm.Model
    Number string
    UserID uint
}
```

### 自動遷移

```go
db.AutoMigrate(&User{}, &Product{}, &CreditCard{})
```

### CRUD 操作

#### 創建

```go
user := User{
    Name:  "Alice",
    Email: "alice@example.com",
    Age:   25,
}

result := db.Create(&user)
fmt.Println(user.ID, result.Error, result.RowsAffected)

users := []User{
    {Name: "Bob", Email: "bob@example.com"},
    {Name: "Charlie", Email: "charlie@example.com"},
}
db.Create(&users)

db.Create(&User{Name: "Tom", Age: 20})
```

#### 查詢

```go
var user User
db.First(&user, 1)
db.First(&user, "email = ?", "alice@example.com")

db.Last(&user)

db.Take(&user)

var users []User
db.Find(&users)

db.Find(&users, []int{1, 2, 3})

var result User
db.Where("name = ?", "Alice").First(&result)
db.Where("age > ?", 18).Find(&users)
db.Where("name IN ?", []string{"Alice", "Bob"}).Find(&users)
db.Where("name LIKE ?", "%ice").Find(&users)

db.Where("name = ? AND age >= ?", "Alice", 18).Find(&users)

db.Where(&User{Name: "Alice", Age: 20}).First(&user)

db.Where(map[string]interface{}{"name": "Alice", "age": 20}).Find(&users)

db.Not("name = ?", "Alice").Find(&users)
db.Not(map[string]interface{}{"name": []string{"Alice", "Bob"}}).Find(&users)

db.Or("name = ?", "Alice").Or("age > ?", 20).Find(&users)

db.Where("name = ?", "Alice").Order("age desc").Find(&users)
db.Order("age desc, name").Find(&users)

db.Limit(10).Offset(5).Find(&users)

db.Where("age > ?", 18).Count(&count)
db.Model(&User{}).Count(&count)

db.Distinct("name").Find(&users)
db.Select("name", "age").Find(&users)
db.Select([]string{"name", "age"}).Find(&users)
db.Omit("password").Find(&users)
```

#### 更新

```go
db.Model(&user).Update("name", "Bob")

db.Model(&user).Updates(User{Name: "Bob", Age: 26})

db.Model(&user).Updates(map[string]interface{}{"name": "Bob", "age": 26})

db.Model(&User{}).Where("age > ?", 18).Update("active", true)

db.Model(&user).Select("name", "age").Updates(map[string]interface{}{"name": "Bob", "age": 0})

db.Model(&user).Omit("name").Updates(map[string]interface{}{"name": "Bob", "age": 0})
```

#### 刪除

```go
db.Delete(&user, 1)
db.Delete(&User{}, 1)
db.Delete(&User{}, []int{1, 2, 3})

db.Where("age < ?", 18).Delete(&User{})

db.Unscoped().Delete(&user)
```

### 關聯

#### 一對一

```go
type User struct {
    gorm.Model
    Name    string
    Profile Profile
}

type Profile struct {
    gorm.Model
    Bio    string
    UserID uint
}

db.Model(&user).Association("Profile").Append(&profile)

var user User
db.Preload("Profile").First(&user, 1)
```

#### 一對多

```go
type User struct {
    gorm.Model
    Name   string
    Emails []Email
}

type Email struct {
    gorm.Model
    Email  string
    UserID uint
}

db.Model(&user).Association("Emails").Append(&email)

var user User
db.Preload("Emails").First(&user, 1)
```

#### 多對多

```go
type User struct {
    gorm.Model
    Name      string
    Languages []Language `gorm:"many2many:user_languages;"`
}

type Language struct {
    gorm.Model
    Name string
}

db.Model(&user).Association("Languages").Append(&language)

var user User
db.Preload("Languages").First(&user, 1)
```

### 原生 SQL

```go
type Result struct {
    Name  string
    Count int
}

var result Result
db.Raw("SELECT name, COUNT(*) as count FROM users GROUP BY name").Scan(&result)

db.Exec("UPDATE users SET age = age + 1 WHERE id = ?", user.ID)
```

### 事務

```go
err := db.Transaction(func(tx *gorm.DB) error {
    if err := tx.Create(&User{Name: "Alice"}).Error; err != nil {
        return err
    }
    
    if err := tx.Create(&User{Name: "Bob"}).Error; err != nil {
        return err
    }
    
    return nil
})

tx := db.Begin()

if err := tx.Create(&user).Error; err != nil {
    tx.Rollback()
    return err
}

if err := tx.Create(&profile).Error; err != nil {
    tx.Rollback()
    return err
}

tx.Commit()
```

### Hooks

```go
func (u *User) BeforeCreate(tx *gorm.DB) error {
    u.ID = uuid.New().ID()
    return nil
}

func (u *User) AfterCreate(tx *gorm.DB) error {
    log.Printf("User created: %s", u.Name)
    return nil
}

func (u *User) BeforeUpdate(tx *gorm.DB) error {
    if tx.Statement.Changed("Email") {
        return errors.New("email cannot be changed")
    }
    return nil
}
```

## Redis

### 安裝

```bash
go get github.com/redis/go-redis/v9
```

### 基本操作

```go
import (
    "github.com/redis/go-redis/v9"
)

func main() {
    ctx := context.Background()
    
    rdb := redis.NewClient(&redis.Options{
        Addr:     "localhost:6379",
        Password: "",
        DB:       0,
    })
    
    err := rdb.Set(ctx, "key", "value", 0).Err()
    if err != nil {
        panic(err)
    }
    
    val, err := rdb.Get(ctx, "key").Result()
    if err == redis.Nil {
        fmt.Println("key does not exist")
    } else if err != nil {
        panic(err)
    } else {
        fmt.Println("key", val)
    }
    
    rdb.SetEx(ctx, "key", "value", 10*time.Second)
    
    rdb.Del(ctx, "key")
    
    exists, err := rdb.Exists(ctx, "key").Result()
    
    ttl, err := rdb.TTL(ctx, "key").Result()
}
```

### 數據結構

```go
rdb.HSet(ctx, "user:1", "name", "Alice")
rdb.HSet(ctx, "user:1", "age", 25)
rdb.HGet(ctx, "user:1", "name")
rdb.HGetAll(ctx, "user:1")

rdb.LPush(ctx, "list", "value1", "value2")
rdb.RPush(ctx, "list", "value3")
rdb.LPop(ctx, "list")
rdb.RPop(ctx, "list")
rdb.LRange(ctx, "list", 0, -1)

rdb.SAdd(ctx, "set", "member1", "member2")
rdb.SMembers(ctx, "set")
rdb.SIsMember(ctx, "set", "member1")

rdb.ZAdd(ctx, "zset", redis.Z{Score: 1, Member: "one"})
rdb.ZRange(ctx, "zset", 0, -1)
rdb.ZRangeWithScores(ctx, "zset", 0, -1)
```

### Pipeline

```go
pipe := rdb.Pipeline()

pipe.Set(ctx, "key1", "value1", 0)
pipe.Set(ctx, "key2", "value2", 0)
pipe.Get(ctx, "key1")

cmds, err := pipe.Exec(ctx)
if err != nil {
    panic(err)
}
```

### Pub/Sub

```go
pubsub := rdb.Subscribe(ctx, "channel")
defer pubsub.Close()

_, err := pubsub.Receive(ctx)
if err != nil {
    panic(err)
}

ch := pubsub.Channel()

go func() {
    for msg := range ch {
        fmt.Println(msg.Channel, msg.Payload)
    }
}()

rdb.Publish(ctx, "channel", "message")
```

## 實戰案例：用戶服務

```go
package repository

type UserRepository struct {
    db *gorm.DB
}

func NewUserRepository(db *gorm.DB) *UserRepository {
    return &UserRepository{db: db}
}

func (r *UserRepository) Create(ctx context.Context, user *User) error {
    return r.db.WithContext(ctx).Create(user).Error
}

func (r *UserRepository) GetByID(ctx context.Context, id uint) (*User, error) {
    var user User
    err := r.db.WithContext(ctx).First(&user, id).Error
    if err == gorm.ErrRecordNotFound {
        return nil, nil
    }
    return &user, err
}

func (r *UserRepository) List(ctx context.Context, offset, limit int) ([]User, error) {
    var users []User
    err := r.db.WithContext(ctx).
        Offset(offset).
        Limit(limit).
        Find(&users).Error
    return users, err
}

func (r *UserRepository) Update(ctx context.Context, user *User) error {
    return r.db.WithContext(ctx).Save(user).Error
}

func (r *UserRepository) Delete(ctx context.Context, id uint) error {
    return r.db.WithContext(ctx).Delete(&User{}, id).Error
}
```

## 最佳實踐

### 1. 使用連接池

```go
sqlDB, _ := db.DB()
sqlDB.SetMaxOpenConns(25)
sqlDB.SetMaxIdleConns(5)
sqlDB.SetConnMaxLifetime(5 * time.Minute)
```

### 2. 使用 Context

所有數據庫操作都應該傳遞 context

### 3. 處理 NULL 值

```go
type User struct {
    Name  sql.NullString
    Age   sql.NullInt64
    Email *string
}
```

### 4. 使用事務

確保數據一致性

### 5. 預編譯語句

批量操作使用預編譯語句

### 6. 索引優化

```go
type User struct {
    Email string `gorm:"index"`
    Name  string `gorm:"index:idx_name"`
}
```

### 7. 分頁查詢

```go
func Paginate(page, pageSize int) func(db *gorm.DB) *gorm.DB {
    return func(db *gorm.DB) *gorm.DB {
        offset := (page - 1) * pageSize
        return db.Offset(offset).Limit(pageSize)
    }
}

db.Scopes(Paginate(1, 20)).Find(&users)
```

### 8. 軟刪除

使用 `gorm.DeletedAt` 實現軟刪除

### 9. 日誌記錄

```go
db, err := gorm.Open(postgres.Open(dsn), &gorm.Config{
    Logger: logger.Default.LogMode(logger.Info),
})
```

### 10. 錯誤處理

始終檢查並處理錯誤

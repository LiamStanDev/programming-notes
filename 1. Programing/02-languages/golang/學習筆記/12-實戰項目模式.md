# 實戰項目模式

## 清晰架構（Clean Architecture）

```mermaid
graph TB
    A[Presentation Layer] --> B[Application Layer]
    B --> C[Domain Layer]
    C --> D[Infrastructure Layer]
    
    A --> A1[HTTP Handlers]
    A --> A2[gRPC Services]
    
    B --> B1[Use Cases]
    B --> B2[DTOs]
    
    C --> C1[Entities]
    C --> C2[Repositories Interface]
    C --> C3[Business Logic]
    
    D --> D1[Database]
    D --> D2[External APIs]
    D --> D3[Cache]
```

## 標準項目結構

```
myapp/
├── cmd/
│   └── server/
│       └── main.go
├── internal/
│   ├── domain/
│   │   ├── user.go
│   │   └── product.go
│   ├── repository/
│   │   ├── user_repository.go
│   │   └── postgres/
│   │       └── user_repository_impl.go
│   ├── service/
│   │   └── user_service.go
│   ├── handler/
│   │   └── http/
│   │       └── user_handler.go
│   └── middleware/
│       ├── auth.go
│       └── logging.go
├── pkg/
│   ├── logger/
│   ├── config/
│   └── utils/
├── api/
│   └── openapi.yaml
├── configs/
│   └── config.yaml
├── migrations/
│   └── 001_create_users.sql
├── scripts/
├── test/
├── go.mod
├── go.sum
├── Makefile
└── README.md
```

## Domain 層

```go
// internal/domain/user.go
package domain

import (
    "context"
    "time"
)

type User struct {
    ID        int64
    Username  string
    Email     string
    Password  string
    CreatedAt time.Time
    UpdatedAt time.Time
}

type UserRepository interface {
    Create(ctx context.Context, user *User) error
    GetByID(ctx context.Context, id int64) (*User, error)
    GetByEmail(ctx context.Context, email string) (*User, error)
    Update(ctx context.Context, user *User) error
    Delete(ctx context.Context, id int64) error
    List(ctx context.Context, offset, limit int) ([]*User, error)
}

func (u *User) Validate() error {
    if u.Username == "" {
        return errors.New("username is required")
    }
    if u.Email == "" {
        return errors.New("email is required")
    }
    if !strings.Contains(u.Email, "@") {
        return errors.New("invalid email format")
    }
    return nil
}
```

## Repository 層

```go
// internal/repository/postgres/user_repository.go
package postgres

import (
    "context"
    "database/sql"
    
    "myapp/internal/domain"
)

type userRepository struct {
    db *sql.DB
}

func NewUserRepository(db *sql.DB) domain.UserRepository {
    return &userRepository{db: db}
}

func (r *userRepository) Create(ctx context.Context, user *domain.User) error {
    query := `
        INSERT INTO users (username, email, password, created_at, updated_at)
        VALUES ($1, $2, $3, $4, $5)
        RETURNING id
    `
    
    now := time.Now()
    err := r.db.QueryRowContext(
        ctx,
        query,
        user.Username,
        user.Email,
        user.Password,
        now,
        now,
    ).Scan(&user.ID)
    
    if err != nil {
        return err
    }
    
    user.CreatedAt = now
    user.UpdatedAt = now
    
    return nil
}

func (r *userRepository) GetByID(ctx context.Context, id int64) (*domain.User, error) {
    query := `
        SELECT id, username, email, password, created_at, updated_at
        FROM users
        WHERE id = $1
    `
    
    user := &domain.User{}
    err := r.db.QueryRowContext(ctx, query, id).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.Password,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    
    return user, nil
}

func (r *userRepository) GetByEmail(ctx context.Context, email string) (*domain.User, error) {
    query := `
        SELECT id, username, email, password, created_at, updated_at
        FROM users
        WHERE email = $1
    `
    
    user := &domain.User{}
    err := r.db.QueryRowContext(ctx, query, email).Scan(
        &user.ID,
        &user.Username,
        &user.Email,
        &user.Password,
        &user.CreatedAt,
        &user.UpdatedAt,
    )
    
    if err == sql.ErrNoRows {
        return nil, nil
    }
    if err != nil {
        return nil, err
    }
    
    return user, nil
}

func (r *userRepository) Update(ctx context.Context, user *domain.User) error {
    query := `
        UPDATE users
        SET username = $1, email = $2, password = $3, updated_at = $4
        WHERE id = $5
    `
    
    _, err := r.db.ExecContext(
        ctx,
        query,
        user.Username,
        user.Email,
        user.Password,
        time.Now(),
        user.ID,
    )
    
    return err
}

func (r *userRepository) Delete(ctx context.Context, id int64) error {
    query := "DELETE FROM users WHERE id = $1"
    _, err := r.db.ExecContext(ctx, query, id)
    return err
}

func (r *userRepository) List(ctx context.Context, offset, limit int) ([]*domain.User, error) {
    query := `
        SELECT id, username, email, password, created_at, updated_at
        FROM users
        ORDER BY created_at DESC
        LIMIT $1 OFFSET $2
    `
    
    rows, err := r.db.QueryContext(ctx, query, limit, offset)
    if err != nil {
        return nil, err
    }
    defer rows.Close()
    
    var users []*domain.User
    for rows.Next() {
        user := &domain.User{}
        if err := rows.Scan(
            &user.ID,
            &user.Username,
            &user.Email,
            &user.Password,
            &user.CreatedAt,
            &user.UpdatedAt,
        ); err != nil {
            return nil, err
        }
        users = append(users, user)
    }
    
    return users, rows.Err()
}
```

## Service 層

```go
// internal/service/user_service.go
package service

import (
    "context"
    "errors"
    
    "myapp/internal/domain"
    "golang.org/x/crypto/bcrypt"
)

type UserService struct {
    repo domain.UserRepository
}

func NewUserService(repo domain.UserRepository) *UserService {
    return &UserService{repo: repo}
}

func (s *UserService) Register(ctx context.Context, username, email, password string) (*domain.User, error) {
    existing, err := s.repo.GetByEmail(ctx, email)
    if err != nil {
        return nil, err
    }
    if existing != nil {
        return nil, errors.New("email already exists")
    }
    
    hashedPassword, err := bcrypt.GenerateFromPassword([]byte(password), bcrypt.DefaultCost)
    if err != nil {
        return nil, err
    }
    
    user := &domain.User{
        Username: username,
        Email:    email,
        Password: string(hashedPassword),
    }
    
    if err := user.Validate(); err != nil {
        return nil, err
    }
    
    if err := s.repo.Create(ctx, user); err != nil {
        return nil, err
    }
    
    user.Password = ""
    
    return user, nil
}

func (s *UserService) Login(ctx context.Context, email, password string) (*domain.User, error) {
    user, err := s.repo.GetByEmail(ctx, email)
    if err != nil {
        return nil, err
    }
    if user == nil {
        return nil, errors.New("invalid credentials")
    }
    
    if err := bcrypt.CompareHashAndPassword([]byte(user.Password), []byte(password)); err != nil {
        return nil, errors.New("invalid credentials")
    }
    
    user.Password = ""
    
    return user, nil
}

func (s *UserService) GetUser(ctx context.Context, id int64) (*domain.User, error) {
    user, err := s.repo.GetByID(ctx, id)
    if err != nil {
        return nil, err
    }
    if user == nil {
        return nil, errors.New("user not found")
    }
    
    user.Password = ""
    
    return user, nil
}

func (s *UserService) UpdateUser(ctx context.Context, id int64, username, email string) (*domain.User, error) {
    user, err := s.repo.GetByID(ctx, id)
    if err != nil {
        return nil, err
    }
    if user == nil {
        return nil, errors.New("user not found")
    }
    
    user.Username = username
    user.Email = email
    
    if err := user.Validate(); err != nil {
        return nil, err
    }
    
    if err := s.repo.Update(ctx, user); err != nil {
        return nil, err
    }
    
    user.Password = ""
    
    return user, nil
}

func (s *UserService) DeleteUser(ctx context.Context, id int64) error {
    return s.repo.Delete(ctx, id)
}

func (s *UserService) ListUsers(ctx context.Context, page, pageSize int) ([]*domain.User, error) {
    offset := (page - 1) * pageSize
    users, err := s.repo.List(ctx, offset, pageSize)
    if err != nil {
        return nil, err
    }
    
    for _, user := range users {
        user.Password = ""
    }
    
    return users, nil
}
```

## Handler 層

```go
// internal/handler/http/user_handler.go
package http

import (
    "net/http"
    "strconv"
    
    "myapp/internal/service"
    "github.com/gin-gonic/gin"
)

type UserHandler struct {
    service *service.UserService
}

func NewUserHandler(service *service.UserService) *UserHandler {
    return &UserHandler{service: service}
}

type RegisterRequest struct {
    Username string `json:"username" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required,min=8"`
}

type LoginRequest struct {
    Email    string `json:"email" binding:"required,email"`
    Password string `json:"password" binding:"required"`
}

type UpdateUserRequest struct {
    Username string `json:"username" binding:"required"`
    Email    string `json:"email" binding:"required,email"`
}

type Response struct {
    Code    int         `json:"code"`
    Message string      `json:"message"`
    Data    interface{} `json:"data,omitempty"`
}

func (h *UserHandler) Register(c *gin.Context) {
    var req RegisterRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, Response{
            Code:    http.StatusBadRequest,
            Message: err.Error(),
        })
        return
    }
    
    user, err := h.service.Register(c.Request.Context(), req.Username, req.Email, req.Password)
    if err != nil {
        c.JSON(http.StatusBadRequest, Response{
            Code:    http.StatusBadRequest,
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusCreated, Response{
        Code:    http.StatusCreated,
        Message: "User created successfully",
        Data:    user,
    })
}

func (h *UserHandler) Login(c *gin.Context) {
    var req LoginRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, Response{
            Code:    http.StatusBadRequest,
            Message: err.Error(),
        })
        return
    }
    
    user, err := h.service.Login(c.Request.Context(), req.Email, req.Password)
    if err != nil {
        c.JSON(http.StatusUnauthorized, Response{
            Code:    http.StatusUnauthorized,
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, Response{
        Code:    http.StatusOK,
        Message: "Login successful",
        Data:    user,
    })
}

func (h *UserHandler) GetUser(c *gin.Context) {
    id, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, Response{
            Code:    http.StatusBadRequest,
            Message: "Invalid user ID",
        })
        return
    }
    
    user, err := h.service.GetUser(c.Request.Context(), id)
    if err != nil {
        c.JSON(http.StatusNotFound, Response{
            Code:    http.StatusNotFound,
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, Response{
        Code:    http.StatusOK,
        Message: "Success",
        Data:    user,
    })
}

func (h *UserHandler) UpdateUser(c *gin.Context) {
    id, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, Response{
            Code:    http.StatusBadRequest,
            Message: "Invalid user ID",
        })
        return
    }
    
    var req UpdateUserRequest
    if err := c.ShouldBindJSON(&req); err != nil {
        c.JSON(http.StatusBadRequest, Response{
            Code:    http.StatusBadRequest,
            Message: err.Error(),
        })
        return
    }
    
    user, err := h.service.UpdateUser(c.Request.Context(), id, req.Username, req.Email)
    if err != nil {
        c.JSON(http.StatusBadRequest, Response{
            Code:    http.StatusBadRequest,
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, Response{
        Code:    http.StatusOK,
        Message: "User updated successfully",
        Data:    user,
    })
}

func (h *UserHandler) DeleteUser(c *gin.Context) {
    id, err := strconv.ParseInt(c.Param("id"), 10, 64)
    if err != nil {
        c.JSON(http.StatusBadRequest, Response{
            Code:    http.StatusBadRequest,
            Message: "Invalid user ID",
        })
        return
    }
    
    if err := h.service.DeleteUser(c.Request.Context(), id); err != nil {
        c.JSON(http.StatusInternalServerError, Response{
            Code:    http.StatusInternalServerError,
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusNoContent, nil)
}

func (h *UserHandler) ListUsers(c *gin.Context) {
    page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
    pageSize, _ := strconv.Atoi(c.DefaultQuery("page_size", "20"))
    
    users, err := h.service.ListUsers(c.Request.Context(), page, pageSize)
    if err != nil {
        c.JSON(http.StatusInternalServerError, Response{
            Code:    http.StatusInternalServerError,
            Message: err.Error(),
        })
        return
    }
    
    c.JSON(http.StatusOK, Response{
        Code:    http.StatusOK,
        Message: "Success",
        Data:    users,
    })
}
```

## 配置管理

```go
// pkg/config/config.go
package config

import (
    "github.com/spf13/viper"
)

type Config struct {
    Server   ServerConfig
    Database DatabaseConfig
    Redis    RedisConfig
    JWT      JWTConfig
}

type ServerConfig struct {
    Port         int
    ReadTimeout  int
    WriteTimeout int
}

type DatabaseConfig struct {
    Host     string
    Port     int
    User     string
    Password string
    DBName   string
    SSLMode  string
}

type RedisConfig struct {
    Host     string
    Port     int
    Password string
    DB       int
}

type JWTConfig struct {
    Secret     string
    ExpireTime int
}

func Load(path string) (*Config, error) {
    viper.SetConfigFile(path)
    viper.SetConfigType("yaml")
    viper.AutomaticEnv()
    
    if err := viper.ReadInConfig(); err != nil {
        return nil, err
    }
    
    var config Config
    if err := viper.Unmarshal(&config); err != nil {
        return nil, err
    }
    
    return &config, nil
}
```

```yaml
# configs/config.yaml
server:
  port: 8080
  read_timeout: 10
  write_timeout: 10

database:
  host: localhost
  port: 5432
  user: postgres
  password: password
  dbname: myapp
  sslmode: disable

redis:
  host: localhost
  port: 6379
  password: ""
  db: 0

jwt:
  secret: your-secret-key
  expire_time: 3600
```

## 依賴注入

```go
// cmd/server/main.go
package main

import (
    "database/sql"
    "fmt"
    "log"
    
    "myapp/internal/handler/http"
    "myapp/internal/repository/postgres"
    "myapp/internal/service"
    "myapp/pkg/config"
    
    "github.com/gin-gonic/gin"
    _ "github.com/lib/pq"
)

func main() {
    cfg, err := config.Load("configs/config.yaml")
    if err != nil {
        log.Fatal(err)
    }
    
    db, err := initDB(cfg.Database)
    if err != nil {
        log.Fatal(err)
    }
    defer db.Close()
    
    userRepo := postgres.NewUserRepository(db)
    
    userService := service.NewUserService(userRepo)
    
    userHandler := http.NewUserHandler(userService)
    
    r := setupRouter(userHandler)
    
    addr := fmt.Sprintf(":%d", cfg.Server.Port)
    log.Printf("Server starting on %s", addr)
    if err := r.Run(addr); err != nil {
        log.Fatal(err)
    }
}

func initDB(cfg config.DatabaseConfig) (*sql.DB, error) {
    dsn := fmt.Sprintf(
        "host=%s port=%d user=%s password=%s dbname=%s sslmode=%s",
        cfg.Host, cfg.Port, cfg.User, cfg.Password, cfg.DBName, cfg.SSLMode,
    )
    
    db, err := sql.Open("postgres", dsn)
    if err != nil {
        return nil, err
    }
    
    if err := db.Ping(); err != nil {
        return nil, err
    }
    
    db.SetMaxOpenConns(25)
    db.SetMaxIdleConns(5)
    
    return db, nil
}

func setupRouter(userHandler *http.UserHandler) *gin.Engine {
    r := gin.Default()
    
    api := r.Group("/api/v1")
    {
        api.POST("/register", userHandler.Register)
        api.POST("/login", userHandler.Login)
        
        users := api.Group("/users")
        {
            users.GET("", userHandler.ListUsers)
            users.GET("/:id", userHandler.GetUser)
            users.PUT("/:id", userHandler.UpdateUser)
            users.DELETE("/:id", userHandler.DeleteUser)
        }
    }
    
    return r
}
```

## Makefile

```makefile
.PHONY: build run test clean migrate-up migrate-down

build:
	go build -o bin/server cmd/server/main.go

run:
	go run cmd/server/main.go

test:
	go test -v -race -cover ./...

lint:
	golangci-lint run

clean:
	rm -rf bin/

migrate-up:
	migrate -path migrations -database "postgres://user:pass@localhost:5432/myapp?sslmode=disable" up

migrate-down:
	migrate -path migrations -database "postgres://user:pass@localhost:5432/myapp?sslmode=disable" down

docker-up:
	docker-compose up -d

docker-down:
	docker-compose down
```

## 最佳實踐總結

### 1. 分層架構

- Domain: 領域模型與業務規則
- Repository: 數據訪問層
- Service: 業務邏輯層
- Handler: 表現層

### 2. 依賴注入

使用構造函數注入依賴

### 3. 接口抽象

Repository 定義為接口，便於測試和替換實現

### 4. 配置管理

使用配置文件管理環境變量

### 5. 錯誤處理

每層適當處理和包裝錯誤

### 6. 日誌記錄

使用結構化日誌

### 7. 測試

- 單元測試：測試業務邏輯
- 集成測試：測試數據庫交互
- 端到端測試：測試 API

### 8. 文檔

- README.md: 項目說明
- API 文檔: OpenAPI/Swagger
- 代碼註釋

### 9. CI/CD

GitHub Actions、GitLab CI

### 10. 監控

Prometheus + Grafana

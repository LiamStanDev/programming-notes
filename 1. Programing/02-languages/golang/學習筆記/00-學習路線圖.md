# Golang 學習路線圖 - .NET 工程師轉型指南

## 學習目標

從資深 .NET 工程師的視角，系統性掌握 Go 語言的核心特性、設計哲學和最佳實踐，能夠在 10 天內具備構建生產級微服務的能力。

## 學習方法論

### 對比學習策略
- **C# → Go 概念映射**: 每個主題都會對比 C# 的實現方式
- **理念差異理解**: Go 的簡約哲學 vs .NET 的全功能框架
- **工具鏈轉換**: Visual Studio/.NET CLI → Go 工具鏈

### 學習節奏
- **每日 3-4 小時**: 理論學習 + 實踐編碼
- **專案驅動**: 每個主題都有對應的實戰項目
- **漸進複雜度**: 從基礎語法到微服務架構

---

## 10 天學習計劃總覽

| 天數 | 核心主題 | 專案實踐 | 關鍵技術點 | 對應 C# 概念 |
|------|---------|---------|-----------|-------------|
| **Day 1** | Go 語法基礎 | RESTful API 模型與測試 | package/module, struct/interface, testing | namespace, class/interface, NUnit |
| **Day 2** | 錯誤哲學與標準庫 | net/http 基礎服務 | error handling, defer, net/http | try-catch, using, HttpListener |
| **Day 3** | 數據庫連接 | PostgreSQL 服務 | database/sql, 連接池 | ADO.NET, EF Core |
| **Day 4** | 併發核心 1 | 併發計數器服務 | Goroutine, Channel | Task, async/await |
| **Day 5** | 併發核心 2 | Context 工作池 | Context, Worker Pool | CancellationToken, TPL |
| **Day 6** | 併發模式與通訊 | Redis + Kafka Producer | Fan-in/out, 訊息佇列 | Reactive Extensions, MassTransit |
| **Day 7** | Web 框架與中間件 | CRUD API + 限流 | Gin/Fiber, Middleware | ASP.NET Core Middleware |
| **Day 8** | 數據持久化與容器化 | ORM + Docker | GORM/SQLx, Dockerfile | EF Core, Docker |
| **Day 9** | 微服務通訊 | gRPC + Kafka Consumer | Protobuf, gRPC | WCF, gRPC-dotnet |
| **Day 10** | 可觀測性與部署 | Observability + K8s | Metrics, Tracing, CLI | Application Insights, K8s |

---

## 核心概念對比: C# vs Go

### 1. 語言設計哲學

| 維度 | C# (.NET) | Go |
|------|-----------|-----|
| **設計理念** | 全功能、多範式、抽象豐富 | 簡約、實用主義、顯式優於隱式 |
| **複雜度** | 高 (generics, LINQ, reflection) | 低 (25 個關鍵字) |
| **編譯速度** | 慢 (MSBuild 複雜) | 極快 (秒級編譯) |
| **記憶體管理** | GC (分代回收) | GC (三色標記 + 併發) |
| **併發模型** | async/await + TPL | Goroutines + Channels |

### 2. 類型系統對比

```csharp
// C# - 類繼承與接口
public interface IReader {
    string Read();
}

public class FileReader : IReader {
    public string Read() => File.ReadAllText("file.txt");
}
```

```go
// Go - 結構與隱式接口
type Reader interface {
    Read() string
}

type FileReader struct{}

func (f FileReader) Read() string {
    data, _ := os.ReadFile("file.txt")
    return string(data)
}
```

**關鍵差異:**
- Go 沒有類繼承，只有組合 (Composition over Inheritance)
- 接口實現是隱式的 (Duck Typing)
- Go 沒有泛型 (Go 1.18+ 引入有限泛型支持)

### 3. 錯誤處理對比

```csharp
// C# - 異常機制
try {
    var content = File.ReadAllText("file.txt");
    Console.WriteLine(content);
} catch (FileNotFoundException ex) {
    Console.WriteLine($"錯誤: {ex.Message}");
} finally {
    // 清理資源
}
```

```go
// Go - 顯式錯誤檢查
content, err := os.ReadFile("file.txt")
if err != nil {
    fmt.Printf("錯誤: %v\n", err)
    return
}
defer cleanup() // 延遲執行

fmt.Println(string(content))
```

**哲學差異:**
- C#: 異常是控制流的一部分
- Go: 錯誤是值，必須顯式處理

### 4. 併發模型對比

```csharp
// C# - Task-based Async
public async Task<string> FetchDataAsync(string url) {
    using var client = new HttpClient();
    return await client.GetStringAsync(url);
}

// 並行處理
var tasks = urls.Select(url => FetchDataAsync(url));
var results = await Task.WhenAll(tasks);
```

```go
// Go - Goroutines + Channels
func fetchData(url string, ch chan<- string) {
    resp, _ := http.Get(url)
    defer resp.Body.Close()
    body, _ := io.ReadAll(resp.Body)
    ch <- string(body)
}

// 並行處理
ch := make(chan string, len(urls))
for _, url := range urls {
    go fetchData(url, ch) // 啟動 goroutine
}

for range urls {
    result := <-ch
    fmt.Println(result)
}
```

**關鍵差異:**
- C#: 基於 Promise/Future 的異步模型
- Go: 基於 CSP (Communicating Sequential Processes)

---

## 學習資源配置

### 開發環境設置

```bash
# 安裝 Go (推薦使用官方二進制)
wget https://go.dev/dl/go1.21.linux-amd64.tar.gz
sudo tar -C /usr/local -xzf go1.21.linux-amd64.tar.gz

# 配置環境變量
export PATH=$PATH:/usr/local/go/bin
export GOPATH=$HOME/go
export PATH=$PATH:$GOPATH/bin

# 驗證安裝
go version
```

### 推薦工具鏈

| 工具 | 用途 | C# 對應 |
|------|------|---------|
| `go build` | 編譯 | dotnet build |
| `go test` | 測試 | dotnet test |
| `go mod` | 依賴管理 | NuGet |
| `gofmt` | 代碼格式化 | dotnet format |
| `golangci-lint` | 靜態分析 | SonarQube |
| `delve` | 調試器 | Visual Studio Debugger |

### 編輯器配置

**VS Code 擴展:**
- Go (官方)
- Go Test Explorer
- Go Outliner

**Vim/Neovim:**
```lua
-- 使用 gopls (Go Language Server)
require('lspconfig').gopls.setup{}
```

---

## 專案結構規範

### 標準 Go 專案佈局

```
myproject/
├── cmd/                    # 應用程式入口
│   └── server/
│       └── main.go
├── internal/               # 私有代碼 (不可被外部導入)
│   ├── handlers/          # HTTP handlers
│   ├── models/            # 數據模型
│   └── services/          # 業務邏輯
├── pkg/                    # 可被外部導入的庫
│   └── utils/
├── api/                    # API 定義 (proto, OpenAPI)
├── configs/                # 配置文件
├── migrations/             # 數據庫遷移
├── scripts/                # 構建/部署腳本
├── test/                   # 額外測試文件
├── go.mod                  # 依賴定義
├── go.sum                  # 依賴鎖定
├── Makefile                # 構建自動化
└── README.md
```

**對比 C# 解決方案:**
- `cmd/` ≈ ASP.NET Core Startup 項目
- `internal/` ≈ Internal 訪問修飾符
- `pkg/` ≈ Class Library 項目
- `go.mod` ≈ .csproj + NuGet

---

## 學習檢查點

每天學習完成後，確保能回答以下問題:

### Day 1 檢查點
- [ ] 能解釋 Go 的 interface 與 C# interface 的差異
- [ ] 能編寫基本的 struct 和方法
- [ ] 能使用 `go test` 編寫單元測試

### Day 2 檢查點
- [ ] 能解釋 `error` 與 `exception` 的差異
- [ ] 理解 `defer` 的執行時機 (vs C# `finally`)
- [ ] 能用 `net/http` 構建基本 HTTP 服務

### Day 3 檢查點
- [ ] 能使用 `database/sql` 連接 PostgreSQL
- [ ] 理解 Go 的連接池機制
- [ ] 能處理 SQL 錯誤和空值 (`sql.NullString`)

### Day 4 檢查點
- [ ] 能解釋 Goroutine 與 C# Task 的差異
- [ ] 理解 Buffered 和 Unbuffered Channel
- [ ] 能避免 Goroutine 洩漏

### Day 5 檢查點
- [ ] 理解 `context.Context` 的傳遞模式
- [ ] 能實現自定義 Worker Pool
- [ ] 能處理 Context 取消和超時

### Day 6 檢查點
- [ ] 能實現 Fan-in/Fan-out 模式
- [ ] 能集成 Redis 客戶端
- [ ] 能實現 Kafka Producer

### Day 7 檢查點
- [ ] 能使用 Gin/Fiber 框架
- [ ] 能編寫自定義 Middleware
- [ ] 能實現 Rate Limiting

### Day 8 檢查點
- [ ] 能使用 GORM/SQLx 進行 CRUD
- [ ] 能編寫 Multi-Stage Dockerfile
- [ ] 能用 Docker Compose 編排服務

### Day 9 檢查點
- [ ] 能定義 Protobuf 消息
- [ ] 能實現 gRPC 服務
- [ ] 能實現 Kafka Consumer

### Day 10 檢查點
- [ ] 能集成 Prometheus Metrics
- [ ] 能實現分佈式 Tracing
- [ ] 能編寫 K8s Deployment 文件

---

## 常見陷阱與最佳實踐

### 1. nil 處理
```go
// ❌ 可能 panic
var m map[string]int
m["key"] = 1 // panic: assignment to entry in nil map

// ✅ 正確初始化
m := make(map[string]int)
m["key"] = 1
```

### 2. Goroutine 洩漏
```go
// ❌ Goroutine 洩漏
func leak() {
    ch := make(chan int)
    go func() {
        val := <-ch // 永遠阻塞
        fmt.Println(val)
    }()
    // ch 沒有發送數據
}

// ✅ 使用 Context 控制
func noLeak(ctx context.Context) {
    ch := make(chan int)
    go func() {
        select {
        case val := <-ch:
            fmt.Println(val)
        case <-ctx.Done():
            return
        }
    }()
}
```

### 3. 錯誤處理
```go
// ❌ 忽略錯誤
data, _ := os.ReadFile("file.txt")

// ✅ 顯式處理
data, err := os.ReadFile("file.txt")
if err != nil {
    return fmt.Errorf("讀取文件失敗: %w", err)
}
```

---

## 參考資源

### 官方文檔
1. [Go 官方教程](https://go.dev/tour/)
2. [Effective Go](https://go.dev/doc/effective_go)
3. [Go 標準庫文檔](https://pkg.go.dev/std)

### 推薦書籍
1. **The Go Programming Language** (Donovan & Kernighan)
2. **Concurrency in Go** (Katherine Cox-Buday)
3. **Learning Go** (Jon Bodner)

### .NET 工程師專用資源
1. [Go for C# Developers](https://github.com/mholt/go-for-dotnet-devs)
2. [Go vs C# Comparison](https://programming-idioms.org/cheatsheet/Go/C%23)

---

## 下一步

開始 **Day 1: Go 語法基礎** → [01-Go語法基礎.md](./01-Go語法基礎.md)

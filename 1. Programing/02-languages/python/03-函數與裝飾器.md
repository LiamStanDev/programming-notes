# 03-å‡½æ•¸èˆ‡è£é£¾å™¨

## ğŸ“– æ ¸å¿ƒæ¦‚å¿µ

Python å‡½æ•¸å¼ç·¨ç¨‹ç‰¹æ€§ï¼š
- **å‡½æ•¸å®šç¾©**: åƒæ•¸ã€è¿”å›å€¼ã€é è¨­åƒæ•¸
- **é«˜éšå‡½æ•¸**: å‡½æ•¸ä½œç‚ºåƒæ•¸/è¿”å›å€¼
- **è£é£¾å™¨**: å‡½æ•¸åŒ…è£å™¨
- **é–‰åŒ…**: å‡½æ•¸æ•ç²å¤–éƒ¨è®Šæ•¸
- **Lambda**: åŒ¿åå‡½æ•¸

```mermaid
graph TD
    A[å‡½æ•¸èˆ‡è£é£¾å™¨] --> B[åŸºç¤å‡½æ•¸]
    A --> C[é«˜éšå‡½æ•¸]
    A --> D[è£é£¾å™¨]
    A --> E[é–‰åŒ…]
    
    B --> B1[åƒæ•¸å‚³é]
    B --> B2[è¿”å›å€¼]
    B --> B3[é è¨­åƒæ•¸]
    
    C --> C1[map/filter/reduce]
    C --> C2[å‡½æ•¸ä½œç‚ºåƒæ•¸]
    C --> C3[å‡½æ•¸ä½œç‚ºè¿”å›å€¼]
    
    D --> D1[åŸºç¤è£é£¾å™¨]
    D --> D2[å¸¶åƒæ•¸è£é£¾å™¨]
    D --> D3[é¡è£é£¾å™¨]
    D --> D4[functools]
    
    E --> E1[è®Šæ•¸æ•ç²]
    E --> E2[å·¥å» å‡½æ•¸]
```

## ğŸ”§ å‡½æ•¸åŸºç¤

### å‡½æ•¸å®šç¾©èˆ‡åƒæ•¸

```python
# åŸºæœ¬å‡½æ•¸
def greet(name: str) -> str:
    return f"Hello, {name}!"

# å¤šå€‹åƒæ•¸
def add(a: int, b: int) -> int:
    return a + b

# é è¨­åƒæ•¸
def greet(name: str, greeting: str = "Hello") -> str:
    return f"{greeting}, {name}!"

greet("Alice")              # "Hello, Alice!"
greet("Bob", "Hi")          # "Hi, Bob!"

# é—œéµå­—åƒæ•¸
def create_user(name: str, *, email: str, age: int) -> dict:
    return {"name": name, "email": email, "age": age}

create_user("Alice", email="alice@example.com", age=30)

# å¯è®Šä½ç½®åƒæ•¸ (*args)
def sum_all(*numbers: int) -> int:
    return sum(numbers)

sum_all(1, 2, 3, 4, 5)  # 15

# å¯è®Šé—œéµå­—åƒæ•¸ (**kwargs)
def create_config(**options: str) -> dict[str, str]:
    return options

create_config(host="localhost", port="8000")
# {"host": "localhost", "port": "8000"}

# çµ„åˆä½¿ç”¨
def process(required: str, *args: int, **kwargs: str) -> None:
    print(f"Required: {required}")
    print(f"Args: {args}")
    print(f"Kwargs: {kwargs}")

process("data", 1, 2, 3, debug="true", mode="fast")
```

### åƒæ•¸è§£åŒ…

```python
# ä½ç½®åƒæ•¸è§£åŒ…
def add(a: int, b: int, c: int) -> int:
    return a + b + c

numbers = [1, 2, 3]
result = add(*numbers)  # ç­‰åŒæ–¼ add(1, 2, 3)

# é—œéµå­—åƒæ•¸è§£åŒ…
def create_user(name: str, email: str, age: int) -> dict:
    return {"name": name, "email": email, "age": age}

user_data = {"name": "Alice", "email": "alice@example.com", "age": 30}
user = create_user(**user_data)
```

### å¤šè¿”å›å€¼

```python
def get_min_max(numbers: list[int]) -> tuple[int, int]:
    return min(numbers), max(numbers)

minimum, maximum = get_min_max([1, 5, 3, 9, 2])
print(minimum, maximum)  # 1 9

# ä½¿ç”¨ NamedTuple
from typing import NamedTuple

class MinMax(NamedTuple):
    min: int
    max: int

def get_min_max(numbers: list[int]) -> MinMax:
    return MinMax(min=min(numbers), max=max(numbers))

result = get_min_max([1, 5, 3, 9, 2])
print(result.min, result.max)  # 1 9
```

## ğŸ”§ é«˜éšå‡½æ•¸

### å‡½æ•¸ä½œç‚ºåƒæ•¸

```python
from typing import Callable

def apply_operation(
    x: int, 
    y: int, 
    operation: Callable[[int, int], int]
) -> int:
    return operation(x, y)

def add(a: int, b: int) -> int:
    return a + b

def multiply(a: int, b: int) -> int:
    return a * b

apply_operation(5, 3, add)       # 8
apply_operation(5, 3, multiply)  # 15
apply_operation(5, 3, lambda a, b: a - b)  # 2
```

### å‡½æ•¸ä½œç‚ºè¿”å›å€¼

```python
def make_multiplier(n: int) -> Callable[[int], int]:
    def multiplier(x: int) -> int:
        return x * n
    return multiplier

double = make_multiplier(2)
triple = make_multiplier(3)

print(double(5))  # 10
print(triple(5))  # 15
```

### å…§å»ºé«˜éšå‡½æ•¸

```python
# map - æ˜ å°„
numbers = [1, 2, 3, 4, 5]
squared = list(map(lambda x: x**2, numbers))
# [1, 4, 9, 16, 25]

# filter - éæ¿¾
evens = list(filter(lambda x: x % 2 == 0, numbers))
# [2, 4]

# reduce - ç´¯ç©
from functools import reduce
total = reduce(lambda acc, x: acc + x, numbers, 0)
# 15

# å¯¦éš›é–‹ç™¼æ›´æ¨è–¦ä½¿ç”¨æ¨å°å¼
squared = [x**2 for x in numbers]
evens = [x for x in numbers if x % 2 == 0]
total = sum(numbers)
```

## ğŸ”§ é–‰åŒ… (Closures)

### åŸºç¤é–‰åŒ…

```python
def make_counter():
    count = 0
    
    def increment():
        nonlocal count  # ä¿®æ”¹å¤–éƒ¨è®Šæ•¸
        count += 1
        return count
    
    return increment

counter1 = make_counter()
counter2 = make_counter()

print(counter1())  # 1
print(counter1())  # 2
print(counter2())  # 1
```

### å¯¦éš›æ‡‰ç”¨ï¼šè¨˜æ†¶åŒ–

```python
def memoize(func: Callable) -> Callable:
    cache = {}
    
    def wrapper(*args):
        if args not in cache:
            cache[args] = func(*args)
        return cache[args]
    
    return wrapper

@memoize
def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

print(fibonacci(100))  # å¿«é€Ÿè¨ˆç®—
```

## ğŸ”§ è£é£¾å™¨ (Decorators)

### åŸºç¤è£é£¾å™¨

```python
from functools import wraps
import time

def timer(func: Callable) -> Callable:
    @wraps(func)  # ä¿ç•™åŸå‡½æ•¸çš„ metadata
    def wrapper(*args, **kwargs):
        start = time.time()
        result = func(*args, **kwargs)
        end = time.time()
        print(f"{func.__name__} took {end - start:.4f}s")
        return result
    return wrapper

@timer
def slow_function():
    time.sleep(1)
    return "Done"

slow_function()  # slow_function took 1.0001s
```

### å¸¶åƒæ•¸çš„è£é£¾å™¨

```python
def repeat(times: int):
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat(times=3)
def greet(name: str):
    print(f"Hello, {name}!")

greet("Alice")
# Hello, Alice!
# Hello, Alice!
# Hello, Alice!
```

### å¸¸ç”¨è£é£¾å™¨æ¨¡å¼

```python
from functools import wraps
from typing import Any
import logging

# æ—¥èªŒè£é£¾å™¨
def log_calls(func: Callable) -> Callable:
    @wraps(func)
    def wrapper(*args, **kwargs):
        logging.info(f"Calling {func.__name__} with {args}, {kwargs}")
        result = func(*args, **kwargs)
        logging.info(f"{func.__name__} returned {result}")
        return result
    return wrapper

# é©—è­‰è£é£¾å™¨
def validate_positive(func: Callable) -> Callable:
    @wraps(func)
    def wrapper(x: int):
        if x < 0:
            raise ValueError("x must be positive")
        return func(x)
    return wrapper

@validate_positive
def square_root(x: int) -> float:
    return x ** 0.5

# å¿«å–è£é£¾å™¨
from functools import lru_cache

@lru_cache(maxsize=128)
def expensive_computation(n: int) -> int:
    time.sleep(0.1)
    return n * n

# é‡è©¦è£é£¾å™¨
def retry(max_attempts: int = 3, delay: float = 1.0):
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            for attempt in range(max_attempts):
                try:
                    return func(*args, **kwargs)
                except Exception as e:
                    if attempt == max_attempts - 1:
                        raise
                    logging.warning(f"Attempt {attempt + 1} failed: {e}")
                    time.sleep(delay)
        return wrapper
    return decorator

@retry(max_attempts=3, delay=0.5)
def unstable_api_call():
    import random
    if random.random() < 0.7:
        raise Exception("API Error")
    return "Success"
```

### é¡è£é£¾å™¨

```python
class CountCalls:
    def __init__(self, func: Callable):
        self.func = func
        self.count = 0
    
    def __call__(self, *args, **kwargs):
        self.count += 1
        print(f"Call {self.count} of {self.func.__name__}")
        return self.func(*args, **kwargs)

@CountCalls
def say_hello():
    print("Hello!")

say_hello()  # Call 1 of say_hello
say_hello()  # Call 2 of say_hello
```

### ç–ŠåŠ è£é£¾å™¨

```python
@timer
@log_calls
@validate_positive
def process_number(x: int) -> int:
    return x * 2

# åŸ·è¡Œé †åºï¼švalidate_positive -> log_calls -> timer
# ç­‰åŒæ–¼ï¼štimer(log_calls(validate_positive(process_number)))
```

## ğŸ’¡ functools æ¨¡çµ„

### partial - éƒ¨åˆ†æ‡‰ç”¨

```python
from functools import partial

def power(base: int, exponent: int) -> int:
    return base ** exponent

square = partial(power, exponent=2)
cube = partial(power, exponent=3)

print(square(5))  # 25
print(cube(5))    # 125

# å¯¦éš›æ‡‰ç”¨ï¼šé è¨­åƒæ•¸
from functools import partial
import json

dump_json = partial(json.dumps, indent=2, ensure_ascii=False)
data = {"name": "ç‹å°æ˜", "age": 30}
print(dump_json(data))
```

### wraps - ä¿ç•™å‡½æ•¸ metadata

```python
from functools import wraps

def my_decorator(func):
    @wraps(func)  # ä¿ç•™ __name__, __doc__ ç­‰
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def example():
    """This is an example function"""
    pass

print(example.__name__)  # "example" (ä¸æ˜¯ "wrapper")
print(example.__doc__)   # "This is an example function"
```

### lru_cache - LRU å¿«å–

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci(n - 1) + fibonacci(n - 2)

# æŸ¥çœ‹å¿«å–çµ±è¨ˆ
print(fibonacci(100))
print(fibonacci.cache_info())
# CacheInfo(hits=98, misses=101, maxsize=128, currsize=101)

# æ¸…é™¤å¿«å–
fibonacci.cache_clear()
```

### singledispatch - å–®åˆ†æ´¾æ³›å‹å‡½æ•¸

```python
from functools import singledispatch

@singledispatch
def process(value):
    raise NotImplementedError(f"Cannot process {type(value)}")

@process.register(int)
def _(value: int):
    return value * 2

@process.register(str)
def _(value: str):
    return value.upper()

@process.register(list)
def _(value: list):
    return len(value)

print(process(5))        # 10
print(process("hello"))  # "HELLO"
print(process([1, 2]))   # 2
```

## ğŸ’¡ å¯¦æˆ°æ¡ˆä¾‹ï¼šWeb API è£é£¾å™¨

```python
from functools import wraps
from typing import Callable, Any
import time
import logging

# èªè­‰è£é£¾å™¨
def require_auth(func: Callable) -> Callable:
    @wraps(func)
    def wrapper(request: dict, *args, **kwargs):
        if not request.get("auth_token"):
            raise PermissionError("Authentication required")
        return func(request, *args, **kwargs)
    return wrapper

# é€Ÿç‡é™åˆ¶è£é£¾å™¨
def rate_limit(max_calls: int, period: float):
    calls = []
    
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(*args, **kwargs):
            now = time.time()
            calls[:] = [call for call in calls if call > now - period]
            
            if len(calls) >= max_calls:
                raise Exception("Rate limit exceeded")
            
            calls.append(now)
            return func(*args, **kwargs)
        return wrapper
    return decorator

# é©—è­‰è£é£¾å™¨
def validate_schema(schema: dict):
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(data: dict, *args, **kwargs):
            for field, field_type in schema.items():
                if field not in data:
                    raise ValueError(f"Missing field: {field}")
                if not isinstance(data[field], field_type):
                    raise TypeError(f"Invalid type for {field}")
            return func(data, *args, **kwargs)
        return wrapper
    return decorator

# çµ„åˆä½¿ç”¨
@require_auth
@rate_limit(max_calls=10, period=60.0)
@validate_schema({"username": str, "email": str})
def create_user(request: dict, data: dict) -> dict:
    logging.info(f"Creating user: {data['username']}")
    return {"id": 1, "username": data["username"], "email": data["email"]}

# ä½¿ç”¨
request = {"auth_token": "secret"}
user_data = {"username": "alice", "email": "alice@example.com"}
user = create_user(request, user_data)
print(user)
```

## âš ï¸ å¸¸è¦‹é™·é˜±

### 1. è£é£¾å™¨å¿˜è¨˜ä½¿ç”¨ @wraps

```python
# âŒ éŒ¯èª¤ï¼šéºå¤±åŸå‡½æ•¸è³‡è¨Š
def my_decorator(func):
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper

@my_decorator
def example():
    """Original docstring"""
    pass

print(example.__name__)  # "wrapper" (éŒ¯èª¤)

# âœ… æ­£ç¢º
from functools import wraps

def my_decorator(func):
    @wraps(func)
    def wrapper(*args, **kwargs):
        return func(*args, **kwargs)
    return wrapper
```

### 2. é–‰åŒ…ä¸­çš„å¯è®Šé è¨­åƒæ•¸

```python
# âŒ éŒ¯èª¤
def make_adders():
    funcs = []
    for i in range(5):
        funcs.append(lambda x: x + i)
    return funcs

adders = make_adders()
print(adders[0](10))  # 14 (é æœŸæ˜¯ 10)

# âœ… æ­£ç¢ºï¼šä½¿ç”¨é è¨­åƒæ•¸æ•ç²
def make_adders():
    return [lambda x, i=i: x + i for i in range(5)]
```

### 3. è£é£¾å™¨åƒæ•¸èˆ‡å‡½æ•¸æ··æ·†

```python
# âŒ éŒ¯èª¤ï¼šæœŸæœ›å¸¶åƒæ•¸ä½†æœªæä¾›
def repeat(times: int = 2):
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            for _ in range(times):
                result = func(*args, **kwargs)
            return result
        return wrapper
    return decorator

@repeat  # TypeError: missing required argument
def greet():
    print("Hello")

# âœ… æ­£ç¢º
@repeat()  # æˆ– @repeat(times=3)
def greet():
    print("Hello")
```

## ğŸ’¡ æœ€ä½³å¯¦è¸

1. **ä½¿ç”¨å‹åˆ¥æç¤ºæå‡å¯è®€æ€§**
   ```python
   def timer(func: Callable[..., Any]) -> Callable[..., Any]:
       ...
   ```

2. **è£é£¾å™¨ç¸½æ˜¯ä½¿ç”¨ @wraps**
   ```python
   from functools import wraps
   
   def my_decorator(func):
       @wraps(func)
       def wrapper(*args, **kwargs):
           ...
   ```

3. **ä½¿ç”¨ functools.lru_cache å¿«å–æ˜‚è²´è¨ˆç®—**
   ```python
   @lru_cache(maxsize=128)
   def expensive_function(n: int) -> int:
       ...
   ```

4. **å„ªå…ˆä½¿ç”¨ partial è€Œé lambda**
   ```python
   # âœ… æ¸…æ™°
   double = partial(multiply, 2)
   
   # âŒ é›£è®€
   double = lambda x: multiply(2, x)
   ```

5. **è£é£¾å™¨ä¿æŒå–®ä¸€è·è²¬**
   ```python
   # âœ… å¥½çš„è¨­è¨ˆ
   @timer
   @log_calls
   @validate_input
   def process():
       ...
   ```

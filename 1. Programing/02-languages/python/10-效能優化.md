# 10-æ•ˆèƒ½å„ªåŒ–

## ğŸ“– æ ¸å¿ƒæ¦‚å¿µ

- **æ•ˆèƒ½åˆ†æ**: timeit, cProfile
- **è¨˜æ†¶é«”å„ªåŒ–**: __slots__, generators
- **ä¸¦è¡ŒåŠ é€Ÿ**: multiprocessing, numba
- **è³‡æ–™çµæ§‹é¸æ“‡**: list vs set vs dict

```mermaid
graph TD
    A[æ•ˆèƒ½å„ªåŒ–] --> B[åˆ†æå·¥å…·]
    A --> C[å„ªåŒ–ç­–ç•¥]
    A --> D[ä¸¦è¡Œè¨ˆç®—]
    
    B --> B1[timeit]
    B --> B2[cProfile]
    B --> B3[memory_profiler]
    
    C --> C1[ç®—æ³•å„ªåŒ–]
    C --> C2[è³‡æ–™çµæ§‹]
    C --> C3[è¨˜æ†¶é«”å„ªåŒ–]
```

## ğŸ”§ æ•ˆèƒ½åˆ†æ

### timeit

```python
import timeit

# æ¸¬è©¦å–®è¡Œç¨‹å¼ç¢¼
result = timeit.timeit("sum(range(100))", number=10000)
print(f"Time: {result:.6f}s")

# æ¸¬è©¦å‡½æ•¸
def test_function():
    return sum(range(100))

result = timeit.timeit(test_function, number=10000)

# æ¯”è¼ƒä¸åŒå¯¦ç¾
list_comp = timeit.timeit("[x**2 for x in range(100)]", number=10000)
map_func = timeit.timeit("list(map(lambda x: x**2, range(100)))", number=10000)

print(f"List comprehension: {list_comp:.6f}s")
print(f"Map: {map_func:.6f}s")
```

### cProfile

```python
import cProfile
import pstats

def slow_function():
    total = 0
    for i in range(1000000):
        total += i
    return total

# åˆ†æ
profiler = cProfile.Profile()
profiler.enable()
slow_function()
profiler.disable()

# æŸ¥çœ‹çµæœ
stats = pstats.Stats(profiler)
stats.sort_stats('cumulative')
stats.print_stats(10)
```

## ğŸ”§ å„ªåŒ–ç­–ç•¥

### é¸æ“‡æ­£ç¢ºçš„è³‡æ–™çµæ§‹

```python
import timeit

# âŒ æ…¢ï¼šä½¿ç”¨ list æŸ¥æ‰¾
numbers_list = list(range(10000))
timeit.timeit("5000 in numbers_list", globals=globals(), number=10000)

# âœ… å¿«ï¼šä½¿ç”¨ set æŸ¥æ‰¾ (O(1))
numbers_set = set(range(10000))
timeit.timeit("5000 in numbers_set", globals=globals(), number=10000)
```

### ä½¿ç”¨ç”Ÿæˆå™¨ç¯€çœè¨˜æ†¶é«”

```python
# âŒ è¨˜æ†¶é«”æ¶ˆè€—å¤§
def get_numbers(n):
    return [i * 2 for i in range(n)]

numbers = get_numbers(1000000)  # å‰µå»ºå¤§åˆ—è¡¨

# âœ… è¨˜æ†¶é«”å‹å¥½
def get_numbers_gen(n):
    for i in range(n):
        yield i * 2

numbers = get_numbers_gen(1000000)  # æƒ°æ€§æ±‚å€¼
```

### __slots__ å„ªåŒ–è¨˜æ†¶é«”

```python
import sys

# âŒ ç„¡ __slots__
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

# âœ… ä½¿ç”¨ __slots__
class OptimizedPoint:
    __slots__ = ['x', 'y']
    
    def __init__(self, x, y):
        self.x = x
        self.y = y

p1 = Point(1, 2)
p2 = OptimizedPoint(1, 2)

print(f"Normal: {sys.getsizeof(p1.__dict__)} bytes")
print(f"Optimized: {sys.getsizeof(p2)} bytes")
```

### å­—ä¸²æ‹¼æ¥å„ªåŒ–

```python
# âŒ æ…¢ï¼šä½¿ç”¨ + æ‹¼æ¥
result = ""
for i in range(10000):
    result += str(i)

# âœ… å¿«ï¼šä½¿ç”¨ join
result = "".join(str(i) for i in range(10000))

# âœ… å¿«ï¼šä½¿ç”¨ f-stringï¼ˆå°‘é‡æ‹¼æ¥ï¼‰
name = "Alice"
greeting = f"Hello, {name}!"
```

## ğŸ”§ ä¸¦è¡ŒåŠ é€Ÿ

### ä½¿ç”¨ numba (JIT ç·¨è­¯)

```python
from numba import jit
import numpy as np

# æ™®é€š Python
def sum_python(arr):
    total = 0
    for i in arr:
        total += i
    return total

# Numba åŠ é€Ÿ
@jit(nopython=True)
def sum_numba(arr):
    total = 0
    for i in arr:
        total += i
    return total

arr = np.arange(1000000)

# sum_numba æœƒå¿« 10-100 å€
```

### ä½¿ç”¨ multiprocessing

```python
from multiprocessing import Pool

def cpu_intensive_task(n):
    return sum(i * i for i in range(n))

if __name__ == "__main__":
    # å–®é€²ç¨‹
    results = [cpu_intensive_task(1000000) for _ in range(4)]
    
    # å¤šé€²ç¨‹
    with Pool(4) as pool:
        results = pool.map(cpu_intensive_task, [1000000] * 4)
```

## ğŸ’¡ å¯¦æˆ°æ¡ˆä¾‹

```python
from functools import lru_cache
from typing import List

# âŒ æœªå„ªåŒ–
def fibonacci(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

# âœ… ä½¿ç”¨å¿«å–å„ªåŒ–
@lru_cache(maxsize=None)
def fibonacci_cached(n: int) -> int:
    if n <= 1:
        return n
    return fibonacci_cached(n-1) + fibonacci_cached(n-2)

# âŒ æœªå„ªåŒ–æŸ¥æ‰¾
def find_duplicates(nums: List[int]) -> List[int]:
    duplicates = []
    for i in range(len(nums)):
        for j in range(i+1, len(nums)):
            if nums[i] == nums[j] and nums[i] not in duplicates:
                duplicates.append(nums[i])
    return duplicates

# âœ… ä½¿ç”¨ set å„ªåŒ–
def find_duplicates_optimized(nums: List[int]) -> List[int]:
    seen = set()
    duplicates = set()
    for num in nums:
        if num in seen:
            duplicates.add(num)
        seen.add(num)
    return list(duplicates)
```

## ğŸ’¡ æœ€ä½³å¯¦è¸

1. **å…ˆæ¸¬é‡å†å„ªåŒ–**
   ```python
   import cProfile
   cProfile.run('your_function()')
   ```

2. **ä½¿ç”¨å…§å»ºå‡½æ•¸**
   ```python
   # âœ… å¿«
   sum(numbers)
   max(numbers)
   
   # âŒ æ…¢
   total = 0
   for n in numbers:
       total += n
   ```

3. **é¿å…å…¨å±€è®Šæ•¸**
   ```python
   # âŒ æ…¢
   global_var = 0
   def increment():
       global global_var
       global_var += 1
   
   # âœ… å¿«
   def increment(value):
       return value + 1
   ```

4. **ä½¿ç”¨ç”Ÿæˆå™¨è¡¨é”å¼**
   ```python
   # âœ… è¨˜æ†¶é«”å‹å¥½
   total = sum(x**2 for x in range(1000000))
   
   # âŒ è¨˜æ†¶é«”æ¶ˆè€—å¤§
   total = sum([x**2 for x in range(1000000)])
   ```

5. **é¸æ“‡åˆé©çš„è³‡æ–™çµæ§‹**
   - æŸ¥æ‰¾: set, dict (O(1))
   - æ’åº: list + sort (O(n log n))
   - æ’å…¥/åˆªé™¤: deque (O(1))
   - å„ªå…ˆç´š: heapq (O(log n))

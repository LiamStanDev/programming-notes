# 08-æ¨™æº–åº«ç²¾é¸

## ğŸ“– æ ¸å¿ƒæ¦‚å¿µ

Python å¼·å¤§çš„æ¨™æº–åº«ï¼š
- **collections**: å°ˆæ¥­å®¹å™¨
- **itertools**: è¿­ä»£å™¨å·¥å…·
- **functools**: å‡½æ•¸å¼å·¥å…·
- **pathlib**: è·¯å¾‘æ“ä½œ
- **datetime**: æ—¥æœŸæ™‚é–“

```mermaid
graph TD
    A[æ¨™æº–åº«] --> B[collections]
    A --> C[itertools]
    A --> D[functools]
    A --> E[å…¶ä»–å¸¸ç”¨]
    
    B --> B1[deque]
    B --> B2[Counter]
    B --> B3[defaultdict]
    B --> B4[namedtuple]
    
    C --> C1[combinations]
    C --> C2[permutations]
    C --> C3[chain]
    
    D --> D1[lru_cache]
    D --> D2[partial]
    D --> D3[reduce]
```

## ğŸ”§ collections

### deque - é›™ç«¯éšŠåˆ—

```python
from collections import deque

dq = deque([1, 2, 3])
dq.append(4)        # å³å´æ·»åŠ 
dq.appendleft(0)    # å·¦å´æ·»åŠ 
dq.pop()            # å³å´ç§»é™¤
dq.popleft()        # å·¦å´ç§»é™¤
dq.rotate(2)        # æ—‹è½‰

# å¯¦éš›æ‡‰ç”¨ï¼šæ»‘å‹•çª—å£
def moving_average(data, window_size):
    window = deque(maxlen=window_size)
    for value in data:
        window.append(value)
        yield sum(window) / len(window)

data = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
print(list(moving_average(data, 3)))
```

### Counter - è¨ˆæ•¸å™¨

```python
from collections import Counter

words = ['apple', 'banana', 'apple', 'cherry', 'banana', 'apple']
counter = Counter(words)

print(counter)              # Counter({'apple': 3, 'banana': 2, 'cherry': 1})
print(counter['apple'])     # 3
print(counter.most_common(2))  # [('apple', 3), ('banana', 2)]

counter.update(['apple', 'date'])
print(counter['apple'])     # 4

# å¯¦éš›æ‡‰ç”¨ï¼šå­—æ¯é »ç‡
text = "hello world"
char_freq = Counter(text)
print(char_freq.most_common(3))
```

### defaultdict - é è¨­å­—å…¸

```python
from collections import defaultdict

# åˆ†çµ„
students = [
    ('Alice', 'A'),
    ('Bob', 'B'),
    ('Charlie', 'A'),
    ('David', 'B'),
]

grade_dict = defaultdict(list)
for name, grade in students:
    grade_dict[grade].append(name)

print(dict(grade_dict))  # {'A': ['Alice', 'Charlie'], 'B': ['Bob', 'David']}

# è¨ˆæ•¸
word_count = defaultdict(int)
for word in ['apple', 'banana', 'apple']:
    word_count[word] += 1
```

### namedtuple

```python
from collections import namedtuple

Point = namedtuple('Point', ['x', 'y'])
p = Point(3, 4)

print(p.x, p.y)     # 3 4
print(p[0], p[1])   # 3 4

# å¯¦éš›æ‡‰ç”¨
User = namedtuple('User', ['id', 'name', 'email'])
user = User(1, 'Alice', 'alice@example.com')
print(user.name)
```

## ğŸ”§ itertools

### çµ„åˆå·¥å…·

```python
from itertools import combinations, permutations, product

# çµ„åˆï¼ˆç„¡é †åºï¼‰
print(list(combinations([1, 2, 3], 2)))
# [(1, 2), (1, 3), (2, 3)]

# æ’åˆ—ï¼ˆæœ‰é †åºï¼‰
print(list(permutations([1, 2, 3], 2)))
# [(1, 2), (1, 3), (2, 1), (2, 3), (3, 1), (3, 2)]

# ç¬›å¡çˆ¾ç©
print(list(product([1, 2], ['a', 'b'])))
# [(1, 'a'), (1, 'b'), (2, 'a'), (2, 'b')]
```

### ç„¡é™è¿­ä»£å™¨

```python
from itertools import count, cycle, repeat

# ç„¡é™è¨ˆæ•¸
for i in count(10, 2):  # å¾ 10 é–‹å§‹ï¼Œæ­¥é€² 2
    if i > 20:
        break
    print(i)  # 10, 12, 14, 16, 18, 20

# å¾ªç’°
counter = 0
for item in cycle([1, 2, 3]):
    counter += 1
    if counter > 7:
        break
    print(item)  # 1, 2, 3, 1, 2, 3, 1

# é‡è¤‡
print(list(repeat(10, 3)))  # [10, 10, 10]
```

### å¯¦ç”¨å·¥å…·

```python
from itertools import chain, groupby, islice

# é€£æ¥å¤šå€‹è¿­ä»£å™¨
list1 = [1, 2, 3]
list2 = [4, 5, 6]
print(list(chain(list1, list2)))  # [1, 2, 3, 4, 5, 6]

# åˆ†çµ„
data = [
    ('A', 1), ('A', 2), ('B', 3), ('B', 4), ('C', 5)
]
for key, group in groupby(data, key=lambda x: x[0]):
    print(key, list(group))
# A [('A', 1), ('A', 2)]
# B [('B', 3), ('B', 4)]
# C [('C', 5)]

# åˆ‡ç‰‡
print(list(islice(range(100), 10, 20, 2)))  # [10, 12, 14, 16, 18]
```

## ğŸ”§ functools

### lru_cache

```python
from functools import lru_cache

@lru_cache(maxsize=128)
def fibonacci(n):
    if n <= 1:
        return n
    return fibonacci(n-1) + fibonacci(n-2)

print(fibonacci(100))
print(fibonacci.cache_info())
```

### partial

```python
from functools import partial

def power(base, exponent):
    return base ** exponent

square = partial(power, exponent=2)
cube = partial(power, exponent=3)

print(square(5))  # 25
print(cube(5))    # 125
```

### reduce

```python
from functools import reduce

numbers = [1, 2, 3, 4, 5]
total = reduce(lambda acc, x: acc + x, numbers, 0)
print(total)  # 15

product = reduce(lambda acc, x: acc * x, numbers, 1)
print(product)  # 120
```

## ğŸ”§ pathlib

```python
from pathlib import Path

# è·¯å¾‘æ“ä½œ
path = Path('/usr/local/bin')
home = Path.home()
cwd = Path.cwd()

# è·¯å¾‘çµ„åˆ
config_file = Path.home() / '.config' / 'app' / 'config.json'

# æª”æ¡ˆæ“ä½œ
if config_file.exists():
    content = config_file.read_text()

# ç›®éŒ„æ“ä½œ
config_file.parent.mkdir(parents=True, exist_ok=True)

# éæ­·
for py_file in Path('.').rglob('*.py'):
    print(py_file)
```

## ğŸ”§ datetime

```python
from datetime import datetime, timedelta, timezone

# ç•¶å‰æ™‚é–“
now = datetime.now()
utc_now = datetime.now(timezone.utc)

# æ ¼å¼åŒ–
formatted = now.strftime('%Y-%m-%d %H:%M:%S')
parsed = datetime.strptime('2024-01-01 12:00:00', '%Y-%m-%d %H:%M:%S')

# æ™‚é–“è¨ˆç®—
tomorrow = now + timedelta(days=1)
week_ago = now - timedelta(weeks=1)

# æ¯”è¼ƒ
if now > parsed:
    print("Now is later")
```

## ğŸ’¡ å¯¦æˆ°æ¡ˆä¾‹

```python
from collections import Counter, defaultdict
from itertools import groupby
from functools import lru_cache
from pathlib import Path

def analyze_logs(log_file: Path):
    error_count = Counter()
    errors_by_hour = defaultdict(list)
    
    for line in log_file.read_text().splitlines():
        if 'ERROR' in line:
            hour = line[:13]  # å‡è¨­æ ¼å¼ç‚º "2024-01-01 12:00:00 ERROR ..."
            error_type = line.split('ERROR')[1].split(':')[0].strip()
            
            error_count[error_type] += 1
            errors_by_hour[hour].append(error_type)
    
    print("Top 5 errors:")
    for error, count in error_count.most_common(5):
        print(f"  {error}: {count}")
    
    print("\nErrors by hour:")
    for hour, errors in sorted(errors_by_hour.items()):
        print(f"  {hour}: {len(errors)} errors")

# analyze_logs(Path('app.log'))
```

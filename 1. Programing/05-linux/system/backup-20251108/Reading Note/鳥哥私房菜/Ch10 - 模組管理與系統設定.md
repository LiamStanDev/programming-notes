# 開機流程
---
### 流程
1. BIOS 或者 UEFI BIOS 進行硬體自檢，並依照設定取得可開機裝置：我們要在 BIOS 界面中選擇開機的 disk，這些 disk 中會有 MBR
2. 讀取執行開機裝置內 MBR 中的 boot loader：常見的爲 grub2，註： GPT 也有保留 MBR
3. 依據 boot loader 設定加載 kernel，kernel 進行硬體偵測與載入驅動
4. 驅動加載完成之後，Kernel 呼叫 systemd，並依照 default.target 流程開機，如下：
	1. systemd 執行 sysinit.target
	2. systemd 執行 multi-user.target
	3. systemd 執行 graphical.target 
### Boot loader
每個 os 都會提供與其對應的 boot loader，所以有多個 os 就會有多個 boot loader，MBR 中的 boot loader 就是某一個 os 的 boot loader，所以 MBR 可能會被其他 os 的 boot loader 覆蓋。
![[Pasted image 20240523114140.png]]
> windows 的 bootloader 是無法載入 windwos 以外的 os，所以要雙啟動建議先安裝 windows 後在安裝 linux，這樣 MBR 才不會被 windows 覆蓋。

* linux 的 bootloader 有控制權轉交的功能，可以轉交給其他 os 的 bootloader 來啟動對應的 kernel
![[Pasted image 20240523120112.png]]

> boot loader 最重要的功能就是載入 kernal

### initramfs
透過 boot loader ，會載入並解壓縮兩個內容：
1. Kernel: 爲 `/boot/vmlinuz-6.8.10-300.fc40.x86_64` 
	* 會以 `vmlinuxz-kernal版本 來命名`
	* 名稱中帶有 `rescure` 是在救援模式下才會載入
2. initramfs: 爲 `/boot/initramfs-6.8.10-300.fc40.x86_64.img`
	* 同 kernel 會帶版本號
	* 也有 rescure
##### Why initramfs ?
因為 linux 會將非必要功能且可以獨立編譯成模組的功能都會獨立編譯爲模組放在 `lib/modules` 中。

假設 linux 是安裝在 STATA 磁碟上，Kernel 根本不知道怎麼操作 STATA，故要先掛載根目錄才能讀取 STATA 驅動，所以變成兩難問題。

故 initramfs 會在 ram 中虛擬出一個文件系統，從中可以讓 Kernel 讀取核心開機驅動，如 STATA, USB, LVM, SCSI 等系統與磁碟有關的驅動來解決這個問題。
##### 流程圖
![[Pasted image 20240523132116.png]]
如上圖所示，boot loader 可以載入 kernel 與 initramfs ，然後在記憶體中讓 initramfs 解壓縮成為根目錄， kernel 就能夠藉此載入適當的驅動程式，最終釋放虛擬檔案系統，並掛載實際的根目錄檔案系統。

### systemd
此時 Kernel 已經載入完畢、完成硬體檢測與驅動載入後，此時硬體已經準備完成，Kernel 就會呼叫 systemd 作為第一支程式。

#### 此時 systemd 的功能
就是準備軟體的執行環境：
1. 主機名稱
2. 網路設定
3. 語系處理
4. 檔案系統格式
5. 其他服務
都會透過 `/etc/systemd/system/default.target` 來規劃。
如下是我透過 `sudo systemctl set default graphical.target` 後的 default.target， 用 `ls -a` 可以看到
```text
lrwxrwxrwx@ - root 19 May 12:59 default.target -> /usr/lib/systemd/system/graphical.target
```
此時 systemd 會找以下目錄的設定檔
* `/etc/systemd/system/graphical.target.wants/`: 多用戶共用
* `/usr/lib/systemd/system/graphical.target.wants/`: 系統預設
* `~/.config/systemd/system/graphical.target.wants/`: 單一用戶

我們可以分析 .target 設定檔中的 Requires，也可以使用以下命令來查看服務的依賴
```shell
systemctl list-dependencies graphical.target
```
發現 systemd 開機啟動流程：
1. local-fs.target + swap.target: 掛載 `/etc/fstab` 所規範的檔案系統
2. sysinit.target: 偵測硬體與載入核心模組
3. basic.target: 載入周邊硬體驅動與防火牆
4. multi-user.target: 系統與網路服務
5. graphical.target: gdm.service 等服務

#### sysinit.target
分析以下命令
```shell
systemctl list-dependencies sysinit.target
```
- 特殊檔案系統裝置的掛載：包括 dev-hugepages.mount dev-mqueue.mount 等掛載服務，主要在掛載跟巨量記憶體分頁使用與訊息佇列的功能。 掛載成功後，會在 /dev 底下建立 /dev/hugepages/, /dev/mqueue/ 等目錄；
- 特殊檔案系統的啟用：包括磁碟陣列、網路磁碟 (iscsi)、LVM 檔案系統、檔案系統對照服務 (multipath) 等等，也會在這裡被偵測與使用到！
- 開機過程的訊息傳遞與動畫執行：使用 plymouthd 服務搭配 plymouth 指令來傳遞動畫與訊息
- 日誌式登錄檔的使用：就是 systemd-journald 這個服務的啟用啊！
- 載入額外的核心模組：透過 /etc/modules-load.d/*.conf 檔案的設定，讓核心額外載入管理員所需要的核心模組！
- 載入額外的核心參數設定：包括 /etc/sysctl.conf 以及 /etc/sysctl.d/*.conf 內部設定！
- 啟動系統的亂數產生器：亂數產生器可以幫助系統進行一些密碼加密演算的功能
- 設定終端機 (console) 字形
- 啟動動態裝置管理員：就是 udevd 這個傢伙！用在動態對應實際裝置存取與裝置檔名對應的一個服務！相當重要喔！也是在這裡啟動的！

#### basic.target
分析以下命令
```shell
systemctl list-dependencies basic.target
```
- 載入 alsa 音效驅動程式：這個 alsa 是個音效相關的驅動程式，會讓你的系統有音效產生囉；
- 載入 firewalld 防火牆：CentOS 7.x 以後使用 firewalld 取代 iptables 的防火牆設定，雖然最終都是使用 iptables 的架構， 不過在設定上面差很多喔！
- 載入 CPU 的微指令功能；
- 啟動與設定 SELinux 的安全本文：如果由 disable 的狀態改成 enable 的狀態，或者是管理員設定強制重新設定一次 SELinux 的安全本文， 也在這個階段處理喔！
- 將目前的開機過程所產生的開機資訊寫入到 /var/log/dmesg 當中
- 由 /etc/sysconfig/modules/*.modules 及 /etc/rc.modules 載入管理員指定的模組！
- 載入 systemd 支援的 timer 功能


# 核心與核心模組
---
### 核心與模組位置
* 核心: `/boot/vmlinuxz`
* ramdisk: `/boot/initramfs`
* 核心模組: `lib/modules/$(uname -r)/kernel`
* 核心原碼: `/usr/src/kernel` (默認部安裝)

### 核心模組
```text
arch	：與硬體平台有關的項目，例如 CPU 的等級等等；
crypto	：核心所支援的加密的技術，例如 md5 或者是 des 等等；
drivers	：一些硬體的驅動程式，例如顯示卡、網路卡、PCI 相關硬體等等；
fs	：核心所支援的 filesystems ，例如 vfat, reiserfs, nfs 等等；
lib	：一些函式庫；
net	：與網路有關的各項協定資料，還有防火牆模組 (net/ipv4/netfilter/*) 等等；
sound	：與音效有關的各項模組；
```

### 添加驅動
* 情境: 我編譯完成一個網卡驅動 mynet.ko (模組都是以.ko 結尾)
```shell
cp mynet.ko /lib/modules/$(uname -r)/kernel/driver/net
depmod # 更新相依性至 /lib/modules/$(uname -r)/modules.dep 中
modprobe a.ko # 載入模組, -f 爲強至載入
lsmod # 查看載入的模組
modinfo a.ko # 查看模組資訊
modporbe -r a.ko # 移出模組
```
> 在執行 modprobe 前要先執行 depmod，不然載入順序會出錯

##### 例子
```shell
modprobe cifs # 這個是 linux 內置的文件系統，但是並有載入
lsmod |　grep -in 'cifs'
modprobe -r cifs
```


# Grub2
---
### 兩階段載入
Boot loader 具有選單、直接載入核心與轉移控制權等功能，但 MBR 才 446 bytes 實在太小，故 linux 將其分為兩步驟載入：
* Stage1: 執行 MBR 中的 boot loader 主程式
* Stage2: 透過 boot loader 主程式所有設定檔與環境參數，這些會放在 `/boot/grub2` 下
```shell
ls -l /boot/grub2
```
```text
-rw-r--r--.  device.map            <==grub2 的裝置對應檔(底下會談到)
drwxr-xr-x.  fonts                 <==開機過程中的畫面會使用到的字型資料
-rw-r--r--.  grub.cfg              <==grub2 的主設定檔！相當重要！
-rw-r--r--.  grubenv               <==一些環境區塊的符號
drwxr-xr-x.  i386-pc               <==針對一般 x86 PC 所需要的 grub2 的相關模組
drwxr-xr-x.  locale                <==就是語系相關的資料囉
drwxr-xr-x.  themes                <==一些開機主題畫面資料
```


### 設定檔修改
grub2 的主要設定檔爲 `/boot/grub2/grub.cfg`，但是官方並不建議修改該文件，而是透過修改 `/etc/default/grub` 與 `/etc/grub.d/` 更妥當。
* `/etc/default/grub`
```shell
GRUB_TIMEOUT=5                   # 指定預設倒數讀秒的秒數
GRUB_DEFAULT=saved               # 指定預設由哪一個選單來開機，預設開機選單之意
GRUB_DISABLE_SUBMENU=true        # 是否要隱藏次選單，通常是藏起來的好！
GRUB_TERMINAL_OUTPUT="console"   # 指定資料輸出的終端機格式，預設是透過文字終端機
GRUB_CMDLINE_LINUX="resume=UUID=f5443246-0560-4aa9-95dd-3b9a1196cedf rd.lvm.lv=fedora/root rd.lvm.lv=fedora/swap rhgb quiet" # 需要傳遞給核心的額外參數
GRUB_DISABLE_RECOVERY="true"     # 取消救援選單的製作
```

* 修改選單 `/etc/grub.d/`
	- 00_header：主要在建立初始的顯示項目，包括需要載入的模組分析、螢幕終端機的格式、倒數秒數、選單是否需要隱藏等等，大部分在 /etc/default/grub 裡面所設定的變數，大概都會在這個腳本當中被利用來重建 grub.cfg 。 
	- 10_linux：根據分析 /boot 底下的檔案，嘗試找到正確的 linux 核心與讀取這個核心需要的檔案系統模組與參數等，都在這個腳本運作後找到並設定到 grub.cfg 當中。 因為這個腳本會將所有在 /boot 底下的每一個核心檔案都對應到一個選單，因此核心檔案數量越多，你的開機選單項目就越多了。 如果未來你不想要舊的核心出現在選單上，那可以透過移除舊核心來處理即可。  
	- 30_os-prober：這個腳本預設會到系統上找其他的 partition 裡面可能含有的作業系統，然後將該作業系統做成選單來處理就是了。 如果你不想要讓其他的作業系統被偵測到並拿來開機，那可以在 /etc/default/grub 裡面加上『 GRUB_DISABLE_OS_PROBER=true 』取消這個檔案的運作。  
	- 40_custom：如果你還有其他想要自己手動加上去的選單項目，或者是其他的需求，那麼建議在這裡補充即可！


* 更新 grub.cfg
```shell
grub2-mkconfig -o /boot/grub2/grub.cfg
```

# 系統設定
---
### 網路設定
##### 網卡名稱含義
* eno1: 主機板 BIOS 內建網卡
* ens1: 主機板 BIOS 內建 PCI-E 界面網卡
* enp2s0: PCI-E 界面獨立網卡
* wlo1: 無線網卡
* eth0: 以上都不符合的 linux 預設網卡名稱
#### 手動設定 IP
需要向 ISP 取得網路參數如：
- method: manual (手動設定)
- IP: 172.16.1.1
- netmask: 255.255.0.0
- gateway: 172.16.200.254
- DNS: 172.16.200.254
- hostname (這個可以自己設定): study.centos.vbird 
```shell
nmcli connection show # 顯示連線代號與網卡名稱

# 修改 ip 設定
nmcli connection modify [連線代號] \
connection.autoconnect yes \ # 自動連線
ipv4.method manual \
ipv4.address 172.16.1.1/16 \
ipv4.gateway 172.16.200.254 \
ipv4.dns 8.8.8.8

# 起用
nmcli connection up [連線代號]

# 查看詳情
nmcli connection show [連線代號]
```
#### DHCP
```shell
nmcli modify [連線代號] \
connection.autoconnection yes \
ipv4.method auto

nmcli connection up [連線代號]

nmcli connection show [連線代號]
```

#### 修改主機名稱
```shell
# 顯示主機資訊
hostnamectl

# 設定主機名稱
hostnamectl set-hostname www.fedora.liamdev

# 查看
cat /etc/hostname
```
### 日期時間設定
```shell
timedatectl # 顯示時間資訊

timedatectl list-timezones  # 列出所有時區

timedatectl set-timezone "America/New_York"

# 手動校準時間
timedatectl set-time "2022-05-23 08:21"

# ntp 協議自動較準，需要連線會開啟端口(安全起見公司建議手動校準)
ntpdate tock.stdtime.gov.tw # 臺灣國家實驗室時間伺服器
hwclock -w # 更新 BIOS 時間紀錄
```
> timedatectl 內建會更新 BIOS 時間紀錄，但是 date 或者 ntpdate 需要自己啟動

### 語系設定
```shell
localectl # 顯示語系
localectl set-locale LANG=en_US.utf8 # 修改語系
```

### 防火牆設定
skip 在網路篇會敘述


# 硬體資訊
---
##### dmidecode 
全名為 DMI decode，用於解析 Desktop Management Interface Table 的工具，其中包含硬體的詳細訊息 e.g. 製造商、型號等
1 ：詳細的系統資料，含主機板的型號與硬體的基礎資料等
4 ：CPU 的相關資料，包括倍頻、外頻、核心數、核心緒數等
9 ：系統的相關插槽格式，包括 PCI, PCI-E 等等的插槽規格說明
17：每一個記憶體插槽的規格，若內有記憶體，則列出該記憶體的容量與型號
```shell
dmidecode -t 1
```

#### 透過 Kernel 資訊來分析設備
Linux Kernel 在開機時就能夠偵測主機硬體並載入適當的模組來驅動硬體，偵測到的各種裝置會被記錄在 `/proc` 與 `/sys`
> 備註：
> * `/proc` 運行時內核信息與狀態，提供系統和進程的實時信息 e.g. `/proc/cpuinfo`, `/proc/partitions`
> * `/dev` 設備文件，提供與硬件設備通信的接口
> * `/sys` 內核對象與設備驅動信息，提供設備和子系統詳細信息與配置接口

可以直接讀取以上文件或者透過以下命令：
1. `fdisk -l`: 讀取分區信息
2. `dmesg`: 核心運作日志
3. `vmstat`: 分析 CPU/RAM/IO 目前狀態
4. `lspci`: 列出 PCI 介面裝置
5. `lsusb`
6. `iostat`: 與 vmstat 類似，但用於 io 設備

```shell
iostat [-c|-d] [-k|-m] [-t] [間隔秒數] [偵測次數]
```
* -c  ：僅顯示 CPU 的狀態；
* -d  ：僅顯示儲存設備的狀態，不可與 -c 一起用；
* -k  ：預設顯示的是 block ，這裡可以改成 K bytes 的大小來顯示；
* -m  ：與 -k 類似，只是以 MB 的單位來顯示結果。
* -t  ：顯示日期出來；

```shell
iostat -d 2 3
```
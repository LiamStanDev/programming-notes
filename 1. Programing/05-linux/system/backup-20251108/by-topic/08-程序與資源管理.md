# 程序與資源管理

## 目錄
- [主題簡介](#主題簡介)
- [原理與架構](#原理與架構)
- [常用指令與範例](#常用指令與範例)
- [常見錯誤與排查](#常見錯誤與排查)
- [最佳實踐與安全性](#最佳實踐與安全性)
- [實戰案例](#實戰案例)

---

## 主題簡介

程序與資源管理是 Linux/UNIX 系統管理的核心，涵蓋程序（Process）與執行緒（Thread）的建立、監控、終止、優先權調整及資源分配。熟練掌握這些技能，有助於效能調校、故障排查、自動化運維與高可用架構設計。
**核心概念：**
- 程序（Process）：執行中的程式，擁有獨立記憶體空間與 PID。
- 執行緒（Thread）：程序內的執行單元，共享程序資源。
- 資源分配：CPU、記憶體、I/O 等由核心排程器分配。
- 優先權（Priority）：決定程序獲得 CPU 時間的先後，可調整。
- cgroup：Linux 控制群組，限制/監控/分配程序群組資源。

---

## 原理與架構

### 程序與執行緒
- **程序（Process）**：每個程序有獨立的虛擬記憶體空間，由核心分配 PID。父子程序關係由 PPID 反映。
- **執行緒（Thread）**：同一程序下的多個執行單元，共享記憶體與資源，適合高效能運算，但需注意同步與競爭條件。

### Linux 調度與資源分配
- **排程器（Scheduler）**：負責分配 CPU 時間片，常見策略有 CFS（完全公平排程）、RT（即時）。
- **優先權（nice/renice）**：nice 值越低，優先權越高（root 可設負值）。
- **資源隔離（cgroup）**：可限制 CPU、記憶體、I/O，防止單一程序壟斷資源。

### 程序狀態
- R（Running）：執行中
- S（Sleeping）：等待事件
- Z（Zombie）：殭屍程序，父程序未回收
- T（Stopped）：暫停

---

## 常用指令與範例

### 1. 程序查詢與監控

#### ps
```bash
$ ps aux
USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
root         1  0.0  0.1  22560  4100 ?        Ss   10:00   0:01 /sbin/init
user      1234  0.2  1.0 123456 20480 pts/0    Sl   10:05   0:10 /usr/bin/python3 script.py
```

#### top / htop
```bash
$ top
top - 10:10:01 up 1 day,  2:34,  2 users,  load average: 0.15, 0.10, 0.05
PID USER      PR  NI    VIRT    RES    SHR S  %CPU %MEM     TIME+ COMMAND
1234 user     20   0  123456  20480   1234 S   0.2  1.0   0:10.00 python3
```
- `htop` 提供互動式介面，可用方向鍵操作。

#### pgrep / pkill
```bash
$ pgrep nginx
1234
2345

$ pkill -f python
# 終止所有包含 'python' 的程序
```

#### jobs, bg, fg
```bash
$ sleep 1000 &
[1] 5678
$ jobs
[1]+  Running                 sleep 1000 &
$ fg %1
sleep 1000
$ bg %1
[1]+ sleep 1000 &
```

#### nohup
```bash
$ nohup ./long_task.sh &
nohup: ignoring input and appending output to 'nohup.out'
```

### 2. 程序控制與優先權

#### nice / renice
```bash
$ nice -n 10 ./heavy_task.sh
# 以較低優先權執行 heavy_task.sh

$ renice -n -5 1234
1234 (process ID) old priority 10, new priority -5
```

#### kill
```bash
$ kill -15 1234   # 溫和終止
$ kill -9 1234    # 強制終止
```

### 3. 資源限制與監控

#### cgroup（需安裝 cgroup-tools）
```bash
$ sudo cgcreate -g memory,cpu:/mygroup
$ sudo cgset -r memory.limit_in_bytes=512M mygroup
$ sudo cgset -r cpu.shares=512 mygroup
$ sudo cgexec -g memory,cpu:mygroup ./heavy_task.sh
```

#### lsof（查詢檔案/port 被哪個程序占用）
```bash
$ sudo lsof /path/to/file
$ sudo lsof -i :80
```

---

## 常見錯誤與排查

| 現象             | 可能原因/排查方式                                                                 | 解決建議                         |
|------------------|----------------------------------------------------------------------------------|----------------------------------|
| 程序無法終止      | 權限不足、程序卡死、核心態等待                                                    | 先 `kill -15`，再 `kill -9`      |
| 資源耗盡         | 程序記憶體/CPU 泄漏，I/O 壅塞                                                     | 用 `top`/`htop` 找高耗用程序      |
| 殭屍程序         | 父程序未回收子程序                                                                 | 查 `ps aux | grep Z`，重啟父程序  |
| 無法取得 PID     | 程序名稱不明、啟動參數不同                                                        | 用 `pgrep`、`ps aux | grep`      |
| 優先權調整失敗   | 非 root 權限無法設負值                                                            | 用 sudo 執行                     |
| cgroup 設定無效  | 未載入 cgroup 模組、權限不足                                                       | 檢查 `/proc/cgroups`、權限        |
| 程序資源釋放異常 | 程序未正常結束，檔案/port 未釋放                                                  | 用 `lsof` 查占用，強制 kill       |

---

## 最佳實踐與安全性

- 定期監控 CPU、記憶體、I/O，預防資源耗盡。
- 合理分配程序優先權，避免單一程序壟斷資源。
- 透過 cgroup 實施資源限制，提升系統穩定性。
- 妥善管理背景程序，避免殭屍程序累積。
- 終止程序時，優先用 SIGTERM，必要時再用 SIGKILL。
- 設置自動化監控與告警（如 systemd、cron、Prometheus）。
- 僅授權必要權限給程序，避免以 root 執行非必要服務。
- 定期檢查殭屍程序與資源釋放狀態。
- 實施資源配額與隔離，防止 DoS 攻擊。

---

## 實戰案例

### 案例一：定位高 CPU 程序並限制資源

1. 查詢高 CPU 程序
```bash
$ ps aux --sort=-%cpu | head
```
2. 用 cgroup 限制其 CPU/記憶體
```bash
$ sudo cgcreate -g cpu,memory:/limitgroup
$ sudo cgset -r cpu.shares=256 limitgroup
$ sudo cgset -r memory.limit_in_bytes=256M limitgroup
$ sudo cgclassify -g cpu,memory:limitgroup <PID>
```

### 案例二：批次終止異常程序

1. 查詢所有 zombie 程序
```bash
$ ps aux | grep Z
```
2. 批次終止特定用戶程序
```bash
$ pkill -u user_name
```

### 案例三：自動監控並告警

1. 編寫監控腳本
```bash
#!/bin/bash
while true; do
  ps aux | grep myapp
  sleep 60
done
```
2. 配合 cron/systemd 定時執行，或整合 Prometheus/Grafana 進行資源監控與告警。

---
